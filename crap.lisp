kirby v1.0.0: compiling: core.kirby -> core.js
(ns (with-meta czlab.kirby.core 
               {:doc {value "" } 
                :author {value "Kenneth Leung" }}) 
    (include {value "./loader.kirby" }))

(defn raise! [msg] (throw (new Error msg)))
(defn trap! [msg] (throw msg))
(defn some? [obj] (not (or (undef? obj) (null? obj))))
(defn nichts? [obj] (not (some? obj)))
(defn zero? [obj] (if (number? obj) (== {value nil source core.kirby line 36 column 25} obj) {value nil source core.kirby line 36 column 32}))
(defn get?? [obj fld dft] (var x (if obj (get obj fld))) (if (undef? x) dft x))
(defn contains? [coll itm] (cond (or (array? coll) (string? coll)) (.includes coll itm) (object? coll) (.includes (keys coll) itm) :else {value nil source core.kirby line 53 column 11}))
(defn excludes? [coll itm] (not (contains? coll itm)))
(defn make-array [len obj] (do-with [ret []] (for ((i {value nil source core.kirby line 64 column 14}) (< i len) (i (inc i))) (.push ret obj))))
(defn vector {value "" source core.kirby line 70 column 14} [] (doto (.call Array.prototype.slice arguments {value nil source core.kirby line 71 column 48}) (set! :eTYPE tkn-vector)))
(defn list {value "" source core.kirby line 76 column 12} [] (.call Array.prototype.slice arguments {value nil source core.kirby line 77 column 42}))
(defn each-key [func obj] (each (fn [k] (func (get obj k) k obj)) (Object.keys obj)))
(defn zipmap [keys vals] (var vs (or vals [])) (do-with [ret {}] (for ((i {value nil source core.kirby line 91 column 14}) (< i (alen keys)) (i (inc i))) (set! vv (nth vs i)) (set! ret (nth keys i) (if (undef? vv) {value nil source core.kirby line 96 column 29} vv)))))
(defn last [coll] (if coll (aget coll (dec (alen coll)))))
(defn nth [coll pos] (if coll (aget coll pos)))
(defn even? [n] (= (mod n {value 2 source core.kirby line 109 column 27}) {value nil source core.kirby line 109 column 30}))
(defn odd? [n] (not (even? n)))
(defn pos? [arg] (and (number? arg) (> arg {value nil source core.kirby line 118 column 29})))
(defn neg? [arg] (and (number? arg) (< arg {value nil source core.kirby line 123 column 29})))
(defn constantly [x] (fn [] x))
(defn identity [x] x)
(defn count [x] (if (some? x) (cond (or (array? x) (string? x)) (.-length x) (object? x) (count (keys x)) :else {value nil source core.kirby line 141 column 13}) {value nil source core.kirby line 142 column 5}))
(defn slice [arr begin end] (if (number? end) (.call Array.prototype.slice arr begin end) (.call Array.prototype.slice arr begin)))
(defn take [c n] (if c (.slice c {value nil source core.kirby line 153 column 34} n) []))
(defn drop [c n] (if c (.slice c n) []))
(defn conj! [c a] (.push c a) c)
(defn conj!! [c a] (if a (.push c a)) c)
(defn not-empty [x] (if (and x (> (alen x) {value nil source core.kirby line 172 column 24})) x {value nil source core.kirby line 172 column 30}))
(defn empty? [x] (if x (== {value nil source core.kirby line 177 column 13} (alen x)) {value true source core.kirby line 177 column 25}))
(defn seq [x] (cond (string? x) (Array.from x) (array? x) x (object? x) (Object.entries x) :else []))
(ns (with-meta czlab.kirby.macros {:doc {value "" source dist/macros.kirby line 9 column 12} :author {value "Kenneth Leung" source dist/macros.kirby line 10 column 15}}))
(defmacro whatis? [obj] (Object.prototype.toString.call (unquote obj)))
(defmacro assert [cond msg] (when-not (unquote cond) (throw (new Error (unquote msg))) {value nil source dist/macros.kirby line 22 column 44}))
(defmacro regexs [pattern glim] (new RegExp (unquote pattern) (unquote glim)))
(defmacro regex [pattern] (new RegExp (unquote pattern)))
(defmacro undef? [obj] (= (typeof (unquote obj)) {value "undefined" source dist/macros.kirby line 31 column 41}))
(defmacro boolean? [obj] (= (typeof (unquote obj)) {value "boolean" source dist/macros.kirby line 32 column 43}))
(defmacro number? [obj] (= (typeof (unquote obj)) {value "number" source dist/macros.kirby line 33 column 42}))
(defmacro string? [obj] (= (typeof (unquote obj)) {value "string" source dist/macros.kirby line 34 column 42}))
(defmacro fn? [obj] (= (typeof (unquote obj)) {value "function" source dist/macros.kirby line 35 column 38}))
(defmacro date? [obj] (= (whatis? (unquote obj)) {value "[object Date]" source dist/macros.kirby line 40 column 21}))
(defmacro regex? [obj] (= (whatis? (unquote obj)) {value "[object RegExp]" source dist/macros.kirby line 45 column 21}))
(defmacro array? [obj] (= (whatis? (unquote obj)) {value "[object Array]" source dist/macros.kirby line 50 column 21}))
(defmacro object? [obj] (= (whatis? (unquote obj)) {value "[object Object]" source dist/macros.kirby line 55 column 21}))
(defmacro null? [obj] (= (whatis? (unquote obj)) {value "[object Null]" source dist/macros.kirby line 60 column 21}))
(defmacro def? [obj] (not (undef? (unquote obj))))
(defmacro true? [obj] (= {value true source dist/macros.kirby line 68 column 26} (unquote obj)))
(defmacro false? [obj] (= {value nil source dist/macros.kirby line 72 column 27} (unquote obj)))
(defmacro values [obj] (Object.values (unquote obj)))
(defmacro keys [obj] (Object.keys (unquote obj)))
(defmacro when-not [cond &rest] (when (not (unquote cond)) (unquote &rest)))
(defmacro unless [cond &rest] (when-not (unquote cond) (unquote &rest)))
(defmacro if-not [cond &rest] (if (not (unquote cond)) (#<< &rest) (#if &rest (#<< &rest))))
(defmacro when [cond &rest] (if (unquote cond) (do (unquote &rest))))
(defmacro cond [&rest] (if (#<< &rest) (#<< &rest) (#if &rest (cond (unquote &rest)))))
(defmacro -> [func form &rest] (#if &rest (-> ((#<< form) (unquote func) (splice-unquote form)) (unquote &rest)) ((#<< form) (unquote func) (splice-unquote form))))
(defmacro ->> [func form &rest] (#if &rest (->> ((splice-unquote form) (unquote func)) (unquote &rest)) ((splice-unquote form) (unquote func))))
(defmacro each [func coll] (.forEach (unquote coll) (unquote func)))
(defmacro reduce0 [func coll] (.reduce (unquote coll) (unquote func)))
(defmacro reduce [func start coll] (.reduce (unquote coll) (unquote func) (unquote start)))
(defmacro map [func coll] (.map (unquote coll) (unquote func)))
(defmacro filter [func coll] (.filter (unquote coll) (unquote func)))
(defmacro some [func coll] (.some (unquote coll) (unquote func)))
(defmacro every? [func coll] (.every (unquote coll) (unquote func)))
(defmacro loop [bindings &rest] ((# (var recur {value nil source dist/macros.kirby line 144 column 18} ____xs {value nil source dist/macros.kirby line 145 column 19} ____f (fn [(#evens* bindings)] (unquote &rest)) ____ret ____f) (set! recur (# (set! ____xs arguments) (when (def? ____ret) (js# {value "for (____ret=undefined; ____ret===undefined; ____ret=____f.apply(this,____xs));" source dist/macros.kirby line 151 column 23}) ____ret))) (recur (#odds* bindings)))))
(defmacro template [name pms &rest] (def (unquote name) (fn [(splice-unquote pms)] (str (unquote &rest)))))
(defmacro template-repeat [coll &rest] (reduce (fn [____memo ____elem ____index ____coll] (str ____memo (str (unquote &rest)))) {value "" source dist/macros.kirby line 165 column 36} (unquote coll)))
(defmacro template-repeat-key [obj &rest] (do-with [____ret {value "" source dist/macros.kirby line 170 column 21}] (each-key (fn [value key] (set! ____ret (str ____ret (str (unquote &rest))))) (unquote obj))))
(defmacro sequence [name args init &rest] (def (unquote name) (fn [(splice-unquote args)] ((# (splice-unquote init) (var next {value nil source dist/macros.kirby line 181 column 22} ____curr {value nil source dist/macros.kirby line 182 column 26} ____actions (new Array (unquote &rest))) (set! next (# (var ne (get ____actions (++ ____curr))) (if ne ne (throw {value "Call to (next) beyond sequence." source dist/macros.kirby line 188 column 30})))) ((next)))))))
(defmacro assert-test [cond msg] (if (unquote cond) (str {value "Passed - " source dist/macros.kirby line 195 column 11} (unquote msg)) (str {value "Failed - " source dist/macros.kirby line 196 column 11} (unquote ms))))
(defmacro test-group [name &rest] (var (unquote name) (# [(unquote &rest)])))
(defmacro test-runner [groupname desc] ((fn [name dsc] (var start (new Date) tests (name) passed {value nil source dist/macros.kirby line 208 column 32} failed {value nil source dist/macros.kirby line 208 column 41}) (each (fn [em] (if (.match em (new RegExp {value "^Passed" source dist/macros.kirby line 211 column 38})) (++ passed) (++ failed))) tests) (str (str {value "\n" source dist/macros.kirby line 215 column 14} dsc {value "\n" source dist/macros.kirby line 215 column 23} start {value "\n\n" source dist/macros.kirby line 215 column 34}) (template-repeat tests ____elem {value "\n" source dist/macros.kirby line 216 column 41}) {value "\nTotal tests " source dist/macros.kirby line 217 column 9} (alen tests) {value "\nPassed " source dist/macros.kirby line 218 column 9} passed {value "\nFailed " source dist/macros.kirby line 219 column 9} failed {value "\nDuration " source dist/macros.kirby line 220 column 9} (- (new Date) start) {value "ms\n" source dist/macros.kirby line 220 column 44})) (unquote groupname) (unquote desc)))
(defmacro m-identity [] (hash-map bind (fn [mv mf] (mf mv)) unit (fn [v] v)))
(defmacro m-maybe [] (hash-map bind (fn [mv mf] (if (nil? mv) {value nil source dist/macros.kirby line 233 column 37} (mf mv))) unit (fn [v] v) zero {value nil source dist/macros.kirby line 235 column 11}))
(defmacro m-array [] (hash-map bind (fn [mv mf] (reduce (fn [accum val] (accum.concat val)) [] (map mv mf))) unit (fn [v] [v]) zero [] plus (# (reduce (fn [accum val] (accum.concat val)) [] (Array.prototype.slice.call arguments)))))
(defmacro m-state [] (hash-map bind (fn [mv f] (fn [s] (var l (mv s) v (get l {value nil source dist/macros.kirby line 260 column 29}) ss (get l {value 1 source dist/macros.kirby line 261 column 30})) ((f v) ss))) unit (fn [v] (fn [s] [v s]))))
(defmacro m-continuation [] (hash-map bind (fn [mv mf] (fn [c] (mv (fn [v] ((mf v) c))))) unit (fn [v] (fn [c] (c v)))))
(defmacro m-bind [binder bindings expr] ((unquote binder) (#slice@2 bindings) (fn [(#<< bindings)] (#if bindings (m-bind (unquote binder) (unquote bindings) (unquote expr)) ((# (unquote expr)))))))
(defmacro do-monad [monad bindings expr] ((fn [____m] (var ____u (fn [v] (if (and (undef? v) (def? ____m.zero)) ____m.zero (____m.unit v)))) (m-bind ____m.bind (unquote bindings) (____u (unquote expr)))) ((unquote monad))))
(defmacro defmonad [name obj] (def (unquote name) (# (unquote obj))))
(defmacro and [&rest] (&& (unquote &rest)))
(defmacro or [&rest] (|| (unquote &rest)))
(defmacro not [&rest] (! (unquote &rest)))
(defmacro not= [&rest] (!= (unquote &rest)))
(defmacro mod [&rest] (% (unquote &rest)))
(defmacro nil? [&rest] (null? (unquote &rest)))
(defmacro eq? [&rest] (== (unquote &rest)))
(defmacro alen [arr] (.-length (unquote arr)))
(defmacro eindex [arr] (- (.-length (unquote arr)) {value 1 source dist/macros.kirby line 309 column 43}))
(defmacro second [coll] (nth (unquote coll) {value 1 source dist/macros.kirby line 313 column 36}))
(defmacro third [coll] (nth (unquote coll) {value 2 source dist/macros.kirby line 314 column 35}))
(defmacro fourth [coll] (nth (unquote coll) {value 3 source dist/macros.kirby line 315 column 36}))
(defmacro first [coll] (nth (unquote coll) {value nil source dist/macros.kirby line 316 column 35}))
(defmacro car {value "index 0" source dist/macros.kirby line 318 column 15} [coll] (first (unquote coll)))
(defmacro cdr [c] (drop (unquote c) {value 1 source dist/macros.kirby line 319 column 28}))
(defmacro cadr {value "index 1" source dist/macros.kirby line 320 column 16} [coll] (second (unquote coll)))
(defmacro caddr {value "index 2" source dist/macros.kirby line 321 column 17} [coll] (third (unquote coll)))
(defmacro cadddr {value "index 3" source dist/macros.kirby line 322 column 18} [coll] (fourth (unquote coll)))
(defmacro bit-shift-right-zero [&rest] (>>> (unquote &rest)))
(defmacro bit-shift-right [&rest] (>> (unquote &rest)))
(defmacro bit-shift-left [&rest] (<< (unquote &rest)))
(defmacro # [&rest] (fn [] (unquote &rest)))
(defmacro inc [x] (+ (unquote x) {value 1 source dist/macros.kirby line 340 column 25}))
(defmacro dec [x] (- (unquote x) {value 1 source dist/macros.kirby line 341 column 25}))
(defmacro try! [&rest] (try (unquote &rest) (catch ____error undefined)))
(defmacro let* [bindings expr] (do-monad m-identity (unquote bindings) (unquote expr)))
(defmacro let [bindings &rest] (do (var (splice-unquote bindings)) (unquote &rest)))
(defmacro do-with [binding &rest] (let (unquote binding) (do (unquote &rest) (#head binding))))
(defmacro do->false [&rest] (do (unquote &rest) {value nil source dist/macros.kirby line 365 column 40}))
(defmacro do->true [&rest] (do (unquote &rest) {value true source dist/macros.kirby line 366 column 39}))
(defmacro do->nil [&rest] (do (unquote &rest) {value nil source dist/macros.kirby line 367 column 38}))
(defmacro do->undef [&rest] (do (unquote &rest) undefined))
(defmacro dotimes [binding &rest] (loop ((#head binding) {value nil source dist/macros.kirby line 373 column 26} ____times (#tail binding)) (when (> ____times (#head binding)) (unquote &rest) (recur (inc (#head binding)) ____times))))
(defmacro if-some [binding then else] (let [(splice-unquote binding)] (if (some? (#head binding)) (unquote then) (unquote else))))
(defmacro when-some [binding &rest] (let [(splice-unquote binding)] (when (some? (#head binding)) (unquote &rest))))
(defmacro conj [c a] (.concat (unquote c) [(unquote a)]))
(defmacro concat [a b] (.concat (unquote a) (unquote b)))
(defmacro js-args? [] (> (alen arguments) {value nil source dist/macros.kirby line 398 column 43}))
(defmacro toggle! [x] (set! (unquote x) (not (unquote x))))
(defmacro jsargs! [] (Array.prototype.slice.call arguments))
