
(ns ^{:doc ""
      :author "Kenneth Leung"}
  czlab.cocos2dx.ccsx)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn randomPos "" [node]
  (var wb (visBox))
  (.setPosition node
                (randInt wb.right)
                (randInt wb.top)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn mkHMenu
  "" [mitems pad] (mkMenu mitems false pad))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn mkVMenu
  "" [mitems pad] (mkMenu mitems true pad))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn mkMenu
  "Make menu with items of same size"
  [mitems vert? pad]

  (var menu (cc.Menu))
  (each #(.addChild menu %) mitems)
  (if-not vert?
    (.alignItemsHorizontallyWithPadding menu pad)
    (.alignItemsVerticallyWithPadding menu pad)) menu)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn mkMenu1 "" [item]
  (doto (cc.Menu)
    (.addChild item)
    (.setPosition 0 0)
    (.setAnchorPoint (anchorBL))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn isDesktop? "" [] false)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn splitHexColor "" [color]
  (var f /^#([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
       s /^#([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])$/
       len (n# color)
       arr (or (.exec f color)
               (.exec s color)))
  (when arr
    (set! arr (slice arr 1))
    (map #(parseInt (str "0x" %))
         (if (= len 4) (map #(str % %) arr) arr))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn colorRGB "" [color]
  (var arr (splitHexColor color))
  (cc.color (1st arr) (2nd arr (3rd arr))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn sfxMusic "" [cfg music repeat?]
  (var fp (.getMusic @cfg music))
  (try
    (.playMusic cc.audioEngine fp repeat?)
    (catch e
      (cc.log "failed to play music: %s" music))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn sfxPlay "" [cfg sound]
  (var fp (.getEffect @cfg sound))
  (try
    (.playEffect cc.audioEngine fp)
    (catch e
      (cc.log "failed to play sound: %s" sound))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn pauseEffects "" [] (.pauseAllEffects cc.audioEngine))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn pauseMusic "" [] (.pauseMusic cc.audioEngine))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn pauseAudio "" [] (pauseEffects) (pauseMusic))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn resumeEffects "" [] (.resumeAllEffects cc.audioEngine))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn resumeMusic "" [] (.resumeMusic cc.audioEngine))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn resumeAudio "" [] (resumeEffects) (resumeMusic))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn stopEffects "" [] (.stopAllEffects cc.audioEngine))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn stopMusic "" [] (.stopMusic cc.audioEngine))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn stopAudio "" [] (stopEffects) (stopMusic))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn calcOffsets "" ^cc.Size [sz]
  (cc.size (/ sz.width *golden-ratio*)
           (/ sz.height *golden-ratio*)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createSpriteBatch
  "" ^cc.SpriteBatchNode [cfg name]
  (new cc.SpriteBatchNode (.getImage @cfg name)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createAudioIcons "" [cfg]
  (var off "sound_off.png"
       on "sound_on.png")
  [(createMenuBtn off off) (createMenuBtn on on)])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn calcDist "" [nodea nodeb]
  (cc.pDistance (.getPosition nodea) (.getPosition nodeb)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn normalize "" [nodea nodeb]
  (cc.pNormalize (cc.pSub (.getPosition nodeb)
                          (.getPosition nodea))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createTTFMenuText "" [font pt txt color]
  (var z (createTTFLabel font pt txt))
  (.setColor z color)
  (new cc.MenuItemLabel z))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createBMFMenuText "" [font txt color]
  (var z (createBMFLabel font txt))
  (.setColor z color)
  (new cc.MenuItemLabel z))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createMenuBtnSprite "" [cfg normal selected]
  (new cc.MenuItemSprite (createSprite normal) (createSprite selected)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createMenuBtnImage "" [src normal selected]
  (new cc.MenuItemImage (.getImage @cfg normal) (.getImage @cfg selected)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn pointInBox?
  "Test if this point is inside this rectangle"
  [box x y]
  (and (>= x box.left)
       (<= x box.right)
       (>= y box.bottom) (<= y box.top)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn positionInBox? "" [box pos] (pointInBox? box pos.x pos.y))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn white "" [] (cc.color 255 255 255))
(defn black "" [] (cc.color 0 0 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createBMFLabel "" [cfg font text]
  (doto (new cc.LabelBMFont
             text
             (.getFont @cfg font)) (.setOpacity (* 0.9 255))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createBMFLabelAtPos "" [cfg font text x y]
  (doto (createBMFLabel cfg font text) (.setPosition f x y)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createTTFLabel "" [font sz text]
  (new cc.LabelTTF text (.getFont @cfg font) sz))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createTTFLabelAtPos "" [font sz text x y]
  (doto (createTTFLabel font sz text) (.setPosition x y)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn collided?
  "Test collision of 2 sprites"
  [nodea nodeb]
  (if (and nodea nodeb) (.intersectsRect (bbox a) (bbox b)) false))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn setDevRes "" [x y resolutionPolicy]
  (-> (.getOpenGLView cc.director)
      (.setDesignResolutionSize x y resolutionPolicy)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn isTapped? "" [node tap]
  (var bb (.getBoundingBox node))
  (<= (.distance tap (.getPosition node)) (* 0.8 bb.size.width)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn deltaX "" [nodea nodeb]
  (- (.getPositionX nodeb) (.getPositionX nodea)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn deltaY "" [nodea nodeb]
  (- (.getPositionY nodeb) (.getPositionY nodea)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn isPortrait? "" [] (var s screen) (> s.height s.width))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn readJson "" [fpath]
  (JSON/parse (jsb.fileUtils.getStringFromFile fpath)))


//////////////////////////////////////////////////////////////////////////
//
bool outOfBound(not_null<c::Node*> ent, const Box4 &B) {
  return N_NIL(ent) ? outOfBound(bbox4(ent), B) : false;
}

//////////////////////////////////////////////////////////////////////////
//
bool outOfBound(const Box4 &a, const Box4 &B) {
  return a.left > B.right    ||
         a.top < B.bottom  ||
         a.right < B.left      ||
         a.bottom > B.top;
}

//////////////////////////////////////////////////////////////////////////
//
const CCT_SZ scaleSize(const CCT_SZ &z, float scale) {
  return CCT_SZ(z.width * scale, z.height * scale);
}

//////////////////////////////////////////////////////////////////////////
//
void undoTimer(c::DelayTime* tm) {
  if (tm) CC_DROP(tm);
}

//////////////////////////////////////////////////////////////////////////
//
void mergeDict(c::Dictionary *src, c::Dictionary *d2) {
  NS_USING(cocos2d)
  DictElement *e= CC_NIL;
  CCDICT_FOREACH(d2, e) {
    auto obj = e->getObject();
    auto key= e->getStrKey();
    src->setObject(obj, key);
  }
}

//////////////////////////////////////////////////////////////////////////
// Reify a timer action
//
c::DelayTime* reifyTimer(not_null<c::Node*> par, float millis) {
  auto t= c::DelayTime::create(millis/1000.0f);// in secs
  CC_KEEP(t)
  par->runAction(t);
  return t;
}

//////////////////////////////////////////////////////////////////////////
//
bool timerDone(c::DelayTime* t) {
  return t ? t->isDone() : false;
}

//////////////////////////////////////////////////////////////////////////////
//
owner<c::Animation*> createAnimation(float dpu, bool restore, int loops) {

  auto a= c::Animation::create();
  a->setRestoreOriginalFrame(restore);
  a->setDelayPerUnit(dpu);
  a->setLoops(loops);
  return a;
}


//////////////////////////////////////////////////////////////////////////
// Reify a sprite from its frame name
c::Sprite* reifySprite(const sstr &name) {
  return c::Sprite::createWithSpriteFrameName(name);
}

//////////////////////////////////////////////////////////////////////////
// Reify a sprite from its frame name
c::Sprite* createSprite(const sstr &name) {
  return c::Sprite::create( XCFG()->getImage(name));
}

//////////////////////////////////////////////////////////////////////////////
//
c::Sprite* loadSprite(const sstr &fname, const sstr &path) {
  auto sp= c::Sprite::create();
  sp->initWithFile(path + "/" + fname);
  return sp;
}

//////////////////////////////////////////////////////////////////////////
//
const Box4 bbox4(not_null<c::Node*> s) {
  auto z= s->getBoundingBox();
  return Box4(z.origin.y + z.size.height,
      z.origin.x + z.size.width,
      z.origin.y,
      z.origin.x);
  /*
    GetTop(s),
    GetRight(s),
    GetBottom(s),
    GetLeft(s) */
}

//////////////////////////////////////////////////////////////////////////
//
void prelude() {
  runEx(XCFG()->prelude());
}

//////////////////////////////////////////////////////////////////////////
//
void runEx(not_null<c::Scene*> ns) {
  run(ns, CC_CSV(c::Float, "SCENE_DELAY"));
}

//////////////////////////////////////////////////////////////////////////
//
void run(not_null<c::Scene*> ns, float delay) {
  CC_DTOR()->replaceScene(
      c::TransitionCrossFade::create(delay, ns));
}

//////////////////////////////////////////////////////////////////////////
//
void run(not_null<c::Scene*> ns) {
  CC_DTOR()->replaceScene(ns);
}

//////////////////////////////////////////////////////////////////////////
//
void pushEx(not_null<c::Scene*> ns) {
  push(ns, CC_CSV(c::Float, "SCENE_DELAY"));
}

//////////////////////////////////////////////////////////////////////////
//
void push(not_null<c::Scene*> ns, float delay) {
  CC_DTOR()->pushScene(
      c::TransitionCrossFade::create(delay, ns));
}

//////////////////////////////////////////////////////////////////////////
//
void push(not_null<c::Scene*> ns) {
  CC_DTOR()->pushScene(ns);
}

//////////////////////////////////////////////////////////////////////////
//
bool isTransitioning() {
  return dynamic_cast<c::TransitionScene*>(
      CC_DTOR()->getRunningScene()) != CC_NIL;
}

//////////////////////////////////////////////////////////////////////////
// Find size of this sprite
//
const CCT_SZ calcSize(const sstr &frame) {
  //return reifySprite(frame)->getContentSize();
  return reifySprite(frame)->boundingBox().size;
}

//////////////////////////////////////////////////////////////////////////
// Calculate halves of width and height of this sprite
//
const CCT_SZ halfHW(not_null<c::Node*> s) {
  //auto z= s->getContentSize();
  auto z= s->getBoundingBox().size;
  return CCT_SZ(z.width * 0.5, z.height * 0.5);
}

//////////////////////////////////////////////////////////////////////////
// Reify a rectangle from this sprite
//
const CCT_RT bbox(not_null<c::Node*> s) {
  return s->getBoundingBox();
  /*
  return CCT_RT(GetLeft(s),
                 GetBottom(s),
                 GetWidth(s),
                 GetHeight(s)); */
}

//////////////////////////////////////////////////////////////////////////
//
float getHeight(not_null<c::Node*> s) {
  //return s->getContentSize().height * s->getScaleY();
  return s->getBoundingBox().size.height;
}

//////////////////////////////////////////////////////////////////////////
//
float getWidth(not_null<c::Node*> s) {
  //return s->getContentSize().width * s->getScaleX();
  return s->getBoundingBox().size.width;
}

//////////////////////////////////////////////////////////////////////////
//
float getContentHeight(not_null<c::Node*> s) {
  return s->getContentSize().height;
}

//////////////////////////////////////////////////////////////////////////
//
float getContentWidth(not_null<c::Node*> s) {
  return s->getContentSize().width;
}

//////////////////////////////////////////////////////////////////////////
//
static float get_XXX(not_null<c::Node*> s, float px, float bound) {
  //auto w= s->getContentSize().width;
  auto w= s->getBoundingBox().size.width;
  auto a= s->getAnchorPoint().x;
  return px + (bound - a) * w ;
}

//////////////////////////////////////////////////////////////////////////
//
static float get_YYY(not_null<c::Node*> s, float py, float bound) {
  //auto h= s->getContentSize().height;
  auto h= s->getBoundingBox().size.height;
  auto a= s->getAnchorPoint().y;
  return py + (bound - a) * h ;
}

//////////////////////////////////////////////////////////////////////////
//
float getLeft(not_null<c::Node*> s) {
  return get_XXX(s, s->getPosition().x, anchorL().x);
}

//////////////////////////////////////////////////////////////////////////
//
float getRight(not_null<c::Node*> s) {
  return get_XXX(s, s->getPosition().x, anchorR().x);
}

//////////////////////////////////////////////////////////////////////////
//
float getBottom(not_null<c::Node*> s) {
  return get_YYY(s, s->getPosition().y, anchorB().y);
}

//////////////////////////////////////////////////////////////////////////
//
float getTop(not_null<c::Node*> s) {
  return get_YYY(s, s->getPosition().y, anchorT().y);
}

//////////////////////////////////////////////////////////////////////////
// Get the x pos of the center of the visible screen
//
float centerX() { return center().x; }

//////////////////////////////////////////////////////////////////////////
// Get the y pos of the center of the visible screen.
//
float centerY() { return center().y; }

//////////////////////////////////////////////////////////////////////////
// Get the center of the visible screen
//
const CCT_PT center() {
  auto rc = visRect();
  return CCT_PT(rc.origin.x + HWZ(rc.size), rc.origin.y + HHZ(rc.size));
}

//////////////////////////////////////////////////////////////////////////
// Get the screen height
//
float screenHeight() { return screen().height; }

//////////////////////////////////////////////////////////////////////////
// Get the screen width
//
float screenWidth() { return screen().width; }

//////////////////////////////////////////////////////////////////////////
// Get the visible screen rectangle
//
const CCT_RT visRect() {
  return CC_DTOR()->getOpenGLView()->getVisibleRect();
}

//////////////////////////////////////////////////////////////////////////////
//
const CCT_SZ visSize() {
  return CC_DTOR()->getOpenGLView()->getVisibleRect().size;
}

//////////////////////////////////////////////////////////////////////////
// Get the visible screen box
//
const Box4 visBox() {
  auto vr = CC_DTOR()->getOpenGLView()->getVisibleRect();
  return Box4(
    vr.origin.y + vr.size.height,
    vr.origin.x + vr.size.width,
    vr.origin.y,
    vr.origin.x
  );
}

//////////////////////////////////////////////////////////////////////////
// Get the actual window/frame size.
//
const CCT_SZ screen() {
  return CC_DTOR()->getOpenGLView()->getFrameSize();
}

//////////////////////////////////////////////////////////////////////////
// Get the actual screen center.
//
const CCT_PT scenter() {
  auto sz = screen();
  return CCT_PT(HWZ(sz), HHZ(sz));
}

//////////////////////////////////////////////////////////////////////////
// Get the center of this box.
//
const CCT_PT vboxMID(const Box4 &box) {
  return CCT_PT(box.left + (box.right-box.left) * 0.5,
              box.bottom + (box.top-box.bottom) * 0.5);
}

//////////////////////////////////////////////////////////////////////////
// Test if this box is hitting boundaries
// rect.x & y are center positioned
//
// If hit, the new position and velocities
// are returned
//
bool traceEnclosure(float dt, const Box4 &bbox,
    const Box4 &rect, const CCT_V2 &vel,
    CCT_PT &outPos, CCT_V2 &outVel) {

  auto sz= rect.top-rect.bottom;//height
  auto sw= rect.right-rect.left;//width
  auto y = rect.bottom+(sz*0.5) + dt * vel.y;// new y
  auto x = rect.left+(sw*0.5) + dt * vel.x;// new x
  auto vx= vel.x;
  auto vy= vel.y;
  auto hit=false;

  if (y + sz > bbox.top) {
    //hitting top wall
    y = bbox.top - sz;
    vy = -vy;
    hit=true;
  }
  else
  if (y - sz < bbox.bottom) {
    //hitting bottom wall
    y = bbox.bottom + sz;
    vy = -vy;
    hit=true;
  }

  if (x + sw > bbox.right) {
    //hitting right wall
    x = bbox.right - sw;
    vx = -vx;
    hit=true;
  }
  else
  if (x - sw < bbox.left) {
    //hitting left wall
    x = bbox.left + sw;
    vx = -vx;
    hit=true;
  }

  outPos.x=x;
  outPos.y=y;
  outVel.x=vx;
  outVel.y=vy;

  return hit;
}

//////////////////////////////////////////////////////////////////////////////
//
bool isIntersect(const Box4 &a1, const Box4 &a2) {
  return ! (a1.left > a2.right ||
            a2.left > a1.right ||
            a1.top < a2.bottom ||
            a2.top < a1.bottom);
}

//////////////////////////////////////////////////////////////////////////
// Get the sprite from the frame cache using its id (e.g. #ship)
//
c::SpriteFrame* getSpriteFrame(const sstr &frameid, const CCT_RT &r) {
  auto f= CC_SCAC()->getSpriteFrameByName(frameid);
  f->setRect(r);
  return f;
}

//////////////////////////////////////////////////////////////////////////
// Get the sprite from the frame cache using its id (e.g. #ship)
//
c::SpriteFrame* getSpriteFrame(const sstr &frameid) {
  return CC_SCAC()->getSpriteFrameByName(frameid);
}

//////////////////////////////////////////////////////////////////////////
//
const CCT_PT anchorC() { return CCT_PT::ANCHOR_MIDDLE;}

//////////////////////////////////////////////////////////////////////////
//
const CCT_PT anchorT() { return CCT_PT::ANCHOR_MIDDLE_TOP;}

//////////////////////////////////////////////////////////////////////////
//
const CCT_PT anchorTR() { return CCT_PT::ANCHOR_TOP_RIGHT; }

//////////////////////////////////////////////////////////////////////////
//
const CCT_PT anchorR() { return CCT_PT::ANCHOR_MIDDLE_RIGHT;}

//////////////////////////////////////////////////////////////////////////
//
const CCT_PT anchorBR() { return CCT_PT::ANCHOR_BOTTOM_RIGHT; }

//////////////////////////////////////////////////////////////////////////
//
const CCT_PT anchorB() { return CCT_PT::ANCHOR_MIDDLE_BOTTOM; }

//////////////////////////////////////////////////////////////////////////
//
const CCT_PT anchorBL() { return CCT_PT::ANCHOR_BOTTOM_LEFT; }

//////////////////////////////////////////////////////////////////////////
//
const CCT_PT anchorL() { return CCT_PT::ANCHOR_MIDDLE_LEFT; }

//////////////////////////////////////////////////////////////////////////
//
const CCT_PT anchorTL() { return CCT_PT::ANCHOR_TOP_LEFT; }

//////////////////////////////////////////////////////////////////////////
// not used for now.
//
void resolveElastic(
    not_null<c::Node*> obj1,
    CCT_V2 &vel1,
    not_null<c::Node*> obj2, CCT_V2 &vel2) {

  auto pos2 = obj2->getPosition();
  auto pos1= obj1->getPosition();
  auto sz2= CC_CSIZE(obj2);
  auto sz1= CC_CSIZE(obj1);
  auto hh1= HHZ(sz1);
  auto hw1= HWZ(sz1);
  auto x = pos1.x;
  auto y= pos1.y;
  auto bx2 = bbox4(obj2);
  auto bx1 = bbox4(obj1);

  // coming from right
  if (bx1.left < bx2.right && bx2.right < bx1.right) {
    vel2.x = - fabs(vel2.x);
    vel1.x = fabs(vel1.x);
    x= getRight(obj2) + hw1;
  }
  else
  // coming from left
  if (bx1.right > bx2.left && bx1.left < bx2.left) {
    vel1.x = - fabs(vel1.x);
    vel2.x = fabs(vel2.x);
    x= getLeft(obj2) - hw1;
  }
  else
  // coming from top
  if (bx1.bottom < bx2.top && bx1.top > bx2.top) {
    vel2.y = - fabs(vel2.y);
    vel1.y = fabs(vel1.y);
    y= getTop(obj2) + hh1;
  }
  else
  // coming from bottom
  if (bx1.top > bx2.bottom && bx2.bottom > bx1.bottom) {
    vel1.y = - fabs(vel1.y);
    vel2.y = fabs(vel2.y);
    y= getBottom(obj2) - hh1;
  }
  else {
    return;
  }
  //obj1->updatePosition(x,y);
}

//////////////////////////////////////////////////////////////////////////////
//
const CCT_PT clamp(const CCT_PT& loc, const CCT_SZ &sz, const Box4 &world) {
  auto hh = HHZ(sz);
  auto hw = HWZ(sz);
  auto x= loc.x;
  auto y= loc.y;

  if ((loc.x + hw) > world.right) {
    x = world.right - hw;
  }
  if ((loc.x - hw) < world.left) {
    x = world.left + hw;
  }
  if ((loc.y - hh) < world.bottom) {
    y = world.bottom + hh;
  }
  if ((loc.y + hh) > world.top) {
    y = world.top - hh;
  }

  return CCT_PT(x,y);
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
const CCT_PT clamp(const CCT_PT &cur, const Box4 &bx) {
  return ccpClamp(cur, c::ccp(bx.left, bx.bottom), c::ccp(bx.right, bx.top));
}

//////////////////////////////////////////////////////////////////////////////
//
int randInt(int upper) {
    //auto r=cocos2d::rand_0_1();
    //CCLOG("rand01 ===== %f", r);
  return (int) floor( cocos2d::rand_0_1() * upper);
}

//////////////////////////////////////////////////////////////////////////////
//
float randFloat(float upper) {
  return cocos2d::rand_0_1() * upper;
}

//////////////////////////////////////////////////////////////////////////////
//
int randSign() {
    return (::rand() % 2) == 1 ? 1 : -1;
  /*
  int n=  cocos2d::rand_0_1() * 10;
  switch (n) {
    case 0: case 2: case 4: case 6: case 8: return 1;
    default: return -1;
  }
  */
}

//////////////////////////////////////////////////////////////////////////////
//
float rand() {
  return cocos2d::rand_0_1();
}

//////////////////////////////////////////////////////////////////////////////
//
float degToRad(float deg) {
  return deg * M_PI / 180;
}

//////////////////////////////////////////////////////////////////////////////
//
long long timeInMillis() {
  return c::utils::getTimeInMilliseconds();
}

//////////////////////////////////////////////////////////////////////////////
//
const CCT_PT calcXY(float angle, float hypot) {
  // quadrants =  4 | 1
  //             --------
  //              3 | 2
  float theta, q, x, y;
  if (angle >= 0 && angle <= 90) {
    theta = degToRad(90 - angle);
    x = cos(theta);
    y = sin(theta);
    q=1;
  }
  else
  if (angle >= 90 && angle <= 180 ) {
    theta = degToRad(angle - 90);
    x = cos(theta);
    y =  - sin(theta);
    q=2;
  }
  else
  if (angle >= 180 && angle <= 270) {
    theta = degToRad(270 - angle);
    x = - cos(theta);
    y = - sin(theta);
    q=3;
  }
  else
  if (angle >= 270 && angle <= 360) {
    theta= degToRad(angle - 270);
    x = - cos(theta);
    y = sin(theta);
    q=4;
  }
  else {
  }

  return CCT_PT( x * hypot, y * hypot);
}

//////////////////////////////////////////////////////////////////////////////
//
VOIDFN throttle(VOIDFN func, int wait) {
  long long ww= (long long)wait;
  long long previous = 0;
  return [=]() mutable {
    auto now = timeInMillis();
    if (previous==0)
    { previous = now; }
    auto remaining = ww - (now - previous);
    if (remaining <= 0 || remaining > ww) {
      previous = now;
      func();
    }
  };
}

//////////////////////////////////////////////////////////////////////////////
//
void testCollide(not_null<f::FPool*> p1, not_null<ecs::Node*> node) {
  if (node->status())
    p1->foreach([=](f::Poolable* _p1) {
      auto e1= (ecs::Node*) _p1;
      testCollide(e1,node);
    });
}

//////////////////////////////////////////////////////////////////////////////
//
void testCollide(not_null<f::FPool*> p1, not_null<f::FPool*> p2) {
  p1->foreach([=](f::Poolable* _p1) {
  p2->foreach([=](f::Poolable* _p2) {
    auto e2= (ecs::Node*) _p2;
    auto e1= (ecs::Node*) _p1;
    testCollide(e1,e2);
  });
  });
}

//////////////////////////////////////////////////////////////////////////////
//
void testCollide(not_null<ecs::Node*> e1, not_null<ecs::Node*> e2) {
  auto s2= CC_GEC(f::CPixie,e2.get(),"f/CPixie");
  auto s1= CC_GEC(f::CPixie,e1.get(),"f/CPixie");
  if (e2->status() &&
      e1->status() &&
      collide(s2,s1)) {
    auto h2= CC_GEC(f::CHealth,e2.get(),"f/CHealth");
    auto h1= CC_GEC(f::CHealth,e1.get(),"f/CHealth");
    h2->hurt();
    h1->hurt();
  }
}

//////////////////////////////////////////////////////////////////////////////
//
void hibernate(not_null<ecs::Node*> node) {
  auto s=CC_GEC(f::CPixie,node.get(),"f/CPixie");
  if (s) { s->deflate(); }
  node->yield();
}

//////////////////////////////////////////////////////////////////////////////
//
void resurrect(not_null<ecs::Node*> node, float x, float y) {
  auto h=CC_GEC(f::CHealth,node.get(),"f/CHealth");
  auto s=CC_GEC(f::CPixie,node.get(),"f/CPixie");
  if (s) { s->inflate(x,y); }
  if (h) { h->reset(); }
  node->take();
}

//////////////////////////////////////////////////////////////////////////////
//
void kumakaze(not_null<ecs::Node*> node) {
  auto h=CC_GEC(f::CHealth,node.get(),"f/CHealth");
  if (h) {
    h->curHP = 0;
  }
}

//////////////////////////////////////////////////////////////////////////////
//
void resurrect(not_null<ecs::Node*> node) {
  auto h=CC_GEC(f::CHealth,node.get(),"f/CHealth");
  auto s=CC_GEC(f::CPixie,node.get(),"f/CPixie");
  if (s) { s->inflate(); }
  if (h) { h->reset(); }
  node->take();
}

//////////////////////////////////////////////////////////////////////////////
//
void resolveNodes(not_null<f::FPool*> pool) {
  pool->foreach([=](f::Poolable *p) {
    if (p->status()) {
      auto ht=CC_GEC(f::CHealth,p,"f/CHealth");
      if (N_NIL(ht) &&
          !ht->alive())
        hibernate(PCAST(ecs::Node,p));
    }
  });
}


NS_END
NS_END


