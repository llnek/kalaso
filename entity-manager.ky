(ns )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn clone "" [obj]
)

(deftype EntityManager []

  (constructor [cb]
    (assoc! this
            :lsnr cb
            :entities []
            :components {}
            :templates {}
            :entData {}
            :processors []
            :uid 0))
  (getUid []
    (++$ @@uid))

  (createEntity [&comps]
    (let [eid (@@getUid)]
      (@@addToEntity eid comps)
      (conj! @@ents eid)))

  (removeEntity [eid]
    (each #(let [x (get @@entData %)]
             (if (.has x eid)
               (.remove x eid)))
          (.keys @@entData))
    (.delete @@ents eid))

  (addComponent [id component]
    (.set @@comps id component))

  (removeComponent [id]
    (.delete @@comps id)
    (.delete @@entData id))

  (getComponentsList []
    (.keys @@comps))

  (addCompToEntity [eid & cids]
    (each (fn [id]
            (if-not (.has me.comps id)
              (raise! ""))
            (if-not (.has me.entData id)
              (.set me.entData id {}))
            (oset! c :____eid eid)
            (.set (.get me.entData id) eid c))
          cids))


    /**
     * De-associate a list of components from the entity.
     *
     * @param {array} componentIds - List of identifiers of the components to remove from the entity.
     * @param {int} entityId - Unique identifier of the entity.
     * @return {object} - this
     */
    removeComponentsFromEntity(componentIds, entityId) {
        // First verify that all the components exist, and throw an error
        // if any is unknown.
        componentIds.forEach(comp => {
            if (!this.components[comp]) {
                throw new Error('Trying to use unknown component: ' + comp);
            }
        });

        // Now we know that this request is correct, let's remove all the
        // components' states for that entity.
        componentIds.forEach(comp => {
            if (this.entityComponentData[comp]) {
                if (this.entityComponentData[comp][entityId]) {
                    delete this.entityComponentData[comp][entityId];
                    if (this.listener) {
                        // Signal the creation of a new entity.
                        this.listener.emit('entityComponentRemoved', entityId, comp);
                    }
                }
            }
        });


        return this;
    }

    /**
     * Return a reference to an object that contains the data of an
     * instanciated component of an entity.
     *
     * @param {int} entityId - Unique identifier of the entity.
     * @param {string} componentId - Unique identifier of the component.
     * @return {object} - Component data of one entity.
     */
    getComponentDataForEntity(componentId, entityId) {
        if (!(componentId in this.components)) {
            throw new Error('Trying to use unknown component: ' + componentId);
        }

        if (
            !this.entityComponentData.hasOwnProperty(componentId) ||
            !this.entityComponentData[componentId].hasOwnProperty(entityId)
        ) {
            throw new Error('No data for component ' + componentId + ' and entity ' + entityId);
        }

        return this.entityComponentData[componentId][entityId];
    }

    /**
     * Update the state of a component, many keys at once.
     *
     * @param {int} entityId - Unique identifier of the entity.
     * @param {string} componentId - Unique identifier of the component.
     * @param {object} newState - Object containing the new state to apply.
     * @return {object} - this
     */
    updateComponentDataForEntity(componentId, entityId, newState) {
        const compState = this.getComponentDataForEntity(componentId, entityId);

        for (let key in newState) {
            if (newState.hasOwnProperty(key) && compState.hasOwnProperty(key)) {
                compState[key] = newState[key];
            }
        }

        return this;
    }

    /**
     * Return a list of objects containing the data of all of a given component.
     *
     * @param {string} componentId - Unique identifier of the component.
     * @return {array} - List of component data for one component.
     */
    getComponentsData(componentId) {
        if (!(componentId in this.components)) {
            throw new Error('Trying to use unknown component: ' + componentId);
        }

        if (!this.entityComponentData.hasOwnProperty(componentId)) {
            return [];
        }

        const comps = this.entityComponentData[componentId];
        // The components are stored as an object where entities are keys, but
        // we want to return an array.
        return Object.keys(comps).map(key => comps[key]);
    }

    /**
     * Return true if the entity has the component.
     *
     * @param {int} entityId - Unique identifier of the entity.
     * @param {string} componentId - Unique identifier of the component.
     * @return {boolean} - True if the entity has the component.
     */
    entityHasComponent(entityId, componentId) {
        if (!(componentId in this.components)) {
            return false;
        }

        return (
            this.entityComponentData.hasOwnProperty(componentId) &&
            this.entityComponentData[componentId].hasOwnProperty(entityId)
        );
    }

    //=========================================================================
    // ASSEMBLAGES

    /**
     * Add an assemblage to the list of known assemblages.
     *
     * @param {string} id - Unique identifier of the assemblage.
     * @param {object} assemblage - An instance of an assemblage to add.
     * @return {object} - this
     */
    addAssemblage(id, assemblage) {
        this.assemblages[id] = assemblage;
        return this;
    }

    /**
     * Remove an assemblage from the list of known assemblages.
     *
     * @param {string} id - Unique identifier of the assemblage.
     * @return {object} - this
     */
    removeAssemblage(id) {
        delete this.assemblages[id];
        return this;
    }

    /**
     * Create a new entity in the system by creating a new instance of each of
     * its components and setting their initial state, using an assemblage.
     *
     * @param {string} assemblageId - Id of the assemblage to create the entity from.
     * @return {int} - Unique identifier of the new entity.
     */
    createEntityFromAssemblage(assemblageId) {
        if (!(assemblageId in this.assemblages)) {
            throw new Error('Trying to use unknown assemblage: ' + assemblageId);
        }

        const assemblage = this.assemblages[assemblageId];
        const entity = this.createEntity(assemblage.components);

        for (let comp in assemblage.initialState) {
            if (assemblage.initialState.hasOwnProperty(comp)) {
                const newState = assemblage.initialState[comp];
                this.updateComponentDataForEntity(comp, entity, newState);
            }
        }

        return entity;
    }

    //=========================================================================
    // PROCESSORS

    /**
     * Add a processor to the list of known processors.
     *
     * @param {object} processor - An instance of a processor to manage.
     * @return {object} - this
     */
    addProcessor(processor) {
        this.processors.push(processor);
        return this;
    }

    /**
     * Remove a processor from the list of known processors.
     *
     * @param {object} processor - An instance of a processor to remove.
     * @return {object} - this
     */
    removeProcessor(processor) {
        this.processors.splice(this.processors.indexOf(processor), 1);
        return this;
    }

    /**
     * Update all the known processors.
     *
     * @param {int} dt - The time delta since the last call to update. Will be passed as an argument to all processor's `update` method.
     * @return {object} - this
     */
    update(dt) {
        this.processors.forEach(processor => processor.update(dt));
        return this;
    }
}

