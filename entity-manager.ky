(ns )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn clone "" [obj]
)

(deftype EntityManager []

  (constructor [cb]
    (assoc! this
            :lsnr cb
            :entities []
            :components {}
            :templates {}
            :entData {}
            :processors []
            :uid 0))
  (getUid []
    (++$ @@uid))

  (createEntity [&comps]
    (let [eid (@@getUid)]
      (@@addToEntity eid comps)
      (conj! @@ents eid)))

  (removeEntity [eid]
    (each #(let [x (get @@entData %)]
             (if (.has x eid)
               (.remove x eid)))
          (.keys @@entData))
    (.delete @@ents eid))

  (addComponent [id component]
    (.set @@comps id component))

  (removeComponent [id]
    (.delete @@comps id)
    (.delete @@entData id))

  (getComponentsList []
    (.keys @@comps))

  (addCompToEntity [eid & cids]
    (each (fn [id]
            (if-not (.has me.comps id)
              (raise! ""))
            (if-not (.has me.entData id)
              (.set me.entData id {}))
            (oset! c :____eid eid)
            (.set (.get me.entData id) eid c))
          cids))

  (removeCompFromEntity [eid & cids]
    (each
      (fn [id]
        (when (and (.has @@entData id)
                   (.has (get @@entData id) eid))
          (.delete (get @@entData id) eid)))
      cids))

  (getCompDataForEntity [eid cid]
    (if-some [x (get @@entData cid)]
      (get x eid)))

  (updateCompDataForEntity [eid cid func]
    (func (@@getCompDataForEntity eid cid)))

  (getComponentsData [cid]
    (if-some [x (get @@entData cid)]
      (Array.from (.values x))
      []))

  (entityHasComp [eid cid]
    (if-some [x (get @@entData cid)]
      (.has x eid)
      false))

  (addAssemblage [id assemblage]
    (assoc! @@templates id assemblage))

  (removeAssemblage [id]
    (dissoc! @@templates id))

  (createEntityFromTemplate [id]
    (when-some [x (get @@templates id)]
      (do-with [ent (@@createEntity x.components)]
        (each-property #() x.model))))

  (addProcessor [processor]
    (conj! @@procs processor))

  (removeProcessor [processor]
    (.splice @@procs (indexOf @@procs processor) 1))

  (update [dt]
    (each #(.update % dt) @@procs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF


