/*Auto generated by Kirby v1.0.0 - Fri Jan 12 2018 22:35:05 GMT-0800 (PST)
  czlab.rygel.ecs
({"doc":"","author":"Kenneth Leung"})
*/

const k = require("kirby");
const atom = k["atom"];
const merge = k["merge"];
const swap_BANG = k["swap_BANG"];
const find = k["find"];
const object_QUERY = k["object_QUERY"];
const sort_BANG = k["sort_BANG"];
const some_QUERY = k["some_QUERY"];
const nichts_QUERY = k["nichts_QUERY"];
const conj_BANG = k["conj_BANG"];
const kirbystdlibref = require("kirby");
////////////////////////////////////////////////////////////////////////////////
//fn: [createEngine] in file: ecs.ky, line: 20
//Create an engine, the core of ECS.
const createEngine = function() {
  return atom({
    "entities": {},
    "systems": [],
    "config": {},
    "registry": {},
    "updating?": false
  });
};
////////////////////////////////////////////////////////////////////////////////
//fn: [createSystem] in file: ecs.ky, line: 30
//Create a new system.  Each system must be provided with
//a user defined worker function and a priority value
const createSystem = function(type, priority, worker) {
  if ( (!(((typeof (worker) === "function")))) ) {
    throw Error("Precondition failed");
  } else {
    null;
  }
  return atom({
    "update": worker,
    "typeId": type,
    "priority": priority,
    "active?": false
  });
};
////////////////////////////////////////////////////////////////////////////////
//fn: [createComponent] in file: ecs.ky, line: 39
const createComponent = function(type, attrs) {
  if ( (!(object_QUERY(attrs))) ) {
    throw Error("Precondition failed");
  } else {
    null;
  }
  return atom(merge(attrs, {
    "typeId": type,
    "auto?": false,
    "entity": null
  }));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [createEntity] in file: ecs.ky, line: 44
const createEntity = function(engine, n) {
  let GS__3 = engine.value;
  let entities = GS__3["entities"];
  let eid = generateEid();
  let e = atom({
    "engine": engine,
    "eid": eid,
    "name": n,
    "bodyparts": {}
  });
  entities[eid] = e;
  return e;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [createPooledEntity] in file: ecs.ky, line: 54
const createPooledEntity = function(engine, n, take_QUERY) {
  let e = createEntity(engine, n);
  return (take_QUERY ?
    takeEntity_BANG(e) :
    e);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [getEntities] in file: ecs.ky, line: 59
//Find all the entities inside this engine,
//which contains these component types
const getEntities = function(engine) {
  let componentTypes = Array.prototype.slice.call(arguments, 1);
  let cmin = Number.SAFE_MAX_INTEGER;
  let GS__4 = engine.value;
  let entities = GS__4["entities"];
  let registry = GS__4["registry"];
  let ret = [];
  let ccs = [];
  let missed_QUERY = false;
  let smallest,
    c,
    cid;
  for (let i = 0, sz = kirbystdlibref.count(componentTypes), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
    (cid = componentTypes[i], c = kirbystdlibref.getProp(registry, cid));
    if (nichts_QUERY(c)) {
      missed_QUERY = true;
      ____break = true;
    } else {
      if (true) {
        let cz = kirbystdlibref.count(c);
        if ( (cz < cmin) ) {
          (smallest = c, cmin = cz);
        }
        conj_BANG(ccs, c);
      }
    }
  }
  if ( ((!missed_QUERY) && not_DASH_empty(ccs)) ) {
    let sum = 0;
    let ccsz = kirbystdlibref.count(ccs);
    Object.keys(smallest).forEach(function(eid) {
      sum = 0;
      ccs.forEach(function() {
        let ____args = Array.prototype.slice.call(arguments);
        return (((____args[0] === smallest) || contains_QUERY(____args[0], eid)) ?
          ++sum :
          null);
      });
      return ((sum === ccsz) ?
        (function() {
          let GS__5 = kirbystdlibref.getProp(entities, eid);
          let obj = GS__5;
          return ((((typeof (GS__5) === "undefined")) || ((GS__5 === null))) ?
            null :
            conj_BANG(ret, obj));
        }).call(this) :
        null);
    });
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [getAllEntities] in file: ecs.ky, line: 104
//Get all the entities inside this engine
const getAllEntities = function(engine) {
  let GS__6 = engine.value;
  let entities = GS__6["entities"];
  return Object.values(entities);
};
const _STAR_idAtom_STAR = atom(0);
////////////////////////////////////////////////////////////////////////////////
//fn: [generateEid] in file: ecs.ky, line: 113
const generateEid = function() {
  return ["e", swap_BANG(_STAR_idAtom_STAR, function(v) {
    if ( (!(v < Number.SAFE_MAX_INTEGER)) ) {
      throw "too many entities";
    } else {
      null;
    }
    return (v + 1);
  })].join("");
};
////////////////////////////////////////////////////////////////////////////////
//fn: [takeEntity!] in file: ecs.ky, line: 120
const takeEntity_BANG = function(entity) {
  swap_BANG(entity, function(e) {
    e["status"] = true;
    return e;
  });
  return entity;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [dropEntity!] in file: ecs.ky, line: 125
const dropEntity_BANG = function(entity) {
  swap_BANG(entity, function(e) {
    e["status"] = false;
    return e;
  });
  return entity;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [deleteEntity] in file: ecs.ky, line: 130
const deleteEntity = function(entity) {
  let GS__7 = entity.value;
  let engine = GS__7["engine"];
  let eid = GS__7["eid"];
  swap_BANG(engine, function(e) {
    dissoc_BANG(e.entities, eid);
    return e;
  });
  swap_BANG(entity, function(e) {
    e["dead?"] = true;
    let GS__8 = e.bodyparts;
    Object.entries(GS__8).forEach(function(e) {
      return (function(v, k) {
        return unbindComponent(engine, k, entity);
      })(kirbystdlibref.getProp(e, 1), kirbystdlibref.getProp(e, 0));
    });
    return e;
  });
  return null;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [deleteEntities] in file: ecs.ky, line: 142
//Get rid of all nodes
const deleteEntities = function(engine) {
  swap_BANG(engine, function(e) {
    e["entities"] = {};
    return e;
  });
  return null;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [addSystem] in file: ecs.ky, line: 148
const addSystem = function(engine, system) {
  let GS__9 = engine.value;
  let systems = GS__9["systems"];
  let compFn = function(s1, s2) {
    return ((s1.priority < s2.priority) ?
      1 :
      ((s1.priority > s2.priority) ?
        -1 :
        0));
  };
  conj_BANG(systems, system);
  sort_BANG(compfn, systems);
  return null;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [deleteSystem] in file: ecs.ky, line: 161
const deleteSystem = function(engine, system) {
  let ret = false;
  let GS__10 = engine.value;
  let systems = GS__10["systems"];
  for (let i = 0, sz = kirbystdlibref.count(systems), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
    if ( (system === systems[i]) ) {
      systems.splice(i, 1);
      ret = true;
      ____break = true;
    }
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [deleteSystems] in file: ecs.ky, line: 171
const deleteSystems = function(engine) {
  swap_BANG(engine, function(e) {
    e["systems"] = [];
    return e;
  });
  return null;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [updateEngine] in file: ecs.ky, line: 175
const updateEngine = function(engine, time) {
  swap_BANG(engine, function(e) {
    e["updating?"] = true;
    return e;
  });
  let GS__11 = engine.value;
  let systems = GS__11["systems"];
  let s;
  for (let i = 0, sz = kirbystdlibref.count(systems), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
    s = systems[i];
    if (kirbystdlibref.getProp(s, "active?")) {
      if ( (!s.update(time)) ) {
        ____break = true;
      } else {
        null;
      }
    }
  }
  doHouseKeeping();
  return swap_BANG(engine, function(e) {
    e["updating?"] = false;
    return e;
  });
};
////////////////////////////////////////////////////////////////////////////////
//fn: [igniteEngine] in file: ecs.ky, line: 189
const igniteEngine = function(engine, initNodes, initSystems) {
  (function() {
    let ____args = Array.prototype.slice.call(arguments);
    let F__12 = initNodes;
    let R__13 = F__12.apply(this, ____args);
    let F__14 = initSystems;
    let R__15 = F__14(R__13);
    return R__15;
  })(engine);
  let GS__16 = engine.value;
  let systems = GS__16["systems"];
  systems.forEach(function(s) {
    return s.preamble();
  });
  return null;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [doHouseKeeping] in file: ecs.ky, line: 195
const doHouseKeeping = function(engine) {
  return null;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [getComCache] in file: ecs.ky, line: 198
const getComCache = function(engine, comType) {
  let GS__17 = engine.value;
  let registry = GS__17["registry"];
  return kirbystdlibref.getProp(registry, comType);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [unbindComponent] in file: ecs.ky, line: 202
const unbindComponent = function(engine, comType, entity) {
  let eid = kirbystdlibref.getProp(entity.value, "eid");
  swap_BANG(engine, function(e) {
    let GS__18 = kirbystdlibref.getProp(e.registry, comType);
    let m = GS__18;
    if ( (((typeof (GS__18) === "undefined")) || ((GS__18 === null))) ) {
      null;
    } else {
      dissoc_BANG(m, eid);
    }
    return e;
  });
  return null;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [bindComponent] in file: ecs.ky, line: 211
const bindComponent = function(engine, component, entity) {
  let eid = kirbystdlibref.getProp(entity.value, "eid");
  let cid = kirbystdlibref.getProp(component.value, "typeId");
  swap_BANG(engine, function(e) {
    let m = kirbystdlibref.getProp(e.registry, cid);
    if (nichts_QUERY(m)) {
      m = {};
      e.registry[cid] = m;
    }
    m[eid] = component;
    return e;
  });
  return null;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [getSystem] in file: ecs.ky, line: 224
const getSystem = function(engine, systemType) {
  let GS__19 = engine.value;
  let systems = GS__19["systems"];
  return find(systems, function() {
    let ____args = Array.prototype.slice.call(arguments);
    return (kirbystdlibref.getProp(____args[0], "typeId") === systemType);
  });
};
////////////////////////////////////////////////////////////////////////////////
//fn: [addComponent] in file: ecs.ky, line: 229
const addComponent = function(entity, component) {
  swap_BANG(component, function(c) {
    c["entity"] = entity;
    return c;
  });
  let cid = kirbystdlibref.getProp(component.value, "typeId");
  if ( (!hasComponent_QUERY(entity, cid)) ) {
    true;
  } else {
    throw new Error("Cannot add Component again");
  }
  bindComponent(engine, component, entity);
  swap_BANG(entity, function(e) {
    e.bodyparts[cid] = component;
    return e;
  });
  return null;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [deleteComponent] in file: ecs.ky, line: 238
const deleteComponent = function(entity, comType) {
  swap_BANG(entity, function(e) {
    dissoc_BANG(e.bodyparts, comType);
    unbindComponent(e.engine, comType, entity);
    return e;
  });
  return null;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [getComponent] in file: ecs.ky, line: 245
const getComponent = function(entity, comType) {
  return kirbystdlibref.getProp(entity.value.bodyparts, comType);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [getAllComponents] in file: ecs.ky, line: 249
const getAllComponents = function(entity) {
  return Object.values(kirbystdlibref.getProp(entity.value, "bodyparts"));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [hasComponent?] in file: ecs.ky, line: 253
const hasComponent_QUERY = function(entity, comType) {
  return contains_QUERY(kirbystdlibref.getProp(entity.value, "bodyparts"), comType);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [createPool] in file: ecs.ky, line: 259
const createPool = function(own_QUERY) {
  return atom({
    "cache": [],
    "own?": own_QUERY,
    "batch": 0
  });
};
////////////////////////////////////////////////////////////////////////////////
//fn: [presetPool] in file: ecs.ky, line: 263
const presetPool = function(pool, ctor, count) {
  return swap_BANG(pool, function(p) {
    for (let x = 0, GS__20 = count, ____break = false; ((!____break) && (x < GS__20)); x = (x + 1)) {
      let GS__21 = ctor();
      let obj = GS__21;
      if ( (((typeof (GS__21) === "undefined")) || ((GS__21 === null))) ) {
        null;
      } else {
        conj_BANG(p.cache, obj);
      }
    }
    (p["ctor"] = ctor, p["batch"] = count);
    return p;
  });
};
module.exports = {
  da57bc0172fb42438a11e6e8778f36fb: {
    ns: "czlab.rygel.ecs",
    macros: {}
  },
  createEngine: createEngine,
  createSystem: createSystem,
  createComponent: createComponent,
  createEntity: createEntity,
  createPooledEntity: createPooledEntity,
  getEntities: getEntities,
  getAllEntities: getAllEntities,
  takeEntity_BANG: takeEntity_BANG,
  dropEntity_BANG: dropEntity_BANG,
  deleteEntity: deleteEntity,
  deleteEntities: deleteEntities,
  addSystem: addSystem,
  deleteSystem: deleteSystem,
  deleteSystems: deleteSystems,
  updateEngine: updateEngine,
  igniteEngine: igniteEngine,
  doHouseKeeping: doHouseKeeping,
  getComCache: getComCache,
  unbindComponent: unbindComponent,
  bindComponent: bindComponent,
  getSystem: getSystem,
  addComponent: addComponent,
  deleteComponent: deleteComponent,
  getComponent: getComponent,
  getAllComponents: getAllComponents,
  hasComponent_QUERY: hasComponent_QUERY,
  createPool: createPool,
  presetPool: presetPool
};