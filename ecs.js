/*Auto generated by Kirby v1.0.0 - Sat Jan 13 2018 02:22:51 GMT-0800 (PST)
  czlab.rygel.ecs
({"doc":"","author":"Kenneth Leung"})
*/

const k = require("kirby");
const atom = k["atom"];
const merge = k["merge"];
const swap_BANG = k["swap_BANG"];
const find = k["find"];
const object_QUERY = k["object_QUERY"];
const sort_BANG = k["sort_BANG"];
const some_QUERY = k["some_QUERY"];
const nichts_QUERY = k["nichts_QUERY"];
const conj_BANG = k["conj_BANG"];
const kirbystdlibref = require("kirby");
const SPV = {
  "PreUpdate": 100,
  "NetPlay": 200,
  "AI": 300,
  "Motion": 400,
  "Move": 500,
  "Logic": 600,
  "Collide": 700,
  "Resolve": 800,
  "Render": 900,
  "Error": -1
};
////////////////////////////////////////////////////////////////////////////////
//fn: [createEngine] in file: ecs.ky, line: 33
//Create an engine, the core of ECS.
const createEngine = function(attrs) {
  return atom(merge(attrs, {
    "entities": {},
    "systems": [],
    "config": {},
    "registry": {},
    "updating?": false
  }));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [createSystem] in file: ecs.ky, line: 46
//Create a new system.  Each system must be provided with
//a user defined worker function and a priority value
const createSystem = function(type, priority, preamble, worker) {
  if ( (!(((typeof (preamble) === "function")) && ((typeof (worker) === "function")))) ) {
    throw Error("Precondition failed");
  } else {
    null;
  }
  return atom({
    "preamble": preamble,
    "update": worker,
    "typeId": type,
    "priority": priority,
    "active?": false
  });
};
////////////////////////////////////////////////////////////////////////////////
//fn: [createComponent] in file: ecs.ky, line: 57
const createComponent = function(type, attrs) {
  if ( (!(object_QUERY(attrs))) ) {
    throw Error("Precondition failed");
  } else {
    null;
  }
  return atom(merge(attrs, {
    "typeId": type,
    "entity": null
  }));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [createEntity] in file: ecs.ky, line: 62
const createEntity = function(engine, attrs) {
  let eid = generateEid();
  let ent = atom(merge(attrs, {
    "engine": engine,
    "dead?": false,
    "eid": eid,
    "bodyparts": {}
  }));
  swap_BANG(engine, function(e) {
    e.entities[eid] = ent;
    return e;
  });
  return ent;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [createPoolable] in file: ecs.ky, line: 73
const createPoolable = function(engine, attrs) {
  let GS__3 = Array.prototype.slice.call(arguments, 2);
  let take_QUERY = GS__3[0];
  let e = createEntity(engine, merge(attrs, {
    "status": false
  }));
  return (take_QUERY ?
    takePoolable_BANG(e) :
    e);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [getEntities] in file: ecs.ky, line: 79
//Find all the entities inside this engine,
//which contains these component types
const getEntities = function(engine) {
  let componentTypes = Array.prototype.slice.call(arguments, 1);
  let cmin = Number.SAFE_MAX_INTEGER;
  let GS__4 = engine.value;
  let entities = GS__4["entities"];
  let registry = GS__4["registry"];
  let ret = [];
  let ccs = [];
  let missed_QUERY = false;
  let smallest,
    c,
    cid;
  for (let i = 0, sz = kirbystdlibref.count(componentTypes), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
    (cid = componentTypes[i], c = kirbystdlibref.getProp(registry, cid));
    if (nichts_QUERY(c)) {
      missed_QUERY = true;
      ____break = true;
    } else {
      if (true) {
        let cz = kirbystdlibref.count(c);
        if ( (cz < cmin) ) {
          (cmin = cz, smallest = c);
        }
        conj_BANG(ccs, c);
      }
    }
  }
  if ( ((!missed_QUERY) && not_DASH_empty(ccs)) ) {
    let sum = 0;
    let ccsz = kirbystdlibref.count(ccs);
    Object.keys(smallest).forEach(function(eid) {
      sum = 0;
      ccs.forEach(function() {
        let ____args = Array.prototype.slice.call(arguments);
        return (((____args[0] === smallest) || contains_QUERY(____args[0], eid)) ?
          ++sum :
          null);
      });
      return ((sum === ccsz) ?
        (function() {
          let GS__5 = kirbystdlibref.getProp(entities, eid);
          let obj = GS__5;
          return ((((typeof (GS__5) === "undefined")) || ((GS__5 === null))) ?
            null :
            conj_BANG(ret, obj));
        }).call(this) :
        null);
    });
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [getAllEntities] in file: ecs.ky, line: 124
//Get all the entities.
const getAllEntities = function(engine) {
  return Object.values(engine.value.entities);
};
const _STAR_idAtom_STAR = atom(0);
////////////////////////////////////////////////////////////////////////////////
//fn: [generateEid] in file: ecs.ky, line: 132
const generateEid = function() {
  return ["e", swap_BANG(_STAR_idAtom_STAR, function(v) {
    if ( (!(v < Number.SAFE_MAX_INTEGER)) ) {
      throw "too many entities";
    } else {
      null;
    }
    return (v + 1);
  })].join("");
};
////////////////////////////////////////////////////////////////////////////////
//fn: [takePoolable!] in file: ecs.ky, line: 139
const takePoolable_BANG = function(entity) {
  swap_BANG(entity, function(e) {
    e["status"] = true;
    return e;
  });
  return entity;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [freePoolable!] in file: ecs.ky, line: 144
const freePoolable_BANG = function(entity) {
  swap_BANG(entity, function(e) {
    e["status"] = false;
    return e;
  });
  return entity;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [popEntity] in file: ecs.ky, line: 149
const popEntity = function(entity) {
  let GS__6 = entity.value;
  let engine = GS__6["engine"];
  let eid = GS__6["eid"];
  swap_BANG(engine, function(e) {
    dissoc_BANG(e.entities, eid);
    return e;
  });
  swap_BANG(entity, function(e) {
    e["dead?"] = true;
    Object.keys(e.bodyparts).forEach(function() {
      let ____args = Array.prototype.slice.call(arguments);
      return subComp(engine, ____args[0], entity);
    });
    return e;
  });
  return null;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [popAllEntities] in file: ecs.ky, line: 160
//Get rid of all entities
const popAllEntities = function(engine) {
  swap_BANG(engine, function(e) {
    (e["registry"] = {}, e["entities"] = {});
    return e;
  });
  return null;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [pushSystem] in file: ecs.ky, line: 168
const pushSystem = function(engine, system) {
  let compFn = function(s1, s2) {
    return ((s1.priority < s2.priority) ?
      -1 :
      ((s1.priority > s2.priority) ?
        1 :
        0));
  };
  swap_BANG(engine, function(e) {
    conj_BANG(e.systems, system);
    sort_BANG(compfn, e.systems);
    return e;
  });
  return null;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [popSystem] in file: ecs.ky, line: 182
const popSystem = function(engine, system) {
  let ret = false;
  swap_BANG(engine, function(e) {
    for (let i = 0, sz = kirbystdlibref.count(e.systems), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
      if ( (system === e.systems[i]) ) {
        e.systems.splice(i, 1);
        ret = true;
        ____break = true;
      }
    }
    return e;
  });
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [popAllSystems] in file: ecs.ky, line: 194
const popAllSystems = function(engine) {
  swap_BANG(engine, function(e) {
    e["systems"] = [];
    return e;
  });
  return null;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [updateEngine] in file: ecs.ky, line: 198
const updateEngine = function(engine, time) {
  swap_BANG(engine, function(e) {
    e["updating?"] = true;
    return e;
  });
  let GS__7 = engine.value;
  let systems = GS__7["systems"];
  let s,
    s_QUOTE;
  for (let i = 0, sz = kirbystdlibref.count(systems), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
    (s = systems[i], s_QUOTE = s.value);
    if (kirbystdlibref.getProp(s_QUOTE, "active?")) {
      if ( (!s_QUOTE.update(time)) ) {
        ____break = true;
      } else {
        null;
      }
    }
  }
  doHouseKeeping();
  return swap_BANG(engine, function(e) {
    e["updating?"] = false;
    return e;
  });
};
////////////////////////////////////////////////////////////////////////////////
//fn: [igniteEngine] in file: ecs.ky, line: 212
const igniteEngine = function(engine, initNodes, initSystems) {
  (function() {
    let ____args = Array.prototype.slice.call(arguments);
    let F__8 = initNodes;
    let R__9 = F__8.apply(this, ____args);
    let F__10 = initSystems;
    let R__11 = F__10(R__9);
    return R__11;
  })(engine);
  engine.value.systems.forEach(function() {
    let ____args = Array.prototype.slice.call(arguments);
    return ____args[0].value.preamble();
  });
  return null;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [doHouseKeeping] in file: ecs.ky, line: 217
const doHouseKeeping = function(engine) {
  return null;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [getCompCache] in file: ecs.ky, line: 220
const getCompCache = function(engine, comType) {
  return kirbystdlibref.getProp(engine.value.registry, comType);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [subComp] in file: ecs.ky, line: 224
const subComp = function(engine, comType, entity) {
  let eid = kirbystdlibref.getProp(entity.value, "eid");
  swap_BANG(engine, function(e) {
    let GS__12 = kirbystdlibref.getProp(e.registry, comType);
    let m = GS__12;
    if ( (((typeof (GS__12) === "undefined")) || ((GS__12 === null))) ) {
      null;
    } else {
      dissoc_BANG(m, eid);
    }
    return e;
  });
  return null;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [addComp] in file: ecs.ky, line: 233
const addComp = function(engine, component, entity) {
  let eid = kirbystdlibref.getProp(entity.value, "eid");
  let cid = kirbystdlibref.getProp(component.value, "typeId");
  swap_BANG(engine, function(e) {
    let m = kirbystdlibref.getProp(e.registry, cid);
    if (nichts_QUERY(m)) {
      m = {};
      e.registry[cid] = m;
    }
    m[eid] = component;
    return e;
  });
  return null;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [getSystem] in file: ecs.ky, line: 245
const getSystem = function(engine, systemType) {
  return find(engine.value.systems, function() {
    let ____args = Array.prototype.slice.call(arguments);
    return (kirbystdlibref.getProp(____args[0].value, "typeId") === systemType);
  });
};
////////////////////////////////////////////////////////////////////////////////
//fn: [bindComponent] in file: ecs.ky, line: 249
const bindComponent = function(entity, component) {
  swap_BANG(component, function(c) {
    c["entity"] = entity;
    return c;
  });
  let cid = kirbystdlibref.getProp(component.value, "typeId");
  if ( (!hasComponent_QUERY(entity, cid)) ) {
    true;
  } else {
    throw new Error("Cannot add Component again");
  }
  addComp(engine, component, entity);
  swap_BANG(entity, function(e) {
    e.bodyparts[cid] = component;
    return e;
  });
  return null;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [unbindComponent] in file: ecs.ky, line: 258
const unbindComponent = function(entity, comType) {
  swap_BANG(entity, function(e) {
    dissoc_BANG(e.bodyparts, comType);
    subComp(e.engine, comType, entity);
    return e;
  });
  return null;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [getComponent] in file: ecs.ky, line: 265
const getComponent = function(entity, comType) {
  return kirbystdlibref.getProp(entity.value.bodyparts, comType);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [getAllComponents] in file: ecs.ky, line: 269
const getAllComponents = function(entity) {
  return Object.values(kirbystdlibref.getProp(entity.value, "bodyparts"));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [hasComponent?] in file: ecs.ky, line: 273
const hasComponent_QUERY = function(entity, comType) {
  return contains_QUERY(kirbystdlibref.getProp(entity.value, "bodyparts"), comType);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [createPool] in file: ecs.ky, line: 277
const createPool = function(own_QUERY) {
  return atom({
    "cache": [],
    "own?": own_QUERY,
    "ctor": null,
    "batch": 0
  });
};
////////////////////////////////////////////////////////////////////////////////
//fn: [presetPool] in file: ecs.ky, line: 281
//Pre-populate a bunch of objects in the pool
const presetPool = function(pool, ctor, count) {
  swap_BANG(pool, function(p) {
    for (let x = 0, GS__13 = count, ____break = false; ((!____break) && (x < GS__13)); x = (x + 1)) {
      let GS__14 = ctor();
      let obj = GS__14;
      if ( (((typeof (GS__14) === "undefined")) || ((GS__14 === null))) ) {
        null;
      } else {
        conj_BANG(p.cache, obj);
      }
    }
    (p["ctor"] = ctor, p["batch"] = count);
    return p;
  });
  return null;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [selectFromPool] in file: ecs.ky, line: 292
//Find an object by applying this filter
const selectFromPool = function(pool, sel) {
  let ret = null;
  let e = null;
  let GS__15 = pool.value;
  let cache = GS__15["cache"];
  for (let i = 0, sz = kirbystdlibref.count(cache), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
    e = cache[i];
    if (sel(e)) {
      ret = e;
      ____break = true;
    }
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [getFromPool] in file: ecs.ky, line: 303
//Get a free object from the pool.  More like a peek
const getFromPool = function(pool, create_QUERY) {
  let ret = null;
  let e = null;
  let GS__16 = pool.value;
  let batch = GS__16["batch"];
  let cache = GS__16["cache"];
  let ctor = GS__16["ctor"];
  for (let i = 0, sz = kirbystdlibref.count(cache), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
    e = cache[i];
    if ( (!kirbystdlibref.getProp(e.value, "status")) ) {
      ret = e;
      ____break = true;
    }
  }
  return (some_QUERY(ret) ?
    ret :
    ((create_QUERY && ctor) ?
      (function() {
        presetPool(pool, ctor, batch);
        return getFromPool(pool, false);
      }).call(this) :
      (true ?
        null :
        null)));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [takeFromPool] in file: ecs.ky, line: 323
//Get a free object from the pool and flag it as in-use
const takeFromPool = function(pool, create_QUERY) {
  let ret = getFromPool(pool, create_QUERY);
  if (ret) {
    takePoolable_BANG(ret);
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [getFromPoolAt] in file: ecs.ky, line: 331
const getFromPoolAt = function(pool, pos) {
  return kirbystdlibref.getProp(pool.value.cache, pos);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [checkIntoPool] in file: ecs.ky, line: 335
const checkIntoPool = function(pool, obj) {
  swap_BANG(pool, function(p) {
    conj_BANG(p.cache, obj);
    return p;
  });
  return obj;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [clearPool] in file: ecs.ky, line: 340
const clearPool = function(pool) {
  let GS__17 = pool.value;
  let own_QUERY = GS__17["own?"];
  swap_BANG(pool, function(p) {
    k.resetVec_BANG(p.cache);
    return p;
  });
  return null;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [getActivesInPool] in file: ecs.ky, line: 346
const getActivesInPool = function(pool) {
  return pool.value.cache.filter(function() {
    let ____args = Array.prototype.slice.call(arguments);
    return kirbystdlibref.getProp(____args[0].value, "status");
  });
};
////////////////////////////////////////////////////////////////////////////////
//fn: [countActivesInPool] in file: ecs.ky, line: 350
//Get the count of active objects
const countActivesInPool = function(pool) {
  let sum = 0;
  pool.value.cache.forEach(function() {
    let ____args = Array.prototype.slice.call(arguments);
    return (kirbystdlibref.getProp(____args[0].value, "status") ?
      ++sum :
      null);
  });
  return sum;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [foreachInPool] in file: ecs.ky, line: 356
const foreachInPool = function(pool, callback) {
  return pool.value.cache.forEach(function(ent) {
    return (kirbystdlibref.getProp(ent.value, "status") ?
      callback(ent) :
      null);
  });
};
////////////////////////////////////////////////////////////////////////////////
//fn: [someInPool?] in file: ecs.ky, line: 361
const someInPool_QUERY = function(pool, test) {
  return pool.value.cache.some(test);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [resetPool] in file: ecs.ky, line: 365
//Hibernate (status off) all objects in the pool
const resetPool = function(pool) {
  swap_BANG(pool, function(p) {
    p.cache.forEach(function(obj) {
      return swap_BANG(obj, function(e) {
        e["status"] = false;
        return e;
      });
    });
    return p;
  });
  return null;
};
module.exports = {
  da57bc0172fb42438a11e6e8778f36fb: {
    ns: "czlab.rygel.ecs",
    macros: {}
  },
  SPV: SPV,
  createEngine: createEngine,
  createSystem: createSystem,
  createComponent: createComponent,
  createEntity: createEntity,
  createPoolable: createPoolable,
  getEntities: getEntities,
  getAllEntities: getAllEntities,
  takePoolable_BANG: takePoolable_BANG,
  freePoolable_BANG: freePoolable_BANG,
  popEntity: popEntity,
  popAllEntities: popAllEntities,
  pushSystem: pushSystem,
  popSystem: popSystem,
  popAllSystems: popAllSystems,
  updateEngine: updateEngine,
  igniteEngine: igniteEngine,
  doHouseKeeping: doHouseKeeping,
  getCompCache: getCompCache,
  subComp: subComp,
  addComp: addComp,
  getSystem: getSystem,
  bindComponent: bindComponent,
  unbindComponent: unbindComponent,
  getComponent: getComponent,
  getAllComponents: getAllComponents,
  hasComponent_QUERY: hasComponent_QUERY,
  createPool: createPool,
  presetPool: presetPool,
  selectFromPool: selectFromPool,
  getFromPool: getFromPool,
  takeFromPool: takeFromPool,
  getFromPoolAt: getFromPoolAt,
  checkIntoPool: checkIntoPool,
  clearPool: clearPool,
  getActivesInPool: getActivesInPool,
  countActivesInPool: countActivesInPool,
  foreachInPool: foreachInPool,
  someInPool_QUERY: someInPool_QUERY,
  resetPool: resetPool
};