/*Auto generated by Kirby v1.0.0 - Fri Mar 23 2018 02:58:09 GMT-0700 (PDT)
  czlab.kirby.stdlib
{"doc" "Kirby's standard core library." "author" "Kenneth Leung"}
*/

const __module_namespace__ = "czlab.kirby.stdlib";
const MODULE_NAMESPACE = "__module_namespace__";
const MAX_DASH_INT = Number.MAX_SAFE_INTEGER;
const MIN_DASH_INT = Number.MIN_SAFE_INTEGER;
////////////////////////////////////////////////////////////////////////////////
//fn: [println] in file: stdlib.ky, line: 803
//Write msg to console.
const println = function() {
  let msgs = Array.prototype.slice.call(arguments, 0);
  return (console ?
    console.log(msgs.join("")) :
    null);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [not-empty] in file: stdlib.ky, line: 808
//If coll is empty, returns nil, else coll.
const not_DASH_empty = function(coll) {
  return ((0 === count(coll)) ?
    null :
    coll);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [noCRef] in file: stdlib.ky, line: 816
//Use a cache to store already referenced objects
//to prevent circular references.
const noCRef = function() {
  let cache = [];
  return function(k, v) {
    if (( (typeof (v) === "function") )) {
      (
      v = "native-fn");
    } else {
      if ( (((Object.prototype.toString.call(v) === "[object Map]")) || object_QMRK(v) || ((Object.prototype.toString.call(v) === "[object Set]"))) ) {
        if (contains_QMRK(cache, v)) {
          (
          v = undefined);
        } else {
          conj_BANG(cache, v);
        }
      } else {
        null;
      }
    }
    return v;
  };
};
////////////////////////////////////////////////////////////////////////////////
//fn: [stringify] in file: stdlib.ky, line: 834
//JSON stringify (no cyclical obj-ref)
const stringify = function(obj) {
  return (obj ?
    JSON.stringify(obj, noCRef()) :
    null);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [opt??] in file: stdlib.ky, line: 842
//If cur is not defined, returns other else cur
const opt_QMRK__QMRK = function(cur, other) {
  return (((typeof (cur) !== "undefined")) ?
    cur :
    other);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [conj!] in file: stdlib.ky, line: 850
//conj[oin]. Returns coll with the xs
//'added'. (conj! nil item) returns [item].
//If coll is a list, prepends else appends to coll.
const conj_BANG = function(coll) {
  let xs = Array.prototype.slice.call(arguments, 1);
  if (nichts_QMRK(coll)) {
    conj_BANG.apply(this, [[]].concat(xs));
  } else {
    if ( (Array.isArray(coll)) ) {
      if (list_QMRK(coll)) {
        coll.unshift.apply(coll, xs.reverse());
      } else {
        coll.push.apply(coll, xs);
      }
    } else {
      if (( (Object.prototype.toString.call(coll) === "[object Set]") )) {
        xs.forEach(function() {
          let ____args = Array.prototype.slice.call(arguments);
          return coll.add(____args[0]);
        });
      } else {
        if (true) {
          throw new Error(["Cannot conj to: ", typeof (coll)].join(""));
        }
      }
    }
  }
  return coll;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [conj] in file: stdlib.ky, line: 871
//Like conj! but
//returns a new collection
const conj = function(coll) {
  let xs = Array.prototype.slice.call(arguments, 1);
  let c = ((Array.isArray(coll)) ?
    (vector_QMRK(coll) ?
      into("vector", coll) :
      (list_QMRK(coll) ?
        into("list", coll) :
        (map_QMRK(coll) ?
          into("map", coll) :
          (obj_QMRK(coll) ?
            into("obj", coll) :
            (set_QMRK(coll) ?
              into("set", coll) :
              (true ?
                Array.prototype.slice.call(coll) :
                null)))))) :
    (((Object.prototype.toString.call(coll) === "[object Set]")) ?
      new Set(coll.values()) :
      (nichts_QMRK(coll) ?
        [] :
        null)));
  return (c ?
    conj_BANG.apply(this, [c].concat(xs)) :
    coll);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [disj!] in file: stdlib.ky, line: 889
//disj[oin]. Returns a set without these keys
const disj_BANG = function(coll) {
  let xs = Array.prototype.slice.call(arguments, 1);
  if (( (Object.prototype.toString.call(coll) === "[object Set]") )) {
    xs.forEach(function() {
      let ____args = Array.prototype.slice.call(arguments);
      return coll.delete(____args[0]);
    });
  }
  return coll;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [disj] in file: stdlib.ky, line: 896
//disj[oin]. Returns a new set without these keys
const disj = function(coll) {
  let xs = Array.prototype.slice.call(arguments, 1);
  let s2 = new Set(xs);
  return new Set((((Object.prototype.toString.call(coll) === "[object Set]")) ?
    Array.from(coll.values()).filter(function() {
      let ____args = Array.prototype.slice.call(arguments);
      return (!s2.has(____args[0]));
    }) :
    []));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [pop!] in file: stdlib.ky, line: 905
//Removes the first element if list,
//else removes the last element,
//returning the element
//and the altered collection
const pop_BANG = function(coll) {
  return ((Array.isArray(coll)) ?
    (function() {
      let r = (list_QMRK(coll) ?
        coll.shift() :
        coll.pop());
      return [r, coll];
    }).call(this) :
    null);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [pop] in file: stdlib.ky, line: 919
//Like pop! but returns a new collection
const pop = function(coll) {
  return ((Array.isArray(coll)) ?
    (function() {
      let r = (list_QMRK(coll) ?
        coll[0] :
        last(coll));
      return [r, (list_QMRK(coll) ?
        coll.slice(1) :
        coll.slice(0, -1))];
    }).call(this) :
    null);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [wrap-str] in file: stdlib.ky, line: 930
//Prepend and append strings to the object.
const wrap_DASH_str = function(obj, start, end) {
  return [start, obj, end].join("");
};
////////////////////////////////////////////////////////////////////////////////
//fn: [getIndex] in file: stdlib.ky, line: 936
const getIndex = function(obj, pos) {
  return ((Array.isArray(obj)) ?
    obj[pos] :
    undefined);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [getProp] in file: stdlib.ky, line: 943
//If prop is a string, returns the value of
//this object property, obeying the own? flag,
//unless if object is a Map, returns value of
//the key. Otherwise, return the value at the
//index of the array.
const getProp = function(obj, prop) {
  let GS__1 = Array.prototype.slice.call(arguments, 2);
  let own_QMRK = getIndex(GS__1, 0);
  return (((Object.prototype.toString.call(obj) === "[object Map]")) ?
    obj.get(prop) :
    (nichts_QMRK(obj) ?
      null :
      (true ?
        (function() {
          (
          own_QMRK = opt_QMRK__QMRK(own_QMRK, true));
          return ((((typeof (prop) === "string")) || ((typeof (prop) === "number"))) ?
            ((own_QMRK && ((typeof (prop) === "string")) && (!obj.hasOwnProperty(prop))) ?
              undefined :
              obj[prop]) :
            undefined);
        }).call(this) :
        null)));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [prn] in file: stdlib.ky, line: 968
//Print data as string - use to dump an AST node
const prn = function(obj) {
  let GS__2 = Array.prototype.slice.call(arguments, 1);
  let r_QMRK = getIndex(GS__2, 0);
  let f = noCRef();
  if (complex_QMRK(obj)) {
    (
    obj = f(null, obj));
  }
  return (obj ?
    prn_STAR(obj, r_QMRK, f) :
    "");
};
////////////////////////////////////////////////////////////////////////////////
//fn: [prnArr*] in file: stdlib.ky, line: 979
//Print an array
const prnArr_STAR = function(obj, r_QMRK, f) {
  return obj.map(function(v, i) {
    let x = f(i, v);
    return prn_STAR(opt_QMRK__QMRK(x, null), r_QMRK, f);
  }).join(" ");
};
////////////////////////////////////////////////////////////////////////////////
//fn: [prn*] in file: stdlib.ky, line: 987
const prn_STAR = function(obj, r_QMRK, func) {
  let pfx = function() {
    let ____args = Array.prototype.slice.call(arguments);
    return prn_STAR(____args[0], r_QMRK, func);
  };
  let parr = ((Array.isArray(obj)) ?
    function() {
      let ____args = Array.prototype.slice.call(arguments);
      return wrap_DASH_str(prnArr_STAR(obj, r_QMRK, func), ____args[0], ____args[1]);
    } :
    null);
  return (function() {
    let C__3;
    switch (typeid(obj)) {
      case "atom":
        C__3 = wrap_DASH_str(pfx(obj.value), "(atom ", ")");
        break;
      case "lambda-arg":
      case "regex-obj":
      case "keyword":
      case "symbol":
        C__3 = obj.value;
        break;
      case "object":
        C__3 = wrap_DASH_str(seq(obj).reduce(function(acc, GS__4) {
          let k = getIndex(GS__4, 0);
          let v = getIndex(GS__4, 1);
          let x = func(k, v);
          if ( (!((typeof (x) === "undefined"))) ) {
            conj_BANG(acc, [pfx(k), ":", pfx(x)].join(""));
          } else {
            null;
          }
          return acc;
        }, []).join(","), "{", "}");
        break;
      case "objectMap":
        C__3 = wrap_DASH_str(seq(obj).reduce(function(acc, GS__5) {
          let k = getIndex(GS__5, 0);
          let v = getIndex(GS__5, 1);
          let x = func(k, v);
          if ( (!((typeof (x) === "undefined"))) ) {
            conj_BANG(acc, [pfx(k), " ", pfx(x)].join(""));
          } else {
            null;
          }
          return acc;
        }, []).join(" "), "{", "}");
        break;
      case "objectSet":
        C__3 = wrap_DASH_str(seq(obj).reduce(function(acc, v) {
          let x = func(v, v);
          if ( (!((typeof (x) === "undefined"))) ) {
            conj_BANG(acc, pfx(v));
          } else {
            null;
          }
          return acc;
        }, []).join(" "), "#{", "}");
        break;
      case "vector":
        C__3 = parr("[", "]");
        break;
      case "map":
      case "obj":
        C__3 = parr("{", "}");
        break;
      case "set":
        C__3 = parr("#{", "}");
        break;
      case "list":
        C__3 = parr("'(", ")");
        break;
      case "string":
        C__3 = (r_QMRK ?
          quote_DASH_str(obj) :
          obj);
        break;
      case "null":
      case "nil":
        C__3 = "null";
        break;
      default:
        C__3 = ((Array.isArray(obj)) ?
          parr("(", ")") :
          obj.toString());
        break;
    }
    return C__3;
  }).call(this);
};
//Defining a lambda positional argument
class LambdaArg {
  ////////////////////////////////////////////////////////////////////////////////
  //fn: [constructor] in file: stdlib.ky, line: 1043
  constructor(arg) {
    let name = ((arg === "%") ?
      "1" :
      arg.slice(1));
    let v = parseInt(name);
    if ( (!(v > 0)) ) {
      throw new Error(["invalid lambda-arg ", arg].join(""));
    } else {
      null;
    }
    (this["value"] = ["%", v].join(""));
    return this;
  }
  ////////////////////////////////////////////////////////////////////////////////
  //fn: [toString] in file: stdlib.ky, line: 1049
  toString() {
    return this.value;
  }
}
//Defining a primitive data type
class Primitive {
  ////////////////////////////////////////////////////////////////////////////////
  //fn: [constructor] in file: stdlib.ky, line: 1054
  constructor(v) {
    (
    this["value"] = v);
    return this;
  }
  ////////////////////////////////////////////////////////////////////////////////
  //fn: [toString] in file: stdlib.ky, line: 1055
  toString() {
    return this.value;
  }
}
//Defining a Regex pattern
class RegexObj {
  ////////////////////////////////////////////////////////////////////////////////
  //fn: [constructor] in file: stdlib.ky, line: 1060
  constructor(v) {
    (
    this["value"] = v);
    return this;
  }
  ////////////////////////////////////////////////////////////////////////////////
  //fn: [toString] in file: stdlib.ky, line: 1061
  toString() {
    return this.value;
  }
}
//Defining a keyword
class Keyword {
  ////////////////////////////////////////////////////////////////////////////////
  //fn: [constructor] in file: stdlib.ky, line: 1066
  constructor(name) {
    (
    this["value"] = name);
    return this;
  }
  ////////////////////////////////////////////////////////////////////////////////
  //fn: [toString] in file: stdlib.ky, line: 1067
  toString() {
    return (this.value.startsWith("::") ?
      [_STAR_ns_STAR(), "/", this.value.slice(2)].join("") :
      (this.value.startsWith(":") ?
        this.value.slice(1) :
        null));
  }
}
//Defining a symbol
class Symbol {
  ////////////////////////////////////////////////////////////////////////////////
  //fn: [constructor] in file: stdlib.ky, line: 1075
  constructor(name) {
    (
    this["value"] = name);
    return this;
  }
  ////////////////////////////////////////////////////////////////////////////////
  //fn: [toString] in file: stdlib.ky, line: 1076
  toString() {
    return this.value;
  }
}
////////////////////////////////////////////////////////////////////////////////
//fn: [primitive?] in file: stdlib.ky, line: 1079
//Returns true if primitive
const primitive_QMRK = function(obj) {
  return (obj instanceof Primitive);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [primitive] in file: stdlib.ky, line: 1083
//Create a Primitive
const primitive = function(v) {
  return new Primitive(v);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [regexObj?] in file: stdlib.ky, line: 1087
//Returns true if a regex
const regexObj_QMRK = function(obj) {
  return (obj instanceof RegexObj);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [regexObj] in file: stdlib.ky, line: 1091
//Create a new regex
const regexObj = function(name) {
  return new RegexObj(name);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [symbol?] in file: stdlib.ky, line: 1095
//Returns true if a symbol
const symbol_QMRK = function(obj) {
  return (obj instanceof Symbol);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [symbol] in file: stdlib.ky, line: 1099
//Create a new Symbol
const symbol = function(name) {
  return new Symbol(name);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [keyword?] in file: stdlib.ky, line: 1103
//Returns true if a keyword
const keyword_QMRK = function(obj) {
  return (obj instanceof Keyword);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [keyword] in file: stdlib.ky, line: 1107
//Create a new Keyword
const keyword = function(name) {
  return new Keyword(name);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [keyword->symbol] in file: stdlib.ky, line: 1111
//Convert a Keyword to Symbol
const keyword_DASH__GT_symbol = function(k) {
  let s = new Symbol([k].join(""));
  (s["source"] = k.source, s["line"] = k.line, s["column"] = k.column);
  return s;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [lambdaArg?] in file: stdlib.ky, line: 1120
//Returns true if a Lambda Arg
const lambdaArg_QMRK = function(obj) {
  return (obj instanceof LambdaArg);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [lambdaArg] in file: stdlib.ky, line: 1124
//Create a new Lambda Arg
const lambdaArg = function(name) {
  return new LambdaArg(name);
};
//Defining a clojure-like Atom
class Atom {
  ////////////////////////////////////////////////////////////////////////////////
  //fn: [constructor] in file: stdlib.ky, line: 1130
  constructor(val) {
    (
    this["value"] = val);
    return this;
  }
}
////////////////////////////////////////////////////////////////////////////////
//fn: [atom?] in file: stdlib.ky, line: 1133
//Returns true if an Atom
const atom_QMRK = function(atm) {
  return (atm instanceof Atom);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [atom] in file: stdlib.ky, line: 1137
//Create a new Atom
const atom = function(val) {
  return new Atom(val);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [reset!] in file: stdlib.ky, line: 1141
//Set a new value to the Atom
const reset_BANG = function(a, v) {
  return (function() {
    (
    a["value"] = v);
    return null;
  }).call(this);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [resetVec!] in file: stdlib.ky, line: 1145
const resetVec_BANG = function(v) {
  return (function() {
    if ( (Array.isArray(v)) ) {
      v.splice(0);
    }
    return null;
  }).call(this);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [resetMap!] in file: stdlib.ky, line: 1149
const resetMap_BANG = function(obj) {
  return (function() {
    if (( (Object.prototype.toString.call(obj) === "[object Map]") )) {
      obj.clear();
    }
    return null;
  }).call(this);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [resetSet!] in file: stdlib.ky, line: 1153
const resetSet_BANG = function(obj) {
  return (function() {
    if (( (Object.prototype.toString.call(obj) === "[object Set]") )) {
      obj.clear();
    }
    return null;
  }).call(this);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [resetObject!] in file: stdlib.ky, line: 1157
const resetObject_BANG = function(obj) {
  return (function() {
    if (object_QMRK(obj)) {
      Object.getOwnPropertyNames(obj).forEach(function() {
        let ____args = Array.prototype.slice.call(arguments);
        return delete obj[____args[0]];
      });
    }
    return null;
  }).call(this);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [objClass] in file: stdlib.ky, line: 1163
const objClass = function(obj) {
  return (obj ?
    obj.constructor :
    null);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [sort!] in file: stdlib.ky, line: 1167
//Returns a sorted sequence of the items in coll.
//If no comparator is supplied, uses compare
const sort_BANG = function(comp, coll) {
  return (((typeof (comp) === "function")) ?
    coll.sort(comp) :
    comp.sort());
};
////////////////////////////////////////////////////////////////////////////////
//fn: [deref] in file: stdlib.ky, line: 1174
//Get value inside the Atom
const deref = function(a) {
  return a.value;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [swap!] in file: stdlib.ky, line: 1178
//Change value inside the Atom,
//returning the new value
const swap_BANG = function(a, f) {
  let xs = Array.prototype.slice.call(arguments, 2);
  (
  a["value"] = f.apply(this, [a.value].concat(xs)));
  return getProp(a, "value");
};
////////////////////////////////////////////////////////////////////////////////
//fn: [typeid] in file: stdlib.ky, line: 1186
//Returns the type-id
//of this object
const typeid = function(obj) {
  return (lambdaArg_QMRK(obj) ?
    "lambda-arg" :
    (keyword_QMRK(obj) ?
      "keyword" :
      (symbol_QMRK(obj) ?
        "symbol" :
        (vector_QMRK(obj) ?
          "vector" :
          (atom_QMRK(obj) ?
            "atom" :
            (list_QMRK(obj) ?
              "list" :
              (map_QMRK(obj) ?
                "map" :
                (obj_QMRK(obj) ?
                  "obj" :
                  (set_QMRK(obj) ?
                    "set" :
                    (((obj === null)) ?
                      "null" :
                      (((obj === true)) ?
                        "true" :
                        (((obj === false)) ?
                          "false" :
                          (((typeof (obj) === "function")) ?
                            "function" :
                            (((typeof (obj) === "string")) ?
                              "string" :
                              (((typeof (obj) === "number")) ?
                                "number" :
                                ((Array.isArray(obj)) ?
                                  "array" :
                                  (object_QMRK(obj) ?
                                    "object" :
                                    (((Object.prototype.toString.call(obj) === "[object Set]")) ?
                                      "objectSet" :
                                      (((Object.prototype.toString.call(obj) === "[object Map]")) ?
                                        "objectMap" :
                                        (true ?
                                          (function() {
                                            throw new Error(["Unknown type [", typeof (obj), "]"].join(""));
                                          }).call(this) :
                                          null))))))))))))))))))));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [complex?] in file: stdlib.ky, line: 1213
//True if x is an array
//or js object.
const complex_QMRK = function(x) {
  return ((Array.isArray(x)) || object_QMRK(x) || ((Object.prototype.toString.call(x) === "[object Map]")) || ((Object.prototype.toString.call(x) === "[object Set]")));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [simple?] in file: stdlib.ky, line: 1220
//True if x is a
//primitive value type
const simple_QMRK = function(obj) {
  return (((typeof (obj) === "undefined")) || ((obj === null)) || ((obj === false)) || ((obj === true)) || ((typeof (obj) === "string")) || ((typeof (obj) === "number")));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [value?] in file: stdlib.ky, line: 1226
//Returns true
//if a simple LISP value
const value_QMRK = function(obj) {
  return (((obj === null)) || vector_QMRK(obj) || list_QMRK(obj) || map_QMRK(obj) || obj_QMRK(obj) || set_QMRK(obj) || ((obj === false)) || ((obj === true)) || ((typeof (obj) === "string")) || ((typeof (obj) === "number")));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [sequential?] in file: stdlib.ky, line: 1241
//True if coll
//implements Sequential
const sequential_QMRK = function(arr) {
  return ((Array.isArray(arr)) && (!set_QMRK(arr)) && (!obj_QMRK(arr)) && (!map_QMRK(arr)));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [set2Set] in file: stdlib.ky, line: 1249
const set2Set = function(s) {
  let ret = new Set();
  for (let GS__8 = 0, GS__6 = true, GS__7 = s, ____sz = count(GS__7), ____break = false; (!____break && GS__6 && (GS__8 < ____sz)); ++GS__8) {
    let s_QUOT = GS__7[GS__8];
    ret.add(s_QUOT);
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [eqSets?] in file: stdlib.ky, line: 1254
const eqSets_QMRK = function(s1, s2) {
  let ok_QMRK = true;
  if ( (s1.size === s2.size) ) {
    s1.forEach(function(v, k) {
      return ((!s2.has(v)) ?
        (ok_QMRK = false) :
        null);
    });
  }
  return ok_QMRK;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [map2Map] in file: stdlib.ky, line: 1265
const map2Map = function(m) {
  let ret = new Map();
  for (let ____coll = m, i = 0, ____end = count(____coll), ____break = false; ((!____break) && (i < ____end)); i = (i + 2)) {
    let e = ____coll[i];
    ret.set(e, m[(i + 1)]);
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [eqMaps?] in file: stdlib.ky, line: 1271
const eqMaps_QMRK = function(m1, m2) {
  let ok_QMRK = true;
  if ( (m1.size === m2.size) ) {
    m1.forEach(function(v, k) {
      return ((!eq_QMRK(m2.get(k), v)) ?
        (ok_QMRK = false) :
        null);
    });
  }
  return ok_QMRK;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [map2Obj] in file: stdlib.ky, line: 1282
const map2Obj = function(m) {
  let v = undefined;
  let ret = {};
  for (let ____coll = m, i = 0, ____end = count(____coll), ____break = false; ((!____break) && (i < ____end)); i = (i + 2)) {
    let k = ____coll[i];
    (
    v = m[(i + 1)]);
    (
    ret[[k].join("")] = v);
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [eq?] in file: stdlib.ky, line: 1289
//True if both are equal
const eq_QMRK = function(a, b) {
  let k = undefined;
  let ok_QMRK = true;
  return ((map_QMRK(a) && map_QMRK(b) && (a.length === b.length)) ?
    eq_QMRK(map2Map(a), map2Map(b)) :
    ((obj_QMRK(a) && obj_QMRK(b) && (a.length === b.length)) ?
      eq_QMRK(map2Obj(a), map2Obj(b)) :
      (((Array.isArray(a)) && (Array.isArray(b)) && (a.length === b.length)) ?
        (function() {
          for (let ____coll = null, i = 0, ____end = a.length, ____break = false; ((!____break) && (i < ____end)); i = (i + 1)) {
            if ( (!eq_QMRK(a[i], b[i])) ) {
              (
              ok_QMRK = false);
              (
              ____break = true);
            }
          }
          return ok_QMRK;
        }).call(this) :
        ((set_QMRK(a) && set_QMRK(b) && (a.length === b.length)) ?
          eqSets_QMRK(set2Set(a), set2Set(b)) :
          (((a instanceof LambdaArg) && (b instanceof LambdaArg)) ?
            (a.value === b.value) :
            (((a instanceof Symbol) && (b instanceof Symbol)) ?
              (a.value === b.value) :
              (((a instanceof Keyword) && (b instanceof Keyword)) ?
                (a.value === b.value) :
                ((object_QMRK(a) && object_QMRK(b) && (count(a) === count(b))) ?
                  (function() {
                    for (let ____coll = Object.keys(a), ____index = 0, ____end = count(____coll), ____break = false; ((!____break) && (____index < ____end)); ____index = (____index + 1)) {
                      let k = ____coll[____index];
                      if ( (!eq_QMRK(getProp(a, k), getProp(b, k))) ) {
                        (
                        ok_QMRK = false);
                        (
                        ____break = true);
                      }
                    }
                    return ok_QMRK;
                  }).call(this) :
                  ((((Object.prototype.toString.call(a) === "[object Map]")) && ((Object.prototype.toString.call(b) === "[object Map]"))) ?
                    eqMaps_QMRK(a, b) :
                    ((((Object.prototype.toString.call(a) === "[object Set]")) && ((Object.prototype.toString.call(b) === "[object Set]"))) ?
                      eqSets_QMRK(a, b) :
                      (true ?
                        (a === b) :
                        null)))))))))));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [object?] in file: stdlib.ky, line: 1336
//Returns true
//if a js object
const object_QMRK = function(obj) {
  return ((!(((obj === null)) || ((Object.prototype.toString.call(obj) === "[object Map]")) || ((Object.prototype.toString.call(obj) === "[object Set]")) || (Array.isArray(obj)))) ?
    (typeof (obj) === "object") :
    null);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [last] in file: stdlib.ky, line: 1344
//Returns the last element
const last = function(coll) {
  return (((Array.isArray(coll)) && (coll.length > 0)) ?
    coll[(coll.length - 1)] :
    null);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [into!] in file: stdlib.ky, line: 1350
//Assign a type to this collection
const into_BANG = function(type, coll) {
  let C__9;
  switch (type) {
    case "list":
    case "set":
    case "obj":
    case "map":
    case "vector":
      C__9 = (coll["____typeid"] = type);
      break;
  }
  return coll;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [into] in file: stdlib.ky, line: 1357
//Like into! but
//returning a new collection
const into = function(type, coll) {
  return ((Array.isArray(coll)) ?
    into_BANG(type, coll.slice(0)) :
    null);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [pairs?] in file: stdlib.ky, line: 1364
//Returns true if
//a LISP list, not data
const pairs_QMRK = function(obj) {
  return ((Array.isArray(obj)) && (!vector_QMRK(obj)) && (!set_QMRK(obj)) && (!obj_QMRK(obj)) && (!map_QMRK(obj)) && (!list_QMRK(obj)));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [list?] in file: stdlib.ky, line: 1373
//Returns true if a List
const list_QMRK = function(obj) {
  return ((Array.isArray(obj)) && (obj.____typeid == "list"));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [list] in file: stdlib.ky, line: 1378
//Create a List
const list = function() {
  let xs = Array.prototype.slice.call(arguments, 0);
  (
  xs["____typeid"] = "list");
  return xs;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [vector?] in file: stdlib.ky, line: 1382
//Returns true if a Vector
const vector_QMRK = function(obj) {
  return ((Array.isArray(obj)) && (obj.____typeid == "vector"));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [vector] in file: stdlib.ky, line: 1387
//Create a Vector
const vector = function() {
  let xs = Array.prototype.slice.call(arguments, 0);
  (
  xs["____typeid"] = "vector");
  return xs;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [set?] in file: stdlib.ky, line: 1391
//Returns true if a Set
const set_QMRK = function(obj) {
  return ((Array.isArray(obj)) && (obj.____typeid == "set"));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [set] in file: stdlib.ky, line: 1396
//Create a Set
const set = function() {
  let xs = Array.prototype.slice.call(arguments, 0);
  (
  xs["____typeid"] = "set");
  return xs;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [map?] in file: stdlib.ky, line: 1400
//Returns true if a Hashmap
const map_QMRK = function(obj) {
  return ((Array.isArray(obj)) && (obj.____typeid == "map"));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [obj?] in file: stdlib.ky, line: 1405
//Returns true if a Object
const obj_QMRK = function(obj) {
  return ((Array.isArray(obj)) && (obj.____typeid == "obj"));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [arraymap] in file: stdlib.ky, line: 1410
//Create a new array map
const arraymap = function() {
  let xs = Array.prototype.slice.call(arguments, 0);
  if (( (!((0 === modulo(xs.length, 2)))) )) {
    throw new Error("Invalid arity for arraymap");
  }
  (xs["____typeid"] = "map");
  return xs;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [object] in file: stdlib.ky, line: 1417
//Create a new js object
const object = function() {
  let xs = Array.prototype.slice.call(arguments, 0);
  if (( (!((0 === modulo(xs.length, 2)))) )) {
    throw new Error("Invalid arity for object");
  }
  return zipobj(evens(xs), odds(xs));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [seq] in file: stdlib.ky, line: 1424
//Returns a sequence
const seq = function(obj) {
  return (((typeof (obj) === "string")) ?
    obj.split("") :
    ((Array.isArray(obj)) ?
      obj.slice(0) :
      (((Object.prototype.toString.call(obj) === "[object Set]")) ?
        Array.from(obj.values()) :
        (((Object.prototype.toString.call(obj) === "[object Map]")) ?
          Array.from(obj.entries()) :
          (object_QMRK(obj) ?
            Object.entries(obj) :
            null)))));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [rseq] in file: stdlib.ky, line: 1434
//Returns a seq of the items in coll in reverse order. If rev is empty returns nil.
const rseq = function(coll) {
  return ((Array.isArray(coll)) ?
    seq(coll).reverse() :
    null);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [contains?] in file: stdlib.ky, line: 1440
//True if item is inside
const contains_QMRK = function(coll, x) {
  return (((Array.isArray(coll)) || ((typeof (coll) === "string"))) ?
    coll.includes(x) :
    (((Object.prototype.toString.call(coll) === "[object Set]")) ?
      coll.has(x) :
      (((Object.prototype.toString.call(coll) === "[object Map]")) ?
        coll.has(x) :
        (object_QMRK(coll) ?
          coll.hasOwnProperty(x) :
          (true ?
            false :
            null)))));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [nichts?] in file: stdlib.ky, line: 1449
//True if object is
//either null of undefined
const nichts_QMRK = function(obj) {
  return (((typeof (obj) === "undefined")) || ((obj === null)));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [some?] in file: stdlib.ky, line: 1453
//True if object is
//defined and not null
const some_QMRK = function(obj) {
  return (!nichts_QMRK(obj));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [count] in file: stdlib.ky, line: 1457
//Count the number of elements inside
const count = function(coll) {
  return (coll ?
    ((((Object.prototype.toString.call(coll) === "[object Map]")) || ((Object.prototype.toString.call(coll) === "[object Set]"))) ?
      coll.size :
      ((((typeof (coll) === "string")) || (Array.isArray(coll))) ?
        coll :
        Object.keys(coll)).length) :
    0);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [concat*] in file: stdlib.ky, line: 1467
//Add many to this collection
const concat_STAR = function(coll) {
  let xs = Array.prototype.slice.call(arguments, 1);
  return (coll ?
    coll.concat.apply(coll, xs) :
    null);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [every] in file: stdlib.ky, line: 1472
const every = function(coll, start, step) {
  let ret = [];
  for (let ____coll = coll, ____index = start, ____end = count(____coll), ____break = false; ((!____break) && (____index < ____end)); ____index = (____index + step)) {
    let e = ____coll[____index];
    conj_BANG(ret, e);
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [evens] in file: stdlib.ky, line: 1477
//Collect every
//2nd item starting at 0
const evens = function(coll) {
  return every(coll, 0, 2);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [odds] in file: stdlib.ky, line: 1481
//Collect every
//2nd item starting at 1
const odds = function(coll) {
  return every(coll, 1, 2);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [modulo] in file: stdlib.ky, line: 1485
//Modulo
const modulo = function(x, N) {
  return ((x < 0) ?
    (x - (-1 * (N + (Math.floor(((-1 * x) / N)) * N)))) :
    (x % N));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [partition] in file: stdlib.ky, line: 1493
//Returns a sequence of lists of n items each.
const partition = function(n, coll) {
  return (function() {
    let _x_ = null;
    let recur = null;
    let _f_ = function(ret, GS__10) {
      let x = getIndex(GS__10, 0);
      let y = getIndex(GS__10, 1);
      if (not_DASH_empty(x)) {
        conj_BANG(ret, x);
      }
      return ((0 === count(y)) ?
        ret :
        recur(ret, split_DASH_seq(y, n)));
    };
    let _r_ = _f_;
    (recur = function() {
      (
      _x_ = arguments);
      if (_r_) {
        for (_r_ = undefined; _r_ === undefined;) {
          _r_ = _f_.apply(this, _x_);
        }
        return _r_;
      }
      return undefined;
    });
    return recur([], split_DASH_seq(coll, n));
  })(this);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [split-str] in file: stdlib.ky, line: 1506
//Returns a sequence of strings of n characters each.
const split_DASH_str = function(n, string) {
  let ret = [];
  for (let ____coll = null, i = 0, ____end = count(string), ____break = false; ((!____break) && (i < ____end)); i = (i + n)) {
    conj_BANG(ret, string.substr(i, n));
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [interleave] in file: stdlib.ky, line: 1516
//Returns a seq of the first item
//in each coll, then the second, etc
const interleave = function(c1, c2) {
  let cz = ((c2.length < c1.length) ?
    c2.length :
    c1.length);
  let ret = [];
  for (let ____coll = null, i = 0, ____end = cz, ____break = false; ((!____break) && (i < ____end)); i = (i + 1)) {
    conj_BANG(ret, c1[i], c2[i]);
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [zipmap] in file: stdlib.ky, line: 1526
//Returns an object with the
//keys mapped to the corresponding vals
const zipmap = function(keys, vals) {
  let cz = ((keys.length < vals.length) ?
    keys.length :
    vals.length);
  let ret = (new Map([]));
  for (let ____coll = null, i = 0, ____end = cz, ____break = false; ((!____break) && (i < ____end)); i = (i + 1)) {
    (assoc_BANG(ret, keys[i], vals[i]));
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [zipobj] in file: stdlib.ky, line: 1537
//Returns an object with the
//keys mapped to the corresponding vals
const zipobj = function(keys, vals) {
  let cz = ((keys.length < vals.length) ?
    keys.length :
    vals.length);
  let ret = {};
  for (let ____coll = null, i = 0, ____end = cz, ____break = false; ((!____break) && (i < ____end)); i = (i + 1)) {
    (assoc_BANG(ret, [keys[i]].join(""), vals[i]));
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [extendAttr] in file: stdlib.ky, line: 1548
const extendAttr = function(obj, attr) {
  let GS__11 = Array.prototype.slice.call(arguments, 2);
  let flags = getIndex(GS__11, 0);
  (
  flags = opt_QMRK__QMRK(flags, {
    "enumerable": false,
    "writable": true
  }));
  Object.defineProperty(obj, attr, flags);
  return obj;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [cons] in file: stdlib.ky, line: 1554
//Returns a new seq where x is the first element and seq is
//the rest.
const cons = function(x, coll) {
  return ((Array.isArray(coll)) ?
    (function() {
      return [x].concat(coll);
    }).call(this) :
    null);
};
const gensym_DASH_counter = atom(0);
////////////////////////////////////////////////////////////////////////////////
//fn: [gensym] in file: stdlib.ky, line: 1563
//Generates next random symbol
const gensym = function() {
  let GS__12 = Array.prototype.slice.call(arguments, 0);
  let pfx = getIndex(GS__12, 0);
  return symbol([opt_QMRK__QMRK(pfx, "GS__"), swap_BANG(gensym_DASH_counter, function(x) {
    return (x + 1);
  })].join(""));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [carve] in file: stdlib.ky, line: 1570
const carve = function(coll) {
  let GS__13 = Array.prototype.slice.call(arguments, 1);
  let start = getIndex(GS__13, 0);
  let end = getIndex(GS__13, 1);
  return (((typeof (end) !== "undefined")) ?
    Array.prototype.slice.call(coll, start, end) :
    (((typeof (start) !== "undefined")) ?
      Array.prototype.slice.call(coll, start) :
      Array.prototype.slice.call(coll)));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [assoc!] in file: stdlib.ky, line: 1578
const assoc_BANG = function(obj) {
  let xs = Array.prototype.slice.call(arguments, 1);
  if (obj) {
    for (let ____coll = xs, i = 0, ____end = count(____coll), ____break = false; ((!____break) && (i < ____end)); i = (i + 2)) {
      let k = ____coll[i];
      let v = xs[(i + 1)];
      if (( (Object.prototype.toString.call(obj) === "[object Map]") )) {
        obj.set(k, v);
      } else {
        if (object_QMRK(obj)) {
          obj[k] = v;
        } else {
          null;
        }
      }
    }
  }
  return obj;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [dissoc!] in file: stdlib.ky, line: 1587
const dissoc_BANG = function(obj) {
  let xs = Array.prototype.slice.call(arguments, 1);
  if (obj) {
    for (let GS__16 = 0, GS__14 = true, GS__15 = xs, ____sz = count(GS__15), ____break = false; (!____break && GS__14 && (GS__16 < ____sz)); ++GS__16) {
      let k = GS__15[GS__16];
      if (( (Object.prototype.toString.call(obj) === "[object Map]") )) {
        obj.delete(k);
      } else {
        if (object_QMRK(obj)) {
          delete obj[k];
        } else {
          null;
        }
      }
    }
  }
  return obj;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [truthy?] in file: stdlib.ky, line: 1595
//LISP truthy
const truthy_QMRK = function(a) {
  return (!falsy_QMRK(a));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [falsy?] in file: stdlib.ky, line: 1598
//LISP falsy
const falsy_QMRK = function(a) {
  return (((a === null)) || ((a === false)));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [flatten] in file: stdlib.ky, line: 1601
//Flatten an array
const flatten = function(xs) {
  return xs.reduce(function(acc, v) {
    return acc.concat(v);
  }, []);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [identity] in file: stdlib.ky, line: 1606
//Returns its argument.
const identity = function(x) {
  return x;
};
const m_DASH_identity = (function() {
  let bind = undefined;
  let unit = undefined;
  let zero = undefined;
  let plus = undefined;
  return (function() {
    let bind = function(mv, mf) {
      return mf(mv);
    };
    let unit = function() {
      let ____args = Array.prototype.slice.call(arguments);
      return ____args[0];
    };
    return {
      "bind": bind,
      "unit": unit,
      "zero": zero,
      "plus": plus
    };
  }).call(this);
}).call(this);
const m_DASH_maybe = (function() {
  let bind = undefined;
  let unit = undefined;
  let zero = undefined;
  let plus = undefined;
  return (function() {
    let bind = function(mv, mf) {
      return ((!((mv === null))) ?
        mf(mv) :
        null);
    };
    let unit = function() {
      let ____args = Array.prototype.slice.call(arguments);
      return ____args[0];
    };
    let zero = null;
    return {
      "bind": bind,
      "unit": unit,
      "zero": zero,
      "plus": plus
    };
  }).call(this);
}).call(this);
const m_DASH_list = (function() {
  let bind = undefined;
  let unit = undefined;
  let zero = undefined;
  let plus = undefined;
  return (function() {
    let bind = function(mv, mf) {
      return flatten(mv.map(mf));
    };
    let unit = function() {
      let ____args = Array.prototype.slice.call(arguments);
      return [].concat(____args[0]);
    };
    let zero = [];
    let plus = function() {
      let ____args = Array.prototype.slice.call(arguments);
      return flatten(____args);
    };
    return {
      "bind": bind,
      "unit": unit,
      "zero": zero,
      "plus": plus
    };
  }).call(this);
}).call(this);
const m_DASH_state = (function() {
  let bind = undefined;
  let unit = undefined;
  let zero = undefined;
  let plus = undefined;
  return (function() {
    let bind = function(mv, mf) {
      return function(state) {
        return (function() {
          let GS__17 = mv(state);
          let value = getIndex(GS__17, 0);
          let newState = getIndex(GS__17, 1);
          return mf(value)(newState);
        }).call(this);
      };
    };
    let unit = function(v) {
      return function() {
        let ____args = Array.prototype.slice.call(arguments);
        return [v, ____args[0]];
      };
    };
    return {
      "bind": bind,
      "unit": unit,
      "zero": zero,
      "plus": plus
    };
  }).call(this);
}).call(this);
const m_DASH_continuation = (function() {
  let bind = undefined;
  let unit = undefined;
  let zero = undefined;
  let plus = undefined;
  return (function() {
    let bind = function(mv, mf) {
      return function(cont) {
        return mv(function(value) {
          return mf(value)(cont);
        });
      };
    };
    let unit = function(value) {
      return function(cont) {
        return cont(value);
      };
    };
    return {
      "bind": bind,
      "unit": unit,
      "zero": zero,
      "plus": plus
    };
  }).call(this);
}).call(this);
////////////////////////////////////////////////////////////////////////////////
//fn: [run-cont] in file: stdlib.ky, line: 1667
//Execute the computation cont
//in the cont monad and return its result.
const run_DASH_cont = function(cont) {
  return cont(identity);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [quote-str] in file: stdlib.ky, line: 1674
//Add quotes around a string
const quote_DASH_str = function(s) {
  let ch = "";
  let out = "\"";
  for (let ____coll = null, i = 0, ____end = count(s), ____break = false; ((!____break) && (i < ____end)); i = (i + 1)) {
    (
    ch = s.charAt(i));
    if ( (ch === "\"") ) {
      (
      out += "\\\"");
    } else {
      if ( (ch === "\n") ) {
        (
        out += "\\n");
      } else {
        if ( (ch === "\t") ) {
          (
          out += "\\t");
        } else {
          if ( (ch === "\f") ) {
            (
            out += "\\f");
          } else {
            if ( (ch === "\r") ) {
              (
              out += "\\r");
            } else {
              if ( (ch === "\v") ) {
                (
                out += "\\v");
              } else {
                if ( (ch === "\\") ) {
                  (
                  out += (("u" === s.charAt((i + 1))) ?
                    ch :
                    "\\\\"));
                } else {
                  if (true) {
                    (
                    out += ch);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return (out += "\"");
};
////////////////////////////////////////////////////////////////////////////////
//fn: [unquote-str] in file: stdlib.ky, line: 1690
//Removes quotes around a string
const unquote_DASH_str = function(s) {
  return ((s.startsWith("\"") && s.endsWith("\"")) ?
    (function() {
      let out = "";
      (s = s.slice(1, -1));
      for (let ____coll = null, i = 0, ____end = count(s), ____break = false; ((!____break) && (i < ____end)); i = (i + 1)) {
        let nx = undefined;
        let ch = s.charAt(i);
        if ( (ch === "\\") ) {
          ++i;
          (
          nx = s.charAt(i));
          if ( (nx === "\"") ) {
            (
            out += "\"");
          } else {
            if ( (nx === "\\") ) {
              (
              out += "\\");
            } else {
              if ( (nx === "n") ) {
                (
                out += "\n");
              } else {
                if ( (nx === "t") ) {
                  (
                  out += "\t");
                } else {
                  if ( (nx === "f") ) {
                    (
                    out += "\f");
                  } else {
                    if ( (nx === "v") ) {
                      (
                      out += "\v");
                    } else {
                      if ( (nx === "r") ) {
                        (
                        out += "\r");
                      } else {
                        if (true) {
                          (
                          out += ch);
                          --i;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          (
          out += ch);
        }
      }
      return out;
    }).call(this) :
    s);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [escXml] in file: stdlib.ky, line: 1714
//Escape XML special chars
const escXml = function(s) {
  let out = "";
  for (let GS__20 = 0, GS__18 = true, GS__19 = s, ____sz = count(GS__19), ____break = false; (!____break && GS__18 && (GS__20 < ____sz)); ++GS__20) {
    let c = GS__19[GS__20];
    if ( (c === "&") ) {
      (
      c = "&amp;");
    } else {
      if ( (c === ">") ) {
        (
        c = "&gt;");
      } else {
        if ( (c === "<") ) {
          (
          c = "&lt;");
        } else {
          if ( (c === "\"") ) {
            (
            c = "&quot;");
          } else {
            if ( (c === "'") ) {
              (
              c = "&apos;");
            } else {
              null;
            }
          }
        }
      }
    }
    (out += c);
  }
  return out;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [split-seq] in file: stdlib.ky, line: 1727
//Split a collection into 2 parts
const split_DASH_seq = function(coll, cnt) {
  return ((cnt < count(coll)) ?
    [Array.prototype.slice.call(coll, 0, cnt), Array.prototype.slice.call(coll, cnt)] :
    [Array.prototype.slice.call(coll, 0), []]);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [select-keys] in file: stdlib.ky, line: 1733
//Get a subset of keys
const select_DASH_keys = function(coll, keys) {
  return seq(keys).reduce(function(acc, n) {
    return (assoc_BANG(acc, n, coll.get(n)));
  }, new Map());
};
////////////////////////////////////////////////////////////////////////////////
//fn: [doUpdateIn!] in file: stdlib.ky, line: 1741
const doUpdateIn_BANG = function(coll, n, func, args, err) {
  let cur = (((typeof (n) === "number")) ?
    (((Array.isArray(coll)) && (n < coll.length)) ?
      coll[n] :
      err(n)) :
    (true ?
      coll.get(n) :
      null));
  let v = func.apply(this, cons(cur, args));
  return (assoc_BANG(coll, n, v));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [update-in!] in file: stdlib.ky, line: 1752
//'Updates' a value in a nested associative structure, where ks is a
//sequence of keys and f is a function that will take the old value
//and any supplied args and return the new value, and returns a new
//nested structure.  If any levels do not exist, hash-maps will be
//created.
const update_DASH_in_BANG = function(coll, keys, func) {
  let xs = Array.prototype.slice.call(arguments, 3);
  let err = function() {
    let ____args = Array.prototype.slice.call(arguments);
    return (function() {
      throw new Error(["update-in! failed, bad nested keys: ", ____args[0]].join(""));
    }).call(this);
  };
  let root = coll;
  let m = undefined;
  let end = (keys.length - 1);
  for (let ____coll = keys, i = 0, ____end = count(____coll), ____break = false; ((!____break) && (i <= end)); i = (i + 1)) {
    let n = ____coll[i];
    if ( (i === end) ) {
      doUpdateIn_BANG(root, n, func, xs, err);
    } else {
      if (( (typeof (n) === "number") )) {
        if ( (!((Array.isArray(root)) && (n < root.length))) ) {
          err(n);
        } else {
          (
          root = root[n]);
        }
      } else {
        if (true) {
          (
          m = root.get(n));
          if (( (typeof (m) === "undefined") )) {
            (
            m = new Map());
            (assoc_BANG(root, n, m));
          }
          if ( (!((Object.prototype.toString.call(m) === "[object Map]"))) ) {
            err(n);
          } else {
            null;
          }
          (root = m);
        }
      }
    }
  }
  return coll;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [get-in] in file: stdlib.ky, line: 1784
//Returns the value in a nested associative structure,
//where ks is a sequence of keys. Returns nil if the key
//is not present, or the not-found value if supplied.
const get_DASH_in = function(coll, keys) {
  let root = coll;
  let ret = null;
  let m = undefined;
  let n = undefined;
  let end = (keys.length - 1);
  for (let ____coll = keys, i = 0, ____end = count(____coll), ____break = false; ((!____break) && (i <= end)); i = (i + 1)) {
    let n = ____coll[i];
    if (( (typeof (n) === "number") )) {
      if ( (!((Array.isArray(root)) && (n < root.length))) ) {
        (
        ret = null);
        (
        ____break = true);
      } else {
        (root = root[n], ret = root);
      }
    } else {
      if (true) {
        (root = root.get(n), ret = root);
      }
    }
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [merge!] in file: stdlib.ky, line: 1809
const merge_BANG = function(base, m) {
  let ret = (base || new Map());
  let src = (m || new Map());
  let GS__21 = src;
  let GS__22 = function(v, k) {
    return (assoc_BANG(ret, k, v));
  };
  if (object_QMRK(GS__21)) {
    let GS__23 = GS__21;
    Object.keys(GS__23).forEach(function(p) {
      return GS__22(getProp(GS__23, p), p);
    });
  } else {
    GS__21.forEach(GS__22);
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [mix!] in file: stdlib.ky, line: 1815
const mix_BANG = function(base, m) {
  let ret = (base || {});
  let src = (m || {});
  let GS__24 = src;
  let GS__25 = function(v, k) {
    return (ret[k] = v);
  };
  if (object_QMRK(GS__24)) {
    let GS__26 = GS__24;
    Object.keys(GS__26).forEach(function(p) {
      return GS__25(getProp(GS__26, p), p);
    });
  } else {
    GS__24.forEach(GS__25);
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [merge] in file: stdlib.ky, line: 1821
//Returns a map that consists of the rest of the maps conj-ed onto
//the first.  If a key occurs in more than one map, the mapping from
//the latter (left-to-right) will be the mapping in the result.
const merge = function() {
  let maps = Array.prototype.slice.call(arguments, 0);
  return maps.reduce(function(acc, n) {
    return merge_BANG(acc, n);
  }, new Map());
};
////////////////////////////////////////////////////////////////////////////////
//fn: [mixin] in file: stdlib.ky, line: 1830
//Returns an object that consists of the rest of the objects conj-ed onto
//the first.  If a property occurs in more than one object, the mapping from
//the latter (left-to-right) will be the mapping in the result.
const mixin = function() {
  let objs = Array.prototype.slice.call(arguments, 0);
  return objs.reduce(function(acc, n) {
    return mix_BANG(acc, n);
  }, {});
};
////////////////////////////////////////////////////////////////////////////////
//fn: [fillArray] in file: stdlib.ky, line: 1839
const fillArray = function(len, v) {
  let ret = [];
  for (let ____coll = null, x = 0, ____end = len, ____break = false; ((!____break) && (x < ____end)); x = (x + 1)) {
    conj_BANG(ret, (((typeof (v) === "function")) ?
      v(x) :
      v));
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [copyArray] in file: stdlib.ky, line: 1845
const copyArray = function(src, des) {
  let sz = Math.min(count(src), count(des));
  for (let ____coll = null, i = 0, ____end = sz, ____break = false; ((!____break) && (i < ____end)); i = (i + 1)) {
    (
    des[i] = src[i]);
  }
  return des;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [difference] in file: stdlib.ky, line: 1852
//Return a set that is the first set
//without elements of the other set.
const difference = function(a, b) {
  let ret = [];
  for (let GS__29 = 0, GS__27 = true, GS__28 = a, ____sz = count(GS__28), ____break = false; (!____break && GS__27 && (GS__29 < ____sz)); ++GS__29) {
    let z = GS__28[GS__29];
    if ( (!contains_QMRK(b, z)) ) {
      conj_BANG(ret, z);
    } else {
      null;
    }
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [inc] in file: stdlib.ky, line: 1863
//Returns a number one greater than x.
const inc = function(x) {
  return (x + 1);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [dec] in file: stdlib.ky, line: 1866
//Returns a number one lesser than x.
const dec = function(x) {
  return (x - 1);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [percent] in file: stdlib.ky, line: 1869
const percent = function(numerator, denominator) {
  return (100 * (numerator / denominator));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [toFixed] in file: stdlib.ky, line: 1873
const toFixed = function(num, digits) {
  (
  digits = opt_QMRK__QMRK(digits, 2));
  return Number(num).toFixed(digits);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [mapcat] in file: stdlib.ky, line: 1878
const mapcat = function(func, coll) {
  let ret = [];
  return ret.concat.apply(ret, coll.map(func));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [ensureTest] in file: stdlib.ky, line: 1887
const ensureTest = function(cnd, msg) {
  (
  msg = (msg || "test"));
  return (function() {
    try {
      return [(cnd ?
        "passed:" :
        "FAILED:"), " ", msg].join("");
    } catch (e) {
      return ["FAILED: ", msg].join("");
    }
  }).call(this);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [ensureTestThrown] in file: stdlib.ky, line: 1893
const ensureTestThrown = function(expected, error, msg) {
  return (((error === null)) ?
    ["FAILED: ", msg].join("") :
    (((expected === typeof (error)) || (expected === "any")) ?
      ["passed: ", msg].join("") :
      ["FAILED: ", msg].join("")));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [runtest] in file: stdlib.ky, line: 1902
const runtest = function(test) {
  let GS__30 = Array.prototype.slice.call(arguments, 1);
  let title = getIndex(GS__30, 0);
  (
  title = opt_QMRK__QMRK(title, "test"));
  let now = new Date();
  let results = test();
  let sum = count(results);
  let ok = count(results.filter(function() {
    let ____args = Array.prototype.slice.call(arguments);
    return ____args[0].startsWith("p");
  }));
  let ps = toFixed(percent(ok, sum));
  return ["+".repeat(78), title, now, "+".repeat(78), results.join("\n"), "=".repeat(78), ["Passed: ", ok, "/", sum, " [", ps, "%]"].join(""), ["Failed: ", (sum - ok)].join(""), ["CPU Time: ", (new Date() - now), "ms"].join("")].join("\n");
};
const _STAR_ns_DASH_cache_STAR = atom([(new Map([["id", "user"], ["meta", null]]))]);
////////////////////////////////////////////////////////////////////////////////
//fn: [pushNSP] in file: stdlib.ky, line: 1924
const pushNSP = function(nsp) {
  let GS__31 = Array.prototype.slice.call(arguments, 1);
  let info = getIndex(GS__31, 0);
  let obj = (new Map([["id", nsp], ["meta", info]]));
  return swap_BANG(_STAR_ns_DASH_cache_STAR, function(a) {
    a.unshift(obj);
    return a;
  });
};
////////////////////////////////////////////////////////////////////////////////
//fn: [popNSP] in file: stdlib.ky, line: 1930
const popNSP = function() {
  return swap_BANG(_STAR_ns_DASH_cache_STAR, function(a) {
    a.shift();
    return a;
  });
};
////////////////////////////////////////////////////////////////////////////////
//fn: [peekNSP] in file: stdlib.ky, line: 1935
const peekNSP = function() {
  return _STAR_ns_DASH_cache_STAR.value[0];
};
////////////////////////////////////////////////////////////////////////////////
//fn: [*ns*] in file: stdlib.ky, line: 1938
const _STAR_ns_STAR = function() {
  return (function() {
    let GS__32 = peekNSP();
    let n = GS__32;
    return ((((typeof (GS__32) === "undefined")) || ((GS__32 === null))) ?
      null :
      getProp(n, "id"));
  }).call(this);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [minBy] in file: stdlib.ky, line: 1941
const minBy = function(func, coll) {
  return (not_DASH_empty(coll) ?
    coll.slice(1).reduce(function(a, b) {
      return ((func(a) < func(b)) ?
        a :
        b);
    }, coll[0]) :
    undefined);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [maxBy] in file: stdlib.ky, line: 1948
const maxBy = function(func, coll) {
  return (not_DASH_empty(coll) ?
    coll.slice(1).reduce(function(a, b) {
      return ((func(a) < func(b)) ?
        b :
        a);
    }, coll[0]) :
    undefined);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [take-while] in file: stdlib.ky, line: 1955
//Returns a sequence of successive items from coll while
//(pred item) returns logical true. pred must be free of side-effects.
const take_DASH_while = function(pred, coll) {
  let ret = [];
  for (let ____coll = coll, ____index = 0, ____end = count(____coll), ____break = false; ((!____break) && (____index < ____end)); ____index = (____index + 1)) {
    let c = ____coll[____index];
    if (pred(c)) {
      conj_BANG(ret, c);
    } else {
      (
      ____break = true);
    }
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [drop-while] in file: stdlib.ky, line: 1968
//Returns a sequence of the items in coll starting from the
//first item for which (pred item) returns logical false.
const drop_DASH_while = function(pred, coll) {
  let ret = [];
  for (let ____coll = coll, i = 0, ____end = count(____coll), ____break = false; ((!____break) && (i < ____end)); i = (i + 1)) {
    let c = ____coll[i];
    if ( (!pred(c)) ) {
      (
      ret = Array.prototype.slice.call(coll, i));
      (
      ____break = true);
    }
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [split-with] in file: stdlib.ky, line: 1981
//Returns a vector of [(take-while pred coll) (drop-while pred coll)]
const split_DASH_with = function(pred, coll) {
  return [take_DASH_while(pred, coll), drop_DASH_while(pred, coll)];
};
const ____macros = {
  "trye!": "(macro* trye! (& xs) (syntax-quote (try (splice-unquote xs) (catch ewroewrwe null))))",
  "empty?": "(macro* empty? (coll) (syntax-quote (= 0 (kirbystdlibref/count (unquote coll)))))",
  "starts-with?": "(macro* starts-with? (s arg) (syntax-quote (.startsWith (unquote s) (unquote arg))))",
  "ends-with?": "(macro* ends-with? (s arg) (syntax-quote (.endsWith (unquote s) (unquote arg))))",
  "n#": "(macro* n# (coll) (syntax-quote (kirbystdlibref/count (unquote coll))))",
  "1st": "(macro* 1st (x) (syntax-quote (first (unquote x))))",
  "_1": "(macro* _1 (x) (syntax-quote (first (unquote x))))",
  "2nd": "(macro* 2nd (x) (syntax-quote (second (unquote x))))",
  "_2": "(macro* _2 (x) (syntax-quote (second (unquote x))))",
  "3rd": "(macro* 3rd (x) (syntax-quote (nth (unquote x) 2)))",
  "_3": "(macro* _3 (x) (syntax-quote (nth (unquote x) 2)))",
  "trap!": "(macro* trap! (& msgs) (let* [sz (count* msgs)] (if* (> sz 1) (syntax-quote (throw (join \"\" (vec (splice-unquote msgs))))) (if* (> sz 0) (syntax-quote (throw (unquote (nth* msgs 0)))) (syntax-quote (throw \"error!\"))))))",
  "merror": "(macro* merror (e) (syntax-quote (new Error (unquote e))))",
  "raise!": "(macro* raise! (& msgs) (let* [sz (count* msgs)] (if* (> sz 1) (syntax-quote (throw (merror (join \"\" (vec (splice-unquote msgs)))))) (if* (> sz 0) (syntax-quote (throw (merror (unquote (nth* msgs 0))))) (syntax-quote (throw (merror \"error!\")))))))",
  "slice": "(macro* slice (arr start end) (if* end (syntax-quote (Array.prototype.slice.call (unquote arr) (unquote start) (unquote end))) (if* start (syntax-quote (Array.prototype.slice.call (unquote arr) (unquote start))) (syntax-quote (Array.prototype.slice.call (unquote arr))))))",
  "numStr": "(macro* numStr (n) (syntax-quote (.toString (Number (unquote n)))))",
  "float": "(macro* float (x) (syntax-quote (parseFloat (unquote x))))",
  "int": "(macro* int (x) (syntax-quote (parseInt (unquote x))))",
  "delay": "(macro* delay (f t) (syntax-quote (setTimeout (unquote f) (unquote t))))",
  "break-out-of-loop!": "(macro* break-out-of-loop! () (syntax-quote (set! ____break true)))",
  "undef!": "(macro* undef! (x) (syntax-quote (set! (unquote x) undefined)))",
  "nil!": "(macro* nil! (x) (syntax-quote (set! (unquote x) null)))",
  "last-index": "(macro* last-index (coll) (syntax-quote (-1 (alen (unquote coll)))))",
  "rest": "(macro* rest (coll) (syntax-quote (.slice (unquote coll) 1)))",
  "cdr": "(macro* cdr (coll) (syntax-quote (.slice (unquote coll) 1)))",
  "second": "(macro* second (coll) (syntax-quote (nth (unquote coll) 1)))",
  "first": "(macro* first (coll) (syntax-quote (nth (unquote coll) 0)))",
  "car": "(macro* car (coll) (syntax-quote (nth (unquote coll) 0)))",
  "nexth": "(macro* nexth (coll i) (syntax-quote (nth (unquote coll) (1 (unquote i)))))",
  "nth": "(macro* nth (coll i) (syntax-quote (aget (unquote coll) (unquote i))))",
  "even?": "(macro* even? (& xs) (syntax-quote (_andp_* (splice-unquote (map* (lambda* [x] (syntax-quote (= 0 (kirbystdlibref/modulo (unquote x) 2)))) xs)))))",
  "odd?": "(macro* odd? (& xs) (syntax-quote (_andp_* (splice-unquote (map* (lambda* [x] (syntax-quote (not (even? (unquote x))))) xs)))))",
  "alen": "(macro* alen (coll) (syntax-quote (.-length (unquote coll))))",
  "nzlen?": "(macro* nzlen? (coll) (syntax-quote (> (alen (unquote coll)) 0)))",
  "zlen?": "(macro* zlen? (coll) (syntax-quote (= (alen (unquote coll)) 0)))",
  "type": "(macro* type (obj) (syntax-quote (typeof (unquote obj))))",
  "whatis?": "(macro* whatis? (obj) (syntax-quote (Object.prototype.toString.call (unquote obj))))",
  "regex?": "(macro* regex? (& xs) (syntax-quote (_andp_* (splice-unquote (map* (lambda* [x] (syntax-quote (= (whatis? (unquote x)) \"[object RegExp]\"))) xs)))))",
  "array?": "(macro* array? (& xs) (syntax-quote (_andp_* (splice-unquote (map* (lambda* [x] (syntax-quote (Array.isArray (unquote x)))) xs)))))",
  "arr?": "(macro* arr? (& xs) (syntax-quote (array? (splice-unquote xs))))",
  "date?": "(macro* date? (& xs) (syntax-quote (_andp_* (splice-unquote (map* (lambda* [x] (syntax-quote (= (whatis? (unquote x)) \"[object Date]\"))) xs)))))",
  "objectMap?": "(macro* objectMap? (& xs) (syntax-quote (_andp_* (splice-unquote (map* (lambda* [x] (syntax-quote (= (whatis? (unquote x)) \"[object Map]\"))) xs)))))",
  "objectSet?": "(macro* objectSet? (& xs) (syntax-quote (_andp_* (splice-unquote (map* (lambda* [x] (syntax-quote (= (whatis? (unquote x)) \"[object Set]\"))) xs)))))",
  "bool?": "(macro* bool? (& xs) (syntax-quote (boolean? (splice-unquote xs))))",
  "boolean?": "(macro* boolean? (& xs) (syntax-quote (_andp_* (splice-unquote (map* (lambda* [x] (syntax-quote (= (typeof (unquote x)) \"boolean\"))) xs)))))",
  "num?": "(macro* num? (& xs) (syntax-quote (number? (splice-unquote xs))))",
  "number?": "(macro* number? (& xs) (syntax-quote (_andp_* (splice-unquote (map* (lambda* [x] (syntax-quote (= (typeof (unquote x)) \"number\"))) xs)))))",
  "str?": "(macro* str? (& xs) (syntax-quote (string? (splice-unquote xs))))",
  "string?": "(macro* string? (& xs) (syntax-quote (_andp_* (splice-unquote (map* (lambda* [x] (syntax-quote (= (typeof (unquote x)) \"string\"))) xs)))))",
  "fn?": "(macro* fn? (& xs) (syntax-quote (_andp_* (splice-unquote (map* (lambda* [x] (syntax-quote (= (typeof (unquote x)) \"function\"))) xs)))))",
  "undef?": "(macro* undef? (& xs) (syntax-quote (_andp_* (splice-unquote (map* (lambda* [x] (syntax-quote (= (typeof (unquote x)) \"undefined\"))) xs)))))",
  "def?": "(macro* def? (& xs) (syntax-quote (_andp_* (splice-unquote (map* (lambda* [x] (syntax-quote (not= (typeof (unquote x)) \"undefined\"))) xs)))))",
  "nil?": "(macro* nil? (& xs) (syntax-quote (_andp_* (splice-unquote (map* (lambda* [x] (syntax-quote (= (unquote x) null))) xs)))))",
  "zero?": "(macro* zero? (& xs) (syntax-quote (_andp_* (splice-unquote (map* (lambda* [x] (syntax-quote (= (unquote x) 0))) xs)))))",
  "one?": "(macro* one? (& xs) (syntax-quote (_andp_* (splice-unquote (map* (lambda* [x] (syntax-quote (= (unquote x) 1))) xs)))))",
  "neg?": "(macro* neg? (& xs) (syntax-quote (_andp_* (splice-unquote (map* (lambda* [x] (syntax-quote (< (unquote x) 0))) xs)))))",
  "pos?": "(macro* pos? (& xs) (syntax-quote (_andp_* (splice-unquote (map* (lambda* [x] (syntax-quote (> (unquote x) 0))) xs)))))",
  "vals": "(macro* vals (obj) (syntax-quote (Array.from (.values (unquote obj)))))",
  "keys": "(macro* keys (obj) (syntax-quote (Array.from (.keys (unquote obj)))))",
  "properties": "(macro* properties (obj) (syntax-quote (Object.getOwnPropertyNames (unquote obj))))",
  "enumerables": "(macro* enumerables (obj) (syntax-quote (Object.keys (unquote obj))))",
  "assert": "(macro* assert (tst & msgs) (syntax-quote (if (unquote tst) true (raise! (splice-unquote msgs)))))",
  "false?": "(macro* false? (& xs) (syntax-quote (_andp_* (splice-unquote (map* (lambda* [x] (syntax-quote (= (unquote x) false))) xs)))))",
  "true?": "(macro* true? (& xs) (syntax-quote (_andp_* (splice-unquote (map* (lambda* [x] (syntax-quote (= (unquote x) true))) xs)))))",
  "when-not": "(macro* when-not (tst & xs) (syntax-quote (when (not (unquote tst)) (splice-unquote xs))))",
  "unless": "(macro* unless (tst & xs) (syntax-quote (when-not (unquote tst) (splice-unquote xs))))",
  "if-not": "(macro* if-not (tst then else) (syntax-quote (if (not (unquote tst)) (unquote then) (unquote else))))",
  "when": "(macro* when (tst & xs) (syntax-quote (if (unquote tst) (do (splice-unquote xs)))))",
  "cond": "(macro* cond (& xs) (let* [len (count* xs)] (do* (assert* (is-even? len) \"cond expects even args\") (if* (> len 0) (let* [c (nth* xs 0) e (nth* xs 1) r (rest* (rest* xs))] (if* (is-same? c \"else\") (syntax-quote (if true (unquote e))) (syntax-quote (if (unquote c) (unquote e) (cond (splice-unquote r))))))))))",
  "->": "(macro* -> (expr form & xs) (let* [x (syntax-quote ((unquote (nth* form 0)) (unquote expr) (splice-unquote (rest* form))))] (if* (> (count* xs) 0) (syntax-quote (-> (unquote x) (splice-unquote xs))) (syntax-quote (unquote x)))))",
  "->>": "(macro* ->> (expr form & xs) (let* [x (syntax-quote ((splice-unquote form) (unquote expr)))] (if* (> (count* xs) 0) (syntax-quote (->> (unquote x) (splice-unquote xs))) (syntax-quote (unquote x)))))",
  "let": "(macro* let (bindings & xs) (let* [sz (count* xs)] (if* (> sz 0) (syntax-quote (with-local-vars [(splice-unquote bindings)] (splice-unquote xs))))))",
  "single?": "(macro* single? (coll) (syntax-quote (= 1 (n# (unquote coll)))))",
  "dual?": "(macro* dual? (coll) (syntax-quote (= 2 (n# (unquote coll)))))",
  "triple?": "(macro* triple? (coll) (syntax-quote (= 3 (n# (unquote coll)))))",
  "loop": "(macro* loop (bindings & more) (let* [es (evens* bindings) os (odds* bindings)] (syntax-quote ((fn [] (with-local-vars [_x_ null recur null _f_ (fn [(splice-unquote es)] (splice-unquote more)) _r_ _f_]) (set! recur (fn [] (set! _x_ arguments) (raw# \"if (_r_) {for(_r_=undefined;_r_===undefined;){_r_=_f_.apply(this,_x_);} return _r_;}\") undefined)) (recur (splice-unquote os))) this))))",
  "concat": "(macro* concat (coll & xs) (syntax-quote (.concat (unquote coll) (splice-unquote xs))))",
  "join": "(macro* join (sep coll) (syntax-quote (.join (unquote coll) (unquote sep))))",
  "do-with": "(macro* do-with (bindings & xs) (let* [sz (count* bindings) _ (assert* (= sz 2) \"expected only 2 in form\") f (nth* bindings 0)] (syntax-quote (let [(unquote f) (unquote (nth* bindings 1))] (splice-unquote xs) (unquote f)))))",
  "do->false": "(macro* do->false (& xs) (syntax-quote (do (splice-unquote xs) false)))",
  "do->true": "(macro* do->true (& xs) (syntax-quote (do (splice-unquote xs) true)))",
  "do->this": "(macro* do->this (& xs) (syntax-quote (do (splice-unquote xs) this)))",
  "do->nil": "(macro* do->nil (& xs) (syntax-quote (do (splice-unquote xs) null)))",
  "do->undef": "(macro* do->undef (& xs) (syntax-quote (do (splice-unquote xs) undefined)))",
  "do->break!": "(macro* do->break! (& xs) (syntax-quote (do (splice-unquote xs) (break-out-of-loop!))))",
  "dotimes": "(macro* dotimes (bindings & xs) (let* [sz (count* bindings) _ (assert* (= 2 sz) \"expected binary form\") b1 (first* bindings)] (syntax-quote (floop [:index (unquote b1) :end (unquote (nth* bindings 1))] (splice-unquote xs)))))",
  "range": "(macro* range (a b c) (let* [start (if* b a 0) end (if* b b a) step (if* c c 1)] (syntax-quote (do-with [ret []] (floop [:start (unquote start) :end (unquote end) :step (unquote step) :index i] (ret.push i))))))",
  "apply": "(macro* apply (f this args) (syntax-quote (.apply (unquote f) (unquote this) (unquote args))))",
  "apply*": "(macro* apply* (f this & args) (syntax-quote (.apply (unquote f) (unquote this) (vec (splice-unquote args)))))",
  "ch@": "(macro* ch@ (s pos) (syntax-quote (.charAt (unquote s) (unquote pos))))",
  "false!": "(macro* false! (x) (syntax-quote (set! (unquote x) false)))",
  "true!": "(macro* true! (x) (syntax-quote (set! (unquote x) true)))",
  "repeat": "(macro* repeat (n x) (syntax-quote (do-with [ret []] (floop [:end (unquote n)] (ret.push (unquote x))))))",
  "if-some+": "(macro* if-some+ (bindings then else) (let* [sz (count* bindings) _ (assert* (= 2 sz) \"expected binary form\") tst (gensym*)] (syntax-quote (let [(unquote tst) (unquote (nth* bindings 1)) (unquote (first* bindings)) (unquote tst)] (if (> (n# (unquote tst)) 0) (unquote then) (unquote else))))))",
  "if-some": "(macro* if-some (bindings then else) (let* [sz (count* bindings) _ (assert* (= 2 sz) \"expected binary form\") tst (gensym*)] (syntax-quote (let [(unquote tst) (unquote (nth* bindings 1)) (unquote (first* bindings)) (unquote tst)] (if (or (undef? (unquote tst)) (nil? (unquote tst))) (unquote else) (unquote then))))))",
  "if-let": "(macro* if-let (bindings then else) (let* [sz (count* bindings) _ (assert* (= 2 sz) \"expected binary form\") tst (gensym*)] (syntax-quote (let [(unquote tst) (unquote (nth* bindings 1)) (unquote (first* bindings)) (unquote tst)] (if (unquote tst) (unquote then) (unquote else))))))",
  "when-some+": "(macro* when-some+ (bindings & xs) (let* [sz (count* bindings) _ (assert* (= 2 sz) \"expected binary form\") tst (gensym*)] (syntax-quote (let [(unquote tst) (unquote (nth* bindings 1)) (unquote (first* bindings)) (unquote tst)] (when (> (n# (unquote tst)) 0) (splice-unquote xs))))))",
  "when-some": "(macro* when-some (bindings & xs) (let* [sz (count* bindings) _ (assert* (= 2 sz) \"expected binary form\") tst (gensym*)] (syntax-quote (let [(unquote tst) (unquote (nth* bindings 1)) (unquote (first* bindings)) (unquote tst)] (when-not (or (undef? (unquote tst)) (nil? (unquote tst))) (splice-unquote xs))))))",
  "when-let": "(macro* when-let (bindings & xs) (let* [sz (count* bindings) _ (assert* (= 2 sz) \"expected binary form\") tst (gensym*)] (syntax-quote (let [(unquote tst) (unquote (nth* bindings 1)) (unquote (first* bindings)) (unquote tst)] (when (unquote tst) (splice-unquote xs))))))",
  "doto": "(macro* doto (target & xs) (let* [v (gensym*)] (syntax-quote (let [(unquote v) (unquote target)] (splice-unquote (map* (lambda* [e] (syntax-quote ((unquote (first* e)) (unquote v) (splice-unquote (rest* e))))) xs)) (unquote v)))))",
  "map": "(macro* map (f coll) (syntax-quote (.map (unquote coll) (unquote f))))",
  "find": "(macro* find (p coll) (syntax-quote (.find (unquote coll) (unquote p))))",
  "filter": "(macro* filter (p coll) (syntax-quote (.filter (unquote coll) (unquote p))))",
  "some": "(macro* some (p coll) (syntax-quote (.some (unquote coll) (unquote p))))",
  "take": "(macro* take (cnt coll) (syntax-quote (slice (unquote coll) 0 (unquote cnt))))",
  "constantly": "(macro* constantly (x) (syntax-quote (fn [& xs] (unquote x))))",
  "drop": "(macro* drop (cnt coll) (syntax-quote (slice (unquote coll) (unquote cnt))))",
  "reduce2": "(macro* reduce2 (f coll) (syntax-quote (.reduce (unquote coll) (unquote f))))",
  "reduce": "(macro* reduce (f start coll) (syntax-quote (.reduce (unquote coll) (unquote f) (unquote start))))",
  "foldl": "(macro* foldl (f start coll) (syntax-quote (reduce (unquote f) (unquote start) (unquote coll))))",
  "str": "(macro* str (& xs) (syntax-quote (.join (vec (splice-unquote xs)) \"\")))",
  "lambda": "(macro* lambda (code) (let* [sz (count* code) body (if* (> sz 1) code (if* (> sz 0) (nth* code 0)))] (syntax-quote (fn [] (with-local-vars [____args (slice arguments)]) (unquote body)))))",
  "each": "(macro* each (func coll) (syntax-quote (.forEach (unquote coll) (unquote func))))",
  "each-property": "(macro* each-property (func obj) (let* [t (gensym*)] (syntax-quote (let [(unquote t) (unquote obj)] (each (fn [p] ((unquote func) (get (unquote t) p) p)) (properties (unquote t)))))))",
  "each-enumerable": "(macro* each-enumerable (func obj) (let* [t (gensym*)] (syntax-quote (let [(unquote t) (unquote obj)] (each (fn [p] ((unquote func) (get (unquote t) p) p)) (enumerables (unquote t)))))))",
  "each-key": "(macro* each-key (func obj) (let* [t (gensym*) f (gensym*)] (syntax-quote (let [(unquote t) (unquote obj) (unquote f) (unquote func)] (if (kirbystdlibref/object? (unquote t)) (each-enumerable (unquote f) (unquote t)) (each (unquote f) (unquote t)))))))",
  "dosync": "(macro* dosync (& exprs) (syntax-quote (do (splice-unquote exprs))))",
  "monad": "(macro* monad (docstring operations) (syntax-quote (with-local-vars [bind undefined unit undefined zero undefined plus undefined] (let [(splice-unquote operations)] (object :bind bind :unit unit :zero zero :plus plus)))))",
  "defmonad": "(macro* defmonad (name docs operations) (let* [ds (if* (is-str? docs) docs \"\") ps (if* (is-str? docs) operations (if* (is-array? docs) docs)) _ (assert* (is-array? ps) \"no macro operations\")] (syntax-quote (const (unquote name) (monad (unquote ds) (unquote ps))))))",
  "dobind": "(macro* dobind (mbind steps expr) (let* [mv (nth* steps 1) a1 (nth* steps 0) more (rest* (rest* steps))] (syntax-quote ((unquote mbind) (unquote mv) (fn [(unquote a1)] (unquote (if* (not-empty* more) (syntax-quote (dobind (unquote mbind) (unquote more) (unquote expr))) (syntax-quote (do (unquote expr))))))))))",
  "domonad": "(macro* domonad (monad steps body) (syntax-quote ((fn [{:keys [bind unit zero] :as mo}] (with-local-vars [ret (lambda (if (and (kirbystdlibref/nichts? %1) (def? zero)) zero (unit %1)))]) (dobind bind (unquote steps) (ret (unquote body)))) (unquote monad))))",
  "deftest": "(macro* deftest (name & body) (syntax-quote (const (unquote name) (lambda (vec (splice-unquote body))))))",
  "ensure": "(macro* ensure (form msg) (syntax-quote (kirbystdlibref/ensureTest (unquote form) (unquote msg))))",
  "ensureThrown": "(macro* ensureThrown (expected form msg) (syntax-quote (try (unquote form) (kirbystdlibref/ensureTestThrown (unquote expected) null (unquote msg)) (catch e (kirbystdlibref/ensureTestThrown (unquote expected) e (unquote msg))))))",
  "assert*": "(macro* assert* (c msg) (syntax-quote (if* (unquote c) true (throw* (unquote msg)))))",
  "cond*": "(macro* cond* (& xs) (if* (> (count* xs) 0) (list* (quote if*) (first* xs) (nth* xs 1) (cons* (quote cond*) (rest* (rest* xs))))))",
  "_andp_*": "(macro* _andp_* (& xs) (if* (= 1 (unquote (count* xs))) (syntax-quote (unquote (first* xs))) (syntax-quote (and (splice-unquote xs)))))",
  "with-local-vars": "(macro* with-local-vars (bindings & more) (let* [_ (assert* (is-array? bindings) \"expecting array as bindings\") e (count* more) b (count* bindings)] (if* (not* (is-even? b)) (throw* \"wanted even number of binding forms\") (if* (> e 0) (syntax-quote (do (vars (splice-unquote bindings)) (splice-unquote more))) (syntax-quote (vars (splice-unquote bindings)))))))"
};
module.exports = {
  da57bc0172fb42438a11e6e8778f36fb: {
    ns: "czlab.kirby.stdlib",
    macros: ____macros
  },
  MODULE_NAMESPACE: MODULE_NAMESPACE,
  MAX_DASH_INT: MAX_DASH_INT,
  MIN_DASH_INT: MIN_DASH_INT,
  println: println,
  not_DASH_empty: not_DASH_empty,
  stringify: stringify,
  opt_QMRK__QMRK: opt_QMRK__QMRK,
  conj_BANG: conj_BANG,
  conj: conj,
  disj_BANG: disj_BANG,
  disj: disj,
  pop_BANG: pop_BANG,
  pop: pop,
  wrap_DASH_str: wrap_DASH_str,
  getIndex: getIndex,
  getProp: getProp,
  prn: prn,
  LambdaArg: LambdaArg,
  Primitive: Primitive,
  RegexObj: RegexObj,
  Keyword: Keyword,
  Symbol: Symbol,
  primitive_QMRK: primitive_QMRK,
  primitive: primitive,
  regexObj_QMRK: regexObj_QMRK,
  regexObj: regexObj,
  symbol_QMRK: symbol_QMRK,
  symbol: symbol,
  keyword_QMRK: keyword_QMRK,
  keyword: keyword,
  keyword_DASH__GT_symbol: keyword_DASH__GT_symbol,
  lambdaArg_QMRK: lambdaArg_QMRK,
  lambdaArg: lambdaArg,
  Atom: Atom,
  atom_QMRK: atom_QMRK,
  atom: atom,
  reset_BANG: reset_BANG,
  resetVec_BANG: resetVec_BANG,
  resetMap_BANG: resetMap_BANG,
  resetSet_BANG: resetSet_BANG,
  resetObject_BANG: resetObject_BANG,
  objClass: objClass,
  sort_BANG: sort_BANG,
  deref: deref,
  swap_BANG: swap_BANG,
  typeid: typeid,
  complex_QMRK: complex_QMRK,
  simple_QMRK: simple_QMRK,
  value_QMRK: value_QMRK,
  sequential_QMRK: sequential_QMRK,
  eq_QMRK: eq_QMRK,
  object_QMRK: object_QMRK,
  last: last,
  into_BANG: into_BANG,
  into: into,
  pairs_QMRK: pairs_QMRK,
  list_QMRK: list_QMRK,
  list: list,
  vector_QMRK: vector_QMRK,
  vector: vector,
  set_QMRK: set_QMRK,
  set: set,
  map_QMRK: map_QMRK,
  obj_QMRK: obj_QMRK,
  arraymap: arraymap,
  object: object,
  seq: seq,
  rseq: rseq,
  contains_QMRK: contains_QMRK,
  nichts_QMRK: nichts_QMRK,
  some_QMRK: some_QMRK,
  count: count,
  concat_STAR: concat_STAR,
  evens: evens,
  odds: odds,
  modulo: modulo,
  partition: partition,
  split_DASH_str: split_DASH_str,
  interleave: interleave,
  zipmap: zipmap,
  zipobj: zipobj,
  extendAttr: extendAttr,
  cons: cons,
  gensym: gensym,
  carve: carve,
  assoc_BANG: assoc_BANG,
  dissoc_BANG: dissoc_BANG,
  truthy_QMRK: truthy_QMRK,
  falsy_QMRK: falsy_QMRK,
  flatten: flatten,
  identity: identity,
  m_DASH_identity: m_DASH_identity,
  m_DASH_maybe: m_DASH_maybe,
  m_DASH_list: m_DASH_list,
  m_DASH_state: m_DASH_state,
  m_DASH_continuation: m_DASH_continuation,
  run_DASH_cont: run_DASH_cont,
  quote_DASH_str: quote_DASH_str,
  unquote_DASH_str: unquote_DASH_str,
  escXml: escXml,
  split_DASH_seq: split_DASH_seq,
  select_DASH_keys: select_DASH_keys,
  update_DASH_in_BANG: update_DASH_in_BANG,
  get_DASH_in: get_DASH_in,
  merge: merge,
  mixin: mixin,
  fillArray: fillArray,
  copyArray: copyArray,
  difference: difference,
  inc: inc,
  dec: dec,
  percent: percent,
  toFixed: toFixed,
  mapcat: mapcat,
  ensureTest: ensureTest,
  ensureTestThrown: ensureTestThrown,
  runtest: runtest,
  pushNSP: pushNSP,
  popNSP: popNSP,
  peekNSP: peekNSP,
  _STAR_ns_STAR: _STAR_ns_STAR,
  minBy: minBy,
  maxBy: maxBy,
  take_DASH_while: take_DASH_while,
  drop_DASH_while: drop_DASH_while,
  split_DASH_with: split_DASH_with
};