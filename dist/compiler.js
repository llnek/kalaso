/*Auto generated by Kirby v1.0.0 - Thu Mar 29 2018 19:08:29 GMT-0700 (PDT)
  czlab.kirby.compiler
{"doc" "Transpiles kirby code to js code." "author" "Kenneth Leung"}
*/

const smap = require("source-map");
const std = require("./stdlib");
const lambdaArg_QMRK = std["lambdaArg_QMRK"];
const pairs_QMRK = std["pairs_QMRK"];
const into_BANG = std["into_BANG"];
const println = std["println"];
const seq = std["seq"];
const merge = std["merge"];
const contains_QMRK = std["contains_QMRK"];
const last = std["last"];
const typeid = std["typeid"];
const prn = std["prn"];
const primitive = std["primitive"];
const set_QMRK = std["set_QMRK"];
const map_QMRK = std["map_QMRK"];
const vector_QMRK = std["vector_QMRK"];
const opt_QMRK__QMRK = std["opt_QMRK__QMRK"];
const some_QMRK = std["some_QMRK"];
const primitive_QMRK = std["primitive_QMRK"];
const regexObj_QMRK = std["regexObj_QMRK"];
const unquote_DASH_str = std["unquote_DASH_str"];
const quote_DASH_str = std["quote_DASH_str"];
const rseq = std["rseq"];
const cons = std["cons"];
const not_DASH_empty = std["not_DASH_empty"];
const conj_BANG = std["conj_BANG"];
const list_QMRK = std["list_QMRK"];
const obj_QMRK = std["obj_QMRK"];
const cons_BANG = std["cons_BANG"];
const gensym = std["gensym"];
const count = std["count"];
const pop_BANG = std["pop_BANG"];
const partition = std["partition"];
const difference = std["difference"];
const carve = std["carve"];
const split_DASH_with = std["split_DASH_with"];
const concat = std["concat"];
const symbol = std["symbol"];
const keyword = std["keyword"];
const symbol_QMRK = std["symbol_QMRK"];
const keyword_QMRK = std["keyword_QMRK"];
const rt = require("./engine");
const KBSTDLR = rt["KBSTDLR"];
const KBSTDLIB = rt["KBSTDLIB"];
const KBPFX = rt["KBPFX"];
const EXPKEY = rt["EXPKEY"];
const reader = require("./reader");
const jsid = reader["jsid"];
const fs = require("fs");
const path = require("path");
const esfmt = require("esformatter");
const kirbystdlibref = std;
const __module_namespace__ = "czlab.kirby.compiler";
const ERRORS_DASH_MAP = (new Map([["no-sourcemap-info", "Expected source map info"], ["invalid-fargs", "Invalid function args"], ["invalid-catch", "Invalid catch clause"], ["invalid-try", "Invalid try clause"], ["invalid-require", "Invalid require clause"], ["invalid-namespace", "Invalid namespace clause"], ["destruct-args", "Bad destructure args"], ["outside-macro", "Invalid clause outside of macro"], ["file-access", "Failed file access"], ["file-read", "Failed file read"], ["file-open", "Failed to open file"], ["unknown-keyword", "Unknown keyword"], ["invalid-arity", "Invalid function arity"], ["invalid-meta", "Invalid meta data"], ["syntax-error", "Syntax error"], ["empty-form", "Invalid form (empty)"]]));
const ARRSLICE = "Array.prototype.slice.call";
const JSARGS = "arguments";
const LARGS = "____args";
const BREAK = "____break";
const MOD_DASH_VER = "1.0.0";
const GET_DASH_INDEX = [KBSTDLR, ".getIndex"].join("");
const GET_DASH_PROP = [KBSTDLR, ".getProp"].join("");
const KEYW = [KBSTDLR, ".keyword"].join("");
const SYMB = [KBSTDLR, ".symbol"].join("");
const COUNT = [KBSTDLR, ".count"].join("");
const MODLO = [KBSTDLR, ".modulo"].join("");
var _STAR_externs_STAR = undefined;
var _STAR_macros_STAR = undefined;
var _STAR_vars_STAR = undefined;
var _STAR_last_DASH_line_STAR = 0;
var _STAR_last_DASH_col_STAR = 0;
var SPEC_DASH_OPS = {};
var MATH_DASH_OP_DASH_REGEX = /^[-+][0-9]+$/;
////////////////////////////////////////////////////////////////////////////////
//fn: [unmangle] in file: compiler.ky, line: 71
//Ensure name is compliant
const unmangle = function(s) {
  return (s.split(".") || []).map(function() {
    let ____args = Array.prototype.slice.call(arguments);
    return reader.jsid(____args[0]);
  }).join(".");
};
////////////////////////////////////////////////////////////////////////////////
//fn: [tnodeEx] in file: compiler.ky, line: 76
const tnodeEx = function(name) {
  let GS__8 = Array.prototype.slice.call(arguments, 1);
  let chunk = kirbystdlibref.getIndex(GS__8, 0);
  return tnode(null, null, null, chunk, name);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [tnode] in file: compiler.ky, line: 80
const tnode = function() {
  let GS__9 = Array.prototype.slice.call(arguments, 0);
  let src = kirbystdlibref.getIndex(GS__9, 0);
  let ln = kirbystdlibref.getIndex(GS__9, 1);
  let col = kirbystdlibref.getIndex(GS__9, 2);
  let chunk = kirbystdlibref.getIndex(GS__9, 3);
  let name = kirbystdlibref.getIndex(GS__9, 4);
  return new smap.SourceNode(opt_QMRK__QMRK(ln, null), opt_QMRK__QMRK(col, null), opt_QMRK__QMRK(src, null), opt_QMRK__QMRK(chunk, null), opt_QMRK__QMRK(name, null));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [doFuncArgs] in file: compiler.ky, line: 89
//Deal with possible destructuring
//of args in function definition
const doFuncArgs = function(args, env) {
  let fargs = node_QUOT(args);
  let fdefs = node_QUOT(args);
  let ret = [fargs, fdefs];
  let pms = [];
  let rval = undefined;
  let out = undefined;
  for (let ____coll = args, i = 0, ____end = kirbystdlibref.count(____coll), ____break = false; ((!____break) && (i < ____end)); i = (i + 1)) {
    let e = ____coll[i];
    (rval = node_QUOT(args), out = node_QUOT(args));
    if (symbol_QMRK(e)) {
      if ( (e == "&") ) {
        (
        e = args[(i + 1)]);
        rval.add([ARRSLICE, "(", JSARGS, ",", [i].join(""), ")"]);
        fdefs.add(["let ", tx_STAR((symbol_QMRK(e) ?
          e :
          dstru_STAR(e, out, env)), env), "=", rval, ";\n", out]);
        (
        ____break = true);
      } else {
        conj_BANG(pms, ((e == "_") ?
          xfi(e, gensym("U__")) :
          e));
      }
    } else {
      if ( (Array.isArray(e)) ) {
        rval.add([JSARGS, "[", [i].join(""), "]"]);
        conj_BANG(pms, dstru_STAR(e, out, env));
        fdefs.add(out);
      } else {
        if (true) {
          error_BANG("destruct-args", args);
        }
      }
    }
  }
  pms.forEach(function() {
    let ____args = Array.prototype.slice.call(arguments);
    return fargs.add(tx_STAR(____args[0], env));
  });
  fargs.join(",");
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [dstru*] in file: compiler.ky, line: 123
//Decide on what the
//rhs should be referred to 'as'
const dstru_STAR = function(coll, out, env) {
  let rhs = gensym();
  for (let ____coll = coll, i = 0, ____end = kirbystdlibref.count(____coll), ____break = false; ((!____break) && (i < ____end)); i = (i + 1)) {
    let e = ____coll[i];
    if ( (keyword_QMRK(e) && (e == "as")) ) {
      (
      rhs = symbol([coll[(i + 1)]].join("")));
      (
      ____break = true);
    }
  }
  xfi(coll, rhs);
  out.add((map_QMRK(coll) ?
    dmap_BANG(rhs, coll, env) :
    (vector_QMRK(coll) ?
      dvec_BANG(rhs, coll, env) :
      (true ?
        "" :
        null))));
  return rhs;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [dvec!] in file: compiler.ky, line: 139
//Destruct a vec
const dvec_BANG = function(src, coll, env) {
  let ret = node_QUOT(coll);
  let rval = undefined;
  let out = undefined;
  let as = tx_STAR(src, env);
  for (let ____coll = coll, i = 0, ____end = kirbystdlibref.count(____coll), ____break = false; ((!____break) && (i < ____end)); i = (i + 1)) {
    let e = ____coll[i];
    (rval = node_QUOT(coll), out = node_QUOT(coll));
    if (symbol_QMRK(e)) {
      if ( (e == "&") ) {
        (
        e = coll[(i + 1)]);
        rval.add([ARRSLICE, "(", as, ",", [i].join(""), ")"]);
        ret.add(["let ", tx_STAR(((!symbol_QMRK(e)) ?
          dstru_STAR(e, out, env) :
          e), env), "=", rval, ";\n", out]);
        (
        ____break = true);
      } else {
        if (true) {
          if ( (!(e == "_")) ) {
            ret.add(["let ", tx_STAR(e, env), "=", slib_BANG(GET_DASH_INDEX), "(", as, ",", [i].join(""), ");\n"]);
          } else {
            null;
          }
        }
      }
    } else {
      if ( (Array.isArray(e)) ) {
        rval.add([as, "[", [i].join(""), "]"]);
        ret.add(["let ", tx_STAR(dstru_STAR(e, out, env), env), "=", rval, ";\n", out]);
      } else {
        if (keyword_QMRK(e)) {
          if ( (e == "as") ) {
            ++i;
          } else {
            error_BANG("unknown-keyword", coll);
          }
        } else {
          if (true) {
            error_BANG("syntax-error", coll);
          }
        }
      }
    }
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [dmap!] in file: compiler.ky, line: 170
//Destruct a map
const dmap_BANG = function(src, coll, env) {
  let ret = node_QUOT(coll);
  let arr = undefined;
  let as = tx_STAR(src, env);
  for (let ____coll = coll, i = 0, ____end = kirbystdlibref.count(____coll), ____break = false; ((!____break) && (i < ____end)); i = (i + 2)) {
    let e = ____coll[i];
    if (keyword_QMRK(e)) {
      if ( ((e == "keys") || (e == "strs")) ) {
        for (let GS__12 = 0, GS__10 = true, GS__11 = coll[(i + 1)], ____sz = kirbystdlibref.count(GS__11), ____break = false; (!____break && GS__10 && (GS__12 < ____sz)); ++GS__12) {
          let a_QUOT = GS__11[GS__12];
          ret.add(["let ", tx_STAR(a_QUOT, env), "=", slib_BANG(GET_DASH_PROP), "(", as, ",", std.quote_DASH_str([a_QUOT].join("")), ");\n"]);
        }
      } else {
        if ( (e == "as") ) {
          null;
        } else {
          if (true) {
            error_BANG("unknown-keyword", coll);
          }
        }
      }
    } else {
      error_BANG("syntax-error", coll);
    }
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [simple?] in file: compiler.ky, line: 188
//Nothing complex
const simple_QMRK = function(ast) {
  return (((typeof (ast) === "undefined")) || ((ast === null)) || ((typeof (ast) === "string")) || ((typeof (ast) === "number")) || ((typeof (ast) === "boolean")));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [wrap] in file: compiler.ky, line: 192
const wrap = function(ret, head, tail) {
  if (ret) {
    if (head) {
      ret.prepend(head);
    }
    if (tail) {
      ret.add(tail);
    }
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [exprHint] in file: compiler.ky, line: 198
//Flag the AST if it is an expression
const exprHint = function(ast, flag) {
  return (function() {
    let GS__13 = (simple_QMRK(ast) ?
      primitive(ast) :
      ast);
    (GS__13["____expr"] = flag);
    return GS__13;
  }).call(this);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [stmt?] in file: compiler.ky, line: 204
const stmt_QMRK = function(ast) {
  if (simple_QMRK(ast)) {
    error_BANG("syntax-error", ast);
  }
  return ((ast.____expr === false));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [error!] in file: compiler.ky, line: 208
const error_BANG = function(e) {
  let GS__14 = Array.prototype.slice.call(arguments, 1);
  let ast = kirbystdlibref.getIndex(GS__14, 0);
  let msg = kirbystdlibref.getIndex(GS__14, 1);
  return (function() {
    throw new Error([kirbystdlibref.getProp(ERRORS_DASH_MAP, e),(msg ?
      [" : ", msg].join("") :
      null),((ast && ((typeof (ast.line) === "number"))) ?
      ["\nline: ", ast.line].join("") :
      null),((ast && ((typeof (ast.source) === "string"))) ?
      ["\nfile: ", ast.source].join("") :
      null)].join(""));
  }).call(this);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [testre?] in file: compiler.ky, line: 215
//Test a regex
const testre_QMRK = function(re, x) {
  return (x ?
    re.test(x) :
    false);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [fn??] in file: compiler.ky, line: 216
const fn_QMRK__QMRK = function(cmd) {
  return (testre_QMRK(reader.REGEX.func, cmd) ?
    ["(", cmd, ")"].join("") :
    cmd);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [pad] in file: compiler.ky, line: 220
const pad = function(n) {
  return " ".repeat(n);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [node'] in file: compiler.ky, line: 223
const node_QUOT = function(ast) {
  let GS__15 = Array.prototype.slice.call(arguments, 1);
  let obj = kirbystdlibref.getIndex(GS__15, 0);
  return (function() {
    let GS__16 = opt_QMRK__QMRK(obj, tnode());
    (GS__16["source"] = ast.source, GS__16["line"] = ast.line, GS__16["column"] = ast.column);
    return GS__16;
  }).call(this);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [txTree] in file: compiler.ky, line: 228
//Process a file unit.  Sort out all the macros first then others.
//Also, always check first for (ns ...)
const txTree = function(root, env) {
  let ms = [];
  let os = [];
  let n1 = root[0];
  let ret = node_QUOT(root);
  if ( (!("ns" == n1[0])) ) {
    throw new Error("(ns ...) must be first form in file");
  } else {
    null;
  }
  conj_BANG(ms, n1);
  for (let GS__19 = 0, GS__17 = true, GS__18 = root.slice(1), ____sz = kirbystdlibref.count(GS__18), ____break = false; (!____break && GS__17 && (GS__19 < ____sz)); ++GS__19) {
    let t = GS__18[GS__19];
    conj_BANG((((Array.isArray(t)) && symbol_QMRK(t[0]) && ("defmacro" == t[0])) ?
      ms :
      os), t);
  }
  ms.concat(os).forEach(function(r) {
    (_STAR_last_DASH_line_STAR = r.line, _STAR_last_DASH_col_STAR = r.col);
    return (function() {
      let GS__20 = tx_STAR(r, env);
      let t = GS__20;
      return ((((typeof (GS__20) === "undefined")) || ((GS__20 === null))) ?
        null :
        ret.add([t, ";\n"]));
    }).call(this);
  });
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [txForm] in file: compiler.ky, line: 247
const txForm = function(expr, env) {
  if ( (Array.isArray(expr)) ) {
    expr.forEach(function() {
      let ____args = Array.prototype.slice.call(arguments);
      return (____args[2][____args[1]] = tx_STAR(____args[0], env));
    });
  }
  return expr;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [txAtom] in file: compiler.ky, line: 252
const txAtom = function(a) {
  let s = [a].join("");
  return (lambdaArg_QMRK(a) ?
    [LARGS, "[",(parseInt(s.slice(1)) - 1), "]"].join("") :
    (regexObj_QMRK(a) ?
      node_QUOT(a, tnodeEx(s, s.slice(1))) :
      (keyword_QMRK(a) ?
        node_QUOT(a, tnodeEx(s, quote_DASH_str(s))) :
        (symbol_QMRK(a) ?
          node_QUOT(a, tnodeEx(s, unmangle(s))) :
          (((a === null)) ?
            "null" :
            (primitive_QMRK(a) ?
              (function() {
                (a = a.value, s = [a].join(""));
                return (((typeof (a) === "string")) ?
                  quote_DASH_str(a) :
                  (((a === null)) ?
                    "null" :
                    (true ?
                      s :
                      null)));
              }).call(this) :
              (((typeof (a) === "string")) ?
                quote_DASH_str(a) :
                (true ?
                  reader.jsid(s) :
                  null))))))));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [tx*] in file: compiler.ky, line: 274
const tx_STAR = function(x) {
  let GS__21 = Array.prototype.slice.call(arguments, 1);
  let env = kirbystdlibref.getIndex(GS__21, 0);
  return ((Array.isArray(x)) ?
    txPairs(x, env) :
    txAtom(x));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [gcmd] in file: compiler.ky, line: 278
const gcmd = function(ast) {
  return (map_QMRK(ast) ?
    "hash-map" :
    (obj_QMRK(ast) ?
      "object" :
      (vector_QMRK(ast) ?
        "vec" :
        (set_QMRK(ast) ?
          "hash-set" :
          (list_QMRK(ast) ?
            "list" :
            (((Array.isArray(ast)) && (!(Array.isArray(ast[0])))) ?
              [ast[0]].join("") :
              (true ?
                "" :
                null)))))));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [quoteSingle] in file: compiler.ky, line: 288
const quoteSingle = function(a) {
  return (keyword_QMRK(a) ?
    [slib_BANG(KEYW), "(\"", a.value, "\")"].join("") :
    (symbol_QMRK(a) ?
      [slib_BANG(SYMB), "(\"", a.value, "\")"].join("") :
      (primitive_QMRK(a) ?
        (function() {
          (
          a = a.value);
          return (((typeof (a) === "string")) ?
            quote_DASH_str(a) :
            (((a === null)) ?
              "null" :
              (true ?
                [a].join("") :
                null)));
        }).call(this) :
        (((typeof (a) === "string")) ?
          quote_DASH_str(a) :
          (true ?
            [a].join("") :
            null)))));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [quote!] in file: compiler.ky, line: 299
const quote_BANG = function(ast, env) {
  return ((Array.isArray(ast)) ?
    (map_QMRK(ast) ?
      quoteMap(ast, env) :
      quoteBlock(ast, env)) :
    quoteSingle(ast));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [quoteMap] in file: compiler.ky, line: 306
const quoteMap = function(ast, env) {
  let cma = "";
  let ret = node_QUOT(ast);
  for (let ____coll = ast, i = 0, ____end = kirbystdlibref.count(____coll), ____break = false; ((!____break) && (i < ____end)); i = (i + 2)) {
    let a_QUOT = ____coll[i];
    if ( (i > 0) ) {
      ret.add(",");
    }
    ret.add([quote_BANG(a_QUOT, env), " , ", quote_BANG(ast[(i + 1)], env)]);
  }
  if ( (!(0 === kirbystdlibref.count(ast))) ) {
    (
    cma = ",");
  } else {
    null;
  }
  return wrap(ret, ["[", slib_BANG(SYMB), "(\"hash-map\")", cma], "]");
};
////////////////////////////////////////////////////////////////////////////////
//fn: [quoteBlock] in file: compiler.ky, line: 317
const quoteBlock = function(ast, env) {
  let ret = node_QUOT(ast);
  for (let ____coll = ast, i = 0, ____end = kirbystdlibref.count(____coll), ____break = false; ((!____break) && (i < ____end)); i = (i + 1)) {
    let a_QUOT = ____coll[i];
    if ( (i > 0) ) {
      ret.add(",");
    }
    ret.add(quote_BANG(a_QUOT, env));
  }
  return wrap(ret, "[", "]");
};
////////////////////////////////////////////////////////////////////////////////
//fn: [spreadInfo] in file: compiler.ky, line: 324
const spreadInfo = function(from, to) {
  return ((from && (!simple_QMRK(from)) && ((typeof (from.line) === "number")) && (Array.isArray(to))) ?
    (function() {
      xfi(from, to);
      return (function() {
        for (let GS__24 = 0, GS__22 = true, GS__23 = to, ____sz = kirbystdlibref.count(GS__23), ____break = false; (!____break && GS__22 && (GS__24 < ____sz)); ++GS__24) {
          let t_QUOT = GS__23[GS__24];
          spreadInfo(from, t_QUOT);
        }
        ;return null;
      }).call(this);
    }).call(this) :
    xfi(from, to));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [txPairs] in file: compiler.ky, line: 333
const txPairs = function(ast, env) {
  let nsp = std.peekNSP();
  let stmtQ = stmt_QMRK(ast);
  let ret = node_QUOT(ast);
  let cmd = gcmd(ast);
  let e1 = ast[0];
  let orig = ast;
  let op = undefined;
  let tmp = undefined;
  let mc = rt.getMacro(cmd);
  xfi(e1, ret);
  xfi(e1, ast);
  if (mc) {
    (ast = rt.expand_QMRK__QMRK(ast, env, mc), ast = xfi(orig, exprHint(ast, (!stmtQ))));
    spreadInfo(orig, ast);
    (
    cmd = gcmd(ast));
  }
  if (reader.REGEX.int.test(cmd)) {
    (cmd = ((!(cmd.startsWith("+") || cmd.startsWith("-"))) ?
      ["+", cmd].join("") :
      cmd), ast = xfi(ast, [symbol(cmd.charAt(0)), ast[1], parseInt(cmd.slice(1))]), cmd = [ast[0]].join(""));
  }
  (op = kirbystdlibref.getProp(SPEC_DASH_OPS, cmd));
  if ( (cmd == "with-meta") ) {
    ret.add(tx_STAR(meta_QMRK__QMRK(ast, env)[1], env));
  } else {
    if (cmd.startsWith(".-")) {
      ret.add([tx_STAR(ast[1], env), ".", tx_STAR(symbol(cmd.slice(2)), env)]);
    } else {
      if (cmd.startsWith(".@")) {
        ret.add([tx_STAR(ast[1], env), "[", cmd.slice((cmd.startsWith(".@+") ?
          3 :
          2)),(cmd.startsWith(".@+") ?
          "+1" :
          ""), "]"]);
      } else {
        if (cmd.startsWith(".")) {
          ret.add([tx_STAR(ast[1], env), tx_STAR(symbol(cmd), env)].concat("(", (function() {
            let GS__25 = [];
            for (let GS__28 = 0, GS__26 = true, GS__27 = Array.prototype.slice.call(ast, 2), ____sz = kirbystdlibref.count(GS__27), ____break = false; (!____break && GS__26 && (GS__28 < ____sz)); ++GS__28) {
              let a_QUOT = GS__27[GS__28];
              GS__25.push((function() {
                return tx_STAR(a_QUOT, env);
              }).call(this));
            }
            return GS__25;
          }).call(this).join(","), ")"));
        } else {
          if (some_QMRK(op)) {
            (
            ret = op(ast, env));
          } else {
            if ( (((cmd == "splice-unquote") || (cmd == "unquote") || (cmd == "syntax-quote")) && (!kirbystdlibref.getProp(nsp, "id").startsWith(KBPFX))) ) {
              error_BANG("outside-macro", ast);
            } else {
              if (true) {
                (
                cmd = (pairs_QMRK(ast) ?
                  [txForm(ast, env)[0]].join("") :
                  tx_STAR(ast, env)));
                if ( (!cmd) ) {
                  error_BANG("empty-form", ast);
                } else {
                  null;
                }
                (cmd = slib_BANG(cmd));
                ret.add((pairs_QMRK(ast) ?
                  [fn_QMRK__QMRK(cmd), "(", ast.slice(1).join(","), ")"] :
                  cmd));
              }
            }
          }
        }
      }
    }
  }
  return node_QUOT(ast, ret);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [writeDoc] in file: compiler.ky, line: 386
//Convert to jsdoc
const writeDoc = function(doc) {
  return (((doc ?
    std.split(unquote_DASH_str(doc), "\n") :
    []) || []).map(function() {
    let ____args = Array.prototype.slice.call(arguments);
    return (function() {
      let s = [____args[0]].join("").trim();
      return (not_DASH_empty(s) ?
        ["//", s, "\n"].join("") :
        null);
    }).call(this);
  }) || []).filter(function() {
    let ____args = Array.prototype.slice.call(arguments);
    return not_DASH_empty(____args[0]);
  });
};
////////////////////////////////////////////////////////////////////////////////
//fn: [txDo] in file: compiler.ky, line: 393
//A Do block
const txDo = function(ast, env) {
  let GS__29 = Array.prototype.slice.call(arguments, 2);
  let return_QMRK = kirbystdlibref.getIndex(GS__29, 0);
  let stmtQ = stmt_QMRK(ast);
  let ret = node_QUOT(ast);
  let e = undefined;
  let end = (ast.length - 1);
  (return_QMRK = (stmtQ ?
    false :
    opt_QMRK__QMRK(return_QMRK, true)));
  for (let ____coll = ast, ____index = 0, ____end = end, ____break = false; ((!____break) && (____index < ____end)); ____index = (____index + 1)) {
    let a_QUOT = ____coll[____index];
    ret.add([tx_STAR(exprHint(a_QUOT, false), env), ";\n"]);
  }
  if ( (end >= 0) ) {
    (
    e = tx_STAR(exprHint(ast[end], (!stmtQ)), env));
    ret.add(((!return_QMRK) ?
      [e, ";\n"] :
      ["return ", e, ";\n"]));
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [isMeta?] in file: compiler.ky, line: 409
const isMeta_QMRK = function(obj) {
  return ((Array.isArray(obj)) && (3 === kirbystdlibref.count(obj)) && symbol_QMRK(obj[0]) && ("with-meta" == [obj[0]].join("")));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [meta??] in file: compiler.ky, line: 414
const meta_QMRK__QMRK = function(obj, env) {
  return (isMeta_QMRK(obj) ?
    (function() {
      let GS__30 = obj;
      let e2 = kirbystdlibref.getIndex(GS__30, 1);
      let e3 = kirbystdlibref.getIndex(GS__30, 2);
      (e2["____meta"] = evalMeta(e3, env));
      return [e2.____meta, e2];
    }).call(this) :
    [null, obj]);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [fmtSpecOps] in file: compiler.ky, line: 422
const fmtSpecOps = function(fname, attrs) {
  let f = function() {
    let ____args = Array.prototype.slice.call(arguments);
    return [reader.jsid("SPEC-OPS"), "[", std.quote_DASH_str(____args[0]), "] = ", fname].join("");
  };
  return (function() {
    let GS__31 = (kirbystdlibref.getProp(attrs, "opcode") || []).map(f).join(";\n");
    let out = GS__31;
    return ((kirbystdlibref.count(GS__31) > 0) ?
      [out, ";\n"].join("") :
      "");
  }).call(this);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [writeFuncPre] in file: compiler.ky, line: 430
const writeFuncPre = function(pre, env) {
  let ret = node_QUOT(pre);
  let c2 = [kirbystdlibref.symbol("if-not"), [kirbystdlibref.symbol("and")].concat(pre), [kirbystdlibref.symbol("throw"), [kirbystdlibref.symbol("Error"), "Precondition failed"]]];
  return ret.add([tx_STAR(exprHint(c2, false), env), ";\n"]);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [writeFuncInfo] in file: compiler.ky, line: 438
const writeFuncInfo = function(fname, ast) {
  let file = (ast.source ?
    ast.source.slice((ast.source.lastIndexOf("/") + 1)) :
    "?");
  let s = ["//fn: [", fname, "] in file: ", file, ", line: ",(ast.line || "?"), "\n"].join("");
  let len = s.length;
  if ( (len < 80) ) {
    (
    len = 80);
  }
  return ["/".repeat(len), "\n", s].join("");
};
////////////////////////////////////////////////////////////////////////////////
//fn: [evalMeta] in file: compiler.ky, line: 450
const evalMeta = function(ast, env) {
  return rt.compute(((Array.isArray(ast)) ?
    ast :
    (keyword_QMRK(ast) ?
      into_BANG("map", [ast, true]) :
      (symbol_QMRK(ast) ?
        into_BANG("map", [keyword(":tag"), ast]) :
        (true ?
          error_BANG("invalid-meta", ast) :
          null)))), env);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [slib!] in file: compiler.ky, line: 461
//Maybe strip out kirbyref
const slib_BANG = function(cmd) {
  let nsp = std.peekNSP();
  let lib = [KBSTDLR, "."].join("");
  (cmd = [cmd].join(""));
  return ((cmd.startsWith(lib) && (kirbystdlibref.getProp(nsp, "id") == KBSTDLIB)) ?
    cmd.slice(lib.length) :
    cmd);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [assertArity] in file: compiler.ky, line: 469
const assertArity = function(kond, ast) {
  if ( (!kond) ) {
    error_BANG("invalid-arity", ast);
  } else {
    null;
  }
  return assertInfo(ast);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [assertInfo] in file: compiler.ky, line: 473
const assertInfo = function(ast) {
  return ((false && ast && (!simple_QMRK(ast)) && (!((typeof (ast.line) === "number")))) ?
    error_BANG("no-sourcemap-info", ast) :
    null);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [loadRLib] in file: compiler.ky, line: 481
//Load in all the exported macros from the external lib
const loadRLib = function(info, env) {
  let ast = undefined;
  let s = undefined;
  let GS__32 = info;
  let ns = kirbystdlibref.getProp(GS__32, "ns");
  let macros = kirbystdlibref.getProp(GS__32, "macros");
  let vars = kirbystdlibref.getProp(GS__32, "vars");
  let GS__33 = macros;
  let GS__34 = function(v, k) {
    (ast = rt.readAST(v), s = symbol([ns, "/", [ast[1]].join("")].join("")));
    (
    ast[1] = s);
    return rt.compute(ast, env);
  };
  if (kirbystdlibref.object_QMRK(GS__33)) {
    let GS__35 = GS__33;
    Object.keys(GS__35).forEach(function(p) {
      return GS__34(kirbystdlibref.getProp(GS__35, p), p);
    });
  } else {
    GS__33.forEach(GS__34);
  }
  return ns;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [loadRVars] in file: compiler.ky, line: 493
const loadRVars = function(info, env) {
  return [(kirbystdlibref.getProp(info, "vars") || []).map(function() {
    let ____args = Array.prototype.slice.call(arguments);
    return symbol(____args[0]);
  }), (kirbystdlibref.getProp(info, "vars") || []).reduce(function() {
    let ____args = Array.prototype.slice.call(arguments);
    return conj_BANG(____args[0], ____args[1]);
  }, (new Set([])))];
};
////////////////////////////////////////////////////////////////////////////////
//fn: [isPub?] in file: compiler.ky, line: 499
const isPub_QMRK = function(ast) {
  return (![((Array.isArray(ast)) ?
    ast[0] :
    ast)].join("").endsWith("-"));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-juxt] in file: compiler.ky, line: 505
//Takes a set of functions and returns a fn that is the juxtaposition
//of those fns.  The returned fn takes a variable number of args, and
//returns a vector containing the result of applying each fn to the
//args (left-to-right).
//((juxt a b c) x) => [(a x) (b x) (c x)]
const sf_DASH_juxt = function(ast, env) {
  let ret = node_QUOT(ast);
  for (let GS__38 = 0, GS__36 = true, GS__37 = ast.slice(1), ____sz = kirbystdlibref.count(GS__37), ____break = false; (!____break && GS__36 && (GS__38 < ____sz)); ++GS__38) {
    let a_QUOT = GS__37[GS__38];
    let f = [gensym("F__")].join("");
    ret.add(["let ", f, "=", tx_STAR(a_QUOT, env), ";\n", "ret.push(", f, ".apply(this,", LARGS, "));\n"]);
  }
  return wrap(ret, ["function () {\nlet ret=[],", LARGS, "=", ARRSLICE, "(", JSARGS, ");\n"], "return ret;\n}");
};
SPEC_DASH_OPS["juxt"] = sf_DASH_juxt;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-deref] in file: compiler.ky, line: 525
//Returns an atom's current state.
const sf_DASH_deref = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) === 2), ast);
  return node_QUOT(ast).add([tx_STAR(ast[1], env), ".value"]);
};
SPEC_DASH_OPS["deref"] = sf_DASH_deref;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-compose] in file: compiler.ky, line: 535
//Takes a set of functions and returns a fn that is the composition
//of those fns.  The returned fn takes a variable number of args,
//applies the rightmost of fns to the args, the next
//fn (right-to-left) to the result, etc.
const sf_DASH_compose = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) >= 2), ast);
  let ret = node_QUOT(ast);
  let f = undefined;
  let r = undefined;
  let prev = undefined;
  let start = (ast.length - 1);
  for (let ____coll = ast, i = start, ____end = 0, ____break = false; ((!____break) && (i > ____end)); i = (i - 1)) {
    let a_QUOT = ____coll[i];
    (f = [gensym("F__")].join(""), r = [gensym("R__")].join(""));
    ret.add(["let ", f, "=", tx_STAR(a_QUOT, env), ";\n", "let ", r, "=", f,((i === start) ?
      [".apply(this,", LARGS].join("") :
      ["(", prev].join("")), ");\n"]);
    (
    prev = r);
  }
  return wrap(ret, ["function () {\nlet ", LARGS, "=", ARRSLICE, "(", JSARGS, ");\n"], ["return ", prev, ";\n", "}"]);
};
SPEC_DASH_OPS["comp"] = sf_DASH_compose;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-quote] in file: compiler.ky, line: 564
//Returns the unevaluated form
const sf_DASH_quote = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) === 2), ast);
  return wrap(node_QUOT(ast), null, quote_BANG(ast[1], env));
};
SPEC_DASH_OPS["quote"] = sf_DASH_quote;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-deftype] in file: compiler.ky, line: 571
//Define a Class
const sf_DASH_deftype = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) >= 3), ast);
  let pub_QMRK = isPub_QMRK(ast);
  let par = ast[2][0];
  let ret = node_QUOT(ast);
  let czn = ast[1];
  let czname = tx_STAR(czn, env);
  let GS__39 = (((typeof (ast[3]) === "string")) ?
    [ast[3], Array.prototype.slice.call(ast, 4)] :
    [null, Array.prototype.slice.call(ast, 3)]);
  let doc = kirbystdlibref.getIndex(GS__39, 0);
  let mtds = kirbystdlibref.getIndex(GS__39, 1);
  rt.addVar(czn, (new Map([["ns", std._STAR_ns_STAR()]])));
  ret.add(["class ", czname,(par ?
    [" extends ", tx_STAR(par, env)].join("") :
    ""), " {\n"]);
  for (let GS__42 = 0, GS__40 = true, GS__41 = mtds, ____sz = kirbystdlibref.count(GS__41), ____break = false; (!____break && GS__40 && (GS__42 < ____sz)); ++GS__42) {
    let m = GS__41[GS__42];
    let mtd = kirbystdlibref.symbol("method");
    let m1 = m[0];
    xfi(m1, mtd);
    cons_BANG(mtd, m);
    rt.addVar([czn, ".", m1].join(""), (new Map([["ns", std._STAR_ns_STAR()]])));
    ret.add([sf_DASH_func(m, env, false), "\n"]);
  }
  if (doc) {
    ret.prepend(writeDoc(doc));
  }
  if (pub_QMRK) {
    conj_BANG(_STAR_vars_STAR, czn);
    (kirbystdlibref.assoc_BANG(_STAR_externs_STAR, czname, czname));
  }
  return ret.add("}\n");
};
SPEC_DASH_OPS["deftype"] = sf_DASH_deftype;
SPEC_DASH_OPS["deftype-"] = sf_DASH_deftype;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-compOp] in file: compiler.ky, line: 602
//Handle comparison operators.
const sf_DASH_compOp = function(ast, env) {
  assertArity(((kirbystdlibref.count(ast) >= 3) && ((!((0 === kirbystdlibref.modulo(kirbystdlibref.count(ast), 2)))))), ast);
  let ret = node_QUOT(ast);
  let op = undefined;
  let cmd = [ast[0]].join("");
  if ( (cmd == "not=") ) {
    (
    ast[0] = kirbystdlibref.symbol("!=="));
  } else {
    if ( (cmd == "=") ) {
      (
      ast[0] = kirbystdlibref.symbol("==="));
    } else {
      null;
    }
  }
  (op = [ast[0]].join(""));
  for (let ____coll = ast, i = 1, ____end = (ast.length - 1), ____break = false; ((!____break) && (i < ____end)); i = (i + 1)) {
    let a_QUOT = ____coll[i];
    if ( (i !== 1) ) {
      ret.add(" && ");
    }
    ret.add([tx_STAR(a_QUOT, env), " ", op, " ", tx_STAR(ast[(i + 1)], env)]);
  }
  return wrap(ret, "(", ")");
};
SPEC_DASH_OPS[">"] = sf_DASH_compOp;
SPEC_DASH_OPS[">="] = sf_DASH_compOp;
SPEC_DASH_OPS["<"] = sf_DASH_compOp;
SPEC_DASH_OPS["<="] = sf_DASH_compOp;
SPEC_DASH_OPS["not="] = sf_DASH_compOp;
SPEC_DASH_OPS["!="] = sf_DASH_compOp;
SPEC_DASH_OPS["=="] = sf_DASH_compOp;
SPEC_DASH_OPS["="] = sf_DASH_compOp;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-arithOp] in file: compiler.ky, line: 621
//Handles math operators
const sf_DASH_arithOp = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) >= 2), ast);
  let ret = node_QUOT(ast);
  let e1 = [ast[0]].join("");
  let cmd = (function() {
    let C__43;
    switch (e1) {
      case "unsigned-bit-shift-right":
        C__43 = ">>>";
        break;
      case "bit-shift-right":
        C__43 = ">>";
        break;
      case "bit-shift-left":
        C__43 = "<<";
        break;
      case "bit-and":
        C__43 = "&";
        break;
      case "bit-or":
        C__43 = "|";
        break;
      case "bit-not":
        C__43 = "~";
        break;
      case "bit-xor":
        C__43 = "^";
        break;
      case "rem":
        C__43 = "%";
        break;
      case "div":
        C__43 = "/";
        break;
      case "and":
        C__43 = "&&";
        break;
      case "or":
        C__43 = "||";
        break;
      case "exp":
        C__43 = "**";
        break;
      default:
        C__43 = e1;
        break;
    }
    return C__43;
  }).call(this);
  if ( ("mod" == cmd) ) {
    ret.add([MODLO, "(", tx_STAR(ast[1], env), ",", tx_STAR(ast[2], env), ")"]);
  } else {
    if ( ("~" == cmd) ) {
      ret.add(["~", tx_STAR(ast[1], env)]);
    } else {
      if (true) {
        if ( (("-" == cmd) && (2 === kirbystdlibref.count(ast))) ) {
          ret.add("-1 * ");
        }
        for (let ____coll = ast, i = 1, ____end = kirbystdlibref.count(____coll), ____break = false; ((!____break) && (i < ____end)); i = (i + 1)) {
          let a_QUOT = ____coll[i];
          if ( (kirbystdlibref.count(ast) > 2) ) {
            if ( (i > 1) ) {
              ret.add([" ", cmd, " "].join(""));
            }
          }
          ret.add(tx_STAR(a_QUOT, env));
        }
      }
    }
  }
  return wrap(ret, "(", ")");
};
SPEC_DASH_OPS["bit-shift-left"] = sf_DASH_arithOp;
SPEC_DASH_OPS["bit-shift-right"] = sf_DASH_arithOp;
SPEC_DASH_OPS["unsigned-bit-shift-right"] = sf_DASH_arithOp;
SPEC_DASH_OPS["or"] = sf_DASH_arithOp;
SPEC_DASH_OPS["and"] = sf_DASH_arithOp;
SPEC_DASH_OPS["exp"] = sf_DASH_arithOp;
SPEC_DASH_OPS["rem"] = sf_DASH_arithOp;
SPEC_DASH_OPS["+"] = sf_DASH_arithOp;
SPEC_DASH_OPS["-"] = sf_DASH_arithOp;
SPEC_DASH_OPS["*"] = sf_DASH_arithOp;
SPEC_DASH_OPS["/"] = sf_DASH_arithOp;
SPEC_DASH_OPS["div"] = sf_DASH_arithOp;
SPEC_DASH_OPS["mod"] = sf_DASH_arithOp;
SPEC_DASH_OPS["bit-and"] = sf_DASH_arithOp;
SPEC_DASH_OPS["bit-or"] = sf_DASH_arithOp;
SPEC_DASH_OPS["bit-not"] = sf_DASH_arithOp;
SPEC_DASH_OPS["bit-xor"] = sf_DASH_arithOp;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-do] in file: compiler.ky, line: 664
//Evaluates the expressions in order and returns the value of the last. If no
//expressions are supplied, returns nil.
const sf_DASH_do = function(ast, env) {
  let ret = node_QUOT(ast);
  let stmtQ = stmt_QMRK(ast);
  ret.add(txDo(exprHint(xfi(ast, ast.slice(1)), (!stmtQ)), env, (!stmtQ)));
  return (stmtQ ?
    wrap(ret, null, "") :
    wrap(ret, "(function() {\n", "}).call(this)"));
};
SPEC_DASH_OPS["do"] = sf_DASH_do;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-case] in file: compiler.ky, line: 682
//Takes an expression, and a set of clauses.
//Each clause can take the form of either:
//test-constant result-expr
//(test-constant1 ... test-constantN)  result-expr
//The test-constants are not evaluated. They must be compile-time
//literals, and need not be quoted.  If the expression is equal to a
//test-constant, the corresponding result-expr is returned. A single
//default expression can follow the clauses, and its value will be
//returned if no clause matches.
const sf_DASH_case = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) >= 4), ast);
  let stmtQ = stmt_QMRK(ast);
  let ret = node_QUOT(ast);
  let tst = ast[1];
  let brk = ";\nbreak;\n";
  let gs = [gensym("C__")].join("");
  let dft = (((!((0 === kirbystdlibref.modulo(kirbystdlibref.count(ast), 2))))) ?
    pop_BANG(ast)[0] :
    null);
  for (let ____coll = ast, i = 2, ____end = kirbystdlibref.count(____coll), ____break = false; ((!____break) && (i < ____end)); i = (i + 2)) {
    let a_QUOT = ____coll[i];
    let c = tx_STAR(ast[(i + 1)], env);
    if (pairs_QMRK(a_QUOT)) {
      for (let ____coll = a_QUOT, j = 0, ____end = kirbystdlibref.count(____coll), ____break = false; ((!____break) && (j < ____end)); j = (j + 1)) {
        let j_QUOT = ____coll[j];
        ret.add(["case ", tx_STAR(j_QUOT, env), ":\n",((j === (a_QUOT.length - 1)) ?
          [gs, "=", c, brk].join("") :
          "")]);
      }
    } else {
      ret.add(["case ", tx_STAR(a_QUOT, env), ":\n", gs, "=", c, brk]);
    }
  }
  if (dft) {
    ret.add(["default:\n", gs, "=", tx_STAR(dft, env), brk]);
  }
  wrap(ret, ["switch (", tx_STAR(tst, env), ") {\n"], "}");
  return (stmtQ ?
    wrap(ret, ["let ", gs, ";\n"], "") :
    wrap(ret, ["(function() { let ", gs, ";\n"].join(""), ["return ", gs, ";}).call(this)"].join("")));
};
SPEC_DASH_OPS["case"] = sf_DASH_case;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-var] in file: compiler.ky, line: 720
//Creates a variable with an initial value
const sf_DASH_var = function(ast, env) {
  assertArity(((!((0 === kirbystdlibref.modulo(kirbystdlibref.count(ast), 2))))), ast);
  let ret = node_QUOT(ast);
  let cmd = [ast[0]].join("");
  let vs = [];
  let keys = (new Map([]));
  let pub_QMRK = ((cmd == "def") || (cmd == "const"));
  (cmd = (cmd.startsWith("const") ?
    "const" :
    ((cmd == "vars") ?
      "let" :
      "var")));
  for (let ____coll = ast, i = 1, ____end = kirbystdlibref.count(____coll), ____break = false; ((!____break) && (i < ____end)); i = (i + 2)) {
    let lhs = ____coll[i];
    let rhs = ast[(i + 1)];
    let out = node_QUOT(ast);
    let x = undefined;
    let rval = tx_STAR(rhs, env);
    if (symbol_QMRK(lhs)) {
      (x = lhs, lhs = tx_STAR(lhs, env));
      if ( (!("let" == cmd)) ) {
        rt.addVar([x].join(""), (new Map([["ns", std._STAR_ns_STAR()]])));
      } else {
        null;
      }
      (kirbystdlibref.assoc_BANG(keys, lhs, lhs));
      conj_BANG(vs, [x].join(""));
      ret.add([cmd, " ", lhs, "=", rval, ";\n"]);
    } else {
      ret.add(["let ", tx_STAR(dstru_STAR(lhs, out, env), env), "=", rval, ";\n", out]);
    }
  }
  if (pub_QMRK) {
    vs.forEach(function() {
      let ____args = Array.prototype.slice.call(arguments);
      return conj_BANG(_STAR_vars_STAR, ____args[0]);
    });
    let GS__44 = keys;
    let GS__45 = function() {
      let ____args = Array.prototype.slice.call(arguments);
      return (kirbystdlibref.assoc_BANG(_STAR_externs_STAR, ____args[1], ____args[0]));
    };
    if (kirbystdlibref.object_QMRK(GS__44)) {
      let GS__46 = GS__44;
      Object.keys(GS__46).forEach(function(p) {
        return GS__45(kirbystdlibref.getProp(GS__46, p), p);
      });
    } else {
      GS__44.forEach(GS__45);
    }
  }
  return ret;
};
SPEC_DASH_OPS["const-"] = sf_DASH_var;
SPEC_DASH_OPS["const"] = sf_DASH_var;
SPEC_DASH_OPS["def-"] = sf_DASH_var;
SPEC_DASH_OPS["def"] = sf_DASH_var;
SPEC_DASH_OPS["var"] = sf_DASH_var;
SPEC_DASH_OPS["vars"] = sf_DASH_var;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-inst?] in file: compiler.ky, line: 751
//Evaluates x and tests if it is an instance of the class
//c. Returns true or false.
//(inst? c x)
const sf_DASH_inst_QMRK = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) === 3), ast);
  return wrap(node_QUOT(ast), null, ["(", tx_STAR(ast[2], env), " instanceof ", tx_STAR(ast[1], env), ")"]);
};
SPEC_DASH_OPS["inst?"] = sf_DASH_inst_QMRK;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-delete] in file: compiler.ky, line: 764
//Delete an object or property of an object.
const sf_DASH_delete = function(ast, env) {
  assertArity(((kirbystdlibref.count(ast) >= 2) && (kirbystdlibref.count(ast) < 4)), ast);
  let ret = node_QUOT(ast);
  ret.add(["delete ", tx_STAR(ast[1], env)]);
  if ( (kirbystdlibref.count(ast) > 2) ) {
    ret.add(["[", tx_STAR(ast[2], env), "]"]);
  }
  return ret;
};
SPEC_DASH_OPS["delete!"] = sf_DASH_delete;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-dissoc!] in file: compiler.ky, line: 778
//Remove a key from Map.
const sf_DASH_dissoc_BANG = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) === 3), ast);
  node_QUOT(ast).add([slib_BANG([KBSTDLR, ".", tx_STAR(symbol("dissoc!"), env)].join("")), "(", tx_STAR(ast[1], env), ",", tx_STAR(ast[2], env), ")"]);
  return ret;
};
SPEC_DASH_OPS["dissoc!"] = sf_DASH_dissoc_BANG;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-new] in file: compiler.ky, line: 791
//The args, if any, are evaluated from left to right,
//and passed to the constructor of the class
//named by Classname. The constructed object is returned.
//e.g.
//(new Error 'a' 3)
const sf_DASH_new = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) >= 2), ast);
  return wrap(node_QUOT(ast), "new ", tx_STAR(xfi(ast, ast.slice(1)), env));
};
SPEC_DASH_OPS["new"] = sf_DASH_new;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-throw] in file: compiler.ky, line: 805
//Throw an exception
const sf_DASH_throw = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) === 2), ast);
  let ret = node_QUOT(ast);
  let stmtQ = stmt_QMRK(ast);
  ret.add(["throw ", tx_STAR(xfi(ast, ast[1]), env)]);
  if ( (!stmtQ) ) {
    wrap(ret, "(function (){ ", ";}).call(this)");
  } else {
    null;
  }
  return ret;
};
SPEC_DASH_OPS["throw"] = sf_DASH_throw;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-x-opop] in file: compiler.ky, line: 819
//Unary operator for increment & decrement
const sf_DASH_x_DASH_opop = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) === 2), ast);
  let cmd = [ast[0]].join("");
  let a2 = tx_STAR(ast[1], env);
  return node_QUOT(ast).add((cmd.endsWith("$") ?
    [a2, cmd.slice(0, -1)] :
    [cmd, a2]));
};
SPEC_DASH_OPS["++"] = sf_DASH_x_DASH_opop;
SPEC_DASH_OPS["--"] = sf_DASH_x_DASH_opop;
SPEC_DASH_OPS["++$"] = sf_DASH_x_DASH_opop;
SPEC_DASH_OPS["--$"] = sf_DASH_x_DASH_opop;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-x-eq] in file: compiler.ky, line: 832
//Compound assignment operators
const sf_DASH_x_DASH_eq = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) === 3), ast);
  let a0 = [ast[0]].join("");
  let cmd = (function() {
    let C__47;
    switch (a0) {
      case "unsigned-bit-shift-right=":
        C__47 = ">>>=";
        break;
      case "bit-shift-right=":
        C__47 = ">>=";
        break;
      case "bit-shift-left=":
        C__47 = "<<=";
        break;
      case "bit-xor=":
        C__47 = "^=";
        break;
      case "bit-or=":
        C__47 = "|=";
        break;
      case "bit-and=":
        C__47 = "&=";
        break;
      case "div=":
        C__47 = "/=";
        break;
      case "rem=":
        C__47 = "%=";
        break;
      case "exp=":
        C__47 = "**=";
        break;
      default:
        C__47 = a0;
        break;
    }
    return C__47;
  }).call(this);
  return wrap(node_QUOT(ast), "(", [tx_STAR(ast[1], env), " ", cmd, " ", tx_STAR(ast[2], env), ")"]);
};
SPEC_DASH_OPS["+="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS["-="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS["*="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS["/="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS["div="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS["rem="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS["exp="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS["bit-and="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS["bit-or="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS["bit-xor="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS["bit-shift-left="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS["bit-shift-right="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS["unsigned-bit-shift-right="] = sf_DASH_x_DASH_eq;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-assoc!] in file: compiler.ky, line: 865
//Object property assignment or array index setter.
const sf_DASH_assoc_BANG = function(ast, env) {
  assertArity(((0 === kirbystdlibref.modulo(kirbystdlibref.count(ast), 2))), ast);
  let ret = node_QUOT(ast);
  let obj = tx_STAR(ast[1], env);
  for (let ____coll = ast, i = 2, ____end = kirbystdlibref.count(____coll), ____break = false; ((!____break) && (i < ____end)); i = (i + 2)) {
    let a_QUOT = ____coll[i];
    if ( (i > 2) ) {
      ret.add(",");
    }
    ret.add([slib_BANG([KBSTDLR, ".", tx_STAR(symbol("assoc!"), env)].join("")), "(", obj, ",", tx_STAR(xfi(ast, a_QUOT), env), ",", tx_STAR(xfi(ast, ast[(i + 1)]), env), ")"]);
  }
  return wrap(ret, "(", ")");
};
SPEC_DASH_OPS["assoc!"] = sf_DASH_assoc_BANG;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-assign!] in file: compiler.ky, line: 881
//Object property assignment or array index setter.
const sf_DASH_assign_BANG = function(ast, env) {
  assertArity(((0 === kirbystdlibref.modulo(kirbystdlibref.count(ast), 2))), ast);
  let ret = node_QUOT(ast);
  let obj = tx_STAR(ast[1], env);
  for (let ____coll = ast, i = 2, ____end = kirbystdlibref.count(____coll), ____break = false; ((!____break) && (i < ____end)); i = (i + 2)) {
    let a_QUOT = ____coll[i];
    if ( (i > 2) ) {
      ret.add(",");
    }
    ret.add([obj, "[", tx_STAR(xfi(ast, a_QUOT), env), "]", "=", tx_STAR(xfi(ast, ast[(i + 1)]), env)]);
  }
  return wrap(ret, "(", ")");
};
SPEC_DASH_OPS["oset!"] = sf_DASH_assign_BANG;
SPEC_DASH_OPS["aset"] = sf_DASH_assign_BANG;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-set] in file: compiler.ky, line: 895
//Set value(s) to variable(s).
//e.g. (set! a 2 b 4 ...)
const sf_DASH_set = function(ast, env) {
  assertArity(((!((0 === kirbystdlibref.modulo(kirbystdlibref.count(ast), 2))))), ast);
  let ret = node_QUOT(ast);
  for (let ____coll = ast, i = 1, ____end = kirbystdlibref.count(____coll), ____break = false; ((!____break) && (i < ____end)); i = (i + 2)) {
    let a_QUOT = ____coll[i];
    if ( (i > 1) ) {
      ret.add(",");
    }
    ret.add([tx_STAR(a_QUOT, env), "=", tx_STAR(xfi(ast, ast[(i + 1)]), env)]);
  }
  return wrap(ret, "(", ")");
};
SPEC_DASH_OPS["set!"] = sf_DASH_set;
SPEC_DASH_OPS["var-set"] = sf_DASH_set;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-fn] in file: compiler.ky, line: 911
//Defines an anonymous function. See defn.
//(fn attrs? [x y] ...)
const sf_DASH_fn = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) >= 2), ast);
  let body = xfi(ast, Array.prototype.slice.call(ast, 2));
  let GS__48 = meta_QMRK__QMRK(ast[1], env);
  let args = kirbystdlibref.getIndex(GS__48, 1);
  if ( (!(Array.isArray(args))) ) {
    error_BANG("invalid-fargs", ast);
  } else {
    null;
  }
  let fargs = doFuncArgs(xfi(ast, args), env);
  return wrap(node_QUOT(ast), null, ["function (", fargs[0], ") {\n", fargs[1], txDo(body, env, true), "}"]);
};
SPEC_DASH_OPS["fn"] = sf_DASH_fn;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-func] in file: compiler.ky, line: 931
//Defines a function. Use defn- to indicate privacy (no export).
//(defn name doc-string? attr-map? [params*] ...)
const sf_DASH_func = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) >= 2), ast);
  let mtd_QMRK = ([ast[0]].join("") == "method");
  let pub_QMRK = isPub_QMRK(ast);
  let fname0 = [ast[1]].join("");
  let fname = [tx_STAR(ast[1], env)].join("");
  let dot_QMRK = contains_QMRK(fname, ".");
  let ret = node_QUOT(ast, tnodeEx(fname));
  let GS__49 = (((typeof (ast[2]) === "string")) ?
    [ast[2], 3] :
    [null, 2]);
  let doc = kirbystdlibref.getIndex(GS__49, 0);
  let pargs = kirbystdlibref.getIndex(GS__49, 1);
  let body = xfi(ast, Array.prototype.slice.call(ast, (pargs + 1)));
  let b1 = body[0];
  let GS__50 = meta_QMRK__QMRK(ast[pargs], env);
  let attrs = kirbystdlibref.getIndex(GS__50, 0);
  let args = kirbystdlibref.getIndex(GS__50, 1);
  if ( (!mtd_QMRK) ) {
    rt.addVar(fname0, (new Map([["ns", std._STAR_ns_STAR()]])));
  } else {
    null;
  }
  if ( (!(Array.isArray(args))) ) {
    error_BANG("invalid-fargs", ast);
  } else {
    null;
  }
  let pre = undefined;
  let post = undefined;
  let fargs = doFuncArgs(xfi(ast, args), env);
  (attrs = (attrs || (new Map([]))));
  if (map_QMRK(b1)) {
    for (let ____coll = b1, i = 0, ____end = kirbystdlibref.count(____coll), ____break = false; ((!____break) && (i < ____end)); i = (i + 2)) {
      let e = ____coll[i];
      let e2 = b1[(i + 1)];
      if ( (keyword_QMRK(e) && (Array.isArray(e2))) ) {
        if ( (e == "post") ) {
          (
          post = e2);
        } else {
          if ( (e == "pre") ) {
            (
            pre = e2);
          } else {
            null;
          }
        }
      }
    }
  }
  if (mtd_QMRK) {
    if (attrs.static) {
      ret.add("static ");
    }
    ret.add([fname, " ("].join(""));
    if ( (fname == "constructor") ) {
      conj_BANG(body, kirbystdlibref.symbol("this"));
    }
  } else {
    if (dot_QMRK) {
      ret.add([fname, " = function ("].join(""));
    } else {
      if (true) {
        ret.add(["const ", fname, " = function ("].join(""));
      }
    }
  }
  ret.add([fargs[0], ") {\n", fargs[1]]);
  if ( (pre || post) ) {
    (
    body = body.slice(1));
    ret.add(writeFuncPre(xfi(ast, pre), env));
  }
  ret.add([txDo(body, env, true), "};\n"]);
  if (not_DASH_empty(attrs)) {
    ret.add(fmtSpecOps(fname, attrs));
  }
  if (doc) {
    ret.prepend(writeDoc(doc));
  }
  if ( (pub_QMRK && (!dot_QMRK) && (!mtd_QMRK)) ) {
    conj_BANG(_STAR_vars_STAR, fname0);
    (kirbystdlibref.assoc_BANG(_STAR_externs_STAR, fname, fname));
  }
  return ret.prepend(writeFuncInfo(fname0, ast));
};
SPEC_DASH_OPS["defn"] = sf_DASH_func;
SPEC_DASH_OPS["defn-"] = sf_DASH_func;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-try] in file: compiler.ky, line: 988
//The exprs are evaluated and, if no exceptions occur, the value of the last
//is returned. If an exception occurs and catch clauses are provided, each is
//examined in turn and the first for which the thrown exception is an instance
//of the named class is considered a matching catch clause. If there is a
//matching catch clause, its exprs are evaluated in a context in which name is
//bound to the thrown exception, and the value of the last is the return value
//of the function. If there is no matching catch clause, the exception
//propagates out of the function. Before returning, normally or abnormally,
//any finally exprs will be evaluated for their side effects.
const sf_DASH_try = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) >= 2), ast);
  let stmtQ = stmt_QMRK(ast);
  let t = undefined;
  let f = undefined;
  let c = undefined;
  let sz = kirbystdlibref.count(ast);
  let ret = node_QUOT(ast);
  (f = last(ast));
  if ( ((Array.isArray(f)) && ([f[0]].join("") == "finally")) ) {
    pop_BANG(ast);
    (
    sz = kirbystdlibref.count(ast));
    xfi(f[0], f);
  } else {
    (
    f = null);
  }
  (c = null);
  if ( (sz > 1) ) {
    (
    c = ast[(sz - 1)]);
  }
  if ( ((Array.isArray(c)) && ([c[0]].join("") == "catch")) ) {
    if ( ((kirbystdlibref.count(c) < 2) || (!symbol_QMRK(c[1]))) ) {
      error_BANG("invalid-catch", ast);
    }
    pop_BANG(ast);
    xfi(c[0], c);
  } else {
    (
    c = null);
  }
  if ( (((f === null)) && ((c === null))) ) {
    error_BANG("invalid-try", ast);
  }
  ret.add(["try {\n", txDo(exprHint(xfi(ast, ast.slice(1)), (!stmtQ)), env), "\n}"]);
  if (c) {
    (
    t = c[1]);
    ret.add(["catch (", tx_STAR(t, env), ") {\n", txDo(exprHint(xfi(c, Array.prototype.slice.call(c, 2)), (!stmtQ)), env), ";\n}\n"]);
  }
  if (f) {
    ret.add(["finally {\n", txDo(exprHint(xfi(f, f.slice(1)), false), env, false), ";\n}\n"]);
  }
  if ( (!stmtQ) ) {
    wrap(ret, "(function(){\n", "}).call(this)");
  } else {
    null;
  }
  return ret;
};
SPEC_DASH_OPS["try"] = sf_DASH_try;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-if] in file: compiler.ky, line: 1043
//Evaluates test. If truthy evaluates 'then' otherwise 'else'.
//(if test then else)
//(if test then)
const sf_DASH_if = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) >= 3), ast);
  let stmtQ = stmt_QMRK(ast);
  let ret = node_QUOT(ast);
  let a1 = exprHint(xfi(ast, ast[1]), true);
  let a2 = exprHint(xfi(ast, ast[2]), (!stmtQ));
  let m_QMRK = (kirbystdlibref.count(ast) > 3);
  let a3 = (m_QMRK ?
    xfi(ast, ast[3]) :
    null);
  let elze = (m_QMRK ?
    exprHint(a3, (!stmtQ)) :
    null);
  (a1 = tx_STAR(a1, env), a2 = tx_STAR(a2, env), elze = tx_STAR(elze, env));
  return wrap(ret, null, (stmtQ ?
    ["if (", a1, ") {\n", a2, ";\n}",(m_QMRK ?
      [" else { \n", elze, ";\n}"].join("") :
      "")] :
    ["(", a1, " ?\n", a2, " :\n",(elze || "null"), ")"]));
};
SPEC_DASH_OPS["if"] = sf_DASH_if;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-get] in file: compiler.ky, line: 1073
//Returns the named property of an object,
//or value at the index of an array.
//(get obj "age")
//(aget obj 4)
//(nth obj 3)
const sf_DASH_get = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) === 3), ast);
  let a0 = [ast[0]].join("");
  let cmd = slib_BANG(GET_DASH_PROP);
  return ((a0 == "get") ?
    wrap(node_QUOT(ast), null, [cmd, "(", tx_STAR(xfi(ast, ast[1]), env), ",", tx_STAR(xfi(ast, ast[2]), env), ")"]) :
    wrap(node_QUOT(ast), null, [tx_STAR(xfi(ast, ast[1]), env), "[", tx_STAR(xfi(ast, ast[2]), env), "]"]));
};
SPEC_DASH_OPS["oget"] = sf_DASH_get;
SPEC_DASH_OPS["nth"] = sf_DASH_get;
SPEC_DASH_OPS["get"] = sf_DASH_get;
SPEC_DASH_OPS["aget"] = sf_DASH_get;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-array] in file: compiler.ky, line: 1097
//Creates a new vector containing the args.
//(vec "hello" "world")
//(vec 1 2 3)
//[1 2 3]
//["hello" "world"]
const sf_DASH_array = function(ast, env) {
  let ret = node_QUOT(ast);
  assertArity(true, ast);
  if ( (!vector_QMRK(ast)) ) {
    if ( (!("vec" == [ast[0]].join(""))) ) {
      throw new Error(["syntax-error", "expecting vec"].join(""));
    } else {
      (
      ast = ast.slice(1));
    }
  } else {
    null;
  }
  for (let GS__53 = 0, GS__51 = true, GS__52 = ast, ____sz = kirbystdlibref.count(GS__52), ____break = false; (!____break && GS__51 && (GS__53 < ____sz)); ++GS__53) {
    let a_QUOT = GS__52[GS__53];
    ret.add(tx_STAR(xfi(ast, a_QUOT), env));
  }
  ret.join(",");
  return wrap(ret, "[", "]");
};
SPEC_DASH_OPS["vec"] = sf_DASH_array;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-objObj] in file: compiler.ky, line: 1120
//Returns a new object with supplied key-mappings.
//(object "a" 1 "b" 2)
//{:a 1 :b 2}
const sf_DASH_objObj = function(ast, env) {
  let ret = node_QUOT(ast);
  assertArity(true, ast);
  if ( (!obj_QMRK(ast)) ) {
    if ( (!("object" == [ast[0]].join(""))) ) {
      throw new Error(["syntax-error", "expecting object"].join(""));
    } else {
      (
      ast = ast.slice(1));
    }
  } else {
    null;
  }
  for (let ____coll = ast, i = 0, ____end = kirbystdlibref.count(____coll), ____break = false; ((!____break) && (i < ____end)); i = (i + 2)) {
    let a_QUOT = ____coll[i];
    ret.add([tx_STAR(a_QUOT, env), ": ", tx_STAR(xfi(ast, ast[(i + 1)]), env)].join(""));
  }
  ret.join(",");
  return wrap(ret, "{", "}");
};
SPEC_DASH_OPS["object"] = sf_DASH_objObj;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-mapObj] in file: compiler.ky, line: 1138
const sf_DASH_mapObj = function(ast, env) {
  let ret = node_QUOT(ast);
  assertArity(true, ast);
  if ( (!map_QMRK(ast)) ) {
    if ( (!("hash-map" == [ast[0]].join(""))) ) {
      throw new Error(["syntax-error", "expecting hash-map"].join(""));
    } else {
      (
      ast = ast.slice(1));
    }
  } else {
    null;
  }
  for (let ____coll = ast, i = 0, ____end = kirbystdlibref.count(____coll), ____break = false; ((!____break) && (i < ____end)); i = (i + 2)) {
    let a_QUOT = ____coll[i];
    ret.add(["[", tx_STAR(a_QUOT, env), ",", tx_STAR(xfi(ast, ast[(i + 1)]), env), "]"].join(""));
  }
  ret.join(",");
  return wrap(ret, "(new Map([", "]))");
};
SPEC_DASH_OPS["hash-map"] = sf_DASH_mapObj;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-setObj] in file: compiler.ky, line: 1154
//Returns a new Set.
//(set 1 2 3)
const sf_DASH_setObj = function(ast, env) {
  let ret = node_QUOT(ast);
  assertArity(true, ast);
  if ( (!set_QMRK(ast)) ) {
    if ( (!("hash-set" == [ast[0]].join(""))) ) {
      throw new Error(["syntax-error", "expecting hash-set"].join(""));
    } else {
      (
      ast = ast.slice(1));
    }
  } else {
    null;
  }
  for (let GS__56 = 0, GS__54 = true, GS__55 = ast, ____sz = kirbystdlibref.count(GS__55), ____break = false; (!____break && GS__54 && (GS__56 < ____sz)); ++GS__56) {
    let a_QUOT = GS__55[GS__56];
    ret.add(tx_STAR(a_QUOT, env));
  }
  ret.join(",");
  return wrap(ret, "(new Set([", "]))");
};
SPEC_DASH_OPS["hash-set"] = sf_DASH_setObj;
////////////////////////////////////////////////////////////////////////////////
//fn: [require!] in file: compiler.ky, line: 1172
const require_BANG = function(path) {
  return (function() {
    try {
      return require(path);
    } catch (e) {
      println("warning: failed to load lib: ", path);
      return null;
    }
  }).call(this);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-require2] in file: compiler.ky, line: 1179
const sf_DASH_require2 = function(ret, fdir, ast, env) {
  let used = undefined;
  let rlib = undefined;
  let as = [gensym("R__")].join("");
  let rpath = [ast[0]].join("");
  let mcs = undefined;
  let nsp = undefined;
  let vvv = undefined;
  let info = undefined;
  let libpath = undefined;
  let refers = undefined;
  let renames = undefined;
  for (let ____coll = ast, j = 1, ____end = kirbystdlibref.count(____coll), ____break = false; ((!____break) && (j < ____end)); j = (j + 2)) {
    let v = ____coll[j];
    let GS__57 = v;
    if ( ("as" == GS__57) ) {
      (
      as = [ast[(j + 1)]].join(""));
    } else {
      if ( ("refer" == GS__57) ) {
        (
        refers = ast[(j + 1)]);
      } else {
        if ( ("rename" == GS__57) ) {
          (
          renames = ast[(j + 1)]);
        } else {
          null;
        }
      }
    }
  }
  (libpath = tx_STAR((contains_QMRK(rpath, "./") ?
    path.resolve(fdir, rpath) :
    rpath), env));
  ret.add(["const ", reader.jsid(as), "= require(", tx_STAR(rpath, env), ");\n"]);
  (
  rlib = require_BANG(unquote_DASH_str(libpath)));
  if (rlib) {
    (
    info = kirbystdlibref.getProp(rlib, EXPKEY));
  }
  rt.addLib([as].join(""), rlib);
  if (info) {
    (mcs = kirbystdlibref.getProp(info, "macros"), vvv = loadRVars(info, env), nsp = loadRLib(info, env));
  }
  (mcs = (mcs || (new Map([]))), vvv = (vvv || []), used = (new Set([])), nsp = (nsp || ""));
  if ( (keyword_QMRK(refers) && vvv && (refers == "all")) ) {
    (
    refers = vvv[0]);
  }
  for (let ____coll = renames, i = 0, ____end = kirbystdlibref.count(____coll), ____break = false; ((!____break) && (i < ____end)); i = (i + 2)) {
    let ro = ____coll[i];
    let rn = renames[i + 1];
    let ev = [ro].join("");
    let rs = [rn].join("");
    if (info) {
      if ( (!(kirbystdlibref.getProp(mcs, ev) || contains_QMRK(vvv[1], ev))) ) {
        throw new Error(["Unknown var: '", ev, "'"].join(""));
      } else {
        null;
      }
      if ( (kirbystdlibref.getProp(mcs, rs) || contains_QMRK(vvv[1], rs)) ) {
        throw new Error(["Cannot rename var: '", ev, "' to existing var: '", rs, "'"].join(""));
      }
    }
    rt.addVar(rs, (new Map([["ns", nsp]])));
    conj_BANG(used, ev);
    ret.add(["const ", tx_STAR(rn, env), "=", as, "[\"", tx_STAR(ro, env), "\"];\n"]);
  }
  return (function() {
    for (let ____coll = refers, ____index = 0, ____end = kirbystdlibref.count(____coll), ____break = false; ((!____break) && (____index < ____end)); ____index = (____index + 1)) {
      let r = ____coll[____index];
      let rs = [r].join("");
      let v = tx_STAR(r, env);
      if ( (!contains_QMRK(used, rs)) ) {
        if (info) {
          if ( (!(kirbystdlibref.getProp(mcs, rs) || contains_QMRK(vvv[1], rs))) ) {
            throw new Error(["Unknown var: '", rs, "'"].join(""));
          } else {
            null;
          }
        }
        rt.addVar(rs, (new Map([["ns", nsp]])));
        ret.add(["const ", v, "=", as, "[\"", v, "\"];\n"]);
      }
    }
    ;return null;
  }).call(this);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-require] in file: compiler.ky, line: 1236
//Loads libs.
//(:require ["z" :rename {hello goodbye}])
//(:require ["a" :as A])
//(:require ["b"]
//["c" :refer [hello world]])
const sf_DASH_require = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) >= 2), ast);
  let ret = node_QUOT(ast);
  let fdir = path.dirname(ast.source);
  for (let GS__60 = 0, GS__58 = true, GS__59 = ast.slice(1), ____sz = kirbystdlibref.count(GS__59), ____break = false; (!____break && GS__58 && (GS__60 < ____sz)); ++GS__60) {
    let a_QUOT = GS__59[GS__60];
    if ( (!((Array.isArray(a_QUOT)) && ((typeof (a_QUOT[0]) === "string")))) ) {
      error_BANG("invalid-require", ast);
    } else {
      null;
    }
    sf_DASH_require2(ret, fdir, a_QUOT, env);
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-ns] in file: compiler.ky, line: 1256
//(ns name doc-string? attr-map? references*)
//Creates a namespace, references can be zero or more of:
//(:require ...)
//(ns ^{:doc "some doc"} hello.world.core ...)
const sf_DASH_ns = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) >= 2), ast);
  let ret = [];
  let doc = null;
  let e = null;
  let mobj = null;
  let pos = 2;
  let GS__61 = meta_QMRK__QMRK(ast[1], env);
  let attrs = kirbystdlibref.getIndex(GS__61, 0);
  let nsp = kirbystdlibref.getIndex(GS__61, 1);
  if ( (!symbol_QMRK(nsp)) ) {
    error_BANG("invalid-namespace", ast);
  } else {
    null;
  }
  if (( (typeof (ast[pos]) === "string") )) {
    (
    attrs = (attrs || (new Map([]))));
    (kirbystdlibref.assoc_BANG(attrs, "doc", ast[pos]));
    ++pos;
  }
  if (map_QMRK(ast[pos])) {
    (mobj = evalMeta(ast[pos], env), attrs = merge(attrs, mobj));
    ++pos;
    (
    nsp["____meta"] = attrs);
  }
  std.pushNSP([nsp].join(""), attrs);
  (
  ast = xfi(ast, Array.prototype.slice.call(ast, pos)));
  for (let GS__64 = 0, GS__62 = true, GS__63 = ast, ____sz = kirbystdlibref.count(GS__63), ____break = false; (!____break && GS__62 && (GS__64 < ____sz)); ++GS__64) {
    let e = GS__63[GS__64];
    if (pairs_QMRK(e)) {
      if ( ([e[0]].join("") == "require") ) {
        conj_BANG(ret, sf_DASH_require(xfi(ast, e), env));
      } else {
        null;
      }
    }
  }
  (nsp = std._STAR_ns_STAR());
  if ( (nsp == [KBPFX, "stdlib"].join("")) ) {
    null;
  } else {
    if (nsp.startsWith(KBPFX)) {
      conj_BANG(ret, ["const ", KBSTDLR, "=std;\n"].join(""));
    } else {
      if (true) {
        conj_BANG(ret, sf_DASH_require(xfi(ast, [kirbystdlibref.symbol("require"), ["kirby", kirbystdlibref.keyword(":as"), kirbystdlibref.symbol("kirbystdlibref")]]), env));
      }
    }
  }
  return conj_BANG(ret, ["const ", std.MODULE_NAMESPACE, "= ", std.quote_DASH_str(nsp), ";\n"].join(""));
};
SPEC_DASH_OPS["ns"] = sf_DASH_ns;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-comment] in file: compiler.ky, line: 1308
const sf_DASH_comment = function(ast, env) {
  return "";
};
SPEC_DASH_OPS["comment"] = sf_DASH_comment;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-while] in file: compiler.ky, line: 1311
//Generates native for loop.
const sf_DASH_while = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) >= 2), ast);
  let stmtQ = stmt_QMRK(ast);
  let ret = node_QUOT(ast);
  let body = exprHint(xfi(ast, Array.prototype.slice.call(ast, 2)), false);
  return ((0 === kirbystdlibref.count(body)) ?
    ret :
    sf_DASH_wloop(ret, ast[1], body, env, stmtQ));
};
SPEC_DASH_OPS["while"] = sf_DASH_while;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-wloop] in file: compiler.ky, line: 1325
//For loop implementation
const sf_DASH_wloop = function(ret, tst, body, env, stmtQ) {
  let nb = [kirbystdlibref.symbol("not"), kirbystdlibref.symbol("____break")];
  ret.add("for (let ____break=false; ");
  xfi(ret, nb);
  (
  tst = [kirbystdlibref.symbol("and"), nb, tst]);
  xfi(ret, tst);
  ret.add([tx_STAR(tst, env), ";", "){\n", txDo(body, env, false), "}\n"]);
  if ( (!stmtQ) ) {
    wrap(ret, "(function() {\n", "; return null; }).call(this)");
  } else {
    null;
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-forxxx] in file: compiler.ky, line: 1340
//Generates native for loop.
const sf_DASH_forxxx = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) >= 2), ast);
  let stmtQ = stmt_QMRK(ast);
  let ret = node_QUOT(ast);
  let body = exprHint(xfi(ast, Array.prototype.slice.call(ast, 2)), false);
  return ((0 === kirbystdlibref.count(body)) ?
    ret :
    sf_DASH_foop(ret, [ast[0]].join(""), xfi(ast, ast[1]), body, env, stmtQ));
};
SPEC_DASH_OPS["floop"] = sf_DASH_forxxx;
SPEC_DASH_OPS["rloop"] = sf_DASH_forxxx;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-foop] in file: compiler.ky, line: 1356
//For loop implementation
const sf_DASH_foop = function(ret, cmd, args, body, env, stmtQ) {
  let vars = [kirbystdlibref.symbol("____coll"), null, kirbystdlibref.symbol("____index"), 0];
  let incr_QMRK = (cmd == "floop");
  let decr_QMRK = (cmd == "rloop");
  let recurs = [];
  let indexer = undefined;
  let tst = undefined;
  let nb = undefined;
  let sz = undefined;
  let begin = 0;
  let lvar = undefined;
  let coll = undefined;
  let start = undefined;
  let end = undefined;
  let step = undefined;
  if (symbol_QMRK(args[0])) {
    (begin = 2, lvar = args[0], coll = args[1]);
    (
    vars = [kirbystdlibref.symbol("____coll"), coll, kirbystdlibref.symbol("____index"), 0]);
  }
  for (let ____coll = args, i = begin, ____end = kirbystdlibref.count(____coll), ____break = false; ((!____break) && (i < ____end)); i = (i + 2)) {
    let e = ____coll[i];
    if ( (e == "while") ) {
      (
      tst = args[(i + 1)]);
    } else {
      if ( (e == "index") ) {
        (
        vars[2] = args[(i + 1)]);
      } else {
        if ( (e == "recur") ) {
          (
          recurs = args[(i + 1)]);
        } else {
          if ( (e == "start") ) {
            (
            start = args[(i + 1)]);
          } else {
            if ( (e == "end") ) {
              (
              end = args[(i + 1)]);
            } else {
              if ( (e == "step") ) {
                (
                step = args[(i + 1)]);
              } else {
                if (symbol_QMRK(e)) {
                  conj_BANG(vars, e, args[(i + 1)]);
                } else {
                  null;
                }
              }
            }
          }
        }
      }
    }
  }
  (indexer = vars[2]);
  if (( (typeof (start) === "undefined") )) {
    if (incr_QMRK) {
      (
      start = 0);
    }
    if (decr_QMRK) {
      (
      start = [kirbystdlibref.symbol("-"), [kirbystdlibref.symbol("n#"), kirbystdlibref.symbol("_coll")], 1]);
    }
  }
  (vars[3] = start);
  if (( (typeof (end) === "undefined") )) {
    (
    end = (decr_QMRK ?
      -1 :
      (incr_QMRK ?
        [kirbystdlibref.symbol("n#"), kirbystdlibref.symbol("____coll")] :
        null)));
  }
  conj_BANG(vars, kirbystdlibref.symbol("____end"), end);
  if (( (typeof (tst) === "undefined") )) {
    if (incr_QMRK) {
      (
      tst = [kirbystdlibref.symbol("<"), indexer, kirbystdlibref.symbol("____end")]);
    }
    if (decr_QMRK) {
      (
      tst = [kirbystdlibref.symbol(">"), indexer, kirbystdlibref.symbol("____end")]);
    }
  }
  ret.add("for (");
  for (let ____coll = vars, i = 0, ____end = kirbystdlibref.count(____coll), ____break = false; ((!____break) && (i < ____end)); i = (i + 2)) {
    let e = ____coll[i];
    if ( (i === 0) ) {
      ret.add("let ");
    }
    if ( (i !== 0) ) {
      ret.add(",");
    }
    ret.add([tx_STAR(e, env), "=", tx_STAR(vars[(i + 1)], env)]);
  }
  ret.add([",", BREAK, "=false;"]);
  (
  nb = [kirbystdlibref.symbol("not"), kirbystdlibref.symbol("____break")]);
  xfi(ret, nb);
  (
  tst = (((typeof (tst) !== "undefined")) ?
    [kirbystdlibref.symbol("and"), nb, tst] :
    nb));
  xfi(ret, tst);
  ret.add([tx_STAR(tst, env), "; "]);
  if (( (typeof (step) === "undefined") )) {
    (
    step = 1);
  }
  if (incr_QMRK) {
    cons_BANG([kirbystdlibref.symbol("+"), indexer, step], recurs);
  }
  if (decr_QMRK) {
    cons_BANG([kirbystdlibref.symbol("-"), indexer, step], recurs);
  }
  for (let ____coll = recurs, i = 0, k = 2, ____end = kirbystdlibref.count(____coll), ____break = false; ((!____break) && (i < ____end)); i = (i + 1), k = (k + 2)) {
    let e = ____coll[i];
    if ( (i !== 0) ) {
      ret.add(",");
    }
    ret.add([tx_STAR(vars[k], env), "=", tx_STAR(e, env)]);
  }
  ret.add(["){\n",(((typeof (lvar) !== "undefined")) ?
    sf_DASH_var(xfi(args, [kirbystdlibref.symbol("vars"), lvar, [kirbystdlibref.symbol("nth"), kirbystdlibref.symbol("____coll"), indexer]]), env) :
    ""), txDo(body, env, false), "}\n"]);
  if ( (!stmtQ) ) {
    wrap(ret, "(function() {\n", "; return null; }).call(this)");
  } else {
    null;
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-jscode] in file: compiler.ky, line: 1426
//Inject raw native code fragment.
//(raw# "console.log('hi');")
const sf_DASH_jscode = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) >= 2), ast);
  let s = [ast[1]].join("");
  let name = reader.jsid("sf-jscode");
  return node_QUOT(ast, tnodeEx(name, ((s.endsWith("\"") && s.startsWith("\"")) ?
    s.slice(1, -1) :
    s)));
};
SPEC_DASH_OPS["raw#"] = sf_DASH_jscode;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-macro] in file: compiler.ky, line: 1443
//Like defn, but the resulting function name is declared as a
//macro and will be used as a macro by the compiler when it is
//called.
//(defmacro macro-name [args] ...)
const sf_DASH_macro = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) >= 4), ast);
  let pms = [];
  let args = ast[2];
  let body = Array.prototype.slice.call(ast, 3);
  let mname = undefined;
  let mobj = undefined;
  let doc = undefined;
  let x = undefined;
  if (( (typeof (args) === "string") )) {
    (doc = args, args = ast[3], body = Array.prototype.slice.call(ast, 4));
  }
  (x = meta_QMRK__QMRK(args, env), args = x[1], mobj = x[0]);
  for (let ____coll = args, i = 0, ____end = kirbystdlibref.count(____coll), ____break = false; ((!____break) && (i < ____end)); i = (i + 1)) {
    let e = ____coll[i];
    let ev = [e].join("");
    if ( (ev == "&") ) {
      if ( (Array.isArray(args[(i + 1)])) ) {
        (
        e = args[(i + 1)]);
        ++i;
        for (let GS__67 = 0, GS__65 = true, GS__66 = e, ____sz = kirbystdlibref.count(GS__66), ____break = false; (!____break && GS__65 && (GS__67 < ____sz)); ++GS__67) {
          let x = GS__66[GS__67];
          if ( (!symbol_QMRK(x)) ) {
            error_BANG("syntax-error", ast);
          } else {
            null;
          }
          conj_BANG(pms, x);
        }
      } else {
        conj_BANG(pms, e, args[(i + 1)]);
        ++i;
      }
    } else {
      if ( (!symbol_QMRK(e)) ) {
        error_BANG("syntax-error", ast);
      } else {
        if (true) {
          conj_BANG(pms, e);
        }
      }
    }
  }
  (mname = ast[1], ast = [kirbystdlibref.symbol("macro*"), mname, pms, body[0]]);
  rt.addVar(mname, (new Map([["ns", std._STAR_ns_STAR()]])));
  if ( (!(mobj && ((kirbystdlibref.getProp(mobj, "private") === true)))) ) {
    (kirbystdlibref.assoc_BANG(_STAR_macros_STAR, mname, prn(ast, true)));
  } else {
    null;
  }
  rt.compute(ast, env);
  return "";
};
SPEC_DASH_OPS["defmacro"] = sf_DASH_macro;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-unary] in file: compiler.ky, line: 1493
//Special unary operators.
const sf_DASH_unary = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) === 2), ast);
  let GS__68 = ast;
  let a0 = kirbystdlibref.getIndex(GS__68, 0);
  let a1 = kirbystdlibref.getIndex(GS__68, 1);
  if ( (a0 == "not") ) {
    (
    a0 = kirbystdlibref.symbol("!"));
  }
  return node_QUOT(ast).add(["(", [tx_STAR(a0, env)].join(""), [tx_STAR(a1, env)].join(""), ")"]);
};
SPEC_DASH_OPS["not"] = sf_DASH_unary;
SPEC_DASH_OPS["!"] = sf_DASH_unary;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-listc] in file: compiler.ky, line: 1505
//List comprehension. Takes a vector of one or more
//binding-form/collection-expr pairs, each followed by zero or more
//modifiers, and yields a lazy sequence of evaluations of expr.
//Collections are iterated in a nested fashion, rightmost fastest,
//and nested coll-exprs can refer to bindings created in prior
//binding-forms.  Supported modifiers are: :let [binding-form expr ...],
//:while test, :when test.
const sf_DASH_listc = function(ast, env) {
  let cap = gensym();
  return wrap(node_QUOT(ast), ["(function() {\n", "let ", [cap].join(""), "=[];\n"], [sf_DASH_doseq(exprHint(ast, false), env, cap), "return ", [cap].join(""), ";\n}).call(this)"]);
};
SPEC_DASH_OPS["for"] = sf_DASH_listc;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-doseq] in file: compiler.ky, line: 1524
//Repeatedly executes body (presumably for side-effects) with
//bindings and filtering as provided by "for".  Does not retain
//the head of the sequence. Returns nil.
const sf_DASH_doseq = function(ast, env) {
  let GS__69 = Array.prototype.slice.call(arguments, 2);
  let capRes = kirbystdlibref.getIndex(GS__69, 0);
  let body = exprHint(xfi(ast, Array.prototype.slice.call(ast, 2)), false);
  let while_QUOT = gensym();
  let inner = "";
  let ret = undefined;
  let fst = true;
  let kount = slib_BANG(COUNT);
  let stmtQ = stmt_QMRK(ast);
  let args = ast[1];
  let _ = (((0 === kirbystdlibref.modulo(kirbystdlibref.count(args), 2))) ?
    true :
    (function() {
      throw new Error("bindings not even");
    }).call(this));
  let GS__70 = split_DASH_with(function() {
    let ____args = Array.prototype.slice.call(arguments);
    return (!keyword_QMRK(____args[0]));
  }, args);
  let x = kirbystdlibref.getIndex(GS__70, 0);
  let y = kirbystdlibref.getIndex(GS__70, 1);
  let arr = rseq(partition(2, x));
  (function() {
    let _x_ = null;
    let recur = null;
    let _f_ = function(p1, pn) {
      return (p1 ?
        (function() {
          let e_QUOT = gensym();
          let n_QUOT = gensym();
          (ret = node_QUOT(ast));
          ret.add(["for(let ", [n_QUOT].join(""), "=0,",((0 === kirbystdlibref.count(pn)) ?
            [[while_QUOT].join(""), "=true,"].join("") :
            ""), [e_QUOT].join(""), "=", tx_STAR(p1[1], env), ",", "____sz=", kount, "(", [e_QUOT].join(""), ")",(fst ?
            ",____break=false" :
            ""), "; (",(fst ?
            "!____break && " :
            ""), [while_QUOT].join(""), " && ", "(", [n_QUOT].join(""), " < ____sz)", "); ++", [n_QUOT].join(""), "){\n"]);
          ret.add(sf_DASH_var(xfi(ast, [kirbystdlibref.symbol("vars"), p1[0], [kirbystdlibref.symbol("nth"), e_QUOT, n_QUOT]]), env));
          if (fst) {
            (
            fst = false);
            doseq_DASH_binds(while_QUOT, ret, y, body, ast, env, capRes);
          } else {
            ret.add(inner);
          }
          ret.add("}\n");
          (
          inner = ret);
          return (not_DASH_empty(pn) ?
            recur(pn[0], pn.slice(1)) :
            null);
        }).call(this) :
        null);
    };
    let _r_ = _f_;
    (recur = function() {
      (
      _x_ = arguments);
      if (_r_) {
        for (_r_ = undefined; _r_ === undefined;) {
          _r_ = _f_.apply(this, _x_);
        }
        return _r_;
      }
      return undefined;
    });
    return recur(arr[0], arr.slice(1));
  })(this);
  if ( (!stmtQ) ) {
    wrap(ret, "(function() {\n", "; return null; }).call(this)");
  } else {
    null;
  }
  return ret;
};
SPEC_DASH_OPS["doseq"] = sf_DASH_doseq;
////////////////////////////////////////////////////////////////////////////////
//fn: [doseq-binds] in file: compiler.ky, line: 1575
const doseq_DASH_binds = function(while_QUOT, ret, binds, body, ast, env, capRes) {
  let patch = node_QUOT(ast);
  partition(2, binds).forEach(function(GS__71) {
    let k = kirbystdlibref.getIndex(GS__71, 0);
    let expr = kirbystdlibref.getIndex(GS__71, 1);
    return (function() {
      let GS__72 = k;
      return (("let" == GS__72) ?
        ret.add(sf_DASH_var(xfi(ast, cons(kirbystdlibref.symbol("vars"), expr)))) :
        (("when" == GS__72) ?
          (function() {
            ret.add(["if (", tx_STAR(expr, env), ") {\n"]);
            return patch.add("}\n");
          }).call(this) :
          (("while" == GS__72) ?
            (function() {
              ret.add(["if (!(", tx_STAR(expr, env), ")) { ", [while_QUOT].join(""), "=false; ____break=true; } else {\n"]);
              return patch.add("}\n");
            }).call(this) :
            null)));
    }).call(this);
  });
  if (capRes) {
    exprHint(body, true);
  }
  if (capRes) {
    ret.add([[capRes].join(""), ".push((function() {\n", txDo(body, env, true), "\n}).call(this));\n"]);
  } else {
    ret.add(txDo(body, env, false));
  }
  return ret.add(patch);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [xfi] in file: compiler.ky, line: 1595
//Transfer source map info
const xfi = function(from, to) {
  if ( (from && to && (!((typeof (to.line) === "number"))) && ((typeof (from.line) === "number"))) ) {
    (to["source"] = from.source, to["line"] = from.line, to["column"] = from.column);
  }
  return to;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [spitMacros] in file: compiler.ky, line: 1606
//Dump all macros to string.
const spitMacros = function() {
  return ((0 === kirbystdlibref.count(_STAR_macros_STAR)) ?
    "{}" :
    std.wrap_DASH_str((seq(_STAR_macros_STAR) || []).map(function(GS__73) {
      let k = kirbystdlibref.getIndex(GS__73, 0);
      let v = kirbystdlibref.getIndex(GS__73, 1);
      return [quote_DASH_str([k].join("")), ":", quote_DASH_str(v)].join("");
    }).join(",\n"), "{\n", "}\n"));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [spitVars] in file: compiler.ky, line: 1616
//Dump all public vars to string.
const spitVars = function() {
  return ((0 === kirbystdlibref.count(_STAR_vars_STAR)) ?
    "[]" :
    std.wrap_DASH_str((_STAR_vars_STAR || []).map(function() {
      let ____args = Array.prototype.slice.call(arguments);
      return quote_DASH_str([____args[0]].join(""));
    }).join(","), "[ ", "]"));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [spitExterns] in file: compiler.ky, line: 1622
//Write out export info
const spitExterns = function() {
  return ["\n\nmodule.exports = {\n", [EXPKEY, ": { ns: ", quote_DASH_str(std._STAR_ns_STAR()), ", vars: ", spitVars(), ", macros: ", spitMacros(), " }"].join(""),(not_DASH_empty(_STAR_vars_STAR) ?
    [",\n", (_STAR_vars_STAR || []).map(function() {
      let ____args = Array.prototype.slice.call(arguments);
      return [reader.jsid(____args[0]), ":", reader.jsid(____args[0])].join("");
    }).join(",\n")].join("") :
    null), "\n};\n"].join("");
};
////////////////////////////////////////////////////////////////////////////////
//fn: [banner] in file: compiler.ky, line: 1634
//Banner text for the target file
const banner = function() {
  let GS__74 = std.peekNSP();
  let id = kirbystdlibref.getProp(GS__74, "id");
  let meta = kirbystdlibref.getProp(GS__74, "meta");
  return ["/*", "Auto generated by Kirby v", MOD_DASH_VER, " - ", new Date(), "\n", "  ", id, "\n",(meta ?
    prn(meta, true) :
    ""), "\n", "*/\n\n"].join("");
};
////////////////////////////////////////////////////////////////////////////////
//fn: [cleanCode] in file: compiler.ky, line: 1640
//Get rid of empty lines or no-op lines
const cleanCode = function(code) {
  return ((code.split("\n") || []).map(function() {
    let ____args = Array.prototype.slice.call(arguments);
    return (function() {
      let GS__75 = ____args[0].trim();
      let s = GS__75;
      return ((kirbystdlibref.count(GS__75) > 0) ?
        ((s !== ";") ?
          ____args[0] :
          null) :
        null);
    }).call(this);
  }) || []).filter(function() {
    let ____args = Array.prototype.slice.call(arguments);
    return not_DASH_empty(____args[0]);
  }).join("\n");
};
////////////////////////////////////////////////////////////////////////////////
//fn: [transpile*] in file: compiler.ky, line: 1646
//Compiles a source file, returning the translated source and
//possible error object.
const transpile_STAR = function(source, fname, options) {
  let ret = txTree(reader.parse(source, fname), rt.genv());
  let GS__76 = options;
  let source_DASH_map = kirbystdlibref.getProp(GS__76, "source-map");
  let no_DASH_format = kirbystdlibref.getProp(GS__76, "no-format");
  let verbose = kirbystdlibref.getProp(GS__76, "verbose");
  let err = undefined;
  let GS__77 = ([".js", ".map"] || []).map(function() {
    let ____args = Array.prototype.slice.call(arguments);
    return [path.basename(fname, ".ky"), ____args[0]].join("");
  });
  let fmap = kirbystdlibref.getIndex(GS__77, 0);
  let smap = kirbystdlibref.getIndex(GS__77, 1);
  if (source_DASH_map) {
    let sout = ret.toStringWithSourceMap({
      "skipValidation": true,
      "file": fmap
    });
    (ret = sout.code);
    fs.writeFileSync(smap, sout.map);
  }
  (cstr = [ret, spitExterns(),(source_DASH_map ?
    ["\n//# sourceMappingURL=", path.relative(path.dirname(fname), smap)].join("") :
    null)].join(""));
  try {
    if ( (!no_DASH_format) ) {
      (
      cstr = esfmt.format(cstr, {}));
    } else {
      null;
    }
  } catch (e) {
    (
    err = e);
  }
  (cstr = cleanCode(cstr));
  return [((0 === kirbystdlibref.count(cstr)) ?
    "" :
    [banner(), cstr].join("")), err];
};
////////////////////////////////////////////////////////////////////////////////
//fn: [transpile] in file: compiler.ky, line: 1682
//Compile kirby file to target source
const transpile = function(code, file) {
  let GS__78 = Array.prototype.slice.call(arguments, 2);
  let options = kirbystdlibref.getIndex(GS__78, 0);
  return (function() {
    (_STAR_last_DASH_line_STAR = 0, _STAR_last_DASH_col_STAR = 0, _STAR_externs_STAR = (new Map([])), _STAR_macros_STAR = (new Map([])), _STAR_vars_STAR = std.into_BANG("vector", []));
    return (function() {
      try {
        return transpile_STAR(code, file, opt_QMRK__QMRK(options, {}));
      } catch (e) {
        return println("Error near line: ", _STAR_last_DASH_line_STAR, ", col: ", _STAR_last_DASH_col_STAR, "\n", [e].join(""));
      }
    }).call(this);
  })();
};
////////////////////////////////////////////////////////////////////////////////
//fn: [dbgAST] in file: compiler.ky, line: 1697
//Dump AST to xml
const dbgAST = function(source, fname) {
  return reader.dumpTree(reader.parse(source, fname), fname);
};
const version = MOD_DASH_VER;
module.exports = {
  da57bc0172fb42438a11e6e8778f36fb: {
    ns: "czlab.kirby.compiler",
    vars: ["tnodeEx", "tnode", "sf-juxt", "transpile", "dbgAST", "version"],
    macros: {}
  },
  tnodeEx: tnodeEx,
  tnode: tnode,
  sf_DASH_juxt: sf_DASH_juxt,
  transpile: transpile,
  dbgAST: dbgAST,
  version: version
};