/*Auto generated by Kirby v1.0.0 - Tue Dec 26 2017 18:32:24 GMT-0800 (PST)
  czlab.kirby.compiler
({ doc : 
author : Kenneth Leung
 })
*/

const smap = require("source-map");
const std = require("./stdlib");
const lambda_DASH_arg_QUERY = std["lambda_DASH_arg_QUERY"];
const hashmap = std["hashmap"];
const pairs_QUERY = std["pairs_QUERY"];
const into_BANG = std["into_BANG"];
const merge = std["merge"];
const contains_QUERY = std["contains_QUERY"];
const last = std["last"];
const typeid = std["typeid"];
const prn = std["prn"];
const primitive = std["primitive"];
const map_QUERY = std["map_QUERY"];
const vector_QUERY = std["vector_QUERY"];
const opt_QUERY__QUERY = std["opt_QUERY__QUERY"];
const some_QUERY = std["some_QUERY"];
const primitive_QUERY = std["primitive_QUERY"];
const not_DASH_empty = std["not_DASH_empty"];
const conj_BANG = std["conj_BANG"];
const list_QUERY = std["list_QUERY"];
const gensym = std["gensym"];
const count = std["count"];
const pop_BANG = std["pop_BANG"];
const slice = std["slice"];
const symbol = std["symbol"];
const keyword = std["keyword"];
const symbol_QUERY = std["symbol_QUERY"];
const keyword_QUERY = std["keyword_QUERY"];
const eng = require("./engine");
const parser = require("./parser");
const jsid = parser["jsid"];
const fs = require("fs");
const path = require("path");
const esfmt = require("esformatter");
const kirbystdlibref = std;
const ERRORS_DASH_MAP = {
  "no_DASH_sourcemap_DASH_info": "Expected source map info",
  "invalid_DASH_fargs": "Invalid function args",
  "invalid_DASH_catch": "Invalid catch clause",
  "invalid_DASH_try": "Invalid try clause",
  "invalid_DASH_include": "Invalid include clause",
  "invalid_DASH_require": "Invalid require clause",
  "invalid_DASH_namespace": "Invalid namespace clause",
  "destruct_DASH_args": "Bad destructure args",
  "outside_DASH_macro": "Invalid clause outside of macro",
  "file_DASH_access": "Failed file access",
  "file_DASH_read": "Failed file read",
  "file_DASH_open": "Failed to open file",
  "unknown_DASH_keyword": "Unknown keyword",
  "invalid_DASH_arity": "Invalid function arity",
  "invalid_DASH_meta": "Invalid meta data",
  "syntax_DASH_error": "Syntax error",
  "empty_DASH_form": "Invalid form (empty)"
};
const ARRSLICE = "Array.prototype.slice.call";
const JSARGS = "arguments";
const LARGS = "____args";
const BREAK = "____break";
const MOD_DASH_VER = "1.0.0";
var _STAR_externs_STAR = null;
var _STAR_ns_STAR = null;
var SPEC_DASH_OPS = {};
var MATH_DASH_OP_DASH_REGEX = /^[-+][0-9]+$/;
////////////////////////////////////////////////////////////////////////////////
//fn: [tnodeEx] in file: compiler.ky,line: 61
//Create a node
const tnodeEx = function(name) {
  let GS__8 = Array.prototype.slice.call(arguments, 1);
  let chunk = GS__8[0];
  return tnode(null, null, null, chunk, name);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [tnode] in file: compiler.ky,line: 65
//Create a token
//with source information
const tnode = function() {
  let GS__9 = Array.prototype.slice.call(arguments, 0);
  let source = GS__9[0];
  let line = GS__9[1];
  let col = GS__9[2];
  let chunk = GS__9[3];
  let name = GS__9[4];
  return new smap.SourceNode(opt_QUERY__QUERY(line, null), opt_QUERY__QUERY(col, null), opt_QUERY__QUERY(source, null), opt_QUERY__QUERY(chunk, null), opt_QUERY__QUERY(name, null));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [doFuncArgs] in file: compiler.ky,line: 75
//Deal with possible destructuring
//of args in function definition
const doFuncArgs = function(args, env) {
  let e,
    ev,
    rval,
    out;
  let pms = [];
  let ret = [
    node_QUOTE(args),
    node_QUOTE(args)
  ];
  let fargs = ret[0];
  let fdefs = ret[1];
  for (let i = 0, sz = kirbystdlibref.count(args), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
    e = args[i];
    if (symbol_QUERY(e)) {
      if ( (e == "&") ) {
        (rval = node_QUOTE(args), e = args[i + 1]);
        rval.add([
          ARRSLICE,
          "(",
          JSARGS,
          ",",
          [
            i
          ].join(""),
          ")"
        ]);
        if (symbol_QUERY(e)) {
          fdefs.add([
            "let ",
            tx_STAR(e, env),
            "=",
            rval,
            ";\n"
          ]);
        } else {
          (out = node_QUOTE(args), e = destruct_STAR(e, out, env));
          fdefs.add([
            "let ",
            tx_STAR(e, env),
            "=",
            rval,
            ";\n",
            out
          ]);
        }
        ____break = true;
      } else {
        if ( (e == "_") ) {
          e = xfi(e, gensym("U__"));
        }
        conj_BANG(pms, e);
      }
    } else {
      if ( (Array.isArray(e)) ) {
        (rval = node_QUOTE(args), out = node_QUOTE(args), e = destruct_STAR(e, out, env));
        rval.add([
          JSARGS,
          "[",
          [
            i
          ].join(""),
          "]"
        ]);
        conj_BANG(pms, e);
        fdefs.add(out);
      } else {
        if (true) {
          error_BANG("destruct_DASH_args", args);
        }
      }
    }
  }
  pms.forEach(function() {
    let ____args = Array.prototype.slice.call(arguments);
    return fargs.add(tx_STAR(____args[0], env));
  });
  fargs.join(",");
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [destruct*] in file: compiler.ky,line: 117
//Decide on what the
//rhs should be referred to 'as'
const destruct_STAR = function(coll, out, env) {
  let rhs = xfi(coll, gensym());
  let e = null;
  for (let i = 0, sz = kirbystdlibref.count(coll), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
    e = coll[i];
    if ( (keyword_QUERY(e) && (e == "as")) ) {
      rhs = std.keyword_DASH__GT_symbol(coll[i + 1]);
      ____break = true;
    }
  }
  if (map_QUERY(coll)) {
    out.add(destructMap(rhs, coll, env));
  } else {
    if (vector_QUERY(coll)) {
      out.add(destructVec(rhs, coll, env));
    } else {
      null;
    }
  }
  return rhs;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [destructVec] in file: compiler.ky,line: 136
const destructVec = function(src, coll, env) {
  let ret = node_QUOTE(coll);
  let as = tx_STAR(src, env);
  let e,
    rval,
    out;
  for (let i = 0, sz = kirbystdlibref.count(coll), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
    e = coll[i];
    if (symbol_QUERY(e)) {
      if ( (e == "_") ) {
        null;
      } else {
        if ( (e == "&") ) {
          (rval = node_QUOTE(coll), out = node_QUOTE(coll), e = coll[i + 1]);
          rval.add([
            ARRSLICE,
            "(",
            as,
            ",",
            [
              i
            ].join(""),
            ")"
          ]);
          if ( (!symbol_QUERY(e)) ) {
            e = destruct_STAR(e, out, env);
          } else {
            null;
          }
          ret.add([
            "let ",
            tx_STAR(e, env),
            "=",
            rval,
            ";\n",
            out
          ]);
          ____break = true;
        } else {
          if (true) {
            ret.add([
              "let ",
              tx_STAR(e, env),
              "=",
              as,
              "[",
              [
                i
              ].join(""),
              "];\n"
            ]);
          }
        }
      }
    } else {
      if ( (Array.isArray(e)) ) {
        (rval = node_QUOTE(coll), out = node_QUOTE(coll), e = destruct_STAR(e, out, env));
        rval.add([
          as,
          "[",
          [
            i
          ].join(""),
          "]"
        ]);
        ret.add([
          "let ",
          tx_STAR(e, env),
          "=",
          rval,
          ";\n",
          out
        ]);
      } else {
        if (keyword_QUERY(e)) {
          if ( (e == "as") ) {
            ++i;
          } else {
            error_BANG("unknown_DASH_keyword", coll);
          }
        } else {
          if (true) {
            error_BANG("syntax_DASH_error", coll);
          }
        }
      }
    }
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [destructMap] in file: compiler.ky,line: 177
const destructMap = function(src, coll, env) {
  let ret = node_QUOTE(coll);
  let as = tx_STAR(src, env);
  let e,
    arr;
  for (let i = 0, sz = kirbystdlibref.count(coll), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
    e = coll[i];
    if (keyword_QUERY(e)) {
      if ( ((e == "keys") || (e == "strs")) ) {
        arr = coll[i + 1];
        ++i;
        for (let j = 0, sz = kirbystdlibref.count(arr), ____break = false; ((!____break) && (j < sz)); j = (j + 1)) {
          e = arr[j];
          ret.add([
            "let ",
            tx_STAR(e, env),
            "=",
            as,
            "[\"",
            [
              e
            ].join(""),
            "\"];\n"
          ]);
        }
      } else {
        if (true) {
          error_BANG("unknown_DASH_keyword", coll);
        }
      }
    } else {
      if (true) {
        error_BANG("syntax_DASH_error", coll);
      }
    }
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [simple?] in file: compiler.ky,line: 203
const simple_QUERY = function(ast) {
  return (((typeof (ast) === "undefined")) || ((ast === null)) || ((typeof (ast) === "string")) || ((typeof (ast) === "number")) || ((typeof (ast) === "boolean")));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [wrap] in file: compiler.ky,line: 207
const wrap = function(ret, head, tail) {
  if (head) {
    ret.prepend(head);
  }
  if (tail) {
    ret.add(tail);
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [exprHint] in file: compiler.ky,line: 212
const exprHint = function(ast, flag) {
  if (simple_QUERY(ast)) {
    ast = primitive(ast);
  }
  ast["____expr"] = flag;
  return ast;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [stmt?] in file: compiler.ky,line: 216
const stmt_QUERY = function(ast) {
  if (simple_QUERY(ast)) {
    error_BANG("syntax_DASH_error", ast);
  }
  return ((ast.____expr === false));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [error!] in file: compiler.ky,line: 220
const error_BANG = function(e) {
  let GS__11 = Array.prototype.slice.call(arguments, 1);
  let ast = GS__11[0];
  let msg = GS__11[1];
  return (function() {
    throw new Error([
      kirbystdlibref.getProp(ERRORS_DASH_MAP, e),
      (msg ?
        [
          " : ",
          msg
        ].join("") :
        null),
      ((ast && ast.line) ?
        [
          "\nline: ",
          ast.line
        ].join("") :
        null),
      ((ast && ast.source) ?
        [
          "\nfile: ",
          ast.source
        ].join("") :
        null)
    ].join(""));
  }).call(this);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [testre?] in file: compiler.ky,line: 227
const testre_QUERY = function(re, x) {
  return (x ?
    re.test(x) :
    false);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [pad] in file: compiler.ky,line: 230
const pad = function(n) {
  return " ".repeat(n);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [node'] in file: compiler.ky,line: 233
const node_QUOTE = function(ast) {
  let GS__12 = Array.prototype.slice.call(arguments, 1);
  let obj = GS__12[0];
  obj = opt_QUERY__QUERY(obj, tnode());
  (obj["source"] = ast.source, obj["line"] = ast.line, obj["column"] = ast.column);
  return obj;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [txTree] in file: compiler.ky,line: 241
const txTree = function(root, env) {
  let ret = node_QUOTE(root);
  let GS__13 = root;
  for (let GS__15 = 0, GS__14 = false, ____break = false; ((!____break) && ((!GS__14) && (GS__15 < GS__13.length))); GS__15 = (GS__15 + 1)) {
    let r = kirbystdlibref.getProp(GS__13, GS__15);
    let t = tx_STAR(r, env);
    if ( (!true) ) {
      GS__14 = true;
    } else {
      null;
    }
    if ( ((!GS__14) && some_QUERY(t)) ) {
      ret.add([
        t,
        "\n"
      ]);
    }
  }
  null;
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [txForm] in file: compiler.ky,line: 248
const txForm = function(expr, env) {
  if ( (Array.isArray(expr)) ) {
    expr.forEach(function(a, i, arr) {
      return arr[i] = tx_STAR(a, env);
    });
  }
  return expr;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [txAtom] in file: compiler.ky,line: 254
//Returns a SourceNode or String
const txAtom = function(a) {
  let s = [
    a
  ].join("");
  return (lambda_DASH_arg_QUERY(a) ?
    [
      LARGS,
      "[",
      s,
      "]"
    ].join("") :
    (keyword_QUERY(a) ?
      node_QUOTE(a, tnodeEx(jsid(s), [
        "\"",
        jsid(s),
        "\""
      ].join(""))) :
      (symbol_QUERY(a) ?
        node_QUOTE(a, tnodeEx(jsid(s), jsid(s))) :
        (((a === null)) ?
          "null" :
          (primitive_QUERY(a) ?
            (function() {
              (a = a.value, s = [
                a
              ].join(""));
              return (((typeof (a) === "string")) ?
                std.quote_DASH_str(a) :
                (((a === null)) ?
                  "null" :
                  (true ?
                    s :
                    null)));
            }).call(this) :
            (((typeof (a) === "string")) ?
              std.quote_DASH_str(a) :
              (true ?
                jsid(s) :
                null)))))));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [tx*] in file: compiler.ky,line: 274
const tx_STAR = function(x) {
  let GS__16 = Array.prototype.slice.call(arguments, 1);
  let env = GS__16[0];
  return ((Array.isArray(x)) ?
    txPairs(x, env) :
    txAtom(x));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [gcmd] in file: compiler.ky,line: 278
const gcmd = function(ast) {
  return (map_QUERY(ast) ?
    "hashmap" :
    (vector_QUERY(ast) ?
      "vec" :
      (list_QUERY(ast) ?
        "list" :
        (((Array.isArray(ast)) && (!(Array.isArray(kirbystdlibref.getProp(ast, 0))))) ?
          [
            kirbystdlibref.getProp(ast, 0)
          ].join("") :
          (true ?
            "" :
            null)))));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [quoteSingle] in file: compiler.ky,line: 286
const quoteSingle = function(a) {
  return (keyword_QUERY(a) ?
    [
      maybeStripStdlib("kirbystdlibref.keyword"),
      "(\":",
      a,
      "\")"
    ].join("") :
    (symbol_QUERY(a) ?
      [
        maybeStripStdlib("kirbystdlibref.symbol"),
        "(\"",
        a,
        "\")"
      ].join("") :
      (primitive_QUERY(a) ?
        (function() {
          a = a.value;
          return (((typeof (a) === "string")) ?
            std.quote_DASH_str(a) :
            (((a === null)) ?
              "null" :
              (true ?
                [
                  a
                ].join("") :
                null)));
        }).call(this) :
        (((typeof (a) === "string")) ?
          std.quote_DASH_str(a) :
          (true ?
            [
              a
            ].join("") :
            null)))));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [quote!] in file: compiler.ky,line: 303
const quote_BANG = function(ast, env) {
  assertInfo(ast);
  return ((Array.isArray(ast)) ?
    (map_QUERY(ast) ?
      quoteMap(ast, env) :
      quoteBlock(ast, env)) :
    quoteSingle(ast));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [quoteMap] in file: compiler.ky,line: 312
const quoteMap = function(ast, env) {
  let comma = "";
  let ret = node_QUOTE(ast);
  for (let i = 0, sz = kirbystdlibref.count(ast), ____break = false; ((!____break) && (i < sz)); i = (i + 2)) {
    if ( (i > 0) ) {
      ret.add(",");
    }
    ret.add([
      quote_BANG(ast[i], env),
      " : ",
      quote_BANG(ast[i + 1], env)
    ]);
  }
  if ( (!(0 === kirbystdlibref.count(ast))) ) {
    comma = ",";
  } else {
    null;
  }
  return wrap(ret, [
    "[",
    "symbol(\"hashmap\")",
    comma
  ], "]");
};
////////////////////////////////////////////////////////////////////////////////
//fn: [quoteBlock] in file: compiler.ky,line: 324
const quoteBlock = function(ast, env) {
  let ret = node_QUOTE(ast);
  for (let i = 0, sz = kirbystdlibref.count(ast), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
    if ( (i > 0) ) {
      ret.add(",");
    }
    ret.add(quote_BANG(ast[i], env));
  }
  return wrap(ret, "[", "]");
};
////////////////////////////////////////////////////////////////////////////////
//fn: [spreadInfo] in file: compiler.ky,line: 333
const spreadInfo = function(from, to) {
  return ((from && (!simple_QUERY(from)) && ((typeof (from.line) === "number")) && (Array.isArray(to))) ?
    (function() {
      xfi(from, to);
      return (function() {
        for (let i = 0, sz = kirbystdlibref.count(to), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
          spreadInfo(from, to[i]);
        }
      }).call(this);
    }).call(this) :
    xfi(from, to));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [txPairs] in file: compiler.ky,line: 345
const txPairs = function(ast, env) {
  let nsp = eng.globalEnv().peekNSP();
  let stmtQ = stmt_QUERY(ast);
  let ret = node_QUOTE(ast);
  let cmd = gcmd(ast);
  let e1 = kirbystdlibref.getProp(ast, 0);
  let orig = ast;
  let op = null;
  let tmp = null;
  let mc = eng.getMacro(cmd);
  xfi(e1, ret);
  xfi(e1, ast);
  if (mc) {
    (ast = eng.expand_QUERY__QUERY(ast, env, mc), ast = xfi(orig, exprHint(ast, (!stmtQ))));
    spreadInfo(orig, ast);
    cmd = gcmd(ast);
  }
  if (parser.REGEX.int.test(cmd)) {
    if ( (!(cmd.startsWith("+") || cmd.startsWith("-"))) ) {
      cmd = [
        "+",
        cmd
      ].join("");
    } else {
      null;
    }
    (ast = xfi(ast, [
      symbol(cmd.charAt(0)),
      kirbystdlibref.getProp(ast, 1),
      parseInt(cmd.slice(1))
    ]), cmd = [
      kirbystdlibref.getProp(ast, 0)
    ].join(""));
  }
  op = kirbystdlibref.getProp(SPEC_DASH_OPS, cmd);
  if ( (cmd == "with-meta") ) {
    ret.add(tx_STAR(kirbystdlibref.getProp(meta_QUERY__QUERY(ast, env), 1), env));
  } else {
    if (cmd.startsWith(".-")) {
      ret.add([
        tx_STAR(kirbystdlibref.getProp(ast, 1), env),
        ".",
        tx_STAR(symbol(cmd.slice(2)), env)
      ]);
    } else {
      if (cmd.startsWith(".@")) {
        tmp = (cmd.startsWith(".@+") ?
          [
            3,
            true
          ] :
          [
            2,
            false
          ]);
        ret.add([
          tx_STAR(kirbystdlibref.getProp(ast, 1), env),
          "[",
          cmd.slice(kirbystdlibref.getProp(tmp, 0)),
          (kirbystdlibref.getProp(tmp, 1) ?
            "+1]" :
            "]")
        ]);
      } else {
        if (cmd.startsWith(".")) {
          ret.add([
            tx_STAR(kirbystdlibref.getProp(ast, 1), env),
            cmd,
            "("
          ]);
          for (let n = 2, sz = kirbystdlibref.count(ast), ____break = false; ((!____break) && (n < sz)); n = (n + 1)) {
            if ( (n !== 2) ) {
              ret.add(",");
            }
            ret.add(tx_STAR(ast[n], env));
          }
          ret.add(")");
        } else {
          if (some_QUERY(op)) {
            ret = op(ast, env);
          } else {
            if ( (((cmd == "splice-unquote") || (cmd == "unquote") || (cmd == "syntax-quote")) && (!nsp.id.startsWith("czlab.kirby."))) ) {
              error_BANG("outside_DASH_macro", ast);
            } else {
              if (true) {
                if (pairs_QUERY(ast)) {
                  txForm(ast, env);
                  cmd = [
                    kirbystdlibref.getProp(ast, 0)
                  ].join("");
                } else {
                  cmd = tx_STAR(ast, env);
                }
                if ( (!cmd) ) {
                  error_BANG("empty_DASH_form", ast);
                } else {
                  null;
                }
                cmd = maybeStripStdlib(cmd);
                if (pairs_QUERY(ast)) {
                  ret.add([
                    (testre_QUERY(parser.REGEX.func, cmd) ?
                      [
                        "(",
                        cmd,
                        ")"
                      ].join("") :
                      cmd),
                    "(",
                    ast.slice(1).join(","),
                    ")"
                  ]);
                } else {
                  ret.add(cmd);
                }
              }
            }
          }
        }
      }
    }
  }
  return node_QUOTE(ast, ret);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [writeDoc] in file: compiler.ky,line: 414
//Convert to jsdoc
const writeDoc = function(doc) {
  let out = [];
  if (doc) {
    std.unquote_DASH_str(doc).split("\n").forEach(function() {
      let ____args = Array.prototype.slice.call(arguments);
      return (function() {
        let s = [
          ____args[0]
        ].join("").trim();
        return (not_DASH_empty(s) ?
          conj_BANG(out, [
            "//",
            s,
            "\n"
          ].join("")) :
          null);
      }).call(this);
    });
  }
  return out;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [txDo] in file: compiler.ky,line: 423
const txDo = function(ast, env) {
  let GS__17 = Array.prototype.slice.call(arguments, 2);
  let return_QUERY = GS__17[0];
  let stmtQ = stmt_QUERY(ast);
  let ret = node_QUOTE(ast);
  let e = null;
  let end = (ast.length - 1);
  return_QUERY = (stmtQ ?
    false :
    opt_QUERY__QUERY(return_QUERY, true));
  for (let i = 0, ____break = false; ((!____break) && (i < end)); i = (i + 1)) {
    e = exprHint(ast[i], false);
    ret.add([
      tx_STAR(e, env),
      ";\n"
    ]);
  }
  if ( (end >= 0) ) {
    (e = exprHint(ast[end], (!stmtQ)), e = tx_STAR(e, env));
    ret.add(((!return_QUERY) ?
      [
        e,
        ";\n"
      ] :
      [
        "return ",
        e,
        ";\n"
      ]));
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [meta??] in file: compiler.ky,line: 441
const meta_QUERY__QUERY = function(obj, env) {
  let mobj = null;
  if ( ((Array.isArray(obj)) && (3 === kirbystdlibref.count(obj)) && ("with-meta" == [
      kirbystdlibref.getProp(obj, 0)
    ].join(""))) ) {
    mobj = evalMeta(obj[2], env);
    kirbystdlibref.getProp(obj, 1)["____meta"] = mobj;
    obj = kirbystdlibref.getProp(obj, 1);
  }
  return [
    mobj,
    obj
  ];
};
////////////////////////////////////////////////////////////////////////////////
//fn: [fmtRegoSpecOps] in file: compiler.ky,line: 453
const fmtRegoSpecOps = function(alias, fname) {
  return [
    parser.jsid("SPEC_DASH_OPS"),
    "[\"",
    alias,
    "\"] = ",
    fname
  ].join("");
};
////////////////////////////////////////////////////////////////////////////////
//fn: [fmtSpecOps] in file: compiler.ky,line: 457
const fmtSpecOps = function(fname, attrs) {
  let ks = (kirbystdlibref.getProp(attrs, "opcode") || []);
  let out = ks.map(function() {
    let ____args = Array.prototype.slice.call(arguments);
    return fmtRegoSpecOps([
      ____args[0]
    ].join(""), fname);
  }).join(";\n");
  return (not_DASH_empty(ks) ?
    [
      out,
      ";\n"
    ].join("") :
    out);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [writeFuncPre] in file: compiler.ky,line: 464
const writeFuncPre = function(pre, env) {
  let ret = node_QUOTE(pre);
  let c2 = [
    kirbystdlibref.symbol("if-not"),
    [
      kirbystdlibref.symbol("and")
    ].concat(pre),
    [
      kirbystdlibref.symbol("throw"),
      [
        kirbystdlibref.symbol("Error"),
        "Precondition failed"
      ]
    ]
  ];
  return ret.add([
    tx_STAR(exprHint(c2, false), env),
    ";\n"
  ]);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [writeFuncInfo] in file: compiler.ky,line: 471
const writeFuncInfo = function(fname, ast) {
  let file = (ast.source ?
    ast.source.slice((ast.source.lastIndexOf("/") + 1)) :
    "?");
  let s = [
    "//fn: [",
    fname,
    "] in file: ",
    file,
    ",line: ",
    (ast.line || "?"),
    "\n"
  ].join("");
  let len = s.length;
  if ( (len < 80) ) {
    len = 80;
  }
  return [
    "/".repeat(len),
    "\n",
    s
  ].join("");
};
var icache = [];
////////////////////////////////////////////////////////////////////////////////
//fn: [includeFile] in file: compiler.ky,line: 486
const includeFile = function(fname, ast) {
  return (contains_QUERY(icache, fname) ?
    node_QUOTE(ast) :
    (function() {
      let src = eng.slurp(fname);
      conj_BANG(icache, fname);
      return txTree(parser.parse(src, fname), eng.globalEnv());
    }).call(this));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [evalMeta] in file: compiler.ky,line: 494
const evalMeta = function(ast, env) {
  let x = ((Array.isArray(ast)) ?
    ast :
    (keyword_QUERY(ast) ?
      into_BANG("map", [
        ast,
        true
      ]) :
      (symbol_QUERY(ast) ?
        into_BANG("map", [
          keyword(":tag"),
          ast
        ]) :
        (true ?
          error_BANG("invalid_DASH_meta", ast) :
          null))));
  let v = eng.compute(x, env);
  return v;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [maybeStripStdlib] in file: compiler.ky,line: 509
const maybeStripStdlib = function(cmd) {
  let lib = "kirbystdlibref.";
  let nsp = eng.globalEnv().peekNSP();
  cmd = [
    cmd
  ].join("");
  return ((cmd.startsWith(lib) && (nsp.id === "czlab.kirby.stdlib")) ?
    cmd.slice(lib.length) :
    cmd);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [assertArity] in file: compiler.ky,line: 518
const assertArity = function(kond, ast) {
  if ( (!kond) ) {
    error_BANG("invalid_DASH_arity", ast);
  } else {
    null;
  }
  return assertInfo(ast);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [assertInfo] in file: compiler.ky,line: 523
const assertInfo = function(ast) {
  return ((false && ast && (!simple_QUERY(ast)) && (!((typeof (ast.line) === "number")))) ?
    error_BANG("no_DASH_sourcemap_DASH_info", ast) :
    null);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-juxt] in file: compiler.ky,line: 533
//Takes a set of functions and returns a fn that is the juxtaposition
//of those fns.  The returned fn takes a variable number of args, and
//returns a vector containing the result of applying each fn to the
//args (left-to-right).
//((juxt a b c) x) => [(a x) (b x) (c x)]
const sf_DASH_juxt = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) >= 2), ast);
  let ret = node_QUOTE(ast);
  ret.add([
    "function () {\n",
    "let ret=[],",
    LARGS,
    "=",
    ARRSLICE,
    "(",
    JSARGS,
    ");\n"
  ]);
  for (let i = 1, f = null, sz = kirbystdlibref.count(ast), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
    f = [
      gensym("F__")
    ].join("");
    ret.add([
      "let ",
      f,
      "=",
      tx_STAR(ast[i], env),
      ";\n",
      "ret.push(",
      f,
      ".apply(this,",
      LARGS,
      "));\n"
    ]);
  }
  return ret.add("return ret;\n}");
};
SPEC_DASH_OPS["juxt"] = sf_DASH_juxt;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-deref] in file: compiler.ky,line: 555
//Returns an atom's current state.
const sf_DASH_deref = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) === 2), ast);
  let ret = node_QUOTE(ast);
  return ret.add([
    tx_STAR(kirbystdlibref.getProp(ast, 1), env),
    ".value"
  ]);
};
SPEC_DASH_OPS["deref"] = sf_DASH_deref;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-compose] in file: compiler.ky,line: 566
//Takes a set of functions and returns a fn that is the composition
//of those fns.  The returned fn takes a variable number of args,
//applies the rightmost of fns to the args, the next
//fn (right-to-left) to the result, etc.
const sf_DASH_compose = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) >= 2), ast);
  let ret = node_QUOTE(ast);
  let end = (ast.length - 1);
  let f,
    r,
    prev;
  ret.add([
    "function () {\n"
  ]);
  ret.add([
    "let ",
    LARGS,
    "=",
    ARRSLICE,
    "(",
    JSARGS,
    ");\n"
  ]);
  for (let i = end, ____break = false; ((!____break) && (i > 0)); i = (i - 1)) {
    (f = [
      gensym("F__")
    ].join(""), r = [
      gensym("R__")
    ].join(""));
    ret.add([
      "let ",
      f,
      "=",
      tx_STAR(ast[i], env),
      ";\n"
    ]);
    if ( (i === end) ) {
      ret.add([
        "let ",
        r,
        "=",
        f,
        ".apply(this,",
        LARGS,
        ");\n"
      ]);
    } else {
      ret.add([
        "let ",
        r,
        "=",
        f,
        "(",
        prev,
        ");\n"
      ]);
    }
    prev = r;
  }
  return ret.add([
    "return ",
    prev,
    ";\n",
    "}"
  ]);
};
SPEC_DASH_OPS["comp"] = sf_DASH_compose;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-quote] in file: compiler.ky,line: 591
//Returns the unevaluated form
const sf_DASH_quote = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) === 2), ast);
  let ret = node_QUOTE(ast);
  return wrap(ret, null, quote_BANG(kirbystdlibref.getProp(ast, 1), env));
};
SPEC_DASH_OPS["quote"] = sf_DASH_quote;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-deftype] in file: compiler.ky,line: 599
//Define a JS Class
const sf_DASH_deftype = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) >= 4), ast);
  let ret = node_QUOTE(ast);
  let mtd,
    pos,
    n,
    m;
  let pub_QUERY = (![
      kirbystdlibref.getProp(ast, 0)
    ].join("").endsWith("-"));
  let czname = tx_STAR(kirbystdlibref.getProp(ast, 1), env);
  let par = kirbystdlibref.getProp(ast[2], 0);
  let czargs = ast[3];
  let GS__18 = (((typeof (ast[4]) === "string")) ?
    [
      ast[4],
      Array.prototype.slice.call(ast, 5)
    ] :
    [
      null,
      Array.prototype.slice.call(ast, 4)
    ]);
  let doc = GS__18[0];
  let mtds = GS__18[1];
  ret.add([
    "class ",
    czname
  ]);
  if (par) {
    ret.add([
      " extends ",
      tx_STAR(par, env)
    ]);
  }
  ret.add(" {\n");
  let GS__19 = mtds;
  for (let GS__21 = 0, GS__20 = false, ____break = false; ((!____break) && ((!GS__20) && (GS__21 < GS__19.length))); GS__21 = (GS__21 + 1)) {
    let m = kirbystdlibref.getProp(GS__19, GS__21);
    null;
    if ( (!true) ) {
      GS__20 = true;
    } else {
      null;
    }
    if ( ((!GS__20) && true) ) {
      (mtd = kirbystdlibref.symbol("method"), m1 = kirbystdlibref.getProp(m, 0), pos = (((typeof (kirbystdlibref.getProp(m, 1)) === "string")) ?
        3 :
        2));
      [
        mtd,
        m
      ].forEach(function() {
        let ____args = Array.prototype.slice.call(arguments);
        return xfi(m1, ____args[0]);
      });
      if ( (([
          m1
        ].join("") == "constructor") && not_DASH_empty(czargs)) ) {
        for (let x = 0, sz = kirbystdlibref.count(czargs), ____break = false; ((!____break) && (x < sz)); x = (x + 2)) {
          czargs[x] = [
            czargs[x]
          ].join("");
        }
        if (getPrePost(m[pos])) {
          ++pos;
        }
        m.splice(pos, 0, [
          kirbystdlibref.symbol("assoc!"),
          kirbystdlibref.symbol("this")
        ].concat(czargs));
      }
      m.unshift(mtd);
      ret.add([
        sf_DASH_func(m, env, false),
        "\n"
      ]);
    }
  }
  null;
  if (doc) {
    ret.prepend(writeDoc(doc));
  }
  if ( (pub_QUERY && ((eng.globalEnv().countNSPCache() === 1))) ) {
    _STAR_externs_STAR[czname] = czname;
  }
  return ret.add("}\n");
};
SPEC_DASH_OPS["deftype"] = sf_DASH_deftype;
SPEC_DASH_OPS["deftype-"] = sf_DASH_deftype;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-compOp] in file: compiler.ky,line: 646
//Handle comparison operators.
const sf_DASH_compOp = function(ast, env) {
  assertArity(((kirbystdlibref.count(ast) >= 3) && ((!((0 === kirbystdlibref.modulo(kirbystdlibref.count(ast), 2)))))), ast);
  let ret = node_QUOTE(ast);
  let a0 = kirbystdlibref.getProp(ast, 0);
  let cmd = [
    a0
  ].join("");
  if ( (cmd == "not=") ) {
    ast[0] = kirbystdlibref.symbol("!==");
  } else {
    if ( (cmd == "=") ) {
      ast[0] = kirbystdlibref.symbol("===");
    } else {
      null;
    }
  }
  a0 = kirbystdlibref.getProp(ast, 0);
  for (let i = 1, op = tx_STAR(a0, env), ____break = false; ((!____break) && (i < (ast.length - 1))); i = (i + 1)) {
    if ( (i !== 1) ) {
      ret.add(" && ");
    }
    ret.add([
      tx_STAR(ast[i], env),
      " ",
      op,
      " ",
      tx_STAR(ast[i + 1], env)
    ]);
  }
  return wrap(ret, "(", ")");
};
SPEC_DASH_OPS["not="] = sf_DASH_compOp;
SPEC_DASH_OPS["!="] = sf_DASH_compOp;
SPEC_DASH_OPS["=="] = sf_DASH_compOp;
SPEC_DASH_OPS["="] = sf_DASH_compOp;
SPEC_DASH_OPS[">"] = sf_DASH_compOp;
SPEC_DASH_OPS[">="] = sf_DASH_compOp;
SPEC_DASH_OPS["<"] = sf_DASH_compOp;
SPEC_DASH_OPS["<="] = sf_DASH_compOp;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-arithOp] in file: compiler.ky,line: 669
//Handles math operators
const sf_DASH_arithOp = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) >= 2), ast);
  let e1 = tx_STAR(kirbystdlibref.getProp(ast, 0), env);
  let ret = node_QUOTE(ast);
  let cmd = (function() {
    let C__22;
    switch ([
      e1
    ].join("")) {
      case "bitwise-zrshift":
        C__22 = ">>>";
        break;
      case "bitwise-rshift":
        C__22 = ">>";
        break;
      case "bitwise-lshift":
        C__22 = "<<";
        break;
      case "bitwise-and":
        C__22 = "&";
        break;
      case "bitwise-or":
        C__22 = "|";
        break;
      case "bitwise-not":
        C__22 = "~";
        break;
      case "bitwise-xor":
        C__22 = "^";
        break;
      case "rem":
        C__22 = "%";
        break;
      case "div":
        C__22 = "/";
        break;
      case "and":
        C__22 = "&&";
        break;
      case "or":
        C__22 = "||";
        break;
      case "exp":
        C__22 = "**";
        break;
      default:
        C__22 = [
          e1
        ].join("");
        break;
    }
    return C__22;
  }).call(this);
  if ( (("-" == cmd) && (2 === kirbystdlibref.count(ast))) ) {
    ret.add("-1 * ");
  }
  for (let i = 1, sz = kirbystdlibref.count(ast), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
    if ( (sz > 2) ) {
      if ( (i > 1) ) {
        ret.add(cmd);
      }
    }
    ret.add(tx_STAR(ast[i], env));
  }
  return wrap(ret, "(", ")");
};
SPEC_DASH_OPS["bitwise-lshift"] = sf_DASH_arithOp;
SPEC_DASH_OPS["bitwise-rshift"] = sf_DASH_arithOp;
SPEC_DASH_OPS["bitwise-zrshift"] = sf_DASH_arithOp;
SPEC_DASH_OPS["+"] = sf_DASH_arithOp;
SPEC_DASH_OPS["-"] = sf_DASH_arithOp;
SPEC_DASH_OPS["*"] = sf_DASH_arithOp;
SPEC_DASH_OPS["/"] = sf_DASH_arithOp;
SPEC_DASH_OPS["div"] = sf_DASH_arithOp;
SPEC_DASH_OPS["mod"] = sf_DASH_arithOp;
SPEC_DASH_OPS["or"] = sf_DASH_arithOp;
SPEC_DASH_OPS["and"] = sf_DASH_arithOp;
SPEC_DASH_OPS["exp"] = sf_DASH_arithOp;
SPEC_DASH_OPS["rem"] = sf_DASH_arithOp;
SPEC_DASH_OPS["bitwise-and"] = sf_DASH_arithOp;
SPEC_DASH_OPS["bitwise-or"] = sf_DASH_arithOp;
SPEC_DASH_OPS["bitwise-not"] = sf_DASH_arithOp;
SPEC_DASH_OPS["bitwise-xor"] = sf_DASH_arithOp;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-do] in file: compiler.ky,line: 706
//Evaluates the expressions in order and returns the value of the last. If no
//expressions are supplied, returns nil.
const sf_DASH_do = function(ast, env) {
  assertArity(true, ast);
  let ret = node_QUOTE(ast);
  let stmtQ = stmt_QUERY(ast);
  ret.add(txDo(exprHint(xfi(ast, ast.slice(1)), (!stmtQ)), env, (!stmtQ)));
  return (stmtQ ?
    wrap(ret, null, "") :
    wrap(ret, "(function() {\n", "}).call(this)"));
};
SPEC_DASH_OPS["do"] = sf_DASH_do;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-case] in file: compiler.ky,line: 724
//Takes an expression, and a set of clauses.
//Each clause can take the form of either:
//test-constant result-expr
//(test-constant1 ... test-constantN)  result-expr
//The test-constants are not evaluated. They must be compile-time
//literals, and need not be quoted.  If the expression is equal to a
//test-constant, the corresponding result-expr is returned. A single
//default expression can follow the clauses, and its value will be
//returned if no clause matches.
const sf_DASH_case = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) >= 4), ast);
  let stmtQ = stmt_QUERY(ast);
  let ret = node_QUOTE(ast);
  let tst = kirbystdlibref.getProp(ast, 1);
  let brk = ";\nbreak;\n";
  let gs = [
    gensym("C__")
  ].join("");
  let e,
    t,
    c,
    dft;
  if (( (!((0 === kirbystdlibref.modulo(kirbystdlibref.count(ast), 2)))) )) {
    dft = kirbystdlibref.getProp(pop_BANG(ast), 0);
  }
  for (let i = 2, sz = kirbystdlibref.count(ast), ____break = false; ((!____break) && (i < sz)); i = (i + 2)) {
    (e = ast[i], c = ast[i + 1], c = tx_STAR(c, env));
    if (pairs_QUERY(e)) {
      for (let j = 0, sz = kirbystdlibref.count(e), ____break = false; ((!____break) && (j < sz)); j = (j + 1)) {
        ret.add([
          "case ",
          tx_STAR(e[j], env),
          ":\n"
        ]);
        if ( (j === (e.length - 1)) ) {
          ret.add([
            gs,
            "=",
            c,
            brk
          ]);
        }
      }
    } else {
      ret.add([
        "case ",
        tx_STAR(e, env),
        ":\n",
        gs,
        "=",
        c,
        brk
      ]);
    }
  }
  if (dft) {
    ret.add([
      "default:\n",
      gs,
      "=",
      tx_STAR(dft, env),
      brk
    ]);
  }
  wrap(ret, [
    "switch (",
    tx_STAR(tst, env),
    ") {\n"
  ], "}");
  return (stmtQ ?
    wrap(ret, [
      "let ",
      gs,
      ";\n"
    ], "") :
    wrap(ret, [
      "(function() { let ",
      gs,
      ";\n"
    ], [
      "return ",
      gs,
      ";}).call(this)"
    ]));
};
SPEC_DASH_OPS["case"] = sf_DASH_case;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-vardefs] in file: compiler.ky,line: 773
//For JS style var defs with no rvalue, e.g. let x,y;
const sf_DASH_vardefs = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) >= 2), ast);
  let ret = node_QUOTE(ast);
  let cmd = [
    kirbystdlibref.getProp(ast, 0)
  ].join("");
  let keys = {};
  let pub_QUERY = (cmd == "def~");
  if (cmd.startsWith("def")) {
    cmd = "var";
  } else {
    cmd = "let";
  }
  for (let i = 1, s = null, sz = kirbystdlibref.count(ast), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
    s = tx_STAR(ast[i], env);
    keys[s] = null;
    if ( (i > 1) ) {
      ret.add(",");
    }
    ret.add(s);
  }
  if ( (pub_QUERY && ((eng.globalEnv().countNSPCache() === 1))) ) {
    let GS__23 = keys;
    Object.entries(GS__23).forEach(function(e) {
      return (function(v, k) {
        return _STAR_externs_STAR[k] = k;
      })(kirbystdlibref.getProp(e, 1), kirbystdlibref.getProp(e, 0));
    });
  }
  return wrap(ret, [
    cmd,
    " "
  ].join(""), ";\n");
};
SPEC_DASH_OPS["def~-"] = sf_DASH_vardefs;
SPEC_DASH_OPS["def~"] = sf_DASH_vardefs;
SPEC_DASH_OPS["var~"] = sf_DASH_vardefs;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-var] in file: compiler.ky,line: 797
//Creates a variable with an initial value
const sf_DASH_var = function(ast, env) {
  assertArity(((!((0 === kirbystdlibref.modulo(kirbystdlibref.count(ast), 2))))), ast);
  let ret = node_QUOTE(ast);
  let cmd = [
    kirbystdlibref.getProp(ast, 0)
  ].join("");
  let keys = [];
  let tmp = null;
  let vname = null;
  let pub_QUERY = ((cmd == "def") || (cmd == "const"));
  let rval,
    rc,
    lhs,
    rhs;
  cmd = (cmd.startsWith("const") ?
    "const" :
    ((cmd == "var") ?
      "let" :
      "var"));
  for (let i = 1, sz = kirbystdlibref.count(ast), ____break = false; ((!____break) && (i < sz)); i = (i + 2)) {
    (lhs = ast[i], rhs = ast[i + 1], rval = tx_STAR(rhs, env));
    if (symbol_QUERY(lhs)) {
      lhs = tx_STAR(lhs, env);
      conj_BANG(keys, lhs);
      ret.add([
        cmd,
        " ",
        lhs,
        "=",
        rval,
        ";\n"
      ]);
    } else {
      (out = node_QUOTE(ast), rhs = destruct_STAR(lhs, out, env));
      ret.add([
        "let ",
        tx_STAR(rhs, env),
        "=",
        rval,
        ";\n",
        out
      ]);
    }
  }
  if ( (pub_QUERY && ((eng.globalEnv().countNSPCache() === 1))) ) {
    keys.forEach(function() {
      let ____args = Array.prototype.slice.call(arguments);
      return _STAR_externs_STAR[____args[0]] = ____args[0];
    });
  }
  return ret;
};
SPEC_DASH_OPS["const-"] = sf_DASH_var;
SPEC_DASH_OPS["const"] = sf_DASH_var;
SPEC_DASH_OPS["def-"] = sf_DASH_var;
SPEC_DASH_OPS["def"] = sf_DASH_var;
SPEC_DASH_OPS["var"] = sf_DASH_var;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-inst?] in file: compiler.ky,line: 833
//Evaluates x and tests if it is an instance of the class
//c. Returns true or false.
//(inst? c x)
const sf_DASH_inst_QUERY = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) === 3), ast);
  return wrap(node_QUOTE(ast), null, [
    "(",
    tx_STAR(kirbystdlibref.getProp(ast, 2), env),
    " instanceof ",
    tx_STAR(kirbystdlibref.getProp(ast, 1), env),
    ")"
  ]);
};
SPEC_DASH_OPS["inst?"] = sf_DASH_inst_QUERY;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-delete] in file: compiler.ky,line: 846
//Delete an object or property of an object.
const sf_DASH_delete = function(ast, env) {
  assertArity(((kirbystdlibref.count(ast) >= 2) && (kirbystdlibref.count(ast) < 4)), ast);
  let ret = node_QUOTE(ast);
  ret.add([
    "delete ",
    tx_STAR(kirbystdlibref.getProp(ast, 1), env)
  ]);
  if ( (kirbystdlibref.count(ast) > 2) ) {
    ret.add([
      "[",
      tx_STAR(ast[2], env),
      "]"
    ]);
  }
  return ret;
};
SPEC_DASH_OPS["delete!"] = sf_DASH_delete;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-new] in file: compiler.ky,line: 861
//The args, if any, are evaluated from left to right,
//and passed to the constructor of the class
//named by Classname. The constructed object is returned.
//e.g.
//(new Error 'a' 3)
const sf_DASH_new = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) >= 2), ast);
  return wrap(node_QUOTE(ast), "new ", tx_STAR(xfi(ast, ast.slice(1)), env));
};
SPEC_DASH_OPS["new"] = sf_DASH_new;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-throw] in file: compiler.ky,line: 875
//Throw an exception
const sf_DASH_throw = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) === 2), ast);
  let ret = node_QUOTE(ast);
  let stmtQ = stmt_QUERY(ast);
  ret.add([
    "throw ",
    tx_STAR(xfi(ast, kirbystdlibref.getProp(ast, 1)), env)
  ]);
  if ( (!stmtQ) ) {
    wrap(ret, "(function (){ ", ";}).call(this)");
  } else {
    null;
  }
  return ret;
};
SPEC_DASH_OPS["throw"] = sf_DASH_throw;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-x-opop] in file: compiler.ky,line: 891
//Unary operator for increment & decrement
const sf_DASH_x_DASH_opop = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) === 2), ast);
  let ret = node_QUOTE(ast);
  let cmd = [
    kirbystdlibref.getProp(ast, 0)
  ].join("");
  let a2 = tx_STAR(kirbystdlibref.getProp(ast, 1), env);
  return ret.add((cmd.endsWith("$") ?
    [
      a2,
      cmd.slice(0, -1)
    ] :
    [
      cmd,
      a2
    ]));
};
SPEC_DASH_OPS["++"] = sf_DASH_x_DASH_opop;
SPEC_DASH_OPS["--"] = sf_DASH_x_DASH_opop;
SPEC_DASH_OPS["++$"] = sf_DASH_x_DASH_opop;
SPEC_DASH_OPS["--$"] = sf_DASH_x_DASH_opop;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-x-eq] in file: compiler.ky,line: 905
//Compound assignment operators
const sf_DASH_x_DASH_eq = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) === 3), ast);
  let cmd = (function() {
    let C__24;
    switch ([
      kirbystdlibref.getProp(ast, 0)
    ].join("")) {
      case "bitwise-zrshift=":
        C__24 = ">>>=";
        break;
      case "bitwise-rshift=":
        C__24 = ">>=";
        break;
      case "bitwise-lshift=":
        C__24 = "<<=";
        break;
      case "bitwise-xor=":
        C__24 = "^=";
        break;
      case "bitwise-or=":
        C__24 = "|=";
        break;
      case "bitwise-and=":
        C__24 = "&=";
        break;
      case "div=":
        C__24 = "/=";
        break;
      case "rem=":
        C__24 = "%=";
        break;
      case "exp=":
        C__24 = "**=";
        break;
      default:
        C__24 = [
          kirbystdlibref.getProp(ast, 0)
        ].join("");
        break;
    }
    return C__24;
  }).call(this);
  return wrap(node_QUOTE(ast), null, [
    tx_STAR(kirbystdlibref.getProp(ast, 1), env),
    " ",
    cmd,
    " ",
    tx_STAR(kirbystdlibref.getProp(ast, 2), env)
  ]);
};
SPEC_DASH_OPS["+="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS["-="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS["*="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS["div="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS["rem="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS["exp="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS["bitwise-and="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS["bitwise-or="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS["bitwise-xor="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS["bitwise-lshift="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS["bitwise-rshift="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS["bitwise-zrshift="] = sf_DASH_x_DASH_eq;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-setin!] in file: compiler.ky,line: 938
//Object property assignment or array index setter.
const sf_DASH_setin_BANG = function(ast, env) {
  assertArity(((0 === kirbystdlibref.modulo(kirbystdlibref.count(ast), 2))), ast);
  let ret = node_QUOTE(ast);
  let more = false;
  let obj = tx_STAR(kirbystdlibref.getProp(ast, 1), env);
  for (let i = 2, sz = kirbystdlibref.count(ast), ____break = false; ((!____break) && (i < sz)); i = (i + 2)) {
    if ( (i > 2) ) {
      ret.add(",");
      more = true;
    }
    ret.add([
      obj,
      "[",
      tx_STAR(xfi(ast, ast[i]), env),
      "]",
      "=",
      tx_STAR(xfi(ast, ast[i + 1]), env)
    ]);
  }
  if (more) {
    wrap(ret, "(", ")");
  }
  return ret;
};
SPEC_DASH_OPS["set-in!"] = sf_DASH_setin_BANG;
SPEC_DASH_OPS["assoc!"] = sf_DASH_setin_BANG;
SPEC_DASH_OPS["=>>"] = sf_DASH_setin_BANG;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-set] in file: compiler.ky,line: 958
//Set value(s) to variable(s).
//e.g. (set! a 2 b 4 ...)
const sf_DASH_set = function(ast, env) {
  assertArity(((!((0 === kirbystdlibref.modulo(kirbystdlibref.count(ast), 2))))), ast);
  let more = false;
  let ret = node_QUOTE(ast);
  for (let i = 1, sz = kirbystdlibref.count(ast), ____break = false; ((!____break) && (i < sz)); i = (i + 2)) {
    if ( (i > 1) ) {
      ret.add(",");
      more = true;
    }
    ret.add([
      tx_STAR(ast[i], env),
      "=",
      tx_STAR(xfi(ast, ast[i + 1]), env)
    ]);
  }
  if (more) {
    wrap(ret, "(", ")");
  }
  return ret;
};
SPEC_DASH_OPS["set!"] = sf_DASH_set;
SPEC_DASH_OPS["=>"] = sf_DASH_set;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-fn] in file: compiler.ky,line: 976
//Defines an anonymous function. See defn.
//(fn attrs? [x y] ...)
const sf_DASH_fn = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) >= 2), ast);
  let body = xfi(ast, Array.prototype.slice.call(ast, 2));
  let GS__25 = meta_QUERY__QUERY(kirbystdlibref.getProp(ast, 1), env);
  let args = GS__25[1];
  if ( (!(Array.isArray(args))) ) {
    error_BANG("invalid_DASH_fargs", ast);
  } else {
    null;
  }
  let fargs = doFuncArgs(xfi(ast, args), env);
  return wrap(node_QUOTE(ast), null, [
    "function (",
    kirbystdlibref.getProp(fargs, 0),
    ") {\n",
    kirbystdlibref.getProp(fargs, 1),
    txDo(body, env, true),
    "}"
  ]);
};
SPEC_DASH_OPS["fn"] = sf_DASH_fn;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-func] in file: compiler.ky,line: 995
//Defines a function. Use defn- to indicate privacy (no export).
//(defn name doc-string? attr-map? [params*] ...)
const sf_DASH_func = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) >= 2), ast);
  let pub_QUERY = (![
      kirbystdlibref.getProp(ast, 0)
    ].join("").endsWith("-"));
  let mtd_QUERY = ([
      kirbystdlibref.getProp(ast, 0)
    ].join("") == "method");
  let fname0 = [
    kirbystdlibref.getProp(ast, 1)
  ].join("");
  let fname = [
    tx_STAR(kirbystdlibref.getProp(ast, 1), env)
  ].join("");
  let dot_QUERY = contains_QUERY(fname, ".");
  let ret = node_QUOTE(ast, tnodeEx(fname));
  let GS__26 = (((typeof (kirbystdlibref.getProp(ast, 2)) === "string")) ?
    [
      kirbystdlibref.getProp(ast, 2),
      3
    ] :
    [
      null,
      2
    ]);
  let doc = GS__26[0];
  let pargs = GS__26[1];
  let body = xfi(ast, Array.prototype.slice.call(ast, (pargs + 1)));
  let b1 = kirbystdlibref.getProp(body, 0);
  let GS__27 = meta_QUERY__QUERY(kirbystdlibref.getProp(ast, pargs), env);
  let attrs = GS__27[0];
  let args = GS__27[1];
  if ( (!(Array.isArray(args))) ) {
    error_BANG("invalid_DASH_fargs", ast);
  } else {
    null;
  }
  let fargs = doFuncArgs(xfi(ast, args), env);
  let pre,
    post;
  attrs = (attrs || {});
  if (map_QUERY(b1)) {
    for (let i = 0, e = null, e2 = null, sz = kirbystdlibref.count(b1), ____break = false; ((!____break) && (i < sz)); i = (i + 2)) {
      (e = b1[i], e2 = b1[i + 1]);
      if ( (keyword_QUERY(e) && (Array.isArray(e2))) ) {
        if ( (e == "post") ) {
          post = e2;
        } else {
          if ( (e == "pre") ) {
            pre = e2;
          } else {
            null;
          }
        }
      }
    }
  }
  if (mtd_QUERY) {
    if (attrs.static) {
      ret.add("static ");
    }
    ret.add([
      fname,
      " ("
    ]);
    if ( (fname == "constructor") ) {
      conj_BANG(body, kirbystdlibref.symbol("this"));
    }
  } else {
    if (dot_QUERY) {
      ret.add([
        fname,
        " = function ("
      ]);
    } else {
      if (true) {
        ret.add([
          "const ",
          fname,
          " = function ("
        ]);
      }
    }
  }
  ret.add([
    kirbystdlibref.getProp(fargs, 0),
    ") {\n",
    kirbystdlibref.getProp(fargs, 1)
  ]);
  if ( (pre || post) ) {
    body = body.slice(1);
    ret.add(writeFuncPre(xfi(ast, pre), env));
  }
  ret.add([
    txDo(body, env, true),
    "};\n"
  ]);
  if (not_DASH_empty(attrs)) {
    ret.add(fmtSpecOps(fname, attrs));
  }
  if (doc) {
    ret.prepend(writeDoc(doc));
  }
  if ( (pub_QUERY && (!dot_QUERY) && (!mtd_QUERY) && ((eng.globalEnv().countNSPCache() === 1))) ) {
    _STAR_externs_STAR[fname] = fname;
  }
  return ret.prepend(writeFuncInfo(fname0, ast));
};
SPEC_DASH_OPS["defn"] = sf_DASH_func;
SPEC_DASH_OPS["defn-"] = sf_DASH_func;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-try] in file: compiler.ky,line: 1055
//The exprs are evaluated and, if no exceptions occur, the value of the last
//is returned. If an exception occurs and catch clauses are provided, each is
//examined in turn and the first for which the thrown exception is an instance
//of the named class is considered a matching catch clause. If there is a
//matching catch clause, its exprs are evaluated in a context in which name is
//bound to the thrown exception, and the value of the last is the return value
//of the function. If there is no matching catch clause, the exception
//propagates out of the function. Before returning, normally or abnormally,
//any finally exprs will be evaluated for their side effects.
const sf_DASH_try = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) >= 2), ast);
  let stmtQ = stmt_QUERY(ast);
  let sz = kirbystdlibref.count(ast);
  let ret = node_QUOTE(ast);
  let t,
    f,
    c;
  f = last(ast);
  if ( ((Array.isArray(f)) && ("finally" == [
      kirbystdlibref.getProp(f, 0)
    ].join(""))) ) {
    pop_BANG(ast);
    sz = kirbystdlibref.count(ast);
    xfi(kirbystdlibref.getProp(f, 0), f);
  } else {
    f = null;
  }
  c = null;
  if ( (sz > 1) ) {
    c = kirbystdlibref.getProp(ast, (sz - 1));
  }
  if ( ((Array.isArray(c)) && ("catch" == [
      kirbystdlibref.getProp(c, 0)
    ].join(""))) ) {
    if ( ((kirbystdlibref.count(c) < 2) || (!symbol_QUERY(kirbystdlibref.getProp(c, 1)))) ) {
      error_BANG("invalid_DASH_catch", ast);
    }
    pop_BANG(ast);
    xfi(kirbystdlibref.getProp(c, 0), c);
  } else {
    c = null;
  }
  if ( (((f === null)) && ((c === null))) ) {
    error_BANG("invalid_DASH_try", ast);
  }
  ret.add([
    "try {\n",
    txDo(exprHint(xfi(ast, ast.slice(1)), (!stmtQ)), env),
    "\n}"
  ]);
  if (c) {
    t = kirbystdlibref.getProp(c, 1);
    ret.add([
      [
        "catch (",
        tx_STAR(t, env),
        ") {\n"
      ].join(""),
      txDo(exprHint(xfi(c, Array.prototype.slice.call(c, 2)), (!stmtQ)), env),
      ";\n}\n"
    ]);
  }
  if (f) {
    ret.add([
      "finally {\n",
      txDo(exprHint(xfi(f, f.slice(1)), false), env, false),
      ";\n}\n"
    ]);
  }
  if ( (!stmtQ) ) {
    wrap(ret, "(function(){\n", "}).call(this)");
  } else {
    null;
  }
  return ret;
};
SPEC_DASH_OPS["try"] = sf_DASH_try;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-if] in file: compiler.ky,line: 1113
//Evaluates test. If truthy evaluates 'then' otherwise 'else'.
//(if test then else)
//(if test then)
const sf_DASH_if = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) >= 3), ast);
  let stmtQ = stmt_QUERY(ast);
  let ret = node_QUOTE(ast);
  let a1 = exprHint(xfi(ast, kirbystdlibref.getProp(ast, 1)), true);
  let a2 = exprHint(xfi(ast, kirbystdlibref.getProp(ast, 2)), (!stmtQ));
  let m_QUERY = (kirbystdlibref.count(ast) > 3);
  let a3 = (m_QUERY ?
    xfi(ast, ast[3]) :
    null);
  let elze = (m_QUERY ?
    exprHint(a3, (!stmtQ)) :
    null);
  (a1 = tx_STAR(a1, env), a2 = tx_STAR(a2, env), elze = tx_STAR(elze, env));
  return wrap(ret, null, (stmtQ ?
    [
      "if (",
      a1,
      ") {\n",
      a2,
      ";\n}",
      (m_QUERY ?
        [
          " else { \n",
          elze,
          ";\n}"
        ] :
        "")
    ] :
    [
      "(",
      a1,
      " ?\n",
      a2,
      " :\n",
      (elze || "null"),
      ")"
    ]));
};
SPEC_DASH_OPS["if"] = sf_DASH_if;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-get] in file: compiler.ky,line: 1142
//Returns the named property of an object,
//or value at the index of an array.
//(get obj "age")
//(nth obj 3)
const sf_DASH_get = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) === 3), ast);
  let cmd = maybeStripStdlib("kirbystdlibref.getProp");
  return wrap(node_QUOTE(ast), null, [
    cmd,
    "(",
    tx_STAR(xfi(ast, kirbystdlibref.getProp(ast, 1)), env),
    ",",
    tx_STAR(xfi(ast, kirbystdlibref.getProp(ast, 2)), env),
    ")"
  ]);
};
SPEC_DASH_OPS["nth"] = sf_DASH_get;
SPEC_DASH_OPS["get"] = sf_DASH_get;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-array] in file: compiler.ky,line: 1161
//Creates a new vector containing the args.
//(vec "hello" "world")
//(vec 1 2 3)
//[1 2 3]
//["hello" "world"]
const sf_DASH_array = function(ast, env) {
  assertArity(true, ast);
  let pos = 0;
  let ret = node_QUOTE(ast);
  return ((0 === kirbystdlibref.count(ast)) ?
    ret.add("[]") :
    (function() {
      if ( (!vector_QUERY(ast)) ) {
        pos = 1;
      } else {
        null;
      }
      ret.add("[\n");
      for (let i = pos, sz = kirbystdlibref.count(ast), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
        if ( (i > pos) ) {
          ret.add(",\n");
        }
        ret.add(tx_STAR(xfi(ast, ast[i]), env));
      }
      return ret.add("\n]");
    }).call(this));
};
SPEC_DASH_OPS["vec"] = sf_DASH_array;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-object] in file: compiler.ky,line: 1186
//Returns a new object with supplied key-mappings.
//(hashmap "a" 1 "b" 2)
//{:a 1 :b 2}
const sf_DASH_object = function(ast, env) {
  assertArity(true, ast);
  let pos = 0;
  let ret = node_QUOTE(ast);
  return ((0 === kirbystdlibref.count(ast)) ?
    ret.add("{}") :
    (function() {
      if ( (!map_QUERY(ast)) ) {
        pos = 1;
      } else {
        null;
      }
      ret.add("{\n");
      for (let i = pos, sz = kirbystdlibref.count(ast), ____break = false; ((!____break) && (i < sz)); i = (i + 2)) {
        if ( (i > pos) ) {
          ret.add(",\n");
        }
        ret.add([
          tx_STAR(ast[i], env),
          ": ",
          tx_STAR(xfi(ast, ast[i + 1]), env)
        ]);
      }
      return ret.add("\n}");
    }).call(this));
};
SPEC_DASH_OPS["hash-map"] = sf_DASH_object;
SPEC_DASH_OPS["hashmap"] = sf_DASH_object;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-include] in file: compiler.ky,line: 1210
//Include another kirby file.
//(:include ["./common.ky"])
//(:include ["./common.ky"]
//["./other.ky"])
const sf_DASH_include = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) >= 2), ast);
  let genv = eng.globalEnv();
  let ret = [];
  let dir = path.dirname(ast.source);
  let fpath,
    e;
  for (let i = 1, sz = kirbystdlibref.count(ast), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
    e = ast[i];
    if ( ((!(Array.isArray(e))) || (1 !== kirbystdlibref.count(e))) ) {
      error_BANG("invalid_DASH_include", ast);
    }
    fpath = [
      kirbystdlibref.getProp(e, 0)
    ].join("");
    if (fpath) {
      fpath = fpath.replace(/[\"]/g, "");
    }
    try {
      fpath = fs.realpathSync([
        dir,
        "/",
        fpath
      ].join(""));
    } catch (e) {
      error_BANG("file_DASH_access", ast);
    }
    try {
      conj_BANG(ret, includeFile(fpath, ast));
    } catch (e) {
      error_BANG("file_DASH_read", ast);
    }
    finally {
      genv.popNSP();
      _STAR_ns_STAR = genv.peekNSP().id;
    }
  }
  return ((0 === kirbystdlibref.count(ret)) ?
    "" :
    ret);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-require] in file: compiler.ky,line: 1250
//Loads libs.
//(:require ["z" :rename {hello goodbye}])
//(:require ["a" :as A])
//(:require ["b"]
//["c" :refer [hello world]])
const sf_DASH_require = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) >= 2), ast);
  let as,
    path,
    v,
    e,
    refers,
    renames;
  let ret = node_QUOTE(ast);
  for (let i = 1, sz = kirbystdlibref.count(ast), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
    (e = ast[i], as = [
      gensym("R__")
    ].join(""), refers = null, renames = null);
    if ( ((!(Array.isArray(e))) || (kirbystdlibref.count(e) < 3)) ) {
      error_BANG("invalid_DASH_require", ast);
    }
    path = [
      kirbystdlibref.getProp(e, 0)
    ].join("");
    for (let j = 1, sz = kirbystdlibref.count(e), ____break = false; ((!____break) && (j < sz)); j = (j + 1)) {
      v = e[j];
      if ( (v == "as") ) {
        as = [
          e[j + 1]
        ].join("");
        ++j;
      } else {
        if ( (v == "refer") ) {
          refers = e[j + 1];
          ++j;
        } else {
          if ( (v == "rename") ) {
            renames = e[j + 1];
            ++j;
          } else {
            null;
          }
        }
      }
    }
    ret.add([
      "const ",
      parser.jsid(as),
      "= require(",
      tx_STAR(path, env),
      ");\n"
    ]);
    for (let i = 0, sz = kirbystdlibref.count(refers), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
      v = tx_STAR(refers[i], env);
      ret.add([
        "const ",
        v,
        "=",
        as,
        "[\"",
        v,
        "\"];\n"
      ]);
    }
    for (let i = 0, sz = kirbystdlibref.count(renames), ____break = false; ((!____break) && (i < sz)); i = (i + 2)) {
      (e = tx_STAR(renames[i], env), v = tx_STAR(renames[i + 1], env));
      ret.add([
        "const ",
        v,
        "=",
        as,
        "[\"",
        e,
        "\"];\n"
      ]);
    }
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-ns] in file: compiler.ky,line: 1298
//(ns name doc-string? attr-map? references*)
//Creates a namespace, references can be zero or more of:
//(:require ...)
//(ns ^{:doc "some doc"} hello.world.core ...)
const sf_DASH_ns = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) >= 2), ast);
  let ret = [];
  let doc = null;
  let e = null;
  let mobj = null;
  let pos = 2;
  let GS__28 = meta_QUERY__QUERY(kirbystdlibref.getProp(ast, 1), env);
  let attrs = GS__28[0];
  let nsp = GS__28[1];
  if ( (!symbol_QUERY(nsp)) ) {
    error_BANG("invalid_DASH_namespace", ast);
  } else {
    null;
  }
  if (( (typeof (ast[pos]) === "string") )) {
    attrs = (attrs || {});
    attrs["doc"] = ast[pos];
    ++pos;
  }
  if (map_QUERY(ast[pos])) {
    (mobj = evalMeta(ast[pos], env), attrs = merge(attrs, mobj));
    ++pos;
    nsp["____meta"] = attrs;
  }
  eng.globalEnv().pushNSP([
    nsp
  ].join(""), attrs);
  _STAR_ns_STAR = [
    nsp
  ].join("");
  if (console) {
    console.log([
      [
        "Processing namespace: ",
        _STAR_ns_STAR
      ].join("")
    ].join(""));
  }
  ast = xfi(ast, Array.prototype.slice.call(ast, pos));
  for (let i = 0, sz = kirbystdlibref.count(ast), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
    e = ast[i];
    if ( (pairs_QUERY(e) && ("include" == [
        kirbystdlibref.getProp(e, 0)
      ].join(""))) ) {
      conj_BANG(ret, sf_DASH_include(xfi(ast, e)));
    } else {
      if ( (pairs_QUERY(e) && ("require" == [
          kirbystdlibref.getProp(e, 0)
        ].join(""))) ) {
        conj_BANG(ret, sf_DASH_require(xfi(ast, e)));
      } else {
        null;
      }
    }
  }
  nsp = eng.globalEnv().peekNSP();
  if ( ((nsp.id === "czlab.kirby.macros") || (nsp.id === "czlab.kirby.stdlib")) ) {
    null;
  } else {
    if (nsp.id.startsWith("czlab.kirby.")) {
      conj_BANG(ret, "const kirbystdlibref=std;\n");
    } else {
      if (true) {
        conj_BANG(ret, sf_DASH_require(xfi(ast, [kirbystdlibref.symbol("require"), ["kirby", kirbystdlibref.keyword(":as"), kirbystdlibref.symbol("kirbystdlibref")]])));
      }
    }
  }
  return ret;
};
SPEC_DASH_OPS["ns"] = sf_DASH_ns;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-comment] in file: compiler.ky,line: 1351
const sf_DASH_comment = function(ast, env) {
  return "";
};
SPEC_DASH_OPS["comment"] = sf_DASH_comment;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-for] in file: compiler.ky,line: 1354
//Generates native (js) for loop.
//(for [initial-vars :while test :recur update-vars] ...)
const sf_DASH_for = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) >= 2), ast);
  let stmtQ = stmt_QUERY(ast);
  let ret = node_QUOTE(ast);
  let body = exprHint(xfi(ast, Array.prototype.slice.call(ast, 2)), false);
  return ((0 === kirbystdlibref.count(body)) ?
    ret :
    sf_DASH_floop(ret, xfi(ast, kirbystdlibref.getProp(ast, 1)), body, env, stmtQ));
};
SPEC_DASH_OPS["for"] = sf_DASH_for;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-floop] in file: compiler.ky,line: 1374
//For loop implementation
const sf_DASH_floop = function(ret, args, body, env, stmtQ) {
  let vars = [];
  let recurs = [];
  let tst,
    nb,
    e;
  for (let i = 0, sz = kirbystdlibref.count(args), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
    e = args[i];
    if ( (e == "while") ) {
      tst = args[i + 1];
      ++i;
    } else {
      if ( (e == "recur") ) {
        recurs = Array.prototype.slice.call(args, (i + 1));
        ____break = true;
      } else {
        if (symbol_QUERY(e)) {
          conj_BANG(vars, e, args[i + 1]);
          ++i;
        } else {
          null;
        }
      }
    }
  }
  ret.add("for (");
  for (let i = 0, sz = kirbystdlibref.count(vars), ____break = false; ((!____break) && (i < sz)); i = (i + 2)) {
    if ( (i === 0) ) {
      ret.add("let ");
    }
    if ( (i !== 0) ) {
      ret.add(",");
    }
    ret.add([
      tx_STAR(vars[i], env),
      "=",
      [
        tx_STAR(vars[i + 1], env)
      ].join("")
    ]);
  }
  ret.add(((0 === kirbystdlibref.count(vars)) ?
    [
      "let ",
      BREAK,
      "=false;"
    ].join("") :
    [
      ",",
      BREAK,
      "=false;"
    ].join("")));
  nb = [kirbystdlibref.symbol("not"), kirbystdlibref.symbol("____break")];
  xfi(ret, nb);
  if (tst) {
    tst = [
      kirbystdlibref.symbol("and"),
      nb,
      tst
    ];
  } else {
    tst = nb;
  }
  xfi(ret, tst);
  ret.add([
    [
      tx_STAR(tst, env)
    ].join(""),
    "; "
  ]);
  for (let i = 0, k = 0, sz = kirbystdlibref.count(recurs), ____break = false; ((!____break) && (i < sz)); i = (i + 1), k = (k + 2)) {
    if ( (i !== 0) ) {
      ret.add(",");
    }
    ret.add([
      tx_STAR(vars[k], env),
      "=",
      [
        tx_STAR(recurs[i], env)
      ].join("")
    ]);
  }
  ret.add([
    "){\n",
    txDo(body, env, false),
    "}\n"
  ]);
  if ( (!stmtQ) ) {
    wrap(ret, "(function() {\n", "}).call(this)");
  } else {
    null;
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-jscode] in file: compiler.ky,line: 1418
//Inject raw native (js) code fragment.
//(js# "console.log('hi');")
const sf_DASH_jscode = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) >= 2), ast);
  let s = [
    kirbystdlibref.getProp(ast, 1)
  ].join("");
  let name = parser.jsid("sf-jscode");
  return node_QUOTE(ast, tnodeEx(name, ((s.endsWith("\"") && s.startsWith("\"")) ?
    s.slice(1, -1) :
    s)));
};
SPEC_DASH_OPS["js#"] = sf_DASH_jscode;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-macro] in file: compiler.ky,line: 1435
//Like defn, but the resulting function name is declared as a
//macro and will be used as a macro by the compiler when it is
//called.
//(defmacro macro-name [args] ...)
const sf_DASH_macro = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) >= 4), ast);
  let pms = [];
  let args = kirbystdlibref.getProp(ast, 2);
  let body = Array.prototype.slice.call(ast, 3);
  let doc,
    x,
    e,
    ev;
  if (( (typeof (args) === "string") )) {
    (doc = args, args = ast[3], body = Array.prototype.slice.call(ast, 4));
  }
  for (let i = 0, sz = kirbystdlibref.count(args), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
    (e = args[i], ev = [
      e
    ].join(""));
    if ( (ev === "&") ) {
      if ( (Array.isArray(args[i + 1])) ) {
        e = args[i + 1];
        ++i;
        for (let j = 0, sz = kirbystdlibref.count(e), ____break = false; ((!____break) && (j < sz)); j = (j + 1)) {
          x = e[j];
          if ( (!symbol_QUERY(x)) ) {
            error_BANG("syntax_DASH_error", ast);
          } else {
            null;
          }
          conj_BANG(pms, x);
        }
      } else {
        conj_BANG(pms, e, args[i + 1]);
        ++i;
      }
    } else {
      if ( (!symbol_QUERY(e)) ) {
        error_BANG("syntax_DASH_error", ast);
      } else {
        if (true) {
          conj_BANG(pms, e);
        }
      }
    }
  }
  eng.compute([
    kirbystdlibref.symbol("macro*"),
    kirbystdlibref.getProp(ast, 1),
    pms,
    kirbystdlibref.getProp(body, 0)
  ], env);
  return "";
};
SPEC_DASH_OPS["defmacro"] = sf_DASH_macro;
////////////////////////////////////////////////////////////////////////////////
//fn: [sf-unary] in file: compiler.ky,line: 1474
//Special unary operators.
const sf_DASH_unary = function(ast, env) {
  assertArity((kirbystdlibref.count(ast) === 2), ast);
  let GS__29 = ast;
  let a0 = GS__29[0];
  let a1 = GS__29[1];
  let ret = node_QUOTE(ast);
  if ( (a0 == "not") ) {
    a0 = kirbystdlibref.symbol("!");
  }
  return ret.add([
    "(",
    [
      tx_STAR(a0, env)
    ].join(""),
    [
      tx_STAR(a1, env)
    ].join(""),
    ")"
  ]);
};
SPEC_DASH_OPS["not"] = sf_DASH_unary;
SPEC_DASH_OPS["~"] = sf_DASH_unary;
SPEC_DASH_OPS["!"] = sf_DASH_unary;
////////////////////////////////////////////////////////////////////////////////
//fn: [getPrePost] in file: compiler.ky,line: 1487
const getPrePost = function(obj) {
  let ret = null;
  if (map_QUERY(obj)) {
    for (let i = 0, e = null, e2 = null, sz = kirbystdlibref.count(obj), ____break = false; ((!____break) && (i < sz)); i = (i + 2)) {
      (e = obj[i], e2 = obj[i + 1]);
      if ( (keyword_QUERY(e) && (Array.isArray(e2))) ) {
        if ( ("post" == e) ) {
          ret = merge(ret, {
            "post": e2
          });
        } else {
          if ( ("pre" == e) ) {
            ret = merge(ret, {
              "pre": e2
            });
          } else {
            null;
          }
        }
      }
    }
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [xfi] in file: compiler.ky,line: 1503
//Transfer source map info
const xfi = function(from, to) {
  return ((from && to) ?
    (function() {
      let tline = to.line;
      let fline = from.line;
      if ( ((!((typeof (tline) === "number"))) && ((typeof (fline) === "number"))) ) {
        (to["source"] = from.source, to["line"] = from.line, to["column"] = from.column);
      }
      return to;
    }).call(this) :
    (true ?
      to :
      null));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [spitExterns] in file: compiler.ky,line: 1517
//Write out export info
const spitExterns = function() {
  let s = "";
  let ks = Object.keys(_STAR_externs_STAR);
  if (not_DASH_empty(ks)) {
    (s = ks.map(function() {
      let ____args = Array.prototype.slice.call(arguments);
      return [
        ____args[0],
        ": ",
        ____args[0]
      ].join("");
    }).join(",\n"), s = [
      "\n\nmodule.exports = {\n",
      s,
      "\n};\n\n"
    ].join(""));
  }
  return s;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [banner] in file: compiler.ky,line: 1524
//Banner text for the target file
const banner = function() {
  let GS__30 = eng.globalEnv().firstNSP();
  let id = GS__30["id"];
  let meta = GS__30["meta"];
  return [
    "/*",
    "Auto generated by Kirby v",
    MOD_DASH_VER,
    " - ",
    new Date(),
    "\n",
    "  ",
    id,
    "\n",
    (meta ?
      std.prn(meta) :
      ""),
    "\n",
    "*/\n\n"
  ].join("");
};
////////////////////////////////////////////////////////////////////////////////
//fn: [cleanCode] in file: compiler.ky,line: 1533
const cleanCode = function(code) {
  let tmp = null;
  let arr = [];
  let GS__31 = code.split("\n");
  for (let GS__33 = 0, GS__32 = false, ____break = false; ((!____break) && ((!GS__32) && (GS__33 < GS__31.length))); GS__33 = (GS__33 + 1)) {
    let s = kirbystdlibref.getProp(GS__31, GS__33);
    let tmp = s.trim();
    if ( (!true) ) {
      GS__32 = true;
    } else {
      null;
    }
    if ( ((!GS__32) && true) ) {
      if ( (not_DASH_empty(tmp) && (tmp !== ";")) ) {
        conj_BANG(arr, s);
      }
    }
  }
  null;
  return arr.join("\n");
};
////////////////////////////////////////////////////////////////////////////////
//fn: [transpile*] in file: compiler.ky,line: 1542
//Compiles a source file, returning the translated source and
//possible error object.
const transpile_STAR = function(source, fname, options) {
  eng.globalEnv().resetNSPCache();
  (_STAR_externs_STAR = {}, _STAR_ns_STAR = null);
  let ret = txTree(parser.parse(source, fname), eng.globalEnv());
  let GS__34 = options;
  let source_DASH_map = GS__34["source-map"];
  let format = GS__34["format"];
  let fbase = path.basename(fname, ".ky");
  let extra = spitExterns();
  let fopts = {};
  let err = null;
  let cstr = (source_DASH_map ?
    (function() {
      let fmap = [
        fbase,
        ".js"
      ].join("");
      let smap = [
        fbase,
        ".map"
      ].join("");
      let sout = ret.toStringWithSourceMap({
        "skipValidation": true,
        "file": fmap
      });
      fs.writeFileSync(smap, sout.map);
      return [
        sout.code,
        extra,
        "\n//# sourceMappingURL=",
        path.relative(path.dirname(fname), smap)
      ].join("");
    }).call(this) :
    [
      ret,
      extra
    ].join(""));
  try {
    if (format) {
      cstr = esfmt.format(cstr, fopts);
    }
  } catch (e) {
    err = e;
  }
  cstr = cleanCode(cstr);
  return [
    ((0 === kirbystdlibref.count(cstr)) ?
      "" :
      [
        banner(),
        cstr
      ].join("")),
    err
  ];
};
////////////////////////////////////////////////////////////////////////////////
//fn: [transpile] in file: compiler.ky,line: 1579
//Compile kirby file to target source
const transpile = function(code, file) {
  let GS__35 = Array.prototype.slice.call(arguments, 2);
  let options = GS__35[0];
  return (function() {
    try {
      return transpile_STAR(code, file, opt_QUERY__QUERY(options, {}));
    } catch (e) {
      if (console) {
        console.log([
          e.stack
        ].join(""));
      }
      return (function() {
        throw e;
      }).call(this);
    }
  }).call(this);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [dbgAST] in file: compiler.ky,line: 1589
//Dump AST to xml
const dbgAST = function(source, fname) {
  return parser.dumpTree(parser.parse(source, fname), fname);
};
const version = MOD_DASH_VER;
module.exports = {
  tnodeEx: tnodeEx,
  tnode: tnode,
  sf_DASH_juxt: sf_DASH_juxt,
  transpile: transpile,
  dbgAST: dbgAST,
  version: version
};