/*Auto generated by Kirby - v1.0.0 */

var _STARpath_STAR= require("path");
var _STARfs_STAR= require("fs");
var _STARprocess_STAR = process;
require.extensions[".kirby"] = function (module,fname) {
  let kb = require("kirby"),
    code = _STARfs_STAR.readFileSync(fname,"utf8");
  return module._compile(kb.transpile(code,_STARpath_STAR.relative(_STARprocess_STAR.cwd(),fname)),fname);
};
function some_QUERY(obj) {
  return (!((typeof(obj) === "undefined") || (Object.prototype.toString.call(obj) === "[object Null]")));
}

function nichts_QUERY(obj) {
  return (!some_QUERY(obj));
}

function zero_QUERY(obj) {
  return ((typeof(obj) === "number") ?
    (0 == obj) :
    false);
}

function get_QUERY_QUERY(obj,fld,dft) {
  let x = (obj ?
    obj[fld] :
    undefined);
  return ((typeof(x) === "undefined") ?
    dft :
    x);
}

function contains_QUERY(coll,itm) {
  return (((Object.prototype.toString.call(coll) === "[object Array]") || (typeof(coll) === "string")) ?
    coll.includes(itm) :
    ((Object.prototype.toString.call(coll) === "[object Object]") ?
      Object.keys(coll).includes(itm) :
      (true ?
        false :
        undefined)));
}

function excludes_QUERY(coll,itm) {
  return (!contains_QUERY(coll,itm));
}

function make_array(len,obj) {
  return   (function() {
  let ret = [];
  return   (function() {
  (function () {
for (var i = 0; (i < len); i = (i + 1)) {
        (function() {
    return ret.push(obj);
    }).call(this);
  }
}).call(this);
  return ret;
  }).call(this);
  }).call(this);
}

function each_key(func,obj) {
  return Object.keys(obj).forEach(function (k) {
    return func(obj[k],k,obj);
  });
}

function zipmap(keys,vals) {
  let vs = (vals || []);
  return   (function() {
  let ret = {};
  return   (function() {
  (function () {
for (var i = 0; (i < (keys)["length"]); i = (i + 1)) {
        (function() {
    vv = nth(vs,i);
    return ret[nth(keys,i)] = ((typeof(vv) === "undefined") ?
      null :
      vv);
    }).call(this);
  }
}).call(this);
  return ret;
  }).call(this);
  }).call(this);
}

function last(coll) {
  return (coll ?
    coll[((coll)["length"] - 1)] :
    undefined);
}

function nth(coll,pos) {
  return (coll ?
    coll[pos] :
    undefined);
}

function even_QUERY(n) {
  return ((n % 2) === 0);
}

function odd_QUERY(n) {
  return (!even_QUERY(n));
}

function pos_QUERY(arg) {
  return ((typeof(arg) === "number") && (arg > 0));
}

function neg_QUERY(arg) {
  return ((typeof(arg) === "number") && (arg < 0));
}

function constantly(x) {
  return function () {
    return x;
  };
}

function identity(x) {
  return x;
}

function conj_BANG(c,a) {
  c.push(a);
  return c;
}

function conj_BANG_BANG(c,a) {
  (a ?
    c.push(a) :
    undefined);
  return c;
}

function not_empty(x) {
  return ((x && ((x)["length"] > 0)) ?
    x :
    null);
}

function empty_QUERY(x) {
  return (x ?
    (0 == (x)["length"]) :
    true);
}

function seq(x) {
  return ((typeof(x) === "string") ?
    Array.from(x) :
    ((Object.prototype.toString.call(x) === "[object Array]") ?
      x :
      ((Object.prototype.toString.call(x) === "[object Object]") ?
        Object.entries(x) :
        (true ?
          [] :
          undefined))));
}

var _STARsmap_STAR= require("source-map");
var _STARpath_STAR= require("path");
var _STARfs_STAR= require("fs");
var TreeNode = (_STARsmap_STAR)["SourceNode"];
var REGEX = {
  "noret": new RegExp("^def\\b|^var\\b|^set!\\b|^throw\\b"),
  "id": new RegExp("^[a-zA-Z_$][?\\-*!0-9a-zA-Z_$]*$"),
  "id2": new RegExp("^[*\\-][?\\-*!0-9a-zA-Z_$]+$"),
  "float": new RegExp("^[-+]?[0-9]+\\.[0-9]+$"),
  "int": new RegExp("^[-+]?[0-9]+$"),
  "hex": new RegExp("^[-+]?0x"),
  "macroGet": new RegExp("^#slice@(\\d+)"),
  "dquoteHat": new RegExp("^\""),
  "dquoteEnd": new RegExp("\"$"),
  "func": new RegExp("^function\\b"),
  "query": new RegExp("\\?","g"),
  "bang": new RegExp("!","g"),
  "dash": new RegExp("-","g"),
  "star": new RegExp("\\*","g"),
  "wspace": new RegExp("\\s")
};
var _STARreserved_STAR = {
  "compare": [
    "!=",
    "==",
    "=",
    ">",
    ">=",
    "<",
    "<="
  ],
  "arith": [
    "+",
    "-",
    "*",
    "/",
    "%"
  ],
  "logic": [
    "||",
    "&&"
  ],
  "bitwise": [
    "^",
    "&",
    "|",
    "<<",
    ">>",
    ">>>"
  ],
  "incdec": [
    "++",
    "--"
  ],
  "unary": [
    "~",
    "!"
  ],
  "assign": [
    "+=",
    "-=",
    "*=",
    "/=",
    "%=",
    "<<=",
    ">>=",
    ">>>=",
    "&=",
    "|=",
    "^="
  ],
  "builtin": [
    "quote",
    "syntax-quote",
    "quasi-quote",
    "unquote",
    "unquote-splice",
    "repeat-n",
    "do",
    "doto",
    "case",
    "range",
    "def-",
    "def",
    "var",
    "new",
    "throw",
    "while",
    "aset",
    "set!",
    "fn",
    "defn-",
    "defn",
    "try",
    "if",
    "get",
    "aget",
    "str",
    "list",
    "[",
    "vec",
    "{",
    "hash-map",
    "ns",
    "comment",
    "for",
    "cons",
    "js#",
    "defmacro"
  ]
};
var _STARreserved_keys_STAR = zipmap(Object.values(_STARreserved_STAR).reduce(function (acc,x) {
  return acc.concat(x);
},[]),[]);
var tkn_string = "STRING";
var tkn_number = "NUMBER";
var tkn_symbol = "SYMBOL";
var tkn_ident = "IDENT";
var tkn_atom = "ATOM";
var tkn_hat = "HAT";
var tkn_meta = "HAT-META";
var tkn_ns = "NS";
var tkn_quote = "QUOTE";
var tkn_back_tick = "BACKTICK";
var tkn_list = "LIST";
var tkn_tree = "TREE";
var tkn_map = "MAP";
var tkn_vector = "VECTOR";
var tkn_array = "ARRAY";
var tkn_object = "OBJECT";
function nodeTag(obj,src,line,col,type) {
  (obj ?
        (function() {
    obj["source"] = src;
    obj["column"] = col;
    obj["line"] = line;
    obj["isMeta"] = false;
    return obj["eTYPE"] = type;
    }).call(this) :
    undefined);
  return obj;
}

function testid_QUERY(name) {
  return (REGEX.id.test(name) || REGEX.id2.test(name));
}

function normalizeId(name) {
  let pfx = "";
  (((typeof(name) === "string") && ("-" === name.charAt(0))) ?
        (function() {
    pfx = "-";
    return name = name.slice(1);
    }).call(this) :
    undefined);
  return (testid_QUERY(name) ?
    [pfx,name].join("").replace(REGEX.query,"_QUERY").replace(REGEX.bang,"_BANG").replace(REGEX.dash,"_").replace(REGEX.star,"_STAR") :
    ((pfx === "") ?
      name :
      [pfx,name].join("")));
}

function tnodeString() {
  let me = this;
  return   (function() {
  let s = "";
  return   (function() {
  me.walk(function (chunk,hint) {
    (((hint.name === chunk) && (typeof(chunk) === "string")) ?
      chunk = normalizeId(chunk) :
      undefined);
    return s += chunk;
  });
  return s;
  }).call(this);
  }).call(this);
}

function tnode(source,line,col,chunk,name,type) {
  let args_QUERY = ((arguments)["length"] > 0);
  return   (function() {
  let n = null;
  return   (function() {
  (args_QUERY ?
    n = (name ?
      new TreeNode(line,col,source,chunk,name) :
      new TreeNode(line,col,source,chunk)) :
    n = new TreeNode());
  n["isMeta"] = false;
  n["eTYPE"] = type;
  return n;
  }).call(this);
  }).call(this);
}

function tnodeEx(chunk,name,type) {
  return tnode(null,null,null,chunk,name,type);
}

function addToken(tree,token,ctx) {
  let n = null,
    t = tkn_symbol;
  return   (function() {
  let ret = "";
  return   (function() {
  (token ?
        (function() {
    ((":else" === token) ?
      token = "true" :
      undefined);
    (("nil" === token) ?
      token = "null" :
      undefined);
    ((token.startsWith("\"") && token.endsWith("\"")) ?
      t = tkn_string :
      ((REGEX.float.test(token) || REGEX.int.test(token) || REGEX.hex.test(token)) ?
        t = tkn_number :
        (("`" === token) ?
          t = tkn_back_tick :
          (token.startsWith(":") ?
            token = ["\"",token.slice(1),"\""].join("") :
            (token.startsWith("'") ?
              token = ["\"",token.slice(1),"\""].join("") :
              (true ?
                t = tkn_ident :
                undefined))))));
    ((tkn_ident === t) ?
            (function() {
      return ((!(empty_QUERY(tree) && contains_QUERY(_STARreserved_keys_STAR,token))) ?
        token = normalizeId(token) :
        undefined);
      }).call(this) :
      undefined);
    n = tnode(ctx.file,ctx.line,(ctx.tcol - 1),token,token,t);
    return conj_BANG_BANG(tree,n);
    }).call(this) :
    undefined);
  return ret;
  }).call(this);
  }).call(this);
}

function lexer(prevToken,ctx) {
  let ____BREAK_BANG = null,
    formType = null,
    token = "",
    ch = null,
    nxch = null,
    escStr_QUERY = false,
    inStr_QUERY = false,
    comment_QUERY = false;
  prevToken = (prevToken || "");
  return   (function() {
  let tree = [];
  return   (function() {
  nodeTag(tree,ctx["source"],ctx["line"],0,(prevToken.endsWith("{") ?
    tkn_object :
    (("[" === prevToken) ?
      tkn_array :
      (true ?
        tkn_list :
        undefined))));
  (prevToken.startsWith("^") ?
    tree["isMeta"] = true :
    undefined);
  ____BREAK_BANG = false;
  (function () {
while ((!____BREAK_BANG) && (ctx.pos < (ctx.codeStr)["length"])) {
  (function() {
  ch = ctx.codeStr.charAt(ctx.pos);
  ++ctx.colno;
  ++ctx.pos;
  nxch = ctx.codeStr.charAt(ctx.pos);
  ((ch === "\n") ?
        (function() {
    ++ctx.lineno;
    ctx.colno = 1;
    return (comment_QUERY ?
      comment_QUERY = (!comment_QUERY) :
      undefined);
    }).call(this) :
    undefined);
  return (comment_QUERY ?
    null :
    (escStr_QUERY ?
            (function() {
      escStr_QUERY = (!escStr_QUERY);
      return token += ch;
      }).call(this) :
      ((ch === "\"") ?
                (function() {
        inStr_QUERY = (!inStr_QUERY);
        return token += ch;
        }).call(this) :
        (inStr_QUERY ?
                    (function() {
          ((ch === "\n") ?
            ch = "\\n" :
            undefined);
          ((ch === "\\") ?
            escStr_QUERY = true :
            undefined);
          return token += ch;
          }).call(this) :
          ((ch === "'") ?
            token += ch :
            (((ch === "[") || (ch === "]")) ?
                            (function() {
              token = addToken(tree,token,ctx);
              ctx.tcol = ctx.colno;
              return ((ch === "[") ?
                                (function() {
                formType = tkn_array;
                return conj_BANG_BANG(tree,lexer(ch,ctx));
                }).call(this) :
                                (function() {
                formType = null;
                return ____BREAK_BANG = true;
                }).call(this));
              }).call(this) :
              (((ch === "{") || (ch === "}")) ?
                                (function() {
                token = addToken(tree,token,ctx);
                ctx.tcol = ctx.colno;
                return ((ch === "{") ?
                                    (function() {
                  formType = tkn_object;
                  return conj_BANG_BANG(tree,lexer(ch,ctx));
                  }).call(this) :
                                    (function() {
                  formType = null;
                  return ____BREAK_BANG = true;
                  }).call(this));
                }).call(this) :
                ((ch === ";") ?
                  comment_QUERY = true :
                  ((ch === "^") ?
                    (REGEX.wspace.test(nxch) ?
                                            (function() {
                      token += ch;
                      return token = addToken(tree,token,ctx);
                      }).call(this) :
                                            (function() {
                      token = addToken(tree,token,ctx);
                      (("{" !== nxch) ?
                        syntax_BANG("e0",tree) :
                        undefined);
                      ++ctx.pos;
                      ctx.tcol = ctx.colno;
                      formType = tkn_object;
                      return conj_BANG_BANG(tree,lexer("^{",ctx));
                      }).call(this)) :
                    (((ch === "(") || (ch === ")")) ?
                                            (function() {
                      token = addToken(tree,token,ctx);
                      ctx.tcol = ctx.colno;
                      return ((ch === "(") ?
                                                (function() {
                        formType = tkn_list;
                        return conj_BANG_BANG(tree,lexer(ch,ctx));
                        }).call(this) :
                                                (function() {
                        formType = null;
                        return ____BREAK_BANG = true;
                        }).call(this));
                      }).call(this) :
                      (REGEX.wspace.test(ch) ?
                                                (function() {
                        ((ch === "\n") ?
                          --ctx.lineno :
                          undefined);
                        token = addToken(tree,token,ctx);
                        ((ch === "\n") ?
                          ++ctx.lineno :
                          undefined);
                        return ctx.tcol = ctx.colno;
                        }).call(this) :
                        (true ?
                          token += ch :
                          undefined))))))))))));
  }).call(this);
}
}).call(this);
  (inStr_QUERY ?
    syntax_BANG("e3",tree) :
    undefined);
  (function() { let ____x;
switch (formType) {
case tkn_array:
____x= syntax_BANG("e5",tree);
break;
case tkn_object:
____x= syntax_BANG("e7",tree);
break;
case tkn_list:
____x= syntax_BANG("e8",tree);
break;
}
return ____x;}).call(this);
  return tree;
  }).call(this);
  }).call(this);
}

function Keyword(k) {this.value=k; return this;}
Keyword.prototype.toString = function() { return this.value; }
function Symbol(s) {this.value=s; return this;}
Symbol.prototype.toString = function() { return this.value; }
function Atom(v) {this.value=v; return this;}
Atom.prototype.toString = function() { return this.value; }
function throwE(token,msg) {
  (function (){ throw new Error((token ?
    [msg,"\nnear line ",token.line,"\nin file ",token.source].join("") :
    [msg,"\nnear EOF "].join(""))); }).call(this);
}

function nextToken(tokens) {
  return   (function() {
  let t = nth(tokens,tokens.pos);
  return   (function() {
  ++tokens.pos;
  return t;
  }).call(this);
  }).call(this);
}

function peekToken(tokens) {
  return nth(tokens,tokens.pos);
}

function toSymbol(s) {
  return new Symbol(s);
}

function toKeyword(k) {
  return new Keyword(k);
}

//
function parseAtom(tokens) {
  let token = nextToken(tokens),
    tn = ((token ?
      (token)["name"] :
      undefined) || "");
  return (empty_QUERY(tn) ?
    undefined :
    (REGEX.float.test(tn) ?
      parseFloat(tn) :
      ((REGEX.hex.test(tn) || REGEX.int.test(tn)) ?
        parseInt(tn) :
        ((tn.startsWith("\"") && tn.endsWith("\"")) ?
          tn :
          (tn.startsWith(":") ?
            toKeyword(tn.slice(1)) :
            ((("nil" === tn) || ("null" === tn)) ?
              null :
              (("true" === tn) ?
                true :
                (("false" === tn) ?
                  false :
                  (true ?
                    toSymbol(tn) :
                    undefined)))))))));
}

function parseBlock(tokens,head,tail) {
  let token = nextToken(tokens),
    tn = (token ?
      (token)["name"] :
      undefined);
  ((tn !== head) ?
    throwE(token,["expected '",head,"'"].join("")) :
    undefined);
  return   (function() {
  let ret = (function () {
    let recur = null,
      ____xs = null,
      ____f = function (ast,token) {
        return ((nichts_QUERY(token) || (tail === (token)["name"])) ?
          (token ?
            ast :
            throwE(token,["expected '",tail,"', got EOF"].join(""))) :
          recur(addAst(ast,parseMore(tokens)),peekToken(tokens)));
      },
      ____ret = ____f;
    recur = function () {
      ____xs = arguments;
      return ((!(typeof(____ret) === "undefined")) ?
                (function() {
        for (____ret=undefined; ____ret===undefined; ____ret=____f.apply(this,____xs));;
        return ____ret;
        }).call(this) :
        undefined)
    };
    return recur([],peekToken(tokens));
  })();
  return   (function() {
  nextToken(tokens);
  return ret;
  }).call(this);
  }).call(this);
}

function parseList(tokens) {
  return   (function() {
  let v = parseBlock(tokens,"(",")");
  return   (function() {
  v["eTYPE"] = tkn_list;
  return v;
  }).call(this);
  }).call(this);
}

function parseVec(tokens) {
  return   (function() {
  let v = parseBlock(tokens,"[","]");
  return   (function() {
  v["eTYPE"] = tkn_vector;
  return v;
  }).call(this);
  }).call(this);
}

function parseMap(tokens) {
  let v = parseBlock(tokens,"{","}");
  (odd_QUERY((v)["length"]) ?
    (function (){ throw new Error("expected even count in map"); }).call(this) :
    undefined);
  return   (function() {
  let ret = {};
  return   (function() {
  (function () {
for (var i = 0; (i < (v)["length"]); i = (i + 2)) {
        (function() {
    return ret[nth(v,i)] = nth(v,(i + 1));
    }).call(this);
  }
}).call(this);
  ret["eTYPE"] = tkn_map;
  return ret;
  }).call(this);
  }).call(this);
}

function skipAndParse(tokens,func) {
  nextToken(tokens);
  return func(tokens);
}

function parseMore(tokens) {
  let tmp = null,
    token = peekToken(tokens);
  return (some_QUERY(token) ?
        (function() {
    return (function() { let ____x;
switch ((token)["name"]) {
case "'":
____x= skipAndParse(tokens,function () {
      return [
        toSymbol("quote"),
        parseMore(tokens)
      ];
    });
break;
case "`":
____x= skipAndParse(tokens,function () {
      return [
        toSymbol("quasi-quote"),
        parseMore(tokens)
      ];
    });
break;
case "~":
____x= skipAndParse(tokens,function () {
      return [
        toSymbol("unquote"),
        parseMore(tokens)
      ];
    });
break;
case "~@":
____x= skipAndParse(tokens,function () {
      return [
        toSymbol("splice-unquote"),
        parseMore(tokens)
      ];
    });
break;
case "^":
____x= skipAndParse(tokens,function () {
      tmp = parseMore(tokens);
      return [
        toSymbol("with-meta"),
        parseMore(tokens),
        tmp
      ];
    });
break;
case "@":
____x= skipAndParse(tokens,function () {
      return [
        toSymbol("deref"),
        parseMore(tokens)
      ];
    });
break;
case ")":
____x= throwE(token,"unexpected ')'");
break;
case "(":
____x= parseList(tokens);
break;
case "]":
____x= throwE(token,"unexpected ']'");
break;
case "[":
____x= parseVec(tokens);
break;
case "}":
____x= throwE(token,"unexpected '}'");
break;
case "{":
____x= parseMap(tokens);
break;
case ";":
case ",":
____x=     (function() {
    nextToken(tokens);
    return undefined;
    }).call(this);
break;
default:
____x= parseAtom(tokens);
break;
}
return ____x;}).call(this);
    }).call(this) :
    undefined);
}

//
function addAst(ast,f) {
  ((!(typeof(f) === "undefined")) ?
    ast.push(f) :
    undefined);
  return ast;
}

//
function parseSource(source,fname) {
  let tokens = tokenize(source,fname),
    tlen = (tokens)["length"];
  tokens["pos"] = 0;
  return   (function() {
  let ast = [];
  return   (function() {
  (function () {
    let recur = null,
      ____xs = null,
      ____f = function (f) {
        addAst(ast,f);
        return ((!(tokens.pos < tlen)) ?
          ast :
          recur(parseMore(tokens)));
      },
      ____ret = ____f;
    recur = function () {
      ____xs = arguments;
      return ((!(typeof(____ret) === "undefined")) ?
                (function() {
        for (____ret=undefined; ____ret===undefined; ____ret=____f.apply(this,____xs));;
        return ____ret;
        }).call(this) :
        undefined)
    };
    return recur(parseMore(tokens));
  })();
  return ast;
  }).call(this);
  }).call(this);
}

//
function tokenize(source,fname) {
  let len = (source)["length"],
    token = "",
    line = 1,
    tcol = 0,
    col = 0,
    pos = 0,
    ch = null,
    nx = null,
    esc_QUERY = false,
    str_QUERY = false,
    comment_QUERY = false;
  return   (function() {
  let tree = [];
  return   (function() {
  let toke_BANG = function (ln,col,s) {
    (s ?
      tree.push(tnode(fname,ln,col,s,s)) :
      undefined);
    return "";
  };
  (function () {
while (pos < len) {
  (function() {
  ch = source.charAt(pos);
  ++col;
  ++pos;
  nx = source.charAt(pos);
  ((ch === "\n") ?
        (function() {
    col = 0;
    ++line;
    return (comment_QUERY ?
      comment_QUERY = (!comment_QUERY) :
      undefined);
    }).call(this) :
    undefined);
  return (comment_QUERY ?
    null :
    (esc_QUERY ?
            (function() {
      esc_QUERY = (!esc_QUERY);
      return token += ch;
      }).call(this) :
      ((ch === "\"") ?
        ((!str_QUERY) ?
                    (function() {
          tcol = col;
          str_QUERY = (!str_QUERY);
          return token += ch;
          }).call(this) :
                    (function() {
          str_QUERY = (!str_QUERY);
          token += ch;
          return token = toke_BANG(line,tcol,token);
          }).call(this)) :
        (str_QUERY ?
                    (function() {
          ((ch === "\n") ?
            ch = "\\n" :
            undefined);
          ((ch === "\\") ?
            esc_QUERY = true :
            undefined);
          return token += ch;
          }).call(this) :
          (((ch === "'") || (ch === "`") || (ch === "@") || (ch === "^")) ?
            ((empty_QUERY(token) && (!REGEX.wspace.test(nx))) ?
                            (function() {
              tcol = col;
              return toke_BANG(line,tcol,ch);
              }).call(this) :
              token += ch) :
            ((ch === "~") ?
              ((empty_QUERY(token) && (!REGEX.wspace.test(nx))) ?
                                (function() {
                tcol = col;
                return ((nx === "@") ?
                                    (function() {
                  ++pos;
                  return toke_BANG(line,tcol,"~@");
                  }).call(this) :
                  toke_BANG(line,tcol,ch));
                }).call(this) :
                token += ch) :
              (((ch === "[") || (ch === "]") || (ch === "{") || (ch === "}") || (ch === "(") || (ch === ")")) ?
                                (function() {
                token = toke_BANG(line,tcol,token);
                tcol = col;
                return toke_BANG(line,tcol,ch);
                }).call(this) :
                ((ch === ";") ?
                                    (function() {
                  token = toke_BANG(line,tcol,token);
                  tcol = col;
                  return comment_QUERY = true;
                  }).call(this) :
                  (((ch === ",") || REGEX.wspace.test(ch)) ?
                    token = toke_BANG(((ch === "\n") ?
                      (line - 1) :
                      line),tcol,token) :
                    (true ?
                                            (function() {
                      (empty_QUERY(token) ?
                                                (function() {
                        return tcol = col;
                        }).call(this) :
                        undefined);
                      return token += ch;
                      }).call(this) :
                      undefined))))))))));
  }).call(this);
}
}).call(this);
  return tree;
  }).call(this);
  }).call(this);
}

function dumpTree(tree) {
  let obj = null,
    indent = (nth(arguments,1) || 0),
    pad = " ".repeat(indent);
  return (function () {
for (var i = 0; (i < (tree)["length"]); i = (i + 1)) {
        (function() {
    obj = nth(tree,i);
    return ((Object.prototype.toString.call(obj) === "[object Array]") ?
            (function() {
      console.log([pad,"<block>"].join(""));
      dumpTree(obj,(indent + 2));
      return console.log([pad,"</block>"].join(""));
      }).call(this) :
      (true ?
                (function() {
        let s = ("" + obj);
        console.log([pad,"<atom>"].join(""));
        console.log(s.replace(new RegExp("&","g"),"&amp;").replace(new RegExp("<","g"),"&lt;").replace(new RegExp(">","g"),"&gt;"));
        return console.log([pad,"</atom>"].join(""));
        }).call(this) :
        undefined));
    }).call(this);
  }
}).call(this);
}

var MODULE_VERSION = "1.0.0",
  loadedMacros_QUERY = false,
  noSemi_QUERY = false,
  tabspace = 2,
  VARGS = "&rest",
  TILDA = "~",
  indent = (-tabspace),
  TILDA_VARGS = [TILDA,VARGS].join("");
var _STARexterns_STAR = null;
var _STARnspaces_STAR = null;
function stripDQ(s) {
  return ((s.startsWith("\"") && s.endsWith("\"")) ?
    s.slice(1,((s)["length"] - 1)) :
    s);
}

function fmtRegoSpecOps(alias,fname) {
  ((!contains_QUERY(_STARreserved_keys_STAR,stripDQ(alias))) ?
        (function() {
    (function (){ throw new Error(["bad special form alias ",alias].join("")); }).call(this);
    return null;
    }).call(this) :
    undefined);
  return ["SPECIAL_OPS[",alias,"] = ",fname].join("");
}

function fmtSpecOps(fname,attrs) {
  let ks = null;
  (function () {
for (var i = 0; (i < (attrs)["length"]); i = (i + 1)) {
        (function() {
    return (("\"res-keys\"" === get_QUERY_QUERY(nth(attrs,i),"name","")) ?
      ks = nth(attrs,(i + 1)) :
      undefined);
    }).call(this);
  }
}).call(this);
  ks = (ks || []);
  return ks.map(function (s) {
    return fmtRegoSpecOps(s.toString(),fname);
  }).join(";\n");
}

function banner() {
  return ["/*","Auto generated by Kirby - v",MODULE_VERSION," ","*/\n\n"].join("");
}

var SPECIAL_OPS = {};
var MACROS_MAP = {};
var ERRORS_MAP = {
  "e0": "Syntax Error",
  "e1": "Empty statement",
  "e2": "Invalid characters in function name",
  "e3": "End of File encountered, unterminated string",
  "e4": "Closing square bracket, without an opening square bracket",
  "e5": "End of File encountered, unterminated array",
  "e6": "Closing curly brace, without an opening curly brace",
  "e7": "End of File encountered, unterminated javascript object '}'",
  "e8": "End of File encountered, unterminated parenthesis",
  "e9": "Invalid character in var name",
  "e10": "Extra chars at end of file. Maybe an extra ')'.",
  "e11": "Cannot Open include File",
  "e12": "Invalid no of arguments to ",
  "e13": "Invalid Argument type to ",
  "e14": "End of File encountered, unterminated regular expression",
  "e15": "Invalid vararg position, must be last argument.",
  "e16": "Invalid arity (args > expected) to ",
  "e17": "Invalid arity (args < expected) to "
};
function eval_QUERY_QUERY(x) {
  return ((Object.prototype.toString.call(x) === "[object Array]") ?
    evalList(x) :
    x);
}

function node_QUERY(obj) {
  return ((Object.prototype.toString.call(obj) === "[object Object]") && (true === obj["$$$isSourceNode$$$"]));
}

function error_BANG(e,line,file,msg) {
  (function (){ throw new Error([ERRORS_MAP[e],(msg ?
    [" : ",msg].join("") :
    undefined),(line ?
    ["\nLine no ",line].join("") :
    undefined),(file ?
    ["\nFile ",file].join("") :
    undefined)].join("")); }).call(this);
}

function syntax_BANG(ecode,expr,cmd) {
  return error_BANG(ecode,(expr ?
    expr["line"] :
    undefined),(expr ?
    expr["source"] :
    undefined),cmd);
}

function assertArgs(expr,cnt,ecode,msg) {
  return (((expr)["length"] !== cnt) ?
    syntax_BANG(ecode,expr,msg) :
    undefined);
}

function pad(z) {
  return " ".repeat(z);
}

function toASTree(code,fname) {
  let state = {
    "codeStr": ["(",code,")"].join(""),
    "source": fname,
    "colno": 1,
    "line": 1,
    "pos": 1,
    "tcol": 1
  };
  return   (function() {
  let ret = lexer(null,state);
  return   (function() {
  ((state.pos < (state.codeStr)["length"]) ?
    error_BANG("e10") :
    undefined);
  return ret;
  }).call(this);
  }).call(this);
}

function parseTree(root) {
  let pstr = "",
    endx = ((root)["length"] - 1),
    treeSize = (root)["length"];
  indent += tabspace;
  pstr = pad(indent);
  return   (function() {
  let ret = tnode();
  return   (function() {
  nodeTag(ret,root["source"],root["line"],root["column"],tkn_tree);
  root.forEach(function (expr,i) {
    let name = get_QUERY_QUERY(nth(expr,0),"name",""),
      r = "",
      tmp = ((Object.prototype.toString.call(expr) === "[object Array]") ?
        evalList(expr) :
        expr);
    (((Object.prototype.toString.call(tmp) === "[object Array]") && (tkn_ns === (tmp)["eTYPE"])) ?
            (function() {
      tmp.forEach(function (x) {
        return ret.add(x);
      });
      return tmp = null;
      }).call(this) :
      undefined);
    (((i === endx) && (0 !== indent) && (!REGEX.noret.test(name))) ?
      r = "return " :
      undefined);
    return (tmp ?
            (function() {
      ret.add([
        [pstr,r].join(""),
        tmp,
        ((!noSemi_QUERY) ?
          ";" :
          ""),
        "\n"
      ]);
      return noSemi_QUERY = false;
      }).call(this) :
      undefined);
  });
  indent -= tabspace;
  return ret;
  }).call(this);
  }).call(this);
}

function evalList(expr) {
  let cmd = "",
    tmp = null,
    mc = null;
  ((tkn_object === (expr)["eTYPE"]) ?
    cmd = "{" :
    ((tkn_array === (expr)["eTYPE"]) ?
      cmd = "[" :
      (true ?
                (function() {
        cmd = get_QUERY_QUERY(nth(expr,0),"name","");
        return mc = MACROS_MAP[cmd];
        }).call(this) :
        undefined)));
  return (some_QUERY(mc) ?
    eval_QUERY_QUERY(evalMacro(mc,expr)) :
    (cmd.startsWith(".-") ?
            (function() {
      let ret = tnode();
      return       (function() {
      ret.add(eval_QUERY_QUERY(nth(expr,1)));
      ret.prepend("(");
      ret.add([
        ")[\"",
        cmd.slice(2),
        "\"]"
      ]);
      return ret;
      }).call(this);
      }).call(this) :
      ((cmd.charAt(0) === ".") ?
                (function() {
        let ret = tnode();
        return         (function() {
        ret.add(eval_QUERY_QUERY(nth(expr,1)));
        ret.add([
          nth(expr,0),
          "("
        ]);
        (function () {
for (var i = 2; (i < (expr)["length"]); i = (i + 1)) {
                    (function() {
          ((i !== 2) ?
            ret.add(",") :
            undefined);
          return ret.add(eval_QUERY_QUERY(nth(expr,i)));
          }).call(this);
        }
}).call(this);
        ret.add(")");
        return ret;
        }).call(this);
        }).call(this) :
        (SPECIAL_OPS.hasOwnProperty(cmd) ?
          SPECIAL_OPS[cmd](expr) :
          (true ?
                        (function() {
            evalAtoms(expr);
            cmd = nth(expr,0);
            ((!cmd) ?
              syntax_BANG("e1",expr) :
              undefined);
            (REGEX.func.test(cmd) ?
              cmd = tnodeEx([
                "(",
                cmd,
                ")"
              ]) :
              undefined);
            return tnodeEx([
              cmd,
              "(",
              tnodeEx(expr.slice(1)).join(","),
              ")"
            ]);
            }).call(this) :
            undefined)))));
}

function evalAtoms(cells) {
  return cells.forEach(function (cell,i,cc) {
    return ((Object.prototype.toString.call(cell) === "[object Array]") ?
      cc[i] = evalList(cell) :
      undefined);
  });
}

function expandMacro(cmd,code,data,frags) {
  let ret = nodeTag([],data.source,data.line,data.column,(code)["eTYPE"]),
    tmp = null,
    sname = get_QUERY_QUERY(nth(code,1),"name",""),
    ename = get_QUERY_QUERY(nth(code,0),"name",""),
    frag = frags[[TILDA,sname].join("")];
  return ((ename === "#<<") ?
    ((!(Object.prototype.toString.call(frag) === "[object Array]")) ?
      syntax_BANG("e13",data,cmd) :
      frag.shift()) :
    ((ename === "#head") ?
      ((!(Object.prototype.toString.call(frag) === "[object Array]")) ?
        syntax_BANG("e13",data,cmd) :
        (not_empty(frag) ?
          nth(frag,0) :
          undefined)) :
      ((ename === "#tail") ?
        ((!(Object.prototype.toString.call(frag) === "[object Array]")) ?
          syntax_BANG("e13",data,cmd) :
          (not_empty(frag) ?
            last(frag) :
            undefined)) :
        (ename.startsWith("#evens") ?
                    (function() {
          let r = [];
          return           (function() {
          (function () {
for (var i = 0; (i < (frag)["length"]); i = (i + 2)) {
                        (function() {
            return conj_BANG_BANG(r,nth(frag,i));
            }).call(this);
          }
}).call(this);
          (ename.endsWith("*") ?
            r["____split"] = true :
            undefined);
          return r;
          }).call(this);
          }).call(this) :
          (ename.startsWith("#odds") ?
                        (function() {
            let r = [];
            return             (function() {
            (function () {
for (var i = 1; (i < (frag)["length"]); i = (i + 2)) {
                            (function() {
              return conj_BANG_BANG(r,nth(frag,i));
              }).call(this);
            }
}).call(this);
            (ename.endsWith("*") ?
              r["____split"] = true :
              undefined);
            return r;
            }).call(this);
            }).call(this) :
            (ename.startsWith("#slice@") ?
                            (function() {
              ((!(Object.prototype.toString.call(frag) === "[object Array]")) ?
                syntax_BANG("e13",data,cmd) :
                undefined);
              tmp = REGEX.macroGet.exec(ename);
              return nth(frag.splice((nth(tmp,1) - 1),1),0);
              }).call(this) :
              ((ename === "#if") ?
                                (function() {
                ((!(Object.prototype.toString.call(frag) === "[object Array]")) ?
                  syntax_BANG("e13",data,cmd) :
                  undefined);
                return (not_empty(frag) ?
                  expandMacro(cmd,nth(code,2),data,frags) :
                  ((((code)["length"] > 3) && nth(code,3)) ?
                    expandMacro(cmd,nth(code,3),data,frags) :
                    undefined));
                }).call(this) :
                (true ?
                                    (function() {
                  let cell = null;
                  (function () {
for (var i = 0; (i < (code)["length"]); i = (i + 1)) {
                                        (function() {
                    cell = nth(code,i);
                    return ((Object.prototype.toString.call(cell) === "[object Array]") ?
                                            (function() {
                      let c = expandMacro(cmd,cell,data,frags);
                      return (((Object.prototype.toString.call(c) === "[object Array]") && (true === c["____split"])) ?
                        (function () {
for (var k = 0; (k < (c)["length"]); k = (k + 1)) {
                                                    (function() {
                          return conj_BANG_BANG(ret,nth(c,k));
                          }).call(this);
                        }
}).call(this) :
                        conj_BANG_BANG(ret,c));
                      }).call(this) :
                                            (function() {
                      let atSign_QUERY = false,
                        rs = null,
                        tn = get_QUERY_QUERY(cell,"name","");
                      tmp = cell;
                      (tn.includes("@") ?
                                                (function() {
                        rs = tn.replace("@","");
                        atSign_QUERY = true;
                        return tmp = tnode(cell.source,cell.line,cell.column,rs,rs);
                        }).call(this) :
                        undefined);
                      return                       (function() {
                      let r = frags[get_QUERY_QUERY(tmp,"name","")];
                      return (some_QUERY(r) ?
                                                (function() {
                        return ((atSign_QUERY || (get_QUERY_QUERY(tmp,"name","") === TILDA_VARGS)) ?
                          (function () {
for (var j = 0; (j < (r)["length"]); j = (j + 1)) {
                                                        (function() {
                            return conj_BANG_BANG(ret,nth(r,j));
                            }).call(this);
                          }
}).call(this) :
                          conj_BANG_BANG(ret,r));
                        }).call(this) :
                        conj_BANG_BANG(ret,cell));
                      }).call(this);
                      }).call(this));
                    }).call(this);
                  }
}).call(this);
                  return ret;
                  }).call(this) :
                  undefined))))))));
}

function evalMacro(mc,data) {
  let args = mc["args"],
    cmd = mc["name"],
    code = mc["code"],
    vargs = false,
    tpos = 0,
    i = 0,
    frags = {};
  (function () {
for (var tpos = (i + 1); (i < (args)["length"]); i = (i + 1),tpos = (i + 1)) {
        (function() {
    return ((get_QUERY_QUERY(nth(args,i),"name","") === VARGS) ?
            (function() {
      vargs = true;
      return frags[TILDA_VARGS] = data.slice(tpos);
      }).call(this) :
      frags[[TILDA,get_QUERY_QUERY(nth(args,i),"name","")].join("")] = ((tpos >= (data)["length"]) ?
        tnodeEx("undefined") :
        nth(data,tpos)));
    }).call(this);
  }
}).call(this);
  (((!vargs) && ((i + 1) < (data)["length"])) ?
    syntax_BANG("e16",data,cmd) :
    undefined);
  return expandMacro(cmd,code,data,frags);
}

function sf_compOp(expr) {
  (((expr)["length"] < 3) ?
    syntax_BANG("e0",expr) :
    undefined);
  evalAtoms(expr);
    (function() {
  let cmd = get_QUERY_QUERY(nth(expr,0),"name","");
  ((cmd === "!=") ?
    expr[0] = "!==" :
    undefined);
  return ((cmd === "=") ?
    expr[0] = "===" :
    undefined);
  }).call(this);
  return   (function() {
  let ret = tnode();
  return   (function() {
  (function () {
for (var i = 0,op = expr.shift(); (i < ((expr)["length"] - 1)); i = (i + 1)) {
        (function() {
    return ret.add(tnodeEx([
      nth(expr,i),
      " ",
      op,
      " ",
      nth(expr,(i + 1))
    ]));
    }).call(this);
  }
}).call(this);
  ret.join(" && ");
  ret.prepend("(");
  ret.add(")");
  return ret;
  }).call(this);
  }).call(this);
}

_STARreserved_STAR["compare"].forEach(function (k) {
  return SPECIAL_OPS[k] = sf_compOp;
});
function sf_arithOp(expr) {
  (((expr)["length"] < 2) ?
    syntax_BANG("e0",expr) :
    undefined);
  evalAtoms(expr);
  let op = tnode(),
    e1 = expr.shift(),
    cmd = get_QUERY_QUERY(e1,"name","");
  return   (function() {
  let ret = tnode();
  return   (function() {
  ((1 === (expr)["length"]) ?
    (("-" === cmd) ?
      ret.add("-") :
      undefined) :
    op.add([
      " ",
      e1,
      " "
    ]));
  ret.add(expr);
  (((expr)["length"] > 1) ?
    ret.join(op) :
    undefined);
  ret.prepend("(");
  ret.add(")");
  return ret;
  }).call(this);
  }).call(this);
}

_STARreserved_STAR["bitwise"].forEach(function (k) {
  return SPECIAL_OPS[k] = sf_arithOp;
});
_STARreserved_STAR["logic"].forEach(function (k) {
  return SPECIAL_OPS[k] = sf_arithOp;
});
_STARreserved_STAR["arith"].forEach(function (k) {
  return SPECIAL_OPS[k] = sf_arithOp;
});
function sf_repeat(expr) {
  assertArgs(expr,3,"e0");
  evalAtoms(expr);
  return   (function() {
  let ret = tnode();
  return   (function() {
  (function () {
for (var i = 0,end = parseInt(get_QUERY_QUERY(nth(expr,1),"name","")); (i < end); i = (i + 1)) {
        (function() {
    ((i !== 0) ?
      ret.add(",") :
      undefined);
    return ret.add(nth(expr,2));
    }).call(this);
  }
}).call(this);
  ret.prepend("[");
  ret.add("]");
  return ret;
  }).call(this);
  }).call(this);
}
SPECIAL_OPS["repeat-n"] = sf_repeat;
function sf_do(expr) {
  let p = pad(indent),
    e = null,
    end = ((expr)["length"] - 1);
  return   (function() {
  let ret = tnode();
  return   (function() {
  (function () {
for (var i = 1; (i < end); i = (i + 1)) {
        (function() {
    e = nth(expr,i);
    return ret.add([
      p,
      evalList(e),
      ";\n"
    ]);
    }).call(this);
  }
}).call(this);
  ((end > 0) ?
        (function() {
    e = eval_QUERY_QUERY(last(expr));
    ret.add([
      p,
      "return ",
      e,
      ";\n"
    ]);
    ret.prepend([p,"(function() {\n"].join(""));
    return ret.add([p,"}).call(this)"].join(""));
    }).call(this) :
    undefined);
  return ret;
  }).call(this);
  }).call(this);
}
SPECIAL_OPS["do"] = sf_do;
function sf_doto(expr) {
  (((expr)["length"] < 2) ?
    syntax_BANG("e0",expr) :
    undefined);
  let p = pad(indent),
    p2 = pad((indent + tabspace)),
    p3 = pad((indent + (2 * tabspace))),
    e = null,
    e1 = eval_QUERY_QUERY(nth(expr,1));
  return   (function() {
  let ret = tnode();
  return   (function() {
  ret.add([
    p2,
    "let ____x = ",
    e1,
    ";\n"
  ]);
  (function () {
for (var i = 2; (i < (expr)["length"]); i = (i + 1)) {
        (function() {
    e = nth(expr,i);
    e.splice(1,0,"____x");
    return ret.add([
      p3,
      evalList(e),
      ";\n"
    ]);
    }).call(this);
  }
}).call(this);
  ret.add([
    p2,
    "return ____x;\n"
  ]);
  ret.prepend([p,"(function() {\n"].join(""));
  ret.add([p,"}).call(this)"].join(""));
  return ret;
  }).call(this);
  }).call(this);
}
SPECIAL_OPS["doto"] = sf_doto;
function sf_case(expr) {
  (((expr)["length"] < 4) ?
    syntax_BANG("e0",expr) :
    undefined);
  let tst = nth(expr,1),
    e = null,
    t = null,
    c = null,
    dft = null;
  (odd_QUERY((expr)["length"]) ?
    dft = expr.pop() :
    undefined);
  return   (function() {
  let ret = tnode();
  return   (function() {
  (function () {
for (var i = 2; (i < (expr)["length"]); i = (i + 2)) {
        (function() {
    c = nth(expr,(i + 1));
    e = nth(expr,i);
    t = (e)["eTYPE"];
    return ((tkn_list === t) ?
      (function () {
for (var j = 0; (j < (e)["length"]); j = (j + 1)) {
                (function() {
        ret.add([
          "case ",
          nth(e,j),
          ":\n"
        ]);
        return ((j === ((e)["length"] - 1)) ?
          ret.add([
            "____x= ",
            eval_QUERY_QUERY(c),
            ";\nbreak;\n"
          ]) :
          undefined);
        }).call(this);
      }
}).call(this) :
      (true ?
                (function() {
        ret.add([
          "case ",
          e,
          ":\n"
        ]);
        return ret.add([
          "____x= ",
          eval_QUERY_QUERY(c),
          ";\nbreak;\n"
        ]);
        }).call(this) :
        undefined));
    }).call(this);
  }
}).call(this);
  (dft ?
        (function() {
    ret.add("default:\n");
    return ret.add([
      "____x= ",
      eval_QUERY_QUERY(dft),
      ";\nbreak;\n"
    ]);
    }).call(this) :
    undefined);
  ret.prepend([
    "switch (",
    eval_QUERY_QUERY(tst),
    ") {\n"
  ]);
  ret.add("}\n");
  ret.prepend("(function() { let ____x;\n");
  ret.add("return ____x;}).call(this)");
  return ret;
  }).call(this);
  }).call(this);
}
SPECIAL_OPS["case"] = sf_case;
function sf_range(expr) {
  ((((expr)["length"] < 2) || ((expr)["length"] > 4)) ?
    syntax_BANG("e0",expr) :
    undefined);
  let len = 0,
    start = 0,
    step = 1,
    end = 0;
  evalAtoms(expr);
  len = (expr)["length"];
  end = parseInt(get_QUERY_QUERY(nth(expr,1),"name",""));
  return   (function() {
  let ret = tnode();
  return   (function() {
  ((len > 2) ?
        (function() {
    start = parseInt(get_QUERY_QUERY(nth(expr,1),"name",""));
    return end = parseInt(get_QUERY_QUERY(nth(expr,2),"name",""));
    }).call(this) :
    undefined);
  ((len > 3) ?
    step = parseInt(get_QUERY_QUERY(nth(expr,3),"name","")) :
    undefined);
  (function () {
for (var i = start; (i < end); i = (i + step)) {
        (function() {
    ((i !== start) ?
      ret.add(",") :
      undefined);
    return ret.add(["",i].join(""));
    }).call(this);
  }
}).call(this);
  ret.prepend("[");
  ret.add("]");
  return ret;
  }).call(this);
  }).call(this);
}
SPECIAL_OPS["range"] = sf_range;
function sf_var(expr,cmd) {
  ((((expr)["length"] < 3) || (0 === ((expr)["length"] % 2))) ?
    syntax_BANG("e0",expr) :
    undefined);
  let vname = null,
    public_QUERY = ("global" === cmd);
  (((expr)["length"] > 3) ?
    indent += tabspace :
    undefined);
  ((public_QUERY || ("local" === cmd)) ?
    cmd = "var" :
    undefined);
  evalAtoms(expr);
  return   (function() {
  let ret = tnode();
  return   (function() {
  (function () {
for (var i = 1; (i < (expr)["length"]); i = (i + 2)) {
        (function() {
    ((i > 1) ?
      ret.add([",\n",pad(indent)].join("")) :
      undefined);
    ((!testid_QUERY(nth(expr,i))) ?
      syntax_BANG("e9",expr) :
      undefined);
    vname = nth(expr,i);
    ((public_QUERY && (1 === (_STARnspaces_STAR)["length"])) ?
      _STARexterns_STAR[vname] = vname :
      undefined);
    return ret.add([
      vname,
      " = ",
      nth(expr,(i + 1))
    ]);
    }).call(this);
  }
}).call(this);
  ret.prepend(" ");
  ret.prepend(cmd);
  (((expr)["length"] > 3) ?
    indent -= tabspace :
    undefined);
  return ret;
  }).call(this);
  }).call(this);
}

function sf_var_local(expr) {
  return sf_var(expr,"local");
}
SPECIAL_OPS["def-"] = sf_var_local;
function sf_var_global(expr) {
  return sf_var(expr,"global");
}
SPECIAL_OPS["def"] = sf_var_global;
function sf_var_let(expr) {
  return sf_var(expr,"let");
}
SPECIAL_OPS["var"] = sf_var_let;
function sf_new(expr) {
  (((expr)["length"] < 2) ?
    syntax_BANG("e0",expr) :
    undefined);
  return   (function() {
  let ret = tnode();
  return   (function() {
  ret.add(evalList(expr.slice(1)));
  ret.prepend("new ");
  return ret;
  }).call(this);
  }).call(this);
}
SPECIAL_OPS["new"] = sf_new;
function sf_throw(expr) {
  assertArgs(expr,2,"e0");
  return   (function() {
  let ret = tnode();
  return   (function() {
  ret.add([
    "throw ",
    eval_QUERY_QUERY(nth(expr,1)),
    ";"
  ]);
  ret.prepend("(function (){ ");
  ret.add(" }).call(this)");
  return ret;
  }).call(this);
  }).call(this);
}
SPECIAL_OPS["throw"] = sf_throw;
function sf_while(expr) {
  (((expr)["length"] < 2) ?
    syntax_BANG("e0",expr) :
    undefined);
  let tst = nth(expr,1);
  expr.splice(0,2,tnodeEx("do","do"));
  return   (function() {
  let ret = null;
  return   (function() {
  ret = tnodeEx([
    "while ",
    eval_QUERY_QUERY(tst),
    " {\n",
    evalList(expr),
    ";\n}\n"
  ]);
  ret.prepend(["(function () {\n"].join(""));
  ret.add("}).call(this)");
  return ret;
  }).call(this);
  }).call(this);
}
SPECIAL_OPS["while"] = sf_while;
function sf_x_opop(expr) {
  (((expr)["length"] !== 2) ?
    syntax_BANG("e0",expr) :
    undefined);
  return tnodeEx([
    nth(expr,0),
    eval_QUERY_QUERY(nth(expr,1))
  ]);
}

_STARreserved_STAR["incdec"].forEach(function (k) {
  return SPECIAL_OPS[k] = sf_x_opop;
});
function sf_x_eq(expr) {
  assertArgs(expr,3,"e0");
  return tnodeEx([
    nth(expr,1),
    " ",
    nth(expr,0),
    " ",
    eval_QUERY_QUERY(nth(expr,2))
  ]);
}

_STARreserved_STAR["assign"].forEach(function (k) {
  return SPECIAL_OPS[k] = sf_x_eq;
});
function sf_set(expr) {
  ((!(((expr)["length"] === 3) || ((expr)["length"] === 4))) ?
    syntax_BANG("e0",expr) :
    undefined);
  return   (function() {
  let ret = tnode();
  return   (function() {
  (((expr)["length"] === 4) ?
        (function() {
    ret.add(eval_QUERY_QUERY(nth(expr,1)));
    ret.add("[");
    ret.add(eval_QUERY_QUERY(nth(expr,2)));
    return ret.add("]");
    }).call(this) :
    ret.add(nth(expr,1)));
  ret.add([
    " = ",
    eval_QUERY_QUERY(last(expr))
  ]);
  return ret;
  }).call(this);
  }).call(this);
}
SPECIAL_OPS["aset"] = sf_set;
SPECIAL_OPS["set!"] = sf_set;
function sf_anonFunc(expr) {
  (((expr)["length"] < 2) ?
    syntax_BANG("e0",expr) :
    undefined);
  ((!(Object.prototype.toString.call(nth(expr,1)) === "[object Array]")) ?
    syntax_BANG("e0",expr) :
    undefined);
  let args = nth(expr,1),
    body = expr.slice(2);
  return   (function() {
  let ret = tnodeEx(args);
  return   (function() {
  ret.join(",");
  ret.prepend("function (");
  ret.add([
    ") {\n",
    parseTree(body),
    pad(indent),
    "}"
  ]);
  return ret;
  }).call(this);
  }).call(this);
}
SPECIAL_OPS["fn"] = sf_anonFunc;
function sf_func(expr,public_QUERY) {
  (((expr)["length"] < 3) ?
    syntax_BANG("e0",expr) :
    undefined);
  let fname = normalizeId(get_QUERY_QUERY(nth(expr,1),"name","")),
    e3 = nth(expr,3)["eTYPE"],
    e2 = nth(expr,2)["eTYPE"],
    doc = null,
    attrs = null,
    args = 2,
    body = 3;
  (function() { let ____x;
switch (e2) {
case tkn_array:
____x= null;
break;
case tkn_string:
____x=   (function() {
  doc = 2;
  args = 3;
  return ((tkn_object === e3) ?
        (function() {
    attrs = 3;
    return args = 4;
    }).call(this) :
    undefined);
  }).call(this);
break;
case tkn_object:
____x=   (function() {
  attrs = 2;
  return args = 3;
  }).call(this);
break;
}
return ____x;}).call(this);
  body = (args + 1);
  (doc ?
    doc = nth(expr,doc) :
    undefined);
  (attrs ?
    attrs = nth(expr,attrs) :
    undefined);
  args = nth(expr,args);
  body = expr.slice(body);
  return   (function() {
  let ret = null;
  return   (function() {
  ret = tnodeEx(args);
  ret.join(",");
  ret.prepend(["function ",fname,"("].join(""));
  ret.add([
    ") {\n",
    parseTree(body),
    pad(indent),
    "}\n"
  ]);
  (attrs ?
        (function() {
    ret.add(fmtSpecOps(fname,attrs));
    return ret.add(";");
    }).call(this) :
    undefined);
  (doc ?
        (function() {
    return ret.prepend(get_QUERY_QUERY(doc,"name","").replace(REGEX.dquoteHat,"").replace(REGEX.dquoteEnd,"").split("\\n").map(function (x) {
      return ["//",x,"\n"].join("");
    }));
    }).call(this) :
    undefined);
  ((public_QUERY && (1 === (_STARnspaces_STAR)["length"])) ?
    _STARexterns_STAR[fname] = fname :
    undefined);
  noSemi_QUERY = true;
  return ret;
  }).call(this);
  }).call(this);
}

function sf_func_private(expr) {
  return sf_func(expr,false);
}
SPECIAL_OPS["defn-"] = sf_func_private;
function sf_func_public(expr) {
  return sf_func(expr,true);
}
SPECIAL_OPS["defn"] = sf_func_public;
function sf_try(expr) {
  let sz = (expr)["length"],
    t = null,
    f = null,
    c = null,
    ind = pad(indent);
  f = last(expr);
  (((Object.prototype.toString.call(f) === "[object Array]") && (get_QUERY_QUERY(nth(f,0),"name","") === "finally")) ?
        (function() {
    f = expr.pop();
    return sz = (expr)["length"];
    }).call(this) :
    f = null);
  c = ((sz > 1) ?
    nth(expr,(sz - 1)) :
    null);
  (((Object.prototype.toString.call(c) === "[object Array]") && (get_QUERY_QUERY(nth(c,0),"name","") === "catch")) ?
        (function() {
    ((((c)["length"] < 2) || (!node_QUERY(nth(c,1)))) ?
      syntax_BANG("e0",expr) :
      undefined);
    return c = expr.pop();
    }).call(this) :
    c = null);
  (((Object.prototype.toString.call(f) === "[object Null]") && (Object.prototype.toString.call(c) === "[object Null]")) ?
    syntax_BANG("e0",expr) :
    undefined);
  return   (function() {
  let ret = tnodeEx([
    ["(function() {\n",ind,"try {\n"].join(""),
    parseTree(expr.slice(1)),
    ["\n",ind,"} "].join("")
  ]);
  return   (function() {
  (c ?
        (function() {
    t = nth(c,1);
    c.splice(0,2,tnodeEx("do","do"));
    return ret.add([
      ["catch (",t,") {\n"].join(""),
      "return ",
      evalList(c),
      [";\n",ind,"}\n"].join("")
    ]);
    }).call(this) :
    undefined);
  (f ?
        (function() {
    f.splice(0,1,tnodeEx("do","do"));
    return ret.add([
      "finally {\n",
      evalList(f),
      [";\n",ind,"}\n"].join("")
    ]);
    }).call(this) :
    undefined);
  ret.add([ind,"}).call(this)"].join(""));
  return ret;
  }).call(this);
  }).call(this);
}
SPECIAL_OPS["try"] = sf_try;
function sf_if(expr) {
  ((((expr)["length"] < 3) || ((expr)["length"] > 4)) ?
    syntax_BANG("e0",expr) :
    undefined);
  indent += tabspace;
  evalAtoms(expr);
  return (function() {
  try {
    return tnodeEx([
      "(",
      nth(expr,1),
      [" ?\n",pad(indent)].join(""),
      nth(expr,2),
      [" :\n",pad(indent)].join(""),
      (nth(expr,3) || "undefined"),
      ")"
    ]);

  } finally {
  (function() {
  return indent -= tabspace;
  }).call(this);
  }
  }).call(this);
}
SPECIAL_OPS["if"] = sf_if;
function sf_get(expr) {
  assertArgs(expr,3,"e0");
  evalAtoms(expr);
  return tnodeEx([
    nth(expr,1),
    "[",
    nth(expr,2),
    "]"
  ]);
}
SPECIAL_OPS["aget"] = sf_get;
SPECIAL_OPS["get"] = sf_get;
function sf_str(expr) {
  (((expr)["length"] < 2) ?
    syntax_BANG("e0",expr) :
    undefined);
  evalAtoms(expr);
  return   (function() {
  let ret = tnode();
  return   (function() {
  ret.add(expr.slice(1));
  ret.join(",");
  ret.prepend("[");
  ret.add("].join(\"\")");
  return ret;
  }).call(this);
  }).call(this);
}
SPECIAL_OPS["str"] = sf_str;
function sf_array(expr) {
  let p = pad(indent),
    epilog = ["\n",p,"]"].join("");
  return   (function() {
  let ret = tnode();
  return   (function() {
  (empty_QUERY(expr) ?
    ret.add("[]") :
    (function() {
    try {
      ((tkn_array !== (expr)["eTYPE"]) ?
        expr.splice(0,1) :
        undefined);
      indent += tabspace;
      evalAtoms(expr);
      p = pad(indent);
      ret.add(["[\n",p].join(""));
      (function () {
for (var i = 0; (i < (expr)["length"]); i = (i + 1)) {
                (function() {
        ((i > 0) ?
          ret.add([",\n",p].join("")) :
          undefined);
        return ret.add(nth(expr,i));
        }).call(this);
      }
}).call(this);
      return ret.add(epilog);

    } finally {
    (function() {
    return indent -= tabspace;
    }).call(this);
    }
    }).call(this));
  return ret;
  }).call(this);
  }).call(this);
}
SPECIAL_OPS["vec"] = sf_array;
SPECIAL_OPS["["] = sf_array;
function sf_object(expr) {
  let p = pad(indent),
    epilog = ["\n",p,"}"].join("");
  return   (function() {
  let ret = tnode();
  return   (function() {
  (empty_QUERY(expr) ?
    ret.add("{}") :
    (function() {
    try {
      ((tkn_object !== (expr)["eTYPE"]) ?
        expr.splice(0,1) :
        undefined);
      indent += tabspace;
      evalAtoms(expr);
      p = pad(indent);
      ret.add(["{\n",p].join(""));
      (function () {
for (var i = 0; (i < (expr)["length"]); i = (i + 2)) {
                (function() {
        ((i > 0) ?
          ret.add([",\n",p].join("")) :
          undefined);
        return ret.add([
          nth(expr,i),
          ": ",
          nth(expr,(i + 1))
        ]);
        }).call(this);
      }
}).call(this);
      return ret.add(epilog);

    } finally {
    (function() {
    return indent -= tabspace;
    }).call(this);
    }
    }).call(this));
  return ret;
  }).call(this);
  }).call(this);
}
SPECIAL_OPS["hash-map"] = sf_object;
SPECIAL_OPS["{"] = sf_object;
var includeFile = (function () {
  let icache = [];
  return function (fname) {
    return (contains_QUERY(icache,fname) ?
      "" :
            (function() {
      icache.push(fname);
      return parseTree(toASTree(_STARfs_STAR.readFileSync(fname),fname));
      }).call(this));
  };
})();
function sf_include(expr) {
  assertArgs(expr,2,"e0");
  let dir = _STARpath_STAR.dirname((expr)["source"]),
    found = false,
    fname = get_QUERY_QUERY(nth(expr,1),"name","");
  ((typeof(fname) === "string") ?
    fname = fname.replace(new RegExp("[\"]","g"),"") :
    undefined);
  (function() {
  try {
    return fname = _STARfs_STAR.realpathSync([dir,"/",fname].join(""));

  } catch (e) {
return   (function() {
  return syntax_BANG("e11",expr);
  }).call(this);
  }
  }).call(this);
  return (function() {
  try {
    indent -= tabspace;
    return includeFile(fname);

  } finally {
  (function() {
  _STARnspaces_STAR.pop();
  return indent += tabspace;
  }).call(this);
  }
  }).call(this);
}

function sf_require(expr) {
  let path = null,
    v = null,
    e = null;
  return   (function() {
  let ret = tnode();
  return   (function() {
  (function () {
for (var i = 1; (i < (expr)["length"]); i = (i + 1)) {
        (function() {
    e = nth(expr,i);
    ((!((Object.prototype.toString.call(e) === "[object Array]") || (3 === (e)["length"]))) ?
      syntax_BANG("e0",expr) :
      undefined);
    path = nth(e,0);
    v = nth(e,2);
    return ret.add([
      "var ",
      normalizeId(v),
      "= require(",
      path,
      ");\n"
    ]);
    }).call(this);
  }
}).call(this);
  return ret;
  }).call(this);
  }).call(this);
}

function sf_ns(expr) {
  (((expr)["length"] < 2) ?
    syntax_BANG("e0",expr) :
    undefined);
  return   (function() {
  let ret = [];
  return   (function() {
  ret["eTYPE"] = tkn_ns;
  (function () {
for (var i = 1; (i < (expr)["length"]); i = (i + 1)) {
        (function() {
    let e = nth(expr,i),
      t = (e)["eTYPE"],
      nm = get_QUERY_QUERY(nth(e,0),"name","");
    return ((tkn_ident === t) ?
      _STARnspaces_STAR.push(e) :
      (((tkn_list === t) && ("include" === nm)) ?
        ret.push(sf_include(e)) :
        (((tkn_list === t) && ("require" === nm)) ?
          ret.push(sf_require(e)) :
          undefined)));
    }).call(this);
  }
}).call(this);
  return ret;
  }).call(this);
  }).call(this);
}
SPECIAL_OPS["ns"] = sf_ns;
function sf_comment(expr) {
  return "";
}
SPECIAL_OPS["comment"] = sf_comment;
function sf_floop(expr) {
  (((expr)["length"] < 2) ?
    syntax_BANG("e0",expr) :
    undefined);
  let c1 = null,
    c2 = null,
    c3 = null,
    c = nth(expr,1),
    ind = pad(indent);
  return   (function() {
  let ret = tnodeEx("for (");
  return   (function() {
  (((!(Object.prototype.toString.call(c) === "[object Array]")) || ((c)["length"] !== 3)) ?
    syntax_BANG("e0",expr) :
    undefined);
  c1 = nth(c,0);
  c2 = nth(c,1);
  c3 = nth(c,2);
  indent += tabspace;
  (function () {
for (var i = 0; (i < (c1)["length"]); i = (i + 2)) {
        (function() {
    (zero_QUERY(i) ?
      ret.add("var ") :
      undefined);
    ((i > 0) ?
      ret.add(",") :
      undefined);
    return ret.add([
      nth(c1,i),
      " = ",
      eval_QUERY_QUERY(nth(c1,(i + 1)))
    ]);
    }).call(this);
  }
}).call(this);
  ret.add("; ");
  ret.add(evalList(c2));
  ret.add("; ");
  (function () {
for (var i = 0; (i < (c3)["length"]); i = (i + 2)) {
        (function() {
    ((i > 0) ?
      ret.add(",") :
      undefined);
    return ret.add([
      nth(c3,i),
      " = ",
      eval_QUERY_QUERY(nth(c3,(i + 1)))
    ]);
    }).call(this);
  }
}).call(this);
  ret.add(") {\n");
  (((expr)["length"] > 2) ?
        (function() {
    expr.splice(0,2,tnodeEx("do","do"));
    return ret.add([
      ind,
      pad(tabspace),
      evalList(expr),
      ";"
    ]);
    }).call(this) :
    undefined);
  ret.add(["\n",ind,"}\n"].join(""));
  ret.prepend("(function () {\n");
  ret.add("}).call(this)");
  indent -= tabspace;
  return ret;
  }).call(this);
  }).call(this);
}
SPECIAL_OPS["for"] = sf_floop;
function sf_jscode(expr) {
  assertArgs(expr,2,"e0");
  noSemi_QUERY = true;
  nth(expr,1).replaceRight(new RegExp("\"","g"),"");
  return nth(expr,1);
}
SPECIAL_OPS["js#"] = sf_jscode;
function sf_macro(expr) {
  (((expr)["length"] < 4) ?
    syntax_BANG("e0",expr) :
    undefined);
  let a3 = nth(expr,3),
    a2 = nth(expr,2),
    doc = null,
    cmd = get_QUERY_QUERY(nth(expr,1),"name","");
  ((tkn_string === a2["eTYPE"]) ?
        (function() {
    doc = nth(expr,2);
    a2 = nth(expr,3);
    return a3 = nth(expr,4);
    }).call(this) :
    undefined);
  return   (function() {
  let ret = "";
  return   (function() {
  (function () {
for (var i = 0; (i < (a2)["length"]); i = (i + 1)) {
        (function() {
    return (((get_QUERY_QUERY(nth(a2,i),"name","") === VARGS) && ((i + 1) !== (a2)["length"])) ?
      syntax_BANG("e15",expr,cmd) :
      undefined);
    }).call(this);
  }
}).call(this);
  MACROS_MAP[cmd] = {
    "doc": doc,
    "args": a2,
    "code": a3,
    "name": cmd
  };
  return ret;
  }).call(this);
  }).call(this);
}
SPECIAL_OPS["defmacro"] = sf_macro;
function sf_unary(expr) {
  assertArgs(expr,2,"e0");
  evalAtoms(expr);
  return ["(",nth(expr,0),nth(expr,1),")"].join("");
}

_STARreserved_STAR["unary"].forEach(function (k) {
  return SPECIAL_OPS[k] = sf_unary;
});
function dbg(obj,hint) {
  return ((Object.prototype.toString.call(obj) === "[object Array]") ?
        (function() {
    hint = (hint || "block");
    console.log(["<",hint,">"].join(""));
    (function () {
for (var i = 0; (i < (obj)["length"]); i = (i + 1)) {
            (function() {
      return dbg(nth(obj,i));
      }).call(this);
    }
}).call(this);
    return console.log(["</",hint,">"].join(""));
    }).call(this) :
    (node_QUERY(obj) ?
            (function() {
      console.log("<node>");
      console.log(obj);
      dbg(obj.children,"subs");
      return console.log("</node>");
      }).call(this) :
      (true ?
        console.log(obj) :
        undefined)));
}

function spitExterns() {
  let p = pad(tabspace),
    s = Object.keys(_STARexterns_STAR).map(function (k) {
      return [p,k,": ",k].join("");
    }).join(",\n");
  return ["\n\nmodule.exports = {\n",s,"\n};\n\n"].join("");
}

function compileCode(codeStr,fname,withSrcMap_QUERY) {
  dumpTree(parseSource(codeStr,fname));
  ((!loadedMacros_QUERY) ?
        (function() {
    loadedMacros_QUERY = true;
    return require("./macros.kirby");
    }).call(this) :
    undefined);
  indent = (-tabspace);
  _STARexterns_STAR = {};
  _STARnspaces_STAR = [];
  let outNode = parseTree(toASTree(codeStr,fname)),
    extra = spitExterns();
  outNode.prepend(banner());
  return (withSrcMap_QUERY ?
        (function() {
    let outFile = [_STARpath_STAR.basename(fname,".kirby"),".js"].join(""),
      srcMap = [outFile,".map"].join(""),
      output = outNode.toStringWithSourceMap({
        "file": outFile
      });
    fs.writeFileSync(srcMap,output.map);
    return [output.code,extra,"\n//# sourceMappingURL=",_STARpath_STAR.relative(_STARpath_STAR.dirname(fname),srcMap)].join("");
    }).call(this) :
    [outNode,extra].join(""));
}

function transpileXXX(code,file,smap_QUERY) {
  return (function() {
  try {
    return compileCode(code,file,smap_QUERY);

  } catch (e) {
return   (function() {
  console.log(e.stack);;
  (function (){ throw e; }).call(this);
  return null;
  }).call(this);
  }
  }).call(this)
}

function dbgAST(codeStr,fname) {
  return dbg(toASTree(codeStr,fname),"tree");
}

function transpileWithSrcMap(code,file) {
  return transpileXXX(code,file,true);
}

function transpile(code,file) {
  return transpileXXX(code,file,false);
}

function parseWithSourceMap(codeStr,fname) {
  let outNode = parseTree(toASTree(codeStr,fname));
  outNode.prepend(MODULE_BANNER);
  return outNode.toStringWithSourceMap();
}

var version = MODULE_VERSION;


module.exports = {
  dbgAST: dbgAST,
  transpileWithSrcMap: transpileWithSrcMap,
  transpile: transpile,
  parseWithSourceMap: parseWithSourceMap,
  version: version
};

