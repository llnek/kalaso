;; Copyright (c) 2013-2017, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http:;;opensource.org;licenses;eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro whatis? [obj] `(Object.prototype.toString.call ~obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro eindex [arr] `(- (alen ~arr) 1))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro alen [arr] `(.-length ~arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro type [obj] `(typeof ~obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro regex [pattern glim]
  (if* glim
    `(new RegExp ~pattern ~glim)
    `(new RegExp ~pattern)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro undef? [obj] `(= (typeof ~obj) "undefined"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro boolean? [obj] `(= (typeof ~obj) "boolean"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro number? [obj] `(= (typeof ~obj) "number"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro string? [obj] `(= (typeof ~obj) "string"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro fn? [obj] `(= (typeof ~obj) "function"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro date? [obj] `(= (whatis? ~obj) "[object Date]"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro regex? [obj] `(= (whatis? ~obj) "[object RegExp]"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro array? [obj] `(= (whatis? ~obj) "[object Array]"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro object? [obj] `(= (whatis? ~obj) "[object Object]"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;(defmacro nil? [obj] `(= (whatis? ~obj) "[object Null]"))
(defmacro nil? [obj] `(= ~obj null))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro isdef? [obj] `(not (undef? ~obj)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro assert [cond msg]
  `(if ~cond true (throw (new Error ~msg))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro true? [obj] `(= true ~obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro false? [obj] `(= false ~obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro when-not [cond & xs] `(when (not ~cond) ~@xs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro unless [cond &xs] `(when-not ~cond ~@xs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro if-not [cond & xs]
  (let* [e1 (nth* xs 0)
         e2 (nth* xs 1)] `(if ~cond ~e2 ~e1)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro when [cond & xs] `(if ~cond (do ~@xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro cond [& xs]
  (let* [len (count* xs)
         ok? (is-even? len)]
    (do*
      (assert* ok? "want even args")
      (if* (> len 0)
        (let* [c (nth* xs 0)
               e (nth* xs 1)
               r (rest* (rest* xs))]
          (do*
            (if* (is-same? c "else") (def* c true))
            `(if ~c ~e (cond ~@r))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro -> [expr form & xs]
  (if* (> (count* xs) 0)
    `(-> (~(nth* form 0) ~expr ~@(rest* form)) ~@xs)
    `(~(nth* form 0) ~expr ~@(rest* form))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro ->> [expr form & xs]
  (if* (> (count* xs) 0)
    `(->> (~@form ~expr) ~@xs)
    `(~@form ~expr)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro xxxlet [bindings & xs]
  (let* [ps (evens* bindings)
         vs (odds* bindings)]
    `((fn [~@ps] ~@xs) ~@vs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro let [bindings & xs]
  `((fn [] (var ~@bindings) ~@xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro loop [bindings & more]
  (let*
    [es (evens* bindings)
     xs (gensym*)
     f (gensym*)
     ret (gensym*)
     os (odds* bindings)]
    `((fn []
         (var recur nil ~xs nil
              ~f (fn [~@es ] ~@more)
              ~ret ~f)
         (set! recur
           (fn []
             (set! ~xs arguments)
             (if (isdef? ~ret)
               (do (for ((~ret undefined)
                         (= ~ret undefined) nil)
                     (set! ~ret (.apply ~f this ~xs))) ~ret)
               undefined)))
         (recur ~@os)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro or [&xs] `(|| ~@xs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro and [&xs] `(&& ~@xs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro do-with [binding & xs]
  `(let [~(first* binding) ~(nth* binding 1)]
    ~@xs
    ~(first* binding)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro do->false [&xs]
  (let* [arg (gensym*)] `(let [~arg false] ~@xs ~arg)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro do->true [&xs]
  (let* [arg (gensym*)] `(let [~arg true] ~@xs ~arg)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro do->nil [&xs]
  (let* [arg (gensym*)] `(let [~arg nil] ~@xs ~arg)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro do->undef [&xs]
  (let* [arg (gensym*)] `(let [~arg undefined] ~@xs ~arg)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro inc [x] `(+ ~x 1))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro dec [x] `(- ~x 1))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro dotimes [binding &xs]
  (let* [_times (gensym*)]
    `(forlet ((~(first* binding) 0 ~_times ~(nth* binding 1))
              (< ~(first* binding) ~_times)
              (~(first* binding) (inc ~(first* binding))))
         ~@xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro if-some [binding then &xs]
  (let* [cvar (gensym*)
         otherwise (nth* xs 0)]
    `(let [~cvar ~(nth* binding 1)
           ~(first* binding) ~cvar]
       (if ~cvar ~then ~otherwise))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro when-some [binding &xs]
  (let* [cvar (gensym*)]
    `(let [~cvar ~(nth* binding 1)
           ~(first* binding) ~cvar]
       (when ~cvar ~@xs))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro doto [target & xs]
  (let* [cvar (gensym*)]
    `(let [~cvar ~target]
       ~@(map* (fn* [e] `(~(first* e) ~cvar ~@(rest* e))) xs)
       ~cvar)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro map [f coll] `(.map ~coll ~f))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro xxreduce [f start coll]
  (if* ~start
    `(.reduce ~coll ~f ~start)
    `(.reduce ~coll ~f)))

(defmacro reduce [f start coll] `(.reduce ~coll ~f ~start))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro each [func coll] `(.forEach ~coll ~func))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro each-key [func obj]
  (let* [tmp (gensym*)]
    `(let [~tmp ~obj]
       (each (fn [e]
               (~func (nth e 1) (nth e 0))) (Object.entries ~tmp)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF
(defmacro do-monad [monad bindings & body]
  `((fn [m] (var mBind m.mBind
                 mResult m.mResult
                 mZero m.mZero mPlus m.mPlus)
            (var ____mResult
                 (fn [& body]
                   (if (and mZero
                            (empty? body))
                     mZero
                     (.apply mResult this body))))
            (m-bind mBind ~bindings (____mResult ~@body))) ~monad))

(defmacro m-bind [binder bindings & body]
  (let* [a2 (nth* bindings 1)
         a1 (nth* bindings 0)
         more (rest* (rest* bindings))]
    `(~binder ~a2
              (fn [~a1]
                ~(if* (not-empty* more)
                    `(m-bind ~binder ~more ~@body)
                     `(do ~@body))))))

(defmacro arrayMonad []
  `(hash-map
     :mBind (fn [mv mf]
             (reduce
               (fn [acc v] (.concat acc v))
               []
               (map mf mv)))
    :mResult (fn [v] (.concat [] v))
    :mZero []
    :mPlus (fn []
             (reduce
               (fn [acc v] (.concat acc v))
               []
               (Array.prototype.slice.call arguments)))))

