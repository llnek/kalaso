;; Copyright (c) 2013-2017, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http:;;opensource.org;licenses;eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(ns ^{:doc ""
      :author "Kenneth Leung"}

  czlab.kirby.bl.defmacros)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro trap! "" [& msgs]
  (let* [z (count* msgs)]
    (if* (> z 1)
      `(throw (join "" (vec ~@msgs)))
      (if* (> z 0)
        `(throw ~(nth* msgs 0))
        `(throw "error!")))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro raise! "" [& msgs]
  (let* [z (count* msgs)]
    (if* (> z 1)
      `(throw (new Error (join "" (vec ~@msgs))))
      (if* (> z 0)
        `(throw (new Error ~(nth* msgs 0)))
        `(throw (new Error ""))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro slice "" [arr & [start end]]
  (if* end
       `(Array.prototype.slice.call ~arr ~start ~end)
       (if* start
        `(Array.prototype.slice.call ~arr ~start)
        `(Array.prototype.slice.call ~arr))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro println "" [&msgs]
  `(if console (console.log (join "" (vec ~@msgs)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro delay "" [f t] `(setTimeout ~f ~t))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro break! "" [] `(set! ____break true))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro undef! "" [x] `(set! ~x undefined))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro last-index "" [coll] `(- (alen ~coll) 1))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro rest "" [coll] `(.slice ~coll 1))
(defmacro cdr "" [coll] `(.slice ~coll 1))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro second "" [coll] `(nth ~coll 1))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro first "" [coll] `(nth ~coll 0))
(defmacro car "" [coll] `(nth ~coll 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro nexth "" [coll i] `(get ~coll (+1 ~i)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro nth "" [coll i] `(get ~coll ~i))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro even? "" [n] `(= 0 (mod ~n 2)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro odd? "" [n] `(not (even? ~n)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro alen "" [coll] `(.-length ~coll))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro type "" [obj] `(typeof ~obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro whatis? "" [obj] `(Object.prototype.toString.call ~obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro regex? "" [obj] `(= (whatis? ~obj) "[object RegExp]"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;(defmacro array? [obj] `(= (whatis? ~obj) "[object Array]"))
(defmacro array? "" [obj] `(Array.isArray ~obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro date? "" [obj] `(= (whatis? ~obj) "[object Date]"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro boolean? "" [obj] `(= (typeof ~obj) "boolean"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro number? "" [obj] `(= (typeof ~obj) "number"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro string? "" [obj] `(= (typeof ~obj) "string"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro fn? "" [obj] `(= (typeof ~obj) "function"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro undef? "" [obj] `(= (typeof ~obj) "undefined"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro def? "" [obj] `(not (undef? ~obj)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro nil? "" [obj] `(= ~obj null))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro values "" [obj] `(Object.values ~obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro keys "" [obj] `(Object.keys ~obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro assert "" [tst & msgs]
  `(if ~tst true (raise! ~@msgs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro false? "" [obj] `(= false ~obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro true? "" [obj] `(= true ~obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro when-not "" [tst & xs] `(when (not ~tst) ~@xs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro unless "" [tst & xs] `(when-not ~tst ~@xs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro if-not "" [tst then & [else]]
  `(if (not ~tst) ~then ~else))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro while "" [tst & xs] `(for [:while ~tst] ~@xs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro when "" [tst & xs] `(if ~tst (do ~@xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro cond "" [& xs]
  (let* [len (count* xs)]
    (do* (assert* (is-even? len)
                  "cond expects even args")
         (if* (> len 0)
           (let* [c (nth* xs 0)
                  e (nth* xs 1)
                  r (rest* (rest* xs))]
             (if* (is-same? c "else")
               `(if true ~e)
               `(if ~c ~e (cond ~@r))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro -> "" [expr form & xs]
  (let* [x `(~(nth* form 0)
                    ~expr ~@(rest* form))]
    (if* (> (count* xs) 0) `(-> ~x ~@xs) `~x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro ->> "" [expr form & xs]
  (let* [x `(~@form ~expr)]
    (if* (> (count* xs) 0) `(->> ~x ~@xs) `~x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro let "" [bindings & xs] `(do (var ~@bindings) ~@xs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;trampoline
(defmacro loop "" [bindings & more]
  (let*
    [ret (gensym*)
     xs (gensym*)
     f (gensym*)
     es (evens* bindings)
     os (odds* bindings)]
    `((fn []
        (var recur nil ~xs nil
             ~f (fn [~@es] ~@more) ~ret ~f)
        (set! recur
              (fn []
                (set! ~xs arguments)
                (if (def? ~ret)
                  (do (for ((~ret undefined)
                            (= ~ret undefined) nil)
                        (set! ~ret (.apply ~f this ~xs))) ~ret)
                  undefined)))
        (recur ~@os)) this)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro and "" [&xs] `(&& ~@xs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro or "" [&xs] `(|| ~@xs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro join "" [sep coll] `(.join ~coll ~sep))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro concat "" [coll x] `(.concat ~coll ~x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro do-with "" [binding & xs]
  (let* [zzz (first* binding)]
    `(let [~zzz ~(nth* binding 1)] ~@xs ~zzz)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro do->false "" [&xs]
  (let* [arg (gensym*)] `(let [~arg false] ~@xs ~arg)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro do->true [&xs]
  (let* [arg (gensym*)] `(let [~arg true] ~@xs ~arg)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro do->nil [&xs]
  (let* [arg (gensym*)] `(let [~arg nil] ~@xs ~arg)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro do->undef [&xs]
  (let* [arg (gensym*)] `(let [~arg undefined] ~@xs ~arg)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro inc [x] `(+ ~x 1))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro dec [x] `(- ~x 1))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro dotimes [binding &xs]
  (let* [_times (gensym*)
         b1 (first* binding)]
    `(forlet ((~b1 0
               ~_times ~(nth* binding 1))
              (< ~b1 ~_times)
              (~b1 (inc ~b1)))
         ~@xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro if-some+ [binding then & [else]]
  (let* [tst (gensym*)]
    `(let [~tst ~(nth* binding 1)
           ~(first* binding) ~tst]
       (if
         (> (alen (if (or (string? ~tst)
                          (array? ~tst))
                    ~tst
                    (keys ~tst))) 0) ~then ~else))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro if-some [binding then & [else]]
  (let* [tst (gensym*)]
    `(let [~tst ~(nth* binding 1)
           ~(first* binding) ~tst]
       (if (or (undef? ~tst)
               (nil? ~tst)) ~else ~then))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro if-let [binding then & [else]]
  (let* [tst (gensym*)]
    `(let [~tst ~(nth* binding 1)
           ~(first* binding) ~tst]
       (if ~tst ~then ~else))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro when-some+ "" [binding &xs]
  (let* [tst (gensym*)]
    `(let [~tst ~(nth* binding 1)
           ~(first* binding) ~tst]
       (when
         (> (alen (if (or (string? ~tst)
                          (array? ~tst))
                    ~tst (keys ~tst))) 0) ~@xs))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro when-some [binding &xs]
  (let* [tst (gensym*)]
    `(let [~tst ~(nth* binding 1)
           ~(first* binding) ~tst]
       (when-not (or (undef? ~tst)
                     (nil? ~tst)) ~@xs))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro when-let [binding &xs]
  (let* [tst (gensym*)]
    `(let [~tst ~(nth* binding 1)
           ~(first* binding) ~tst] (when ~tst ~@xs))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro doto [target & xs]
  (let* [cvar (gensym*)]
    `(let [~cvar ~target]
       ~@(map* (fn* [e]
                    `(~(first* e) ~cvar ~@(rest* e))) xs)
       ~cvar)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro map [f coll] `(.map ~coll ~f))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro reduce [f start coll] `(.reduce ~coll ~f ~start))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro reduce2 [f coll] `(.reduce ~coll ~f))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro each [func coll] `(.forEach ~coll ~func))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro each-key [func obj]
  (let* [tmp (gensym*)]
    `(let [~tmp ~obj]
       (each (fn [e]
               (~func (nth e 1) (nth e 0)))
             (Object.entries ~tmp)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro do-monad "" [monad bindings & body]
  ((fn [mo]
     (var res (fn [&xs]
                (if (and (empty? xs)
                         (def? mo.zero))
                  mo.zero
                  (mo.result.apply mo xs))))
     (do-bind mo.bind ~bindings (res.apply this ~@body))) ~monad))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro do-bind "" [bindfunc bindings & body]
  (let* [a2 (nth* bindings 1)
         a1 (nth* bindings 0)
         more (rest* (rest* bindings))]
    `(~bindfunc ~a2
                (fn [~a1]
                  ~(if* (not-empty* more)
                        `(do-bind ~bindfunc
                                  ~more
                                  ~@body)
                        `(do ~@body))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro monad-identity "" [monads bindings & body]
  `(do-monad (.-identity monads) ~bindings ~@body))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro monad-maybe "" [monads bindings & body]
  `(do-monad (.-maybe monads) ~bindings ~@body))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro monad-array "" [monads bindings & body]
  `(do-monad (.-array monads) ~bindings ~@body))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro monad-state "" [monads bindings & body]
  `(do-monad (.-state monads) ~bindings ~@body))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro monad-continuation "" [monads bindings & body]
  `(do-monad (.-continuation monads) ~bindings ~@body))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF


