/*Auto generated by Kirby - v1.0.0 czlab.kirby.main Mon Nov 06 2017 23:09:55 GMT-0800 (PST)*/

var tx= require("./cg/transpiler");
var std= require("./bl/stdlib");
var rdr= require("./bl/lexer");
var rt= require("./rt/runtime");
var gopt= require("node-getopt");
var watcher= require("watch");
var path= require("path");
var fs= require("fs");
var kirbystdlibref=std;

let validFlag_QUERY;
validFlag_QUERY= /-h\b|-r\b|-v\b|-b\b|-s\b|-t\b/;

let error_BANG;
error_BANG= function () {
let ____args;
____args= Array.prototype.slice.call(arguments);

return (function() {
(console ?
console.log([ ____args[0] ].join("")) :
null);
return process.exit(1);
}).call(this);
};

let opt;
opt= gopt.create([ [ "h","help","display this help" ],[ "v","version","show version" ],[ "r","run","run .ky files" ],[ "w","watch","auto-compile changed files" ],[ "b","browser-bundle","bundle for browser" ],[ "m","source-map","generate source maps" ],[ "t","show-ast","show AST" ] ]).setHelp(["kirby [OPTION] [<infile>] [<outfile>]\n\n","<outfile> default to <infile> with \".js\" extension\n\n","Also compile stdin to stdout\n","eg. $ echo '(console.log \"hello\")' | kirby\n\n","[[OPTIONS]]\n\n"].join("")).bindHelp().parseSystem();

//when no args do stdin -> stdout compile or run repl and return null to
//  halt operations.
function handleNoArgs() {
let pout,source,pin;
pout= process.stdout;
source= "";
pin= process.stdin;

pout.on("error",error_BANG);
(function() {
let G__1;
G__1= pin;

G__1.setEncoding("utf8");
G__1.resume();
G__1.on("data",function () {
let ____args;
____args= Array.prototype.slice.call(arguments);

return source += ____args[0].toString();
});
G__1.on("end",function () {
let ____args;
____args= Array.prototype.slice.call(arguments);

return (function() {
try {
return pout.write(tx.transpile(source,process.cwd()));

} catch (e) {
return error_BANG(e);

}
}).call(this);
});
G__1.on("error",error_BANG);
return G__1;
}).call(this);
return setTimeout(function () {
let ____args;
____args= Array.prototype.slice.call(arguments);

return ((0 === pin.bytesRead) ?
(function() {
pin.removeAllListeners("data");
return runrepl();
}).call(this) :
null);
},20);
}

//
function compileFiles() {
let fin,fout;
fin= (opt.argv[0] ?
opt.argv[0] :
error_BANG("No Input file"));
fout= opt.argv[1];

((!fout) ?
(function() {
fout=fin.replace(/\.ky$/,".js");
return ((fout === fin) ?
error_BANG("Input file must have extension \".ky\"") :
null);
}).call(this) :
null);
return (function() {
try {
let G____9= opt.options;
let source_DASHmap,show_DASHast;
source_DASHmap=G____9["source-map"];
show_DASHast=G____9["show-ast"];

let source;
source= null;

((!show_DASHast) ?
(console ?
console.log([ "kirby v1.0.0",": compiling: ",fin," -> ",fout ].join("")) :
null) :
null);
source=fs.readFileSync(fin,"utf8");
return (show_DASHast ?
tx.dbgAST(source,fin,dirs) :
(function() {
let out;
out= (source_DASHmap ?
tx.transpileWithSrcMap(source,fin) :
tx.transpile(source,fin));

return fs.writeFileSync(fout,out,"utf8");
}).call(this));

} catch (e) {
return error_BANG(e);

}
}).call(this);
}

//
function init() {
require.extensions[".ky"]=function (module,fname) {
return module._compile(require("./cg/transpiler").transpile(fs.readFileSync(fname,"utf8"),path.relative(process.cwd(),fname)),fname);
};
return rt.init();
}

//
function main() {
init();
return compileFiles();
}

main()


module.exports = {
main: main
};

