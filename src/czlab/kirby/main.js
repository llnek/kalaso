/*Auto generated by Kirby - v1.0.0 czlab.kirby.main Sat Nov 11 2017 17:25:48 GMT-0800 (PST)*/

const tx = require("./cg/transpiler");
const std = require("./bl/stdlib");
const rdr = require("./bl/lexer");
const rt = require("./rt/runtime");
const gopt = require("node-getopt");
const watcher = require("watch");
const path = require("path");
const fs = require("fs");
const kirbystdlibref = std;

var validFlag_QUERY = /-h\b|-r\b|-v\b|-b\b|-s\b|-t\b/;

var error_BANG = function() {
  let ____args = Array.prototype.slice.call(arguments);
  return (function() {
    if (console) {
      console.log([____args[0]].join(""));
    }
    return process.exit(1);
  }).call(this);
};

var opt = gopt.create([["h", "help", "display this help"], ["v", "version", "show version"], ["r", "run", "run .ky files"], ["w", "watch", "auto-compile changed files"], ["b", "browser-bundle", "bundle for browser"], ["m", "source-map", "generate source maps"], ["f", "format", "format source code"], ["t", "show-ast", "show AST"]]).setHelp(["kirby [OPTION] [<infile>] [<outfile>]\n\n", "<outfile> default to <infile> with \".js\" extension\n\n", "Also compile stdin to stdout\n", "eg. $ echo '(console.log \"hello\")' | kirby\n\n", "[[OPTIONS]]\n\n"].join("")).bindHelp().parseSystem();

//when no args do stdin -> stdout compile or run repl and return null to
//  halt operations.
function handleNoArgs() {
  let pout = process.stdout;
  let source = "";
  let pin = process.stdin;
  pout.on("error", error_BANG);
  let G__1 = pin;
  G__1.setEncoding("utf8");
  G__1.resume();
  G__1.on("data", function() {
    let ____args = Array.prototype.slice.call(arguments);
    return source += ____args[0].toString();
  });
  G__1.on("end", function() {
    let ____args = Array.prototype.slice.call(arguments);
    return (function() {
      try {
        pout.write(tx.transpile(source, process.cwd()));

      } catch (e) {
        return error_BANG(e);
      }
    }).call(this);
  });
  G__1.on("error", error_BANG);
  G__1;
  return setTimeout(function() {
    let ____args = Array.prototype.slice.call(arguments);
    return ((0 === pin.bytesRead) ?
      (function() {
        pin.removeAllListeners("data");
        return runrepl();
      }).call(this) :
      null);
  }, 20);
}

//
function compileFiles() {
  let fin = (opt.argv[0] ?
    opt.argv[0] :
    error_BANG("No Input file"));
  let fout = opt.argv[1];
  if ( (!fout) ) {
    fout = fin.replace(/\.ky$/, ".js");
    if ( (fout === fin) ) {
      error_BANG("Input file must have extension \".ky\"");
    }
  }
  return (function() {
    try {
      let options = opt.options;
      let G____9 = options;
      let source_DASH_map,
        show_DASH_ast;
      source_DASH_map = G____9["source-map"];
      show_DASH_ast = G____9["show-ast"];
      let source = null;
      if ( (!show_DASH_ast) ) {
        if (console) {
          console.log(["kirby v1.0.0", ": compiling: ", fin, " -> ", fout].join(""));
        }
      }
      source = fs.readFileSync(fin, "utf8");
      if (show_DASH_ast) {
        tx.dbgAST(source, fin, dirs);
      } else {
        let out = (source_DASH_map ?
          tx.transpileWithSrcMap(source, fin, options) :
          tx.transpile(source, fin, options));
        fs.writeFileSync(fout, out, "utf8");
      }

    } catch (e) {
      return error_BANG(e);
    }
  }).call(this);
}

//
function init() {
  require.extensions[".ky"] = function(module, fname) {
    return module._compile(require("./cg/transpiler").transpile(fs.readFileSync(fname, "utf8"), path.relative(process.cwd(), fname)), fname);
  };
  return rt.init();
}

//
function main() {
  init();
  return compileFiles();
}

main()


module.exports = {
  main: main
};

