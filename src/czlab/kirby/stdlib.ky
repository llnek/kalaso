;; Copyright (c) 2013-2018, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc "Kirby's standard core library."
      :author "Kenneth Leung"}

  czlab.kirby.stdlib)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const MODULE_NAMESPACE "__module_namespace__")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro empty?
  "Returns true if coll has no items"
  [coll] `(= 0 (kirbystdlibref/count ~coll)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro starts-with?
  "Determines whether a string begins with the characters of a specified string, returning true or false as appropriate."
  [s arg] `(.startsWith ~s ~arg))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro ends-with?
  "Determines whether a string ends with the characters of a specified string, returning true or false as appropriate."
  [s arg] `(.endsWith ~s ~arg))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro n# "Refer to count." [coll] `(kirbystdlibref/count ~coll))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro 1st "Returns the first item in the collection." [x] `(first ~x))
(defmacro _1 "Refer to first." [x] `(first ~x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro 2nd "Returns the second item in the collection." [x] `(second ~x))
(defmacro _2 "Refer to second." [x] `(second ~x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro 3rd "Returns the third item in the collection." [x] `(nth ~x 2))
(defmacro _3 "Refer to 3rd." [x] `(nth ~x 2))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro trap! "Throw a string." [&msgs]
  (let* [sz (count* msgs)]
    (if* (> sz 1)
      `(throw (join "" (vec ~@msgs)))
      (if* (> sz 0)
        `(throw ~(nth* msgs 0)) `(throw "error!")))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro merror "Create a Error Object." [e] `(new Error ~e))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro raise! "Throw an Error Object." [&msgs]
  (let* [sz (count* msgs)]
    (if* (> sz 1)
      `(throw (merror (join "" (vec ~@msgs))))
      (if* (> sz 0)
        `(throw (merror ~(nth* msgs 0))) `(throw (merror "error!"))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro slice
  "Returns a shallow copy of a portion of an array into a new array object selected from begin to end (end not included). "
  [arr &[start end]]
  (if* end
       `(Array.prototype.slice.call ~arr ~start ~end)
       (if* start
            `(Array.prototype.slice.call ~arr ~start)
            `(Array.prototype.slice.call ~arr))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro numStr "A number into string." [n] `(.toString (Number ~n)))
(defmacro float "A string into float." [x] `(parseFloat ~x))
(defmacro int "A string into int." [x] `(parseInt ~x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro delay "Run function at a later time." [f t] `(setTimeout ~f ~t))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro break-out-of-loop! "Toggle *break*." [] `(set! ____break true))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro undef! "Set x to undefined." [x] `(set! ~x undefined))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro nil! "Set x to null." [x] `(set! ~x nil))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro last-index "Length -1." [coll] `(-1 (alen ~coll)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro rest
  "Returns a possibly empty seq of the items after the first."
  [coll] `(.slice ~coll 1))
(defmacro cdr "Refer to rest." [coll] `(.slice ~coll 1))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro second "Get the second item." [coll] `(nth ~coll 1))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro first "Get the first item." [coll] `(nth ~coll 0))
(defmacro car "Refer to first." [coll] `(nth ~coll 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro nexth "Get the next item after i." [coll i] `(nth ~coll (+1 ~i)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro nth "Get the item at index i." [coll i] `(get ~coll ~i))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro even?
  "True if all args are even." [&xs]
  `(_andp_* ~@(map* (lambda* [x] `(= 0 (kirbystdlibref/modulo ~x 2))) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro odd?
  "True if all args are odd." [&xs]
  `(_andp_* ~@(map* (lambda* [x] `(not (even? ~x))) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro alen "Length of array." [coll] `(.-length ~coll))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro nzlen? "Array length > 0." [coll] `(> (alen ~coll) 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro zlen? "Array length is 0." [coll] `(= (alen ~coll) 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro type "Type of object." [obj] `(typeof ~obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro whatis?
  "Long form of object type."
  [obj] `(Object.prototype.toString.call ~obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro regex?
  "True if all args are RegExps." [&xs]
  `(_andp_* ~@(map* (lambda* [x] `(= (whatis? ~x) "[object RegExp]")) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro array?
  "True if all args are arrays."
  [&xs] `(_andp_* ~@(map* (lambda* [x] `(Array.isArray ~x)) xs)))
(defmacro arr? "Refer to array?." [&xs] `(array? ~@xs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro date?
  "True if all args are Dates."
  [&xs] `(_andp_* ~@(map* (lambda* [x] `(= (whatis? ~x) "[object Date]")) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro objectMap?
  "True if all args are Maps."
  [&xs] `(_andp_* ~@(map* (lambda* [x] `(= (whatis? ~x) "[object Map]")) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro objectSet?
  "True if all args are Sets."
  [&xs] `(_andp_* ~@(map* (lambda* [x] `(= (whatis? ~x) "[object Set]")) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro bool? "Refer to boolean?." [&xs] `(boolean? ~@xs))
(defmacro boolean?
  "True if all args are booleans."
  [&xs] `(_andp_* ~@(map* (lambda* [x] `(= (typeof ~x) "boolean")) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro num? "Refer to number?." [&xs] `(number? ~@xs))
(defmacro number?
  "True if all args are numbers."
  [&xs] `(_andp_* ~@(map* (lambda* [x] `(= (typeof ~x) "number")) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro str? "Refer to string?." [&xs] `(string? ~@xs))
(defmacro string?
  "True if all args are strings."
  [&xs] `(_andp_* ~@(map* (lambda* [x] `(= (typeof ~x) "string")) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro fn?
  "True if all args are functions."
  [&xs] `(_andp_* ~@(map* (lambda* [x] `(= (typeof ~x) "function")) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro undef?
  "True if all args are undefineds."
  [&xs] `(_andp_* ~@(map* (lambda* [x] `(= (typeof ~x) "undefined")) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro def?
  "True if all args are defined."
  [&xs] `(_andp_* ~@(map* (lambda* [x] `(not= (typeof ~x) "undefined")) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro nil?
  "True if all args are nulls."
  [&xs] `(_andp_* ~@(map* (lambda* [x] `(= ~x null)) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro zero?
  "True if all args are zeros."
  [&xs] `(_andp_* ~@(map* (lambda* [x] `(= ~x 0)) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro one?
  "True if all args are 1s."
  [&xs] `(_andp_* ~@(map* (lambda* [x] `(= ~x 1)) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro neg?
  "True if all args are negative."
  [&xs] `(_andp_* ~@(map* (lambda* [x] `(< ~x 0)) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro pos?
  "True if all args are positive."
  [&xs] `(_andp_* ~@(map* (lambda* [x] `(> ~x 0)) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro values
  "The values for each element in the Map or Set object."
  [obj] `(Array.from (.values ~obj)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro keys
  "The keys for each element in the Map object."
  [obj] `(Array.from (.keys ~obj)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro properties
  "Returns all properties (including non-enumerable properties except for those which use Symbol) found directly upon a given object."
  [obj] `(Object.getOwnPropertyNames ~obj))
(defmacro enumerables
  "Returns a given object's own enumerable properties."
  [obj] `(Object.keys ~obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro assert
  "Assert a condition else throw Error."
  [tst & msgs] `(if ~tst true (raise! ~@msgs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro false?
  "True if all args are false."
  [&xs] `(_andp_* ~@(map* (lambda* [x] `(= ~x false)) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro true?
  "True if all args are true."
  [&xs] `(_andp_* ~@(map* (lambda* [x] `(= ~x true)) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro when-not
  "Evaluates test. If logical false, evaluates body in an implicit do."
  [tst & xs] `(when (not ~tst) ~@xs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro unless "Refer to when-not." [tst & xs] `(when-not ~tst ~@xs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro if-not
  "Evaluates test. If logical false, evaluates and returns then expr,
otherwise else expr, if supplied, else nil."
  [tst then & [else]] `(if (not ~tst) ~then ~else))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro while
  "Repeatedly executes body while test expression is true."
  [tst & xs] `(for [:while ~tst] ~@xs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro when
  "Evaluates test. If logical true, evaluates body in an implicit do."
  [tst & xs] `(if ~tst (do ~@xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro cond
  "Takes a set of test/expr pairs. It evaluates each test one at a
time.  If a test returns logical true, cond evaluates and returns
the value of the corresponding expr and doesn't evaluate any of the
other tests or exprs."
  [&xs]
  (let* [len (count* xs)]
    (do* (assert* (is-even? len) "cond expects even args")
         (if* (> len 0)
           (let* [c (nth* xs 0)
                  e (nth* xs 1)
                  r (rest* (rest* xs))]
             (if* (is-same? c "else")
               `(if true ~e)
               `(if ~c ~e (cond ~@r))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro ->
  "Threads the expr through the forms. Inserts x as the
second item in the first form, making a list of it if it is not a
list already. If there are more forms, inserts the first form as the
second item in second form, etc."
  [expr form & xs]
  (let* [x `(~(nth* form 0)
                    ~expr ~@(rest* form))]
    (if* (> (count* xs) 0) `(-> ~x ~@xs) `~x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro ->>
  "Threads the expr through the forms. Inserts x as the
last item in the first form, making a list of it if it is not a
list already. If there are more forms, inserts the first form as the
last item in second form, etc."
  [expr form & xs]
  (let* [x `(~@form ~expr)]
    (if* (> (count* xs) 0) `(->> ~x ~@xs) `~x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro let
  "binding => binding-form init-expr
 Evaluates the exprs in a lexical context in which the symbols in
the binding-forms are bound to their respective init-exprs or parts
therein."
  [bindings & xs] `(do (var ~@bindings) ~@xs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro single? "True if coll has only 1 item." [coll] `(= 1 (n# ~coll)))
(defmacro dual? "True if coll has only 2 items." [coll] `(= 2 (n# ~coll)))
(defmacro triple? "True if coll has only 3 items." [coll] `(= 3 (n# ~coll)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro loop
  "Evaluates the exprs in a lexical context in which the symbols in
the binding-forms are bound to their respective init-exprs or parts
therein. Acts as a recur target."
  [bindings & more]
  (let* [es (evens* bindings)
         os (odds* bindings)]
    `((fn []
        (var _x_ nil recur nil
             _f_ (fn [~@es] ~@more) _r_ _f_)
        (set! recur
              (fn []
                (set! _x_ arguments)
                (raw# "if (_r_) {for(_r_=undefined;_r_===undefined;){_r_=_f_.apply(this,_x_);} return _r_;}")
                undefined))
        (recur ~@os)) this)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro concat
  "Returns the concatenation of the elements in the supplied colls."
  [coll x] `(.concat ~coll ~x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro join
  "Returns a string of all elements in coll, as returned by (seq coll),
 separated by a separator."
  [sep coll] `(.join ~coll ~sep))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro do-with
  "varbinding=> symbol init-expr
 Executes the body in a context in which the symbol is always the
  returned value."
  [bindings & xs]
  (let* [f (nth* bindings 0)]
    `(let [~f ~(nth* bindings 1)] ~@xs ~f)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro do->false
  "Executes the exprs in a context in which false is always the returned value."
  [&xs] (let* [a (gensym*)] `(let [~a false] ~@xs ~a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro do->true
  "Executes the exprs in a context in which true is always the returned value."
  [&xs]
  (let* [a (gensym*)] `(let [~a true] ~@xs ~a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro do->nil
  "Executes the exprs in a context in which null is always the returned value."
  [&xs]
  (let* [a (gensym*)] `(let [~a nil] ~@xs ~a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro do->undef
  "Executes the exprs in a context in which undefined is always the returned value."
  [&xs]
  (let* [a (gensym*)] `(let [~a undefined] ~@xs ~a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro do->break!
  "Executes the exprs in a context and ends with a toggle on *break*"
  [&xs]
  `(do ~@xs (break-out-of-loop!)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro inc "Returns a number one greater than x." [x] `(+1 ~x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro dec "Returns a number one lesser than x." [x] `(-1 ~x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro dotimes
  "bindings => name n
 Repeatedly executes body (presumably for side-effects) with name
bound to integers from 0 through n-1."
  [bindings &xs]
  (let* [_t (gensym*)
         b1 (first* bindings)]
    `(for [~b1 0 ~_t ~(nth* bindings 1)
           :while (< ~b1 ~_t) :recur (+1 ~b1)] ~@xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro range

  "(range end)(range start end)(range start end step)

  Returns a seq of nums from start (inclusive) to end
(exclusive), by step, where start defaults to 0, step to 1."

  [a & [b c]]
  (let* [start (if* b a 0)
         end (if* b b a)
         step (if* c c 1)]
    `(do-with [ret []]
       (for [i ~start
             :while (< i ~end) :recur (+ i ~step)]
         (ret.push i)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro apply
  "Applies fn f to the  args."
  [f this args] `(.apply ~f ~this ~args))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro apply*
  "Applies fn f to the var-args."
  [f this & args]
  `(.apply ~f ~this (vec ~@args)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro ch@
  "Returns a new string consisting of the single UTF-16 code unit located at the specified offset into the string."
  [s pos] `(.charAt ~s ~pos))
(defmacro false! "Set x to false." [x] `(set! ~x false))
(defmacro true! "Set x to true." [x] `(set! ~x true))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro repeat
  "Returns a sequence of n x's."
  [n x]
  `(do-with [ret []]
     (for [i 0
           :while (< i ~n)
           :recur (+1 i)] (ret.push ~x))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro doseq

  "Repeatedly executes body with
bindings and filtering as provided by :let :when :while.  Does not retain
the head of the sequence. Returns nil."

  [bindings & xs]
  (let*
    [loopExpr (gensym*)
     escvar (gensym*)
     idxvar (gensym*)
     _let (if* (is-eq? (nth* bindings 2) ':let)
               (nth* bindings 3))
     _while (if* (is-eq? (nth* bindings 2) ':while)
                 (nth* bindings 3)
                 (if* (is-eq? (nth* bindings 4) ':while)
                      (nth* bindings 5)
                      (if* (is-eq? (nth* bindings 6) ':while)
                           (nth* bindings 7)
                           true)))
     _when (if* (is-eq? (nth* bindings 2) ':when)
                (nth* bindings 3)
                (if* (is-eq? (nth* bindings 4) ':when)
                     (nth* bindings 5)
                     (if* (is-eq? (nth* bindings 6) ':when)
                          (nth* bindings 7)
                          true)))]
    `(let [~loopExpr ~(nth* bindings 1)]
       (for [~idxvar 0
             ~escvar false
             :while (and (not ~escvar)
                         (< ~idxvar (alen ~loopExpr))) :recur (+1 ~idxvar)]
         (var ~(nth* bindings 0)
              (nth ~loopExpr ~idxvar))
         ~(if* _let `(var ~@_let))
         (if-not ~_while (set! ~escvar true))
         (when (and (not ~escvar) ~_when) ~@xs)) nil)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro if-some+

  "bindings => binding-form test
  If test is not empty, evaluates then with binding-form bound to the
 value of test, if not, yields else"

  [bindings then & [else]]
  (let* [tst (gensym*)]
    `(let [~tst ~(nth* bindings 1)
           ~(first* bindings) ~tst]
       (if (> (n# ~tst) 0) ~then ~else))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro if-some

  "bindings => binding-form test
  If test is not undefined/nil, evaluates then with binding-form bound to the
 value of test, if not, yields else"

  [bindings then & [else]]
  (let* [tst (gensym*)]
    `(let [~tst ~(nth* bindings 1)
           ~(first* bindings) ~tst]
       (if (or (undef? ~tst)
               (nil? ~tst)) ~else ~then))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro if-let

  "bindings => binding-form test
 If test is true, evaluates then with binding-form bound to the value of
test, if not, yields else"

  [bindings then & [else]]
  (let* [tst (gensym*)]
    `(let [~tst ~(nth* bindings 1)
           ~(first* bindings) ~tst] (if ~tst ~then ~else))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro when-some+

  "bindings => binding-form test
  When test is not empty, evaluates body with binding-form bound to the
 value of test"

  [bindings &xs]
  (let* [tst (gensym*)]
    `(let [~tst ~(nth* bindings 1)
           ~(first* bindings) ~tst]
       (when (> (n# ~tst) 0) ~@xs))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro when-some

  "bindings => binding-form test
  When test is not undefined/nil, evaluates body with binding-form bound to the
 value of test"

  [bindings &xs]
  (let* [tst (gensym*)]
    `(let [~tst ~(nth* bindings 1)
           ~(first* bindings) ~tst]
       (when-not (or (undef? ~tst)
                     (nil? ~tst)) ~@xs))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro when-let

  "bindings => binding-form test
 When test is true, evaluates body with binding-form bound to the value of test"

  [bindings &xs]
  (let* [tst (gensym*)]
    `(let [~tst ~(nth* bindings 1)
           ~(first* bindings) ~tst] (when ~tst ~@xs))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro doto

  "Evaluates x then calls all of the methods and functions with the
value of x supplied at the front of the given arguments.  The forms
are evaluated in order.  Returns x.
 (doto (new Map) (.set \"a\" 1) (.set \"b\" 2))"

  [target & xs]
  (let* [v (gensym*)]
    `(let [~v ~target]
       ~@(map* (lambda* [e]
                    `(~(first* e) ~v ~@(rest* e))) xs) ~v)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro map
  "Creates a new array with the results of
  calling a provided function on every element in the calling array."
  [f coll] `(.map ~coll ~f))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro find
  "Returns the value of the first element in the array
  that satisfies the predicate. Otherwise undefined is returned."
  [p coll] `(.find ~coll ~p))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro filter
  "Creates a new array with all elements that
  pass the test implemented by the provided predicate."
  [p coll] `(.filter ~coll ~p))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro some
  "Tests whether at least one element in the array
  passes the test implemented by the provided predicate."
  [p coll] `(.some ~coll ~p))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro take

  "Returns a sequence of the first n items in coll, or all items if
there are fewer than n."

  [coll cnt] `(slice ~coll 0 ~cnt))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro constantly
  "Returns a function that takes any number of arguments and returns x."
  [x] `(fn [&xs] ~x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro drop
  "Returns a sequence of all but the first n items in coll."
  [coll cnt] `(slice ~coll ~cnt))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro reduce2

  "Applies a function against an accumulator and
  each element in the array (from left to right)
  to reduce it to a single value. No initial value."
  [f coll] `(.reduce ~coll ~f))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro reduce

  "Applies a function against an accumulator and
  each element in the array (from left to right)
  to reduce it to a single value."

  [f start coll] `(.reduce ~coll ~f ~start))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro foldl
  "Refer to reduce"
  [f start coll] `(reduce ~f ~start ~coll))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro str

  "With no args, returns the empty string. With one arg x, returns
x.toString().  (str nil) returns the empty string. With more than
one arg, returns the concatenation of the str values of the args."

  [&xs] `(.join (vec ~@xs) ""))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro lambda
  "Defines a function, with anonymous args."
  [code]
  (let* [sz (count* code)
         body (if* (> sz 1)
                   code
                   (if* (> sz 0) (nth* code 0)))]
    `(fn [] (var ____args (slice arguments)) ~body)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro each
  "Executes a provided function once for each array element."
  [func coll] `(.forEach ~coll ~func))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro each-property
  "Refer to each - iterates through keys of an obj."
  [func obj]
  (let* [t (gensym*)]
    `(let [~t ~obj]
       (each (fn [p] (~func (get ~t p) p)) (properties ~t)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro each-enumerable
  "Refer to each - iterates through enumerable keys of an obj."
  [func obj]
  (let* [t (gensym*)]
    `(let [~t ~obj]
       (each (fn [p] (~func (get ~t p) p)) (enumerables ~t)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro each-key "Refer to each - iterates through a Map or Object."
  [func obj]
  (let* [t (gensym*) f (gensym*)]
    `(let [~t ~obj ~f ~func]
       (if (kirbystdlibref/object? ~t)
         (each-enumerable ~f ~t) (each ~f ~t)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro dosync "For now, do like do." [&exprs] `(do ~@exprs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;monads
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro monad

  "Define a monad by defining the monad operations. The definitions
   are written like bindings to the monad operations bind and
   unit (required) and zero and plus (optional)."

  ^:internal [docstring operations]

  `(do (var~ bind unit zero plus)
       (let [~@operations]
         (object :bind bind :unit unit :zero zero :plus plus))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro defmonad

  "Define a named monad by defining the monad operations. The definitions
   are written like bindings to the monad operations bind and
   unit (required) and zero and plus (optional)."

  [name & [docs operations]]
  (let* [ds (if* (is-str? docs) docs "")
         ps (if* (is-str? docs)
                 operations
                 (if* (is-array? docs) docs))
         _ (assert* (is-array? ps)
                    "no macro operations")]
    `(const ~name (monad ~ds ~ps))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro dobind
  ""
  ^:internal [mbind steps expr]
  (let* [mv (nth* steps 1)
         a1 (nth* steps 0)
         more (rest* (rest* steps))]
    `(~mbind ~mv
             (fn [~a1]
               ~(if* (not-empty* more)
                     `(dobind ~mbind ~more ~expr)
                     `(do ~expr))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro domonad

  "Monad comprehension. Takes the name of a monad, a vector of steps
   given as binding-form, and a result value
   specified by body."

  [monad steps body]
  `((fn [{:keys [bind unit zero] :as mo}]
      (var ret #(if (and (kirbystdlibref/nichts? %)
                         (def? zero)) zero (unit %)))
      (dobind bind ~steps (ret ~body))) ~monad))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;testing stuff
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro deftest
  "" [name & body] `(const ~name #(vec ~@body)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro ensure
  "" [form msg] `(kirbystdlibref/ensureTest ~form ~msg))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro ensureThrown
  "" [expected form msg]
  `(try ~form
        (kirbystdlibref/ensureTestThrown ~expected nil ~msg)
        (catch e
          (kirbystdlibref/ensureTestThrown ~expected e ~msg))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro assert*
  "" [c msg] `(if* ~c true (throw* ~msg)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro cond*
  "" [&xs]
  (if* (> (count* xs) 0)
    (list* 'if*
          (first* xs)
          (nth* xs 1)
          (cons* 'cond* (rest* (rest* xs))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro _andp_*
  "" [&xs]
  (if* (= 1 ~(count* xs)) `~(first* xs) `(and ~@xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;END MACROS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn println
  "Write msg to console." [&msgs]
  (if console (console.log (join "" msgs))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn not-empty

  "If coll is empty, returns nil, else coll."
  [coll]

  (if (empty? coll) nil coll))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- noCRef

  "Use a cache to store already referenced objects
  to prevent circular references."
  []

  (var cache [])
  (fn [k v]
    (cond (fn? v)
          (set! v "native-fn")
          (or (objectMap? v)
              (object? v)
              (objectSet? v))
          (if (contains? cache v)
            (undef! v)
            (conj! cache v))) v))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn stringify

  "JSON stringify (no cyclical obj-ref)"
  ^String [obj]

  (if obj (JSON/stringify obj (noCRef))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn opt??

  "If cur is not defined, returns other else cur"
  ^Any [cur other]

  (if (def? cur) cur other))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn conj!

  "conj[oin]. Returns coll with the xs
  'added'. (conj! nil item) returns [item].
  If coll is a list, prepends else appends to coll."

  ^Array [coll & xs]
  (cond
    (nichts? coll)
    (apply conj! this (concat [[]] xs))
    (array? coll)
    (if (list? coll)
      (->> (xs.reverse)
           (coll.unshift.apply coll))
      (coll.push.apply coll xs))
    (objectSet? coll)
    (doseq [x xs] (.add coll x))) coll)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn conj "Like conj! but
           returns a new collection"
  ^Any [coll & xs]
  (var c (cond
           (array? coll)
           (cond (vector? coll) (into :vector coll)
                 (list? coll) (into :list coll)
                 (map? coll) (into :map coll)
                 (obj? coll) (into :obj coll)
                 (set? coll) (into :set coll)
                 :else (slice coll))
           (objectSet? coll)
           (new Set (.values coll))
           (nichts? coll) []))
  (if c (apply conj! this (concat [c] xs)) coll))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn disj!
  "disj[oin]. Returns a set without these keys"
  [coll & xs]
  (doseq [x xs] (.delete coll x)) coll)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn disj
  "disj[oin]. Returns a new set without these keys"
  [coll & xs]
  (var s2 (new Set xs))
  (new Set (filter #(not (.has s2 %)) (values coll))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn pop!

  "Removes the first element if list,
  else removes the last element,
  returning the element
  and the altered collection"

  ^Array [coll]
  (when (array? coll)
    (var r (if (list? coll)
             (coll.shift) (coll.pop))) [r coll]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn pop
  "Like pop! but returns a new collection"
  ^Array [coll]
  (when (array? coll)
    (var r (if (list? coll)
             (1st coll) (last coll)))
    [r (if (list? coll)
         (coll.slice 1) (coll.slice 0 -1))]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn wrap-str

  "Prepend and append strings to the object."
  [obj start end] (str start obj end))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getProp

  "If prop is a string, returns the value of
  this object property, obeying the own? flag,
  unless if object is a Map, returns value of
  the key. Otherwise, return the value at the
  index of the array."

  ^Any
  [obj prop & [own?]]
  (if (objectMap? obj)
    (.get obj prop)
    (do (set! own? (opt?? own? true))
        (if (or (string? prop)
                (number? prop))
          (if (and own?
                   (string? prop)
                   (not (obj.hasOwnProperty prop)))
            undefined
            (raw# "obj[prop]"))
          undefined))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn prn

  "Print data as string - use to dump an AST node"
  ^String [obj & [r?]]

  (var f (noCRef))
  (if (complex? obj)
    (set! obj (f nil obj)))
  (if obj (prn* obj r? f) ""))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- prnArr* "Print an array" [obj r? f]
  (join " "
        (map (fn [v i]
               (var x (f i v))
               (-> (opt?? x nil)
                   (prn* r? f))) obj)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- prn*

  "" [obj r? func]

  (var pfx #(prn* % r? func)
       parr (if (arr? obj)
              #(wrap-str
                 (prnArr* obj
                          r? func) %1 %2)))
  (case (typeid obj)
    :atom
    (wrap-str (func nil obj.value) "(atom " ")")
    (:lambda-arg :regex-obj :keyword :symbol)
    (.-value obj)
    :object
    (-> (reduce (fn [acc [k v]]
                  (var x (func k v))
                  (if-not (undef? x)
                    (conj! acc (str (pfx k)
                                    ":" (pfx x)))) acc) [] (seq obj))
        (.join  ",")
        (wrap-str "{" "}"))
    :objectMap
    (-> (reduce (fn [acc [k v]]
                  (var x (func k v))
                  (if-not (undef? x)
                    (conj! acc (str (pfx k)
                                    " " (pfx x)))) acc) [] (seq obj))
        (.join  " ")
        (wrap-str "{" "}"))
    :objectSet
    (-> (reduce (fn [acc v]
                  (var x (func v v))
                  (if-not (undef? x)
                    (conj! acc (pfx v))) acc) [] (seq obj))
        (.join  " ")
        (wrap-str "#{" "}"))
    :vector
    (parr "[" "]")
    (:map :obj)
    (parr "{" "}")
    :set
    (parr "#{" "}")
    :list
    (parr "'(" ")")
    :string
    (if r? (quote-str obj) obj)
    (:null :nil)
    "null"
    (if (array? obj)
      (parr "(" ")") (obj.toString))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deftype LambdaArg []
  "Defining a lambda positional argument"
  (constructor "" [arg]
    (var name (if (= arg "%")
                "1" (rest arg))
         v (int name))
    (if-not (> v 0)
      (raise! "invalid lambda-arg " arg))
    (set! this.value (str "%" v)))
  (toString "" [] this.value))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deftype Primitive []
  "Defining a primitive data type"
  (constructor "" [v]
    (set! this.value v))
  (toString "" [] this.value))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deftype RegexObj []
  "Defining a Regex pattern"
  (constructor "" [v]
    (set! this.value v))
  (toString "" [] this.value))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deftype Keyword []
  "Defining a keyword"
  (constructor "" [name]
    (set! this.value name))
  (toString "" []
    (cond (starts-with? this.value "::")
          (str (*ns*) "/" (.slice this.value 2))
          (starts-with? this.value ":") (.slice this.value 1))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deftype Symbol []
  "Defining a symbol"
  (constructor "" [name]
    (set! this.value name))
  (toString "" [] this.value))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn primitive?
  "Returns true if primitive" [obj] (inst? Primitive obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn primitive
  "Create a Primitive" ^Primitive [v] (new Primitive v))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn regexObj?
  "Returns true if a regex" [obj] (inst? RegexObj obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn regexObj
  "Create a new regex" ^RegexObj [name] (new RegexObj name))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn symbol?
  "Returns true if a symbol" [obj] (inst? Symbol obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn symbol
  "Create a new Symbol" ^Symbol [name] (new Symbol name))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn keyword?
  "Returns true if a keyword" [obj] (inst? Keyword obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn keyword
  "Create a new Keyword" ^Keyword [name] (new Keyword name))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn keyword->symbol
  "Convert a Keyword to Symbol" ^Symbol [k]
  (var s (new Symbol (str k)))
  (assign! s
          :source k.source
          :line  k.line
          :column k.column) s)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn lambdaArg?
  "Returns true if a Lambda Arg" [obj] (inst? LambdaArg obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn lambdaArg
  "Create a new Lambda Arg" ^LambdaArg [name] (new LambdaArg name))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deftype Atom []
  "Defining a clojure-like Atom"
  (constructor "" [val] (set! this.value val)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn atom?
  "Returns true if an Atom" [atm] (inst? Atom atm))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn atom
  "Create a new Atom" ^Atom [val] (new Atom val))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn reset!
  "Set a new value to the Atom" [a v] (do->nil (set! a.value v)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn resetVec! "" [v]
  (do->nil (if (array? v) (.splice v 0))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn resetMap! "" [obj]
  (do->nil (if (objectMap? obj) (.clear obj))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn resetSet! "" [obj]
  (do->nil (if (objectSet? obj) (.clear obj))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn resetObject! "" [obj]
  (do->nil
    (if (object? obj)
      (each #(delete! obj %) (properties obj)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn sort!
  "Returns a sorted sequence of the items in coll.
  If no comparator is supplied, uses compare"
  [comp coll]
  (if (fn? comp) (.sort coll comp) (.sort comp)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn XXfind

  "Returns the value of the first element
  in the collection that satisfies the
  provided predicate function"
  [coll pred]

  (var ret nil c nil)
  (for [i 0 sz (n# coll)
        :while (< i sz) :recur (+1 i)]
    (set! c (.@i coll))
    (when (pred c)
      (set! ret c)
      (break-out-of-loop!))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn deref
  "Get value inside the Atom" ^Any [a] (.-value a))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn swap! "Change value inside the Atom,
            returning the new value"
  ^Any [a f & xs]
  (->> (concat [a.value] xs)
       (apply f this)
       (set! a.value )) (get a :value))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn typeid "Returns the type-id
             of this object"
  [obj]
  (cond
    (lambdaArg? obj) :lambda-arg
    (keyword? obj) :keyword
    (symbol? obj) :symbol
    (vector? obj) :vector
    (atom? obj) :atom
    (list? obj) :list
    (map? obj) :map
    (obj? obj) :obj
    (set? obj) :set
    (nil? obj) :null
    (true? obj) :true
    (false? obj) :false
    (fn? obj) :function
    (string? obj) :string
    (number? obj) :number
    (array? obj) :array
    (object? obj) :object
    (objectSet? obj) :objectSet
    (objectMap? obj) :objectMap
    :else
    (raise! "Unknown type [" (type obj) "]")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn complex?
  "True if x is an array
  or js object." [x] (or (array? x)
                         (object? x)
                         (objectMap? x) (objectSet? x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn simple? "True if x is a
              primitive value type" [obj]
  (or (undef? obj)
      (nil? obj) (false? obj) (true? obj) (string? obj) (number? obj)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn value? "Returns true
             if a simple LISP value"
  [obj]
  (or (nil? obj)
      (vector? obj)
      (list? obj)
      (map? obj)
      (obj? obj)
      (set? obj)
      (false? obj)
      (true? obj)
      (string? obj)
      (number? obj)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn sequential? "True if coll
                  implements Sequential"
  [arr] (and (array? arr)
             (not (set? arr))
             (not (obj? arr))
             (not (map? arr))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- set2Set "" [s]
  (var ret (new Set))
  (for [i 0 sz (n# s)
        :while (< i sz) :recur (+1 i)]
    (.add ret (.@i m))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- eqSets? "" [s1 s2]
  (var ok? #t)
  (when (= (.-size s1)
           (.-size s2))
    (.forEach s1
              (fn [v k]
                (if-not (.has s2 v)
                  (false! ok?)))))
  ok?)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- map2Map "" [m]
  (var ret (new Map))
  (for [i 0 sz (n# m)
        :while (< i sz) :recur (+2 i)]
    (.set ret (.@i m) (.@+i m))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- eqMaps? "" [m1 m2]
  (var ok? #t)
  (when (= (.-size m1)
           (.-size m2))
    (.forEach m1
              (fn [v k]
                (if-not (eq? (.get m2 k) v)
                  (false! ok?)))))
  ok?)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- map2Obj "" [m]
  (var ret (object ))
  (var~ k v)
  (for [i 0 sz (n# m)
        :while (< i sz) :recur (+2 i)]
    (set! k (.@i m)
          v (.@+i m))
    (assign! ret (str k) v)) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn eq? "True if both are equal" [a b]
  (var k nil ok? true)
  (cond
    (and (map? a) (map? b)
         (= (alen a) (alen b)))
    (eq? (map2Map a) (map2Map b))

    (and (obj? a) (obj? b)
         (= (alen a) (alen b)))
    (eq? (map2Obj a) (map2Obj b))

    (and (array? a) (array? b)
         (= (alen a) (alen b)))
    (do (for [i 0 sz (alen a)
              :while (and ok? (< i sz)) :recur (+1 i)]
          (when-not (eq? (.@i a)
                         (.@i b)) (false! ok?))) ok?)
    (and (set? a) (set? b)
         (= (alen a) (alen b)))
    (eqSets? (set2Set a) (set2Set b))

    (and (inst? LambdaArg a)
         (inst? LambdaArg b))
    (= a.value b.value)
    (and (inst? Symbol a)
         (inst? Symbol b))
    (= a.value b.value)
    (and (inst? Keyword a)
         (inst? Keyword b))
    (= a.value b.value)
    (and (object? a)
         (object? b)
         (= (n# a) (n# b)))
    (do (for [i 0 ks (Object.keys a) sz (n# ks)
              :while (and ok? (< i sz)) :recur (+1 i)]
          (set! k (.@i ks))
          (when-not (eq? (get a k)
                         (get b k)) (false! ok?))) ok?)
    (and (objectMap? a)
         (objectMap? b))
    (eqMaps? a b)


    (and (objectSet? a)
         (objectSet? b))
    (eqSets? a b)

    :else
    (= a b)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn object? "Returns true
              if a js object" [obj]
  (if-not (or (nil? obj)
              (objectMap? obj)
              (objectSet? obj)
              (array? obj)) (= (type obj) "object")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn last "Returns the last element"
  ^Any [coll]
  (if (and (array? coll)
           (nzlen? coll)) (nth coll (last-index coll))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn into! "Assign a type to this collection"
  ^Array [type coll]
  (case type
    (:list :set :obj :map :vector)
    (assign! coll :____typeid type)) coll)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn into "Like into! but
           returning a new collection"
  ^Array [type coll]
  (into! type (coll.slice 0)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn pairs? "Returns true if
             a LISP list, not data" [obj]
  (and (array? obj)
       (not (vector? obj))
       (not (set? obj))
       (not (obj? obj))
       (not (map? obj)) (not (list? obj))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn list? "Returns true if a List"
  [obj] (and (array? obj)
             (== obj.____typeid :list)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn list
  "Create a List" ^Array [&xs] (assign! xs :____typeid :list) xs)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn vector? "Returns true if a Vector"
  [obj] (and (array? obj)
             (== obj.____typeid :vector)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn vector
  "Create a Vector" ^Array [&xs] (assign! xs :____typeid :vector) xs)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn set? "Returns true if a Set"
  [obj] (and (array? obj)
             (== obj.____typeid :set)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn set
  "Create a Set" ^Array [&xs] (assign! xs :____typeid :set) xs)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn map? "Returns true if a Hashmap"
  [obj] (and (array? obj)
             (== obj.____typeid :map)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn obj? "Returns true if a Object"
  [obj] (and (array? obj)
             (== obj.____typeid :obj)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn arraymap "Create a new array map"
  ^Array [&xs]
  (if (odd? (alen xs))
    (raise! "Invalid arity for arraymap"))
  (assign! xs :____typeid :map) xs)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn object "Create a new js object"
  ^Object [&xs]
  (if (odd? (alen xs))
    (raise! "Invalid arity for object"))
  (zipobj (evens xs) (odds xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn seq "Returns a sequence"
  ^Array [obj]
  (cond
    (string? obj) (obj.split "")
    (array? obj) (obj.slice 0)
    (objectSet? obj) (Array.from (.values obj))
    (objectMap? obj) (Array.from (.entries obj))
    (object? obj) (Object.entries obj)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn contains? "True if item is inside" [coll x]
  (cond
    (or (array? coll)
        (string? coll)) (coll.includes x)
    (objectSet? coll) (.has coll x)
    (objectMap? coll) (.has coll x)
    (object? coll) (coll.hasOwnProperty x) :else false))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn nichts? "True if object is
              either null of undefined" [obj] (or (undef? obj) (nil? obj)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn some? "True if object is
            defined and not null" [obj] (not (nichts? obj)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn count "Count the number of elements inside"
  ^Integer [coll]
  (if coll
    (if (or (objectMap? coll)
            (objectSet? coll))
      (.-size coll)
      (alen (if (or (string? coll)
                    (array? coll)) coll (Object.keys coll)))) 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn concat* "Add many to this collection"
  ^Array [coll & xs]
  (if coll (coll.concat.apply coll xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- every "" ^Array [coll start step]
  (var ret [])
  (for [i start sz (n# coll)
        :while (< i sz) :recur (+ i step)] (conj! ret (.@i coll))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn evens "Collect every
            2nd item starting at 0" ^Array [coll] (every coll 0 2))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn odds "Collect every
           2nd item starting at 1" ^Array [coll] (every coll 1 2))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn modulo "Modulo"
  ^Integer [x N]
  (if (< x 0)
    (- x (* -1
            (+ N (* (Math.floor (div (- x) N)) N))))
    (rem x N)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn partition

  "Returns a sequence of lists of n items each."

  ^Array [n coll]
  (loop [ret []
         [x y] (split-seq coll n)]
    (if (not-empty x) (conj! ret x))
    (if (empty? y)
      ret
      (recur ret (split-seq y n)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn split-str

 "Returns a sequence of strings of n characters each."
  [n string]

  (var ret [])
  (for [i 0 sz (n# string) :while (< i sz)]
    (conj! ret (.substr string i n))
    (set! i (+ i n))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn interleave "Returns a seq of the first item
                 in each coll, then the second, etc"
  ^Array [c1 c2]
  (var cz (if (< (alen c2)
                 (alen c1))
            (alen c2) (alen c1))
       ret [])
  (for [i 0
        :while (< i cz) :recur (+1 i)] (conj! ret (.@i c1) (.@i c2))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn zipmap "Returns an object with the
             keys mapped to the corresponding vals"
  ^Map [keys vals]
  (var cz (if (< (alen keys)
                 (alen vals))
            (alen keys) (alen vals))
       ret {})
  (for [i 0
        :while (< i cz) :recur (+1 i)]
    (assoc! ret (.@i keys) (.@i vals))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn zipobj "Returns an object with the
             keys mapped to the corresponding vals"
  ^Map [keys vals]
  (var cz (if (< (alen keys)
                 (alen vals))
            (alen keys) (alen vals))
       ret (object))
  (for [i 0
        :while (< i cz) :recur (+1 i)]
    (assoc! ret $(.@i keys) (.@i vals))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn extendAttr "" ^Object [obj attr & [flags]]
  (set! flags (opt?? flags
                   (object :enumerable #f :writable #t)))
  (Object.defineProperty obj attr flags) obj)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn cons
  "Returns a new seq where x is the first element and seq is
  the rest." [x coll] (when (array? coll)
                        (.concat [x] coll)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- gensym-counter (atom 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn gensym "Generates next random symbol"
  ^Symbol [& [pfx]]
  (symbol (str (opt?? pfx "GS__")
               (swap! gensym-counter
                      (fn [x] (+1 x))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn carve "" ^Array [coll & [start end]]
  (if (def? end)
    (Array.prototype.slice.call coll start end)
    (if (def? start)
      (Array.prototype.slice.call coll start)
      (Array.prototype.slice.call coll))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn assoc! "" ^Any [obj & xs]
  (var~ k v)
  (when obj
    (for [i 0 sz (n# xs)
          :while (< i sz) :recur (+2 i)]
      (set! k (.@i xs)
            v (.@+i xs))
      (cond
        (objectMap? obj) (.set obj k v)
        (object? obj) (raw# "obj[k]=v")))) obj)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn dissoc! "" ^Any [obj & xs]
  (var~ k)
  (when obj
    (for [i 0 sz (n# xs)
          :while (< i sz) :recur (+1 i)]
      (set! k (.@i xs))
      (cond
        (objectMap? obj) (.delete obj k)
        (object? obj) (raw# "delete obj[k]")))) obj)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn truthy? "LISP truthy" [a] (not (falsy? a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn falsy? "LISP falsy" [a] (or (nil? a)(false? a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn flatten
  "Flatten an array" [xs]
  (reduce (fn [acc v] (concat acc v)) [] xs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn identity "Returns its argument." [x] x)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;monads
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmonad m-identity

  "Monad describing plain computations. This monad does in fact nothing
  at all. It is useful for testing, for combination with monad
  transformers, and for code that is parameterized with a monad."

  [ bind (fn [mv mf] (mf mv)) unit #(%1)] )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmonad m-maybe

  "Monad describing computations with possible failures. Failure is
  represented by nil, any other value is considered valid. As soon as
  a step returns nil, the whole computation will yield nil as well."

  [bind (fn [mv mf]
          (if-not (nil? mv) (mf mv))) unit #(%1) zero nil] )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmonad m-list

  "Monad describing multi-valued computations, i.e. computations
  that can yield multiple values. Any object implementing the seq
  protocol can be used as a monadic value."

  [bind (fn [mv mf] (flatten (map mf mv)))
   unit #(concat [] %)
   zero []
   plus #(flatten ____args) ])


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmonad m-state

  "Monad describing stateful computations. The monadic values have the
  structure (fn [old-state] [result new-state])."

  [bind (fn [mv mf]
          (fn [state]
            (let [[value newState] (mv state)]
              ((mf value) newState))))
   unit (fn [v] #([v %1])) ])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmonad m-continuation

  "Monad describing computations in continuation-passing style. The monadic
  values are functions that are called with a single argument representing
  the continuation of the computation, to which they pass their result."

  [bind (fn [mv mf]
          (fn [cont]
            (mv (fn [value] ((mf value) cont)))))
   unit (fn [value] (fn [cont] (cont value))) ])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn run-cont
  "Execute the computation cont
  in the cont monad and return its result."
  [cont]
  (cont identity))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn quote-str "Add quotes around a string" ^String [s]
  (var out "\"")
  (for [i 0 ch "" sz (count s)
        :while (< i sz) :recur (+1 i)]
    (set! ch (ch@ s i))
    (cond
      (= ch "\"") (+= out "\\\"")
      (= ch "\n") (+= out "\\n")
      (= ch "\t") (+= out "\\t")
      (= ch "\f") (+= out "\\f")
      (= ch "\r") (+= out "\\r")
      (= ch "\v") (+= out "\\v")
      (= ch "\\") (+= out (if (= "u" (ch@ s (+1 i))) ch "\\\\"))
      :else (+= out ch)))
  (+= out "\""))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn unquote-str "Removes quotes around a string" ^String [s]
  (if (and (starts-with? s "\"")
           (ends-with? s "\""))
    (do-with [out ""]
      (set! s (s.slice 1 -1))
      (for [i 0 nx "" ch "" sz (count s)
            :while (< i sz) :recur (+1 i)]
        (set! ch (ch@ s i))
        (if (= ch "\\")
          (do (++ i)
              (set! nx (ch@ s i))
              (cond
                (= nx "\"") (+= out "\"")
                (= nx "\\") (+= out "\\")
                (= nx "n") (+= out "\n")
                (= nx "t") (+= out "\t")
                (= nx "f") (+= out "\f")
                (= nx "v") (+= out "\v")
                (= nx "r") (+= out "\r")
                :else (do (+= out ch) (-- i))))
          (+= out ch))))
    s))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn escXml "Escape XML special chars" ^String [s]
  (var out "")
  (for [i 0 c nil sz (n# s)
        :while (< i sz) :recur (+1 i)]
    (set! c (.@i s))
    (cond
      (= c "&") (set! c "&amp;")
      (= c ">") (set! c "&gt;")
      (= c "<") (set! c "&lt;")
      (= c "\"") (set! c "&quot;")
      (= c "'") (set! c "&apos;"))
    (+= out c))
  out)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn split-seq "Split a collection into 2 parts" ^Array [coll cnt]
  (if (< cnt (count coll))
    [(take coll cnt) (drop coll cnt)]
    [(slice coll 0) []]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn select-keys "Get a subset of keys" ^Map [coll keys]
  (reduce
    (fn [acc n]
      (assoc! acc
              n
              (.get coll n))) (new Map) (seq keys)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- doUpdateIn! "" [coll n func args err]
  (var cur (cond
             (number? n)
             (if (and (array? coll)
                      (< n (alen coll))) (nth coll n) (err n))
             :else (.get coll n))
       v (apply func this (cons cur args)))
  (assoc! coll n v))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn update-in!

  "'Updates' a value in a nested associative structure, where ks is a
sequence of keys and f is a function that will take the old value
and any supplied args and return the new value, and returns a new
nested structure.  If any levels do not exist, hash-maps will be
created."

  ^Map [coll keys func & xs]

  (var err #(raise! "update-in! failed, bad nested keys: " %))
  (var root coll
       end (last-index keys))
  (var~ m n)
  (for [i 0 :while (<= i end) :recur (+1 i)]
    (set! n (.@i keys))
    (cond
      (= i end)
      (doUpdateIn! root n func xs err)
      (number? n)
      (if-not (and (array? root)
                   (< n (alen root)))
        (err n)
        (set! root (nth root n)))
      :else
      (do (set! m (.get root n))
          (when (undef? m) (set! m (new Map)) (assoc! root n m))
          (if-not (objectMap? m) (err n))
          (set! root m))))
  coll)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn get-in
  "Returns the value in a nested associative structure,
  where ks is a sequence of keys. Returns nil if the key
  is not present, or the not-found value if supplied."
  ^Any [coll keys]

  (var root coll
       ret nil
       end (last-index keys))
  (var~ m n)
  (for [i 0 :while (<= i end) :recur (+1 i)]
    (set! n (.@i keys))
    (cond
      (number? n)
      (if-not (and (array? root)
                   (< n (alen root)))
        (do->break! (set! ret nil))
        (set! root (nth root n)
              ret root))
      :else
      (do (set! root (.get root n)
                ret root)))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- merge! "" [base m]
  (var ret (or base (new Map))
       src (or m (new Map)))
  (each-key (fn [v k]
              (assoc! ret k v)) src) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn merge

  "Returns a map that consists of the rest of the maps conj-ed onto
the first.  If a key occurs in more than one map, the mapping from
the latter (left-to-right) will be the mapping in the result."

  [&maps] (reduce (fn [acc n] (merge! acc n)) (new Map) maps))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn fillArray "" [len v]
  (var ret [])
  (dotimes [x len]
    (conj! ret (if (fn? v) (v x) v))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn copyArray "" [src des]
  (var sz (Math/min (n# src)
                    (n# des)))
  (for [i 0 :while (< i sz) :recur (+1 i)]
    (aset des i (nth src i)))
  des)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn difference
  "Return a set that is the first set
  without elements of the other set."
  [a b]

  (var ret [] z nil)
  (for [i 0 sz (n# a)
        :while (< i sz) :recur (+1 i)]
    (set! z (.@i a))
    (if-not (contains? b z) (conj! ret z)))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn percent "" ^Number [numerator denominator]
  (* 100.0 (div numerator denominator)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn toFixed "" ^String [num digits]
  (set! digits (opt?? digits 2))
  (.toFixed (Number num) digits))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;testing stuff
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn ensureTest "" [cnd msg]
  (set! msg (or msg "test"))
  (try (str (if cnd "passed:" "FAILED:") " " msg)
       (catch e (str "FAILED: " msg))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn ensureTestThrown "" [expected error msg]
  (if (nil? error)
    (str "FAILED: " msg)
    (if (or (= expected (type error))
            (= expected "any"))
      (str "passed: " msg)
      (str "FAILED: " msg))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn runtest "" [test & [title]]
  (set! title (opt?? title "test"))
  (var now (new Date)
       results (test)
       sum (n# results)
       ok (n# (filter #(starts-with? % "p") results))
       ps (toFixed (percent ok sum)))
  (->> [(.repeat "+" 78)
        title now
        (.repeat "+" 78)
        (join "\n" results)
        (.repeat "=" 78)
        (str "Passed: " ok "/" sum " [" ps "%]")
        (str "Failed: " (- sum ok))
        (str "CPU Time: " (- (new Date) now) "ms")]
       (join "\n")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- *ns-cache* (atom [{:id "user" :meta nil}]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn pushNSP "" [nsp & [info]]
  (var obj {:id nsp :meta info})
  (swap! *ns-cache*
         (fn [a] (.unshift a obj) a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn popNSP "" []
  (swap! *ns-cache*
         (fn [a] (.shift a) a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn peekNSP "" [] (nth (deref *ns-cache*) 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn *ns* "" [] (if-some [n (peekNSP)] (get n :id)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF




