;; Copyright (c) 2013-2017, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http:;;opensource.org;licenses;eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author "Kenneth Leung"}

  czlab.kirby.compiler

  (include "./reader.kirby"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(def- MODULE-VERSION "1.0.0"
      loadedMacros? false
      noSemi? false
      tabspace 2
      VARGS "&rest"
      TILDA "~"
      indent (- tabspace)
      TILDA-VARGS (str TILDA VARGS))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;module exports
(def- *externs* nil)
(def- *nspaces* nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- banner []
  (str "/*"
       "Auto generated by Kirby - v"
       MODULE-VERSION
       " "
       "*/\n\n"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(def- SPECIAL-OPS {})
(def- MACROS-MAP {})
(def- ERRORS-MAP {
  :e0 "Syntax Error"
  :e1 "Empty statement"
  :e2 "Invalid characters in function name"
  :e3 "End of File encountered, unterminated string"
  :e4 "Closing square bracket, without an opening square bracket"
  :e5 "End of File encountered, unterminated array"
  :e6 "Closing curly brace, without an opening curly brace"
  :e7 "End of File encountered, unterminated javascript object '}'"
  :e8 "End of File encountered, unterminated parenthesis"
  :e9 "Invalid character in var name"
  :e10 "Extra chars at end of file. Maybe an extra ')'."
  :e11 "Cannot Open include File"
  :e12 "Invalid no of arguments to "
  :e13 "Invalid Argument type to "
  :e14 "End of File encountered, unterminated regular expression"
  :e15 "Invalid vararg position, must be last argument."
  :e16 "Invalid arity (args > expected) to "
  :e17 "Invalid arity (args < expected) to " })

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- eval?? [x]
  (if (list? x) (evalList x) x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- node? [obj]
  (and (object? obj)
       (true? (get obj "$$$isSourceNode$$$"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- error! [e line file msg]
  (throw
    (new Error
         (str (get ERRORS-MAP e)
              (if msg (str " : " msg))
              (if line (str "\nLine no " line))
              (if file (str "\nFile " file))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- syntax! [ecode expr cmd]
  (error! ecode
          (if expr (get expr :line))
          (if expr (get expr :source)) cmd))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- assertArgs [expr cnt ecode msg]
  (if (not= (alen expr) cnt) (syntax! ecode expr msg)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- pad [z] (.repeat " " z))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- toASTree [code fname]
  (var state {:codeStr (str "(" code ")")
              :source fname
              :colno 1
              :line 1
              :pos 1
              :tcol 1 })
  (do-with [ret (lexer nil state)]
    (if (< state.pos (alen state.codeStr)) (error! :e10))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- parseTree [root]

  (var pstr ""
       endx (eindex root)
       treeSize (alen root))

  (+= indent tabspace)
  (set! pstr (pad indent))

  (do-with [ret (tnode)]
    (nodeTag ret
             (get root :source)
             (get root :line)
             (get root :column)
             tkn-tree)
    (each
      (fn [expr i]
        (var name (name?? (car expr))
             r ""
             tmp (if (list? expr)
                   (evalList expr) expr))
        (when (and (array? tmp)
                   (= tkn-ns (.-eTYPE tmp)))
          (each (fn [x] (.add ret x)) tmp)
          (set! tmp nil))
        (if (and (= i endx)
                 (not= 0 indent)
                 (not (REGEX.noret.test name)))
          (set! r "return "))
        (when tmp
          (.add ret [(str pstr r)
                     tmp
                     (if-not noSemi? ";" "") "\n"])
          (set! noSemi? false))) root)
    (-= indent tabspace)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- evalList [expr]

  (var cmd "" tmp nil mc nil)

  (cond
    (= tkn-object (.-eTYPE expr)) (set! cmd "{")
    (= tkn-array (.-eTYPE expr)) (set! cmd "[")
    :else
    (do (set! cmd (name?? (car expr)))
        (set! mc (get MACROS-MAP cmd))))

  (cond
    (some? mc)
    (eval?? (evalMacro mc expr))

    (.startsWith cmd ".-")
    (do-with [ret (tnode)]
      (.add ret (eval?? (cadr expr)))
      (.prepend ret "(")
      (.add ret [")[\"" (.slice cmd 2) "\"]"]))

    (= (.charAt cmd 0) ".")
    (do-with [ret (tnode)]
      (.add ret (eval?? (cadr expr)))
      (.add ret [(car expr) "("])
      (for ((i 2) (< i (alen expr)) (i (inc i)))
        (if (not= i 2) (.add ret ","))
        (.add ret (eval?? (nth expr i))))
      (.add ret ")"))

    (.hasOwnProperty SPECIAL-OPS cmd)
    ((get SPECIAL-OPS cmd) expr)

    :else
    (do (evalAtoms expr)
        (set! cmd (car expr))
        (if-not cmd (syntax! :e1 expr))
        (if (REGEX.func.test cmd)
          (set! cmd (tnodeEx ["(" cmd ")"])))
        (tnodeEx [cmd "("
                  (-> (.slice expr 1)
                      (tnodeEx )
                      (.join  ",")) ")"]))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- evalAtoms [cells]
  (each
    (fn [cell i cc]
      (if (list? cell)
        (set! cc i (evalList cell)))) cells))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- expandMacro [cmd code data frags]
  (var ret (nodeTag []
                    data.source
                    data.line
                    data.column
                    (.-eTYPE code))
       tmp nil
       sname (name?? (cadr code))
       ename (name?? (car code))
       frag (get frags (str TILDA sname)))

  (cond
    (= ename "#<<")
    (if-not (list? frag)
      (syntax! :e13 data cmd)
      (.shift frag))
    ;;
    (= ename "#head")
    (if-not (list? frag)
      (syntax! :e13 data cmd)
      (if (not-empty frag) (car frag)))
    ;;
    (= ename "#tail")
    (if-not (list? frag)
      (syntax! :e13 data cmd)
      (if (not-empty frag) (last frag)))
    ;;=> 0,2,4...
    (.startsWith ename "#evens")
    (do-with [r []]
      (for ((i 0) (< i (alen frag)) (i (+ i 2)))
        (conj!! r (nth frag i)))
      (if (.endsWith ename "*")
        (set! r "____split" true)))
    ;;=> 1,3,5...
    (.startsWith ename "#odds")
    (do-with [r []]
      (for ((i 1) (< i (alen frag)) (i (+ i 2)))
        (conj!! r (nth frag i)))
      (if (.endsWith ename "*")
        (set! r "____split" true)))
    ;;
    (.startsWith ename "#slice@")
    (do (if-not (list? frag) (syntax! :e13 data cmd))
        (set! tmp (REGEX.macroGet.exec ename))
        (car (.splice frag (dec (cadr tmp)) 1)))
    ;;
    (= ename "#if")
    (do (if-not (list? frag) (syntax! :e13 data cmd))
        (cond
          (not-empty frag)
          (expandMacro cmd (caddr code) data frags)
          (and (> (alen code) 3)
               (nth code 3))
          (expandMacro cmd (cadddr code) data frags)))
    ;;
    :else
    (let [cell nil]
      (for ((i 0) (< i (alen code)) (i (inc i)))
        (set! cell (nth code i))
        (if (list? cell)
          (let [c (expandMacro cmd cell data frags)]
            (if (and (list? c)
                     (true? (get c "____split")))
              (for ((k 0) (< k (alen c)) (k (inc k)))
                (conj!! ret (nth c k)))
              (conj!! ret c)))
          (let [atSign? false
                rs nil
                tn (name?? cell)]
            (set! tmp cell)
            (when (.includes tn "@")
              (set! rs (.replace tn "@" ""))
              (set! atSign? true)
              (set! tmp
                    (tnode cell.source
                           cell.line
                           cell.column rs rs)))
            (if-some [r (get frags (name?? tmp))]
              (do (if (or atSign?
                          (= (name?? tmp) TILDA-VARGS))
                    (for ((j 0) (< j (alen r)) (j (inc j)))
                      (conj!! ret (nth r j)))
                    (conj!! ret r)))
              (conj!! ret cell)))))
      ret)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- evalMacro [mc data]
  (var args (get mc :args)
       cmd (get mc :name)
       code (get mc :code)
       vargs false
       tpos 0
       i 0
       frags {})

  ;;map all args to actual data, say &rest -> rest of the data
  ;;tpos is always one ahead to skip out the macro cmd
  (for ((tpos (inc i))
        (< i (alen args)) (i (inc i) tpos (inc i)))
    (if (= (name?? (nth args i)) VARGS)
      (do (set! vargs true)
          (set! frags TILDA-VARGS (.slice data tpos)))
      (set! frags
            (str TILDA (name?? (nth args i)))
            (if (>= tpos (alen data))
              (tnodeEx "undefined") (nth data tpos)))))

  ;;check if enough args were supplied to the macro
  (if (and (not vargs)
           (< (inc i) (alen data))) (syntax! :e16 data cmd))

  (expandMacro cmd code data frags))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-compOp [expr]
  (if (< (alen expr) 3) (syntax! :e0 expr))
  (evalAtoms expr)
  (let [cmd (name?? (car expr))]
    (if (= cmd "!=") (aset expr 0 "!=="))
    (if (= cmd "=") (aset expr 0 "===")))
  (do-with [ret (tnode)]
    (for ((i 0 op (.shift expr))
          (< i (dec (alen expr))) (i (inc i)))
      (.add ret (tnodeEx [(nth expr i)
                          " "
                          op
                          " "
                          (nth expr (inc i))])))
    (.join ret " && ")
    (.prepend ret "(")
    (.add ret ")")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(each (fn [k]
        (set! SPECIAL-OPS k sf-compOp))
      ["!=" "==" "=" ">" ">=" "<" "<="])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-arithOp [expr]
  (if (< (alen expr) 2) (syntax! :e0 expr))
  (evalAtoms expr)
  (var op (tnode)
       e1 (.shift expr)
       cmd (name?? e1))
  (do-with [ret (tnode)]
    (if (= 1 (alen expr))
      (if (= "-" cmd) (.add ret "-"))
      (.add op [" " e1 " "]))
    (.add ret expr)
    (if (> (alen expr) 1) (.join ret op))
    (.prepend ret "(")
    (.add ret ")")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(each (fn [k]
        (set! SPECIAL-OPS k sf-arithOp)) ["+" "-" "*" "/" "%"])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-logicalOp [expr] (sf-arithOp expr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(each (fn [k]
        (set! SPECIAL-OPS k sf-logicalOp))
      ["||" "&&" "^" "|" "&" ">>>" ">>" "<<"])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-repeat [expr]
  (assertArgs expr 3 :e0)
  (evalAtoms expr)
  (do-with [ret (tnode)]
    (for ((i 0
           end (parseInt (name?? (cadr expr))))
          (< i end)
          (i (inc i)))
      (if (not= i 0) (.add ret ","))
      (.add ret (caddr expr)))
    (.prepend ret "[")
    (.add ret "]")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "repeat-n" sf-repeat)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-do [expr]
  (var p (pad indent)
       e nil
       end (eindex expr))
  (do-with [ret (tnode)]
    (for ((i 1) (< i end) (i (inc i)))
      (set! e (nth expr i))
      (.add ret [p (evalList e) ";\n"]))
    (when (> end 0)
      (set! e (eval?? (last expr)))
      (.add ret [p "return " e ";\n"])
      (.prepend ret
                (str p "(function() {\n"))
      (.add ret (str p "}).call(this)")))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "do" sf-do)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-doto [expr]

  (if (< (alen expr) 2) (syntax! :e0 expr))

  (var p (pad indent)
       p2 (pad (+ indent tabspace))
       p3 (pad (+ indent (* 2 tabspace)))
       e nil
       e1 (eval?? (cadr expr)))

  (do-with [ret (tnode)]
    (.add ret [p2 "let ____x = " e1 ";\n"])
    (for ((i 2) (< i (alen expr)) (i (inc i)))
      (set! e (nth expr i))
      (.splice e 1 0 "____x")
      (.add ret [p3 (evalList e) ";\n"]))
    (.add ret [p2 "return ____x;\n"])
    (.prepend ret
              (str p
                   "(function() {\n"))
    (.add ret (str p "}).call(this)"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "doto" sf-doto)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-case [expr]
  (if (< (alen expr) 4) (syntax! :e0 expr))
  (var tst (cadr expr)
       e nil t nil c nil dft nil)
  (if (odd? (alen expr))
    (set! dft (.pop expr)))
  (do-with [ret (tnode)]
    (for ((i 2)
          (< i (alen expr))(i (+ i 2)))
      (set! c (nth expr (inc i)))
      (set! e (nth expr i))
      (set! t (.-eTYPE e))
      (cond
        (= tkn-list t)
        (for ((j 0)
              (< j (alen e))(j (inc j)))
          (.add ret ["case " (nth e j) ":\n"])
          (if (= j (eindex e))
            (.add ret [(eval?? c) ";\nbreak;\n"])))
        :else
        (do (.add ret ["case " e ":\n"])
            (.add ret [(eval?? c) ";\nbreak;\n"]))))
    (when dft
      (.add ret "default:\n")
      (.add ret [(eval?? dft) ";\nbreak;\n"]))
    (.prepend ret ["switch (" (eval?? tst) ") {\n"])
    (.add ret "}\n")
    (.prepend ret "(function() {\n")
    (.add ret "}).call(this)")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "case" sf-case)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-range [expr]

  (if (or (< (alen expr) 2 )
          (> (alen expr) 4)) (syntax! :e0 expr))

  (var len 0 start 0 step 1 end 0)
  (evalAtoms expr)
  (set! len (alen expr))
  (set! end (parseInt (name?? (cadr expr))))

  (do-with [ret (tnode)]
    (when (> len 2)
      (set! start (parseInt (name?? (cadr expr))))
      (set! end (parseInt (name?? (caddr expr)))))
    (if (> len 3)
      (set! step (parseInt (name?? (nth expr 3)))))
    (for ((i start) (< i end) (i (+ i step)))
      (if (not= i start) (.add ret ","))
      (.add ret (str "" i)))
    (.prepend ret "[")
    (.add ret "]")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "range" sf-range)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-var [expr cmd]

  ;;must be even pairs
  (if (or (< (alen expr) 3)
          (= 0 (mod (alen expr) 2))) (syntax! :e0 expr))

  (var vname nil
       public? (= "global" cmd))

  (if (> (alen expr) 3) (+= indent tabspace))

  (if (or public?
          (= "local" cmd)) (set! cmd "var"))

  (evalAtoms expr)
  (do-with [ret (tnode)]
    (for ((i 1) (< i (alen expr)) (i (+ i 2)))
      (if (> i 1)
        (.add ret (str ",\n" (pad indent))))
      (if-not (testid? (nth expr i)) (syntax! :e9 expr))
      (set! vname (nth expr i))
      (if (and public?
               (= 1 (alen *nspaces*)))
        (set! *externs* vname vname))
      (.add ret [vname " = " (nth expr (inc i))]))
    (.prepend ret " ")
    (.prepend ret cmd)
    (if (> (alen expr) 3)
      (-= indent tabspace))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "def-" (fn [x] (sf-var x "local")))
(set! SPECIAL-OPS "def" (fn [x] (sf-var x "global")))
(set! SPECIAL-OPS "var" (fn [x] (sf-var x "let")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-new [expr]
  (if (< (alen expr) 2) (syntax! :e0 expr))
  (do-with [ret (tnode)]
    (.add ret (evalList (.slice expr 1)))
    (.prepend ret "new ")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "new" sf-new)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-throw [expr]
  (assertArgs expr 2 :e0)
  (do-with [ret (tnode)]
    (.add ret (eval?? (cadr expr)))
    (.prepend ret "throw ")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "throw" sf-throw)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-while [expr]
  (if (< (alen expr) 2) (syntax! :e0 expr))
  (var tst (cadr expr))
  (.splice expr 0 2 (tnodeEx "do" "do"))
  (do-with [ret nil]
    (set! ret
          (tnodeEx
            ["while "
             (eval?? tst) " {\n"
             (evalList expr) ";\n}\n"]))
    (.prepend ret
              (str "(function () {\n"))
    (.add ret "}).call(this)")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "while" sf-while)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-x-opop [expr]
  (if (not= (alen expr) 2) (syntax! :e0 expr))
  (tnodeEx [(car expr) (eval?? (cadr expr))]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(each (fn [k]
        (set! SPECIAL-OPS k sf-x-opop))
      ["++" "--"])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-x-eq [expr]
  (assertArgs expr 3 :e0)
  (tnodeEx [(cadr expr)
            " "
            (car expr)
            " "
            (eval?? (caddr expr))]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(each (fn [k]
        (set! SPECIAL-OPS k sf-x-eq))
      ["+=" "-="])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-set [expr]
  (if-not (or (= (alen expr) 3)
              (= (alen expr) 4)) (syntax! :e0 expr))
  (do-with [ret (tnode)]
    (if (= (alen expr) 4)
      (do
        (.add ret (eval?? (cadr expr)))
        (.add ret "[")
        (.add ret (eval?? (caddr expr)))
        (.add ret "]"))
      (.add ret (cadr expr)))
    (.add ret [" = " (eval?? (last expr))])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "aset" sf-set)
(set! SPECIAL-OPS "set!" sf-set)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-anonFunc [expr]
  (if (< (alen expr) 2) (syntax! :e0 expr))
  (if-not (list? (cadr expr)) (syntax! :e0 expr))
  (var args (cadr expr)
       body (.slice expr 2))
  (do-with [ret (tnodeEx args)]
    (.join ret ",")
    (.prepend ret "function (")
    (.add ret [") {\n"
               (parseTree body)
               (pad indent) "}"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "fn" sf-anonFunc)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-func [expr public?]
  (if (< (alen expr) 3) (syntax! :e0 expr))
  (var fname (normalizeId
               (name?? (cadr expr)))
       doc nil args 2 body 3)
  (when (= tkn-string
           (get (caddr expr) :eTYPE))
    (set! doc 2)
    (set! args 3)
    (set! body 4))
  (if doc (set! doc (nth expr doc)))
  (set! args (nth expr args))
  (set! body (.slice expr body))
  (do-with [ret nil]
    (set! ret (tnodeEx args))
    (.join ret ",")
    (.prepend ret (str "function " fname "("))
    (.add ret [") {\n"
               (parseTree body)
               (pad indent) "}"])
    (when doc
      (->>
        (map (fn [x] (str "//" x "\n"))
                 (-> (name?? doc)
                     (.replace REGEX.dquoteHat "")
                     (.replace REGEX.dquoteEnd "")
                     (.split "\\n")))
        (.prepend ret )))
    (if (and public?
             (= 1 (alen *nspaces*)))
      (set! *externs* fname fname))
    (set! noSemi? true)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "defn-" (fn [x] (sf-func x false)))
(set! SPECIAL-OPS "defn" (fn [x] (sf-func x true)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-try [expr]
  (var sz (alen expr)
       t nil
       f nil
       c nil
       ind (pad indent))
  ;;look for finally
  (set! f (last expr))
  (if (and (list? f)
           (= (name?? (car f)) "finally"))
    (do (set! f (.pop expr))
        (set! sz (alen expr)))
    (set! f nil))
  ;;look for catch
  (set! c (if (> sz 1) (nth expr (dec sz)) nil))
  (if (and (list? c)
           (= (name?? (car c)) "catch"))
    (do (if (or (< (alen c) 2)
                (not (node? (cadr c)))) (syntax! :e0 expr))
        (set! c (.pop expr)))
    (set! c nil))
  ;;try needs either a catch or finally or both
  (if (and (nil? f)
           (nil? c)) (syntax! :e0 expr))
  (do-with [ret (tnodeEx
                  [(str "(function() {\n"
                        ind "try {\n")
                   (parseTree (.slice expr 1))
                   (str "\n" ind "} ") ])]
    (when c
      (set! t (cadr c))
      (.splice c 0 2 (tnodeEx "do" "do"))
      (.add ret [(str "catch (" t ") {\n")
                 "return "
                 (evalList c) (str ";\n" ind "}\n")]))
    (when f
      (.splice f 0 1 (tnodeEx "do" "do"))
      (.add ret ["finally {\n"
                 (evalList f)
                 (str ";\n" ind "}\n") ]))
    (.add ret (str ind "}).call(this)"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "try" sf-try)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-if [expr]
  (if (or (< (alen expr) 3)
          (> (alen expr) 4)) (syntax! :e0 expr))
  (+= indent tabspace)
  (evalAtoms expr)
  (try
    (tnodeEx
      ["("
       (cadr expr)
       (str " ?\n" (pad indent))
       (caddr expr)
       (str " :\n" (pad indent))
       (or (cadddr expr) "undefined") ")"])
    (finally
      (-= indent tabspace))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "if" sf-if)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-get [expr]
  (assertArgs expr 3 :e0)
  (evalAtoms expr)
  (tnodeEx [(cadr expr) "[" (caddr expr) "]"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "get" sf-get)
(set! SPECIAL-OPS "aget" (get SPECIAL-OPS "get"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-str [expr]
  (if (< (alen expr) 2) (syntax! :e0 expr))
  (evalAtoms expr)
  (do-with [ret (tnode)]
    (.add ret (.slice expr 1))
    (.join ret ",")
    (.prepend ret "[")
    (.add ret "].join(\"\")")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "str" sf-str)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-array [expr]
  (var p (pad indent)
       epilog (str "\n" p "]"))
  (do-with [ret (tnode)]
    (if (empty? expr)
      (.add ret "[]")
      (try
        (if (not= tkn-array (.-eTYPE expr))
          (.splice expr 0 1))
        (+= indent tabspace)
        (evalAtoms expr)
        (set! p (pad indent))
        (.add ret (str "[\n" p))
        (for ((i 0) (< i (alen expr)) (i (inc i)))
          (if (> i 0)
            (.add ret (str ",\n" p)))
          (.add ret (nth expr i)))
        (.add ret epilog)
        (finally
          (-= indent tabspace))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "[" sf-array)
(set! SPECIAL-OPS "vec" (get SPECIAL-OPS "["))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-object [expr]
  (var p (pad indent)
       epilog (str "\n" p "}"))
  (do-with [ret (tnode)]
    (if (empty? expr)
      (.add ret "{}")
      (try
        (if (not= tkn-object (.-eTYPE expr))
          (.splice expr 0 1))
        (+= indent tabspace)
        (evalAtoms expr)
        (set! p (pad indent))
        (.add ret (str "{\n" p))
        (for ((i 0) (< i (alen expr)) (i (+ i 2)))
          (if (> i 0)
            (.add ret (str ",\n" p)))
          (.add ret [(nth expr i)
                     ": "
                     (nth expr (inc i))]))
        (.add ret epilog)
        (finally
          (-= indent tabspace))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "{" sf-object)
(set! SPECIAL-OPS "hash-map" (get SPECIAL-OPS "{"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(def- includeFile
  ((# (var icache [])
      (fn [fname]
        (if (contains? icache fname)
          ""
          (do (.push icache fname)
              (parseTree (toASTree (.readFileSync *fs* fname) fname))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-include [expr]

  (assertArgs expr 2 :e0)

  (var dir (.dirname *path*
                     (.-source expr))
       found false
       fname (name?? (cadr expr)))

  (if (string? fname)
    (set! fname (.replace fname
                          (regexs "[\"]" "g") "")))

  (try
    (set! fname
          (.realpathSync *fs*
                         (str dir "/" fname)))
    (catch e
      (syntax! :e11 expr)))
  (try
    (-= indent tabspace)
    (includeFile fname)
    (finally
      (.pop *nspaces*)
      (+= indent tabspace))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;(set! SPECIAL-OPS "include" sf-include)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;(require ["path" :as *path*] ["fs" :as *fs*]))
(defn- sf-require [expr]
  (var path nil v nil e nil)
  (do-with [ret (tnode)]
    (for ((i 1)
          (< i (alen expr)) (i (inc i)))
      (set! e (nth expr i))
      (if-not (or (array? e)
                  (= 3 (alen e))) (syntax! :e0 expr))
      (set! path (car e))
      (set! v (caddr e))
      (.add ret ["var "
                 (normalizeId v)
                 "= require(" path ");\n"]))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;(set! SPECIAL-OPS "require" sf-require)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-ns [expr]
  (if (< (alen expr) 2) (syntax! :e0 expr))
  (do-with [ret []]
    (set! ret :eTYPE tkn-ns)
    (for ((i 1)
          (< i (alen expr)) (i (inc i)))
      (var e (nth expr i)
           t (.-eTYPE e)
           nm (name?? (car e)))
      (cond
        (= tkn-ident t) (.push *nspaces* e)
        (and (= tkn-list t)
             (= "include" nm))
        (.push ret (sf-include e))
        (and (= tkn-list t)
             (= "require" nm))
        (.push ret (sf-require e))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "ns" sf-ns)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-comment [expr] "")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "comment" sf-comment)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-floop [expr]

  (if (< (alen expr) 2) (syntax! :e0 expr))

  (var c1 nil
       c2 nil
       c3 nil
       c (cadr expr)
       ind (pad indent))

  (do-with [ret (tnodeEx "for (")]
    (if (or (not (list? c))
            (not= (alen c) 3)) (syntax! :e0 expr))
    (set! c1 (car c))
    (set! c2 (cadr c))
    (set! c3 (caddr c))
    (+= indent tabspace)
    (for ((i 0) (< i (alen c1)) (i (+ i 2)))
      (if (zero? i) (.add ret "var "))
      (if (> i 0) (.add ret ","))
      (.add ret [(nth c1 i)
                 " = "
                 (eval?? (nth c1 (inc i))) ]))
    (.add ret "; ")
    (.add ret (evalList c2))
    (.add ret "; ")
    (for ((i 0) (< i (alen c3)) (i (+ i 2)))
      (if (> i 0) (.add ret ","))
      (.add ret [(nth c3 i)
                 " = "
                 (eval?? (nth c3 (inc i)))] ))
    (.add ret ") {\n")
    (when (> (alen expr) 2)
      (.splice expr 0 2 (tnodeEx "do" "do"))
      (.add ret [ind (pad tabspace) (evalList expr) ";"]))
    (.add ret (str "\n" ind "}\n"))
    (.prepend ret "(function () {\n")
    (.add ret "}).call(this)")
    (-= indent tabspace)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "for" sf-floop)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-jscode [expr]
  (assertArgs expr 2 :e0)
  (set! noSemi? true)
  (.replaceRight (cadr expr) (regexs "\"" "g") "")
  (cadr expr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "js#" sf-jscode)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-macro [expr]
  (if (< (alen expr) 4) (syntax! :e0 expr))
  (var a3 (cadddr expr)
       a2 (caddr expr)
       doc nil
       cmd (name?? (cadr expr)))
  (when (= tkn-string (get a2 :eTYPE))
    (set! doc (nth expr 2))
    (set! a2 (nth expr 3))
    (set! a3 (nth expr 4)))
  (do-with [ret ""]
    (for ((i 0) (< i (alen a2)) (i (inc i)))
      (if (and (= (name?? (nth a2 i)) VARGS)
               (not= (inc i) (alen a2)))
        (syntax! :e15 expr cmd)))
    (set! MACROS-MAP
          cmd
          { :doc doc :args a2 :code a3 :name cmd })))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "defmacro" sf-macro)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-not [expr]
  (assertArgs expr 2 :e0)
  (evalAtoms expr)
  (str "(!" (cadr expr) ")"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "!" sf-not)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- dbg [obj hint]
  (cond
    (list? obj)
    (do (set! hint (or hint "block"))
        (console.log (str "<" hint ">"))
        (for ((i 0) (< i (alen obj)) (i (inc i)))
          (dbg (nth obj i)))
        (console.log (str "</" hint ">")))
    (node? obj)
    (do (console.log "<node>")
        (console.log obj)
        (dbg obj.children "subs")
        (console.log "</node>"))
    :else
    (console.log obj)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- spitExterns []
  (var p (pad tabspace)
       s (-> (map (fn [k]
                    (str p k ": " k)) (keys *externs*))
             (.join ",\n")))
  (str "\n\nmodule.exports = {\n" s "\n};\n\n"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- compileCode [codeStr fname withSrcMap?]

  (when-not loadedMacros?
    (set! loadedMacros? true)
    (require "./macros.kirby"))

  (set! indent (- tabspace))
  (set! *externs* {})
  (set! *nspaces* [])

  (var outNode (parseTree (toASTree codeStr fname))
       extra (spitExterns))
  (.prepend outNode (banner))

  (if withSrcMap?
    (let [outFile (str (.basename *path* fname ".kirby") ".js")
          srcMap  (str outFile ".map")
          output (.toStringWithSourceMap outNode
                                         { :file outFile })]
      (.writeFileSync fs srcMap output.map)
      (str output.code
           extra
           "\n//# sourceMappingURL="
           (.relative *path* (.dirname *path* fname) srcMap)))
    (str outNode extra)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- transpileXXX [code file smap?]
  (try
    (compileCode code file smap?)
    (catch e
      (js# "console.log(e.stack);")
      (throw e)
      nil)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn dbgAST [codeStr fname]
  (dbg (toASTree codeStr fname) "tree"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn transpileWithSrcMap [code file]
  (transpileXXX code file true))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn transpile [code file]
  (transpileXXX code file false))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn parseWithSourceMap [codeStr fname]
  (var outNode (parseTree (toASTree codeStr fname)))
  (.prepend outNode MODULE-BANNER)
  (.toStringWithSourceMap outNode))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(def version MODULE-VERSION)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

