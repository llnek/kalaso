;; Copyright (c) 2013-2017, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http:;;opensource.org;licenses;eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author "Kenneth Leung"}

  czlab.kirby.compiler)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(include "./reader.kirby")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(def- MODULE-BANNER "/* Kirby Generated: Test only */\n"
      MODULE-VERSION "1.0.0"
      loadedMacros? false
      includePaths []
      noSemi? false
      tabspace 2
      VARGS "&rest"
      TILDA "~"
      indent (- tabspace)
      TILDA-VARGS (str TILDA VARGS))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(def- SPECIAL-OPS {})
(def- MACROS-MAP {})
(def- ERRORS-MAP {
  e0 "Syntax Error"
  e1 "Empty statement"
  e2 "Invalid characters in function name"
  e3 "End of File encountered, unterminated string"
  e4 "Closing square bracket, without an opening square bracket"
  e5 "End of File encountered, unterminated array"
  e6 "Closing curly brace, without an opening curly brace"
  e7 "End of File encountered, unterminated javascript object '}'"
  e8 "End of File encountered, unterminated parenthesis"
  e9 "Invalid character in var name"
  e10 "Extra chars at end of file. Maybe an extra ')'."
  e11 "Cannot Open include File"
  e12 "Invalid no of arguments to "
  e13 "Invalid Argument type to "
  e14 "End of File encountered, unterminated regular expression"
  e15 "Invalid vararg position, must be last argument."
  e16 "Invalid arity (args > expected) to "
  e17 "Invalid arity (args < expected) to " })

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- eval?? [x]
  (if (list? x) (evalList x) x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- node? [obj]
  (and (object? obj)
       (true? (get obj "$$$isSourceNode$$$"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- error! [e line file msg]
  (throw
    (new Error
         (str (get ERRORS-MAP e)
              (if msg (str " : " msg))
              (if line (str "\nLine no " line))
              (if file (str "\nFile " file))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- syntax! [ecode expr cmd]
  (var info (or (get expr KIRBY) {}))
  (error! ecode info.filename info.lineno cmd))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- assertArgs [expr cnt ecode msg]
  (if (not= (alen expr) cnt) (syntax! ecode expr msg)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- pad [z] (.repeat " " z))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- toASTree [code fname]
  (var state {codeStr (str "(" code ")")
              filename fname
              lineno 1
              colno 1
              pos 1
               tknCol 1 })
  (do-with [ret (lexer nil state)]
    (if (< state.pos (alen state.codeStr)) (error! :e10))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- parseTree [root]

  (var pstr ""
       endx (eindex root)
       treeSize (alen root))

  (+= indent tabspace)
  (set! pstr (pad indent))

  (do-with [ret (tnode)]
    (each (fn [expr i]
            (var name ""
                 tmp nil r "")
            (if (list? expr)
              (let [e (car expr)]
                (if (node? e)
                  (set! name e.name))
                (set! tmp (evalList expr))
                (when (= name "include")
                  (.add ret tmp)
                  (set! tmp nil)))
              (set! tmp expr))
            (if (and (= i endx)
                     (not= 0 indent)
                     (not (REGEX.noret.test name)))
              (set! r "return "))
            (when tmp
              (.add ret [(str pstr r)
                         tmp
                         (if-not noSemi? ";" "") "\n"])
              (set! noSemi? false))) root)
    (-= indent tabspace)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- evalList2 [expr]

  (evalConCells expr)
  (var s nil
       ename (car expr))
  (if-not ename
    (syntax! :e1 expr))
  (if (REGEX.func.test ename)
    (set! ename (tnodeChunk ["(" ename ")"])))
  (tnodeChunk [ename "("
               (-> (.slice expr 1)
                   (tnodeChunk )
                   (.join  ",")) ")"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- evalList [expr]

  (var cmd "" tmp nil mc nil
       info (or (get expr KIRBY) {}))

  (cond
    (= :object (.-eTYPE info)) (set! cmd "{")
    (= :array (.-eTYPE info)) (set! cmd "[")
    (node? (car expr))
    (do (set! cmd (.-name (car expr)))
        (set! mc (get MACROS-MAP cmd))))

  (cond
    (some? mc) (eval?? (evalMacro mc expr))
    (string? cmd)
    (cond
      (.startsWith cmd ".-")
      (do-with [ret (tnode)]
        (.add ret (eval?? (cadr expr)))
        (.prepend ret "(")
        (.add ret [")[\"" (.slice cmd 2) "\"]"]))
      (= (.charAt cmd 0) ".")
      (do-with [ret (tnode)]
        (.add ret (eval?? (cadr expr)))
        (.add ret [(car expr) "("])
        (for ((i 2) (< i (alen expr)) (i (inc i)))
          (if (not= i 2) (.add ret ","))
          (.add ret (eval?? (nth expr i))))
        (.add ret ")"))
      (.hasOwnProperty SPECIAL-OPS cmd)
      ((get SPECIAL-OPS cmd) expr)
      :else
      (evalList2 expr))
    :else
    (evalList2 expr)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- evalConCells [cells]
  (each (fn [cell i cc]
          (if (list? cell) (set! cc i (evalList cell)))) cells))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- expandMacro [code data frags]
  (var state nil
       ret []
       ename ""
       tmp nil
       s1name ""
       ci (or (get code KIRBY) {})
       di (or (get data KIRBY) {}))

  (set! state (Object.assign di))
  (set! ret KIRBY state)

  (when (and (list? code)
             (> (alen code) 1))
    (set! s1name (.-name (cadr code)))
    (set! frag (get frags (str TILDA s1name))))

  (if (and (list? code)
           (not-empty code))
   (set! ename (.-name (car code))))

  ;;deal with array and object literals
  (if (or (= :object (.-eTYPE ci))
          (= :array (.-eTYPE ci)))
    (set! state :eTYPE ci.eTYPE))

  (set! ename (or ename ""))
  ;;the magic
  (cond
    (= ename "#<<")
    (if-not (list? frag)
      (syntax! :e13 data cmd)
      (.shift frag))
    ;;
    (= ename "#head")
    (if-not (list? frag)
      (syntax! :e13 data cmd)
      (if (not-empty frag) (car frag)))
    ;;
    (= ename "#tail")
    (if-not (list? frag)
      (syntax! :e13 data cmd)
      (if (not-empty frag) (last frag)))
    ;;=> 0,2,4...
    (.startsWith ename "#evens")
    (do-with [r []]
      (for ((i 0) (< i (alen frag)) (i (+ i 2)))
        (conj!! r (nth frag i)))
      (if (.endsWith ename "*") (set! r "___split" true)))
    ;;=> 1,3,5...
    (.startsWith ename "#odds")
    (do-with [r []]
      (for ((i 1) (< i (alen frag)) (i (+ i 2)))
        (conj!! r (nth frag i)))
      (if (.endsWith ename "*") (set! r "___split" true)))
    ;;
    (.startsWith ename "#slice@")
    (do
      (if-not (list? frag) (syntax! :e13 data cmd))
      (set! tmp (REGEX.macroGet.exec ename))
      (car (.splice frag (dec (cadr tmp)) 1)))
    ;;
    (= ename "#if")
    (do
      (if-not (list? frag) (syntax! :e13 data cmd))
      (cond
        (not-empty frag) (expandMacro (nth code 2) data frags)
        (and (> (alen code) 3)
             (nth code 3)) (expandMacro (nth code 3) data frags)))
    ;;
    :else
    (let [cell nil]
      (for ((i 0) (< i (alen code)) (i (inc i)))
        (set! cell (nth code i))
        (if (list? cell)
          (let [c (expandMacro cell data frags)]
            (if (and (list? c)
                     (true? (get c "___split")))
              (for ((k 0) (< k (alen c)) (k (inc k)))
                (conj!! ret (nth c k)))
              (conj!! ret c)))
          ;;else
          (let [tn (.-name cell)
                atSign? false]
            (set! tmp cell)
            (when (.includes tn "@")
              (set! atSign? true)
              (set! tmp
                    (tnode cell.line
                           cell.column
                           cell.source
                           (.replace tn "@" "")
                           (.replace tn "@" ""))))
            (if-some [repl (get frags tmp.name)]
              (do (if (or atSign?
                          (= tmp.name TILDA-VARGS))
                    (for ((j 0) (< j (alen repl)) (j (inc j)))
                      (conj!! ret (nth repl j)))
                    (conj!! ret repl)))
              (conj!! ret cell)))))
      ret)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- evalMacro [mc data]
  (var args (get mc :args)
       cmd (get mc :name)
       code (get mc :code)
       vargs false
       tpos 0
       i 0
       frags {})

  ;;map all args to actual data, say &rest -> rest of the data
  ;;tpos is always one ahead to skip out the macro cmd
  (for ((tpos (inc i))
        (< i (alen args)) (i (inc i) tpos (inc i)))
    (if (= (.-name (nth args i)) VARGS)
      (do (set! vargs true)
          (set! frags TILDA-VARGS (.slice data tpos)))
      (set! frags
            (str TILDA (.-name (nth args i)))
            (if (>= tpos (alen data))
              (tnodeChunk "undefined") (nth data tpos)))))

  ;;check if enough args were supplied to the macro
  (if (and (not vargs)
           (< (inc i) (alen data))) (syntax! :e16 data cmd))

  (expandMacro code data frags))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-compOp [expr]
  (if (< (alen expr) 3) (syntax! :e0 expr))
  (evalConCells expr)
  ;; dont use === as it is a source node
  (if (eq? (car expr) "!=") (aset expr 0  "!=="))
  (if (eq? (car expr) "=") (aset expr 0 "==="))
  (do-with [ret (tnode)]
    (for ((i 0 op (.shift expr))
          (< i (dec (alen expr))) (i (inc i)))
      (.add ret (tnodeChunk [(nth expr i) " "
                                          op
                                          " "
                                          (nth expr (inc i))])))
    (.join ret " && ")
    (.prepend ret "(")
    (.add ret ")")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(each (fn [k]
        (set! SPECIAL-OPS k sf-compOp))
      ["!=" "==" "=" ">" ">=" "<" "<="])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-arithOp [expr]
  (if (< (alen expr) 2) (syntax! :e0 expr))
  (evalConCells expr)
  (var op (tnode)
       e1 (.shift expr) cmd (.-name e1))
  (do-with [ret (tnode)]
    (if (= 1 (alen expr))
      (if (= "-" cmd) (.add ret "-"))
      (.add op [" " e1 " "]))
    (.add ret expr)
    (if (> (alen expr) 1) (.join ret op))
    (.prepend ret "(")
    (.add ret ")")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(each (fn [k]
        (set! SPECIAL-OPS k sf-arithOp)) ["+" "-" "*" "/" "%"])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-logicalOp [expr] (sf-arithOp expr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(each (fn [k]
        (set! SPECIAL-OPS k sf-logicalOp))
      ["||" "&&" "^" "|" "&" ">>>" ">>" "<<"])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-repeat [expr]
  (assertArgs expr 3 :e0)
  (evalConCells expr)
  (do-with [ret (tnode)]
    (for ((i 0
           end (parseInt (.-name (cadr expr))))
          (< i end)
          (i (inc i)))
      (if (not= i 0) (.add ret ","))
      (.add ret (nth expr 2)))
    (.prepend ret "[")
    (.add ret "]")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "repeat-n" sf-repeat)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-do [expr]
  (var p (pad indent)
       e nil
       end (eindex expr))
  (do-with [ret (tnode)]
    (for ((i 1) (< i end) (i (inc i)))
      (set! e (nth expr i))
      (.add ret [p (evalList e) ";\n"]))
    (when (> end 0)
      (set! e (eval?? (last expr)))
      (.add ret [p "return " e ";\n"])
      (.prepend ret (str p "(function() {\n"))
      (.add ret (str p "})()")))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "do" sf-do)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-doto [expr]

  (if (< (alen expr) 2) (syntax! :e0 expr))

  (var p (pad indent)
       p2 (pad (+ indent tabspace))
       p3 (pad (+ indent (* 2 tabspace)))
       e nil
       e1 (eval?? (nth expr 1)))
  (do-with [ret (tnode)]
    (.add ret [p2 "let ____x = " e1 ";\n"])
    (for ((i 2) (< i (alen expr)) (i (inc i)))
      (set! e (nth expr i))
      (.splice e 1 0 "____x")
      (.add ret [p3 (evalList e) ";\n"]))
    (.add ret [p2 "return ____x;\n"])
    (.prepend ret (str p "(function() {\n"))
    (.add ret (str p "})()"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "doto" sf-doto)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-range [expr]

  (if (or (< (alen expr) 2 )
          (> (alen expr) 4)) (syntax! :e0 expr))

  (var len 0 start 0 step 1 end 0)
  (evalConCells expr)
  (set! len (alen expr))
  (set! end (parseInt (.-name (cadr expr))))
  (do-with [ret (tnode)]
    (when (> len 2)
      (set! start (parseInt (.-name (nth expr 1))))
      (set! end (parseInt (.-name (nth expr 2)))))
    (if (> len 3)
      (set! step (parseInt (.-name (nth expr 3)))))
    (for ((i start) (< i end) (i (+ i step)))
      (if (not= i start) (.add ret ","))
      (.add ret (str "" i)))
    (.prepend ret "[")
    (.add ret "]")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "range" sf-range)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-var [expr cmd]

  (if (or (< (alen expr) 3)
          (= 0 (mod (alen expr) 2))) (syntax! :e0 expr))

  (if (> (alen expr) 3)
    (+= indent tabspace))

  (evalConCells expr)
  (do-with [ret (tnode)]
    (for ((i 1) (< i (alen expr)) (i (+ i 2)))
      (if (> i 1)
        (.add ret (str ",\n" (pad indent))))
      (if-not (testid? (nth expr i)) (syntax! :e9 expr))
      (.add ret [(nth expr i) " = " (nth expr (inc i))]))
    (.prepend ret " ")
    (.prepend ret cmd)
    (if (> (alen expr) 3)
      (-= indent tabspace))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "var" (fn [x] (sf-var x "let")))
(set! SPECIAL-OPS "def" (fn [x] (sf-var x "var")))
(set! SPECIAL-OPS "def-" (get SPECIAL-OPS "def"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-new [expr]
  (if (< (alen expr) 2) (syntax! :e0 expr))
  (do-with [ret (tnode)]
    (.add ret (evalList (.slice expr 1)))
    (.prepend ret "new ")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "new" sf-new)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-throw [expr]
  (assertArgs expr 2 :e0)
  (do-with [ret (tnode)]
    (.add ret (eval?? (cadr expr)))
    (.prepend ret "throw ")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "throw" sf-throw)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-while [expr]
  (var f1 (nth expr 1))
  (.splice expr 0 2 (tnodeChunk "do" "do"))
  (do-with [ret nil]
    (set! ret (tnodeChunk ["while "
                          (eval?? f1)
                          " {\n" (evalList expr) ";\n}\n"]))
    (.prepend ret "(function () {\n")
    (.add ret "})()")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "while" sf-while)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-x-opop [expr op]
  (if (not= (alen expr) 2) (syntax! :e0 expr))
  (tnodeChunk [op (eval?? (cadr expr))]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "dec!!" (fn [x] (sf-x-opop x "--")))
(set! SPECIAL-OPS "inc!!" (fn [x] (sf-x-opop x "++")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-x-eq [expr op]
  (assertArgs expr 3 :e0)
  (tnodeChunk [(cadr expr)
               (str " " op "= ")
               (eval?? (nth expr 2))]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "dec!" (fn [x] (sf-x-eq x "-")))
(set! SPECIAL-OPS "inc!" (fn [x] (sf-x-eq x "+")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-set [expr]
  (if-not (or (= (alen expr) 3)
              (= (alen expr) 4)) (syntax! :e0 expr))
  (do-with [ret (tnode)]
    (if (= (alen expr) 4)
      (do
        (.add ret (eval?? (cadr expr)))
        (.add ret "[")
        (.add ret (eval?? (nth expr 2)))
        (.add ret "]"))
      (.add ret (cadr expr)))
    (.add ret [" = " (eval?? (last expr))])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "aset" sf-set)
(set! SPECIAL-OPS "set!" sf-set)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-anonFunc [expr]
  (if (< (alen expr) 2) (syntax! :e0 expr))
  (if-not (list? (cadr expr)) (syntax! :e0 expr))
  (var fArgs (cadr expr)
       fBody (.slice expr 2))
  (do-with [ret (tnodeChunk fArgs)]
    (.join ret ",")
    (.prepend ret "function (")
    (.add ret [") {\n"
               (parseTree fBody)
               (pad indent) "}"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "fn" sf-anonFunc)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-func [expr public?]
  (if (< (alen expr) 2) (syntax! :e0 expr))
  (var fName nil
       fArgs nil fBody nil)
  (do-with [ret nil]
    (if (and (not (list? (cadr expr)))
             (list? (nth expr 2)))
      (do
        (set! fName (normalizeId (.-name (cadr expr))))
        (set! fArgs (nth expr 2))
        (set! fBody (.slice expr 3)))
      (syntax! :e0 expr))
    (set! ret (tnodeChunk fArgs))
    (.join ret ",")
    (.prepend ret (str "function " fName "("))
    (.add ret [") {\n"
               (parseTree fBody)
               (pad indent) "}"])
    (set! noSemi? true)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "defn-" (fn [x] (sf-func x false)))
(set! SPECIAL-OPS "defn" (fn [x] (sf-func x true)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-try [expr]
  (var sz (alen expr)
       t nil
       f nil
       c nil
       ind (pad indent))
  ;;look for finally
  (set! f (last expr))
  (if (and (list? f)
           (= (.-name (car f)) "finally"))
    (do (set! f (.pop expr))
        (set! sz (alen expr)))
    (set! f nil))
  ;;look for catch
  (set! c (if (> sz 1) (nth expr (dec sz)) nil))
  (if (and (list? c)
           (= (.-name (car c)) "catch"))
    (do
      (if (or (< (alen c) 2)
              (not (node? (cadr c)))) (syntax! :e0 expr))
      (set! c (.pop expr)))
    (set! c nil))
  ;;try needs either a catch or finally or both
  (if (and (nil? f)
           (nil? c)) (syntax! :e0 expr))
  (do-with [ret (tnodeChunk
                  [(str "(function() {\n"
                        ind "try {\n")
                   (parseTree (.slice expr 1))
                   (str "\n" ind "} ") ])]
    (when c
      (set! t (cadr c))
      (.splice c 0 2 (tnodeChunk "do" "do"))
      (.add ret [(str "catch (" t ") {\n")
                 "return "
                 (evalList c) (str ";\n" ind "}\n")]))
    (when f
      (.splice f 0 1 (tnodeChunk "do" "do"))
      (.add ret ["finally {\n"
                 (evalList f)
                 (str ";\n" ind "}\n") ]))
    (.add ret (str ind "})()"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "try" sf-try)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-if [expr]
  (if (or (< (alen expr) 3)
          (> (alen expr) 4)) (syntax! :e0 expr))
  (+= indent tabspace)
  (evalConCells expr)
  (try
    (tnodeChunk ["("
                 (cadr expr)
                 (str " ?\n" (pad indent))
                 (nth expr 2)
                 (str " :\n" (pad indent))
                 (or (nth expr 3) "undefined") ")"])
    (finally
      (-= indent tabspace))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "if" sf-if)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-get [expr]
  (assertArgs expr 3 :e0)
  (evalConCells expr)
  (tnodeChunk [(cadr expr) "[" (nth expr 2) "]"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "get" sf-get)
(set! SPECIAL-OPS "aget" (get SPECIAL-OPS "get"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-str [expr]
  (if (< (alen expr) 2) (syntax! :e0 expr))
  (evalConCells expr)
  (do-with [ret (tnode)]
    (.add ret (.slice expr 1))
    (.join ret ",")
    (.prepend ret "[")
    (.add ret "].join('')")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "str" sf-str)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-array [expr]
  (var info (or (get expr KIRBY) {})
       p (pad indent)
       epilog (str "\n" p "]"))
  (do-with [ret (tnode)]
    (if (empty? expr)
      (.add ret "[]")
      (try
        (if (not= :array (.-eTYPE info))
          (.splice expr 0 1))
        (+= indent tabspace)
        (evalConCells expr)
        (set! p (pad indent))
        (.add ret (str "[\n" p))
        (for ((i 0) (< i (alen expr)) (i (inc i)))
          (if (> i 0)
            (.add ret (str ",\n" p)))
          (.add ret (nth expr i)))
        (.add ret epilog)
        (finally
          (-= indent tabspace))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "[" sf-array)
(set! SPECIAL-OPS "vec" (get SPECIAL-OPS "["))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-object [expr]
  (var info (or (get expr KIRBY) {})
       p (pad indent)
       epilog (str "\n" p "}"))
  (do-with [ret (tnode)]
    (if (empty? expr)
      (.add ret "{}")
      (try
        (if (not= :object (.-eTYPE info))
          (.splice expr 0 1))
        (+= indent tabspace)
        (evalConCells expr)
        (set! p (pad indent))
        (.add ret (str "{\n" p))
        (for ((i 0) (< i (alen expr)) (i (+ i 2)))
          (if (> i 0)
            (.add ret (str ",\n" p)))
          (.add ret [(nth expr i) ": " (nth expr (inc i))]))
        (.add ret epilog)
        (finally
          (-= indent tabspace))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "{" sf-object)
(set! SPECIAL-OPS "hash-map" (get SPECIAL-OPS "{"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(def- includeFile
  ((# (var icache [])
      (fn [fname]
        (if (not= (.indexOf icache fname) -1)
          ""
          (do (.push icache fname)
              (parseTree (toASTree (.readFileSync *fs* fname) fname))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-include [expr]

  (assertArgs expr 2 :e0)

  (var found false
       fname (.-name (cadr expr))
       info (or (get expr KIRBY) {}))

  (if (string? fname)
    (set! fname (.replace fname
                          (regexs "[\"]" "g") "")))

  (-= indent tabspace)

  (each (fn [pfx]
          (try!
            (when-not found
              (set! fname (.realpathSync *fs* (str pfx "/" fname)))
              (set! found true))))
        (conj includePaths
              (.dirname *path* info.filename)))

  (if-not found (syntax! :e11 expr))
  (try
    (includeFile fname)
    (finally
      (+= indent tabspace))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "include" sf-include)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-ns [expr] "")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "ns" sf-ns)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-comment [expr] "")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "comment" sf-comment)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-floop [expr]

  (if (< (alen expr) 2) (syntax! :e0 expr))

  (var c1 nil
       c2 nil
       c3 nil
       c (cadr expr)
       ind (pad indent))

  (do-with [ret (tnodeChunk "for (")]
    (if (or (not (list? c))
            (not= (alen c) 3)) (syntax! :e0 expr))
    (set! c1 (car c))
    (set! c2 (cadr c))
    (set! c3 (nth c 2))
    (+= indent tabspace)
    (for ((i 0) (< i (alen c1)) (i (+ i 2)))
      (if (= i 0) (.add ret "var "))
      (if (not= i 0) (.add ret ","))
      (.add ret [(nth c1 i)
                 " = "
                 (eval?? (nth c1 (inc i))) ]))
    (.add ret "; ")
    (.add ret (evalList c2))
    (.add ret "; ")
    (for ((i 0) (< i (alen c3)) (i (+ i 2)))
      (if (not= i 0) (.add ret ","))
      (.add ret [(nth c3 i)
                 " = "
                 (eval?? (nth c3 (inc i)))] ))
    (.add ret ") {\n")
    (when (> (alen expr) 2)
      (.splice expr 0 2 (tnodeChunk "do" "do"))
      (.add ret [ind (pad tabspace) (evalList expr) ";"]))
    (.add ret (str "\n" ind "}\n"))
    (.prepend ret "(function () {\n")
    (.add ret "})()")
    (-= indent tabspace)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "for" sf-floop)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-jscode [expr]
  (assertArgs expr 2 :e0)
  (set! noSemi? true)
  (.replaceRight (cadr expr) (regexs "\"" "g") "")
  (cadr expr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "js#" sf-jscode)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-macro [expr]
  (assertArgs expr  4 :e0)
  (var a2 (nth expr 2)
       a3 (nth expr 3)
       cmd (.-name (cadr expr)))
  (do-with [ret ""]
    (for ((i 0) (< i (alen a2)) (i (inc i)))
      (if (and (= (.-name (nth a2 i)) VARGS)
               (not= (inc i) (alen a2)))
        (syntax! :e15 expr cmd)))
    (set! a2 KIRBY {eTYPE nil})
    (set! a3 KIRBY {eTYPE nil})
    (set! MACROS-MAP cmd { args a2 code a3 name cmd })))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "defmacro" sf-macro)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sf-not [expr]
  (assertArgs expr 2 :e0)
  (evalConCells expr)
  (str "(!" (cadr expr) ")"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(set! SPECIAL-OPS "!" sf-not)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- dbg [obj hint]
  (cond
    (list? obj)
    (do
      (set! hint (or hint "block"))
      (console.log (str "<" hint ">"))
      (for ((i 0) (< i (alen obj)) (i (inc i)))
        (dbg (nth obj i)))
      (console.log (str "</" hint ">")))
    (node? obj)
    (do
      (console.log "<node>")
      (console.log obj)
      (dbg obj.children "subs")
      (console.log "</node>"))
    :else
    (console.log obj)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- dbgAST [codeStr fname]
  (dbg (toASTree codeStr fname) "tree"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- compileCode [codeStr fname withSrcMap? incPaths]

  (when-not loadedMacros?
    (set! loadedMacros? true)
    (require "./macros.kirby"))

  (if (array? incPaths)
    (set! includePaths incPaths))
  (set! indent (- tabspace))

  (var outNode (parseTree (toASTree codeStr fname)))
  (.prepend outNode MODULE-BANNER)

  (if withSrcMap?
    (let [outFile (str (.basename *path* fname ".kirby") ".js")
          srcMap  (str outFile ".map")
          output (.toStringWithSourceMap outNode
                                         { file outFile })]
      (.writeFileSync fs srcMap output.map)
      (str output.code
           "\n//# sourceMappingURL="
           (.relative *path* (.dirname *path* fname) srcMap)))
    (.toString outNode)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- transpileXXX [code file smap? incDirs]
  (try
    (compileCode code file smap? incDirs)
    (catch e
      (js# "console.log(e.stack);")
      (throw e)
      nil)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- transpileWithSrcMap [code file incDirs]
  (transpileXXX code file true incDirs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- transpile [code file incDirs]
  (transpileXXX code file false incDirs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- parseWithSourceMap [codeStr fname]
  (var outNode (parseTree (toASTree codeStr fname)))
  (.prepend outNode MODULE-BANNER)
  (.toStringWithSourceMap outNode))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(do-with [exports {}]
  (set! exports "transpileWithSrcMap" transpileWithSrcMap)
  (set! exports "parseWithSourceMap" parseWithSourceMap)
  (set! exports "transpile" transpile)
  (set! exports "version" MODULE-VERSION)
  (set! exports "dbgAST" dbgAST)
  (set! module.exports exports))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

