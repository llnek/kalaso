;; Copyright (c) 2013-2017, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author "Kenneth Leung"}

  czlab.kirby.bl.parser

  (require ["./stdlib" :as std]
           ["./lexer" :as rdr]))

(def- tnodeEx (rdr/tnodeEx))
(def- tnode (rdr/tnode))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- throwE "" [token msg]
  (if token
    (raise! msg "\nnear line " token.line "\nin file " token.source)
    (raise! msg "\nnear EOF ")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- nextToken "" [tokens]
  (do-with [t (peekToken tokens)] (++ tokens.pos)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- peekToken "" [tokens] (nth tokens tokens.pos))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- copyTokenData "" [token node]
  (when (std/object? node)
    (set! node.source token.source)
    (set! node.line token.line)
    (set! node.column token.column)) node)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- readAtom "" [tokens]
  (var ret nil tn ""
       token (nextToken tokens))
  (if token
    (set! tn token.name))
  (cond
    (empty? tn)
    (set! ret undefined)
    (rdr.REGEX.float.test tn)
    (set! ret (parseFloat tn))
    (or (rdr.REGEX.hex.test tn)
        (rdr.REGEX.int.test tn))
    (set! ret (parseInt tn))
    (and (tn.startsWith "\"")
         (tn.endsWith "\""))
    (set! ret tn)
    (tn.startsWith ":")
    (set! ret (std/keyword tn))
    (tn.startsWith "%")
    (set! ret (std/lambda-arg tn))
    (or (= "nil" tn)
        (= "null" tn))
    (set! ret nil)
    (= "true" tn)
    (set! ret true)
    (= "false" tn)
    (set! ret false)
    :else (set! ret (std/symbol tn)))
  (copyTokenData token ret))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- readBlock "" [tokens head tail]
  (var token (nextToken tokens)
       ok? true ret nil tn "" cur nil)
  (if token (set! tn token.name))
  (if (not= tn head)
    (throwE token (str "expected '" head "'")))
  (do-with [ast []]
    (set! cur (peekToken tokens))
    (while ok?
      (when (or (std/nichts? cur)
                (= tail cur.name))
        (if cur
          (copyTokenData token ast)
          (throwE cur (str "expected '" tail "', got EOF")))
        (set! ok? false))
      (when ok?
        (addAst ast (read* tokens))
        (set! cur (peekToken tokens))))
    (nextToken tokens)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- readList "" [cur tokens] (readBlock tokens "(", ")"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- readVector "" [cur tokens]
  (do-with [v (readBlock tokens "[" "]")]
    (set-in! v :____vec true)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- readMap "" [cur tokens]
  (do-with [v (readBlock tokens "{" "}")]
    (set-in! v :____map true)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- skip+parse "" [tokens func]
  (copyTokenData (nextToken tokens) (func tokens)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- read* "" [tokens]
  (var tmp nil token (peekToken tokens))
  (if (std/nichts? token)
    undefined
    (case token.name
      "'" (skip+parse tokens
                      #([ (std/symbol "quote") (read* tokens)]))
      "`" (skip+parse tokens
                      #([ (std/symbol "quasiquote") (read* tokens)]))
      "~" (skip+parse tokens
                      #([ (std/symbol "unquote") (read* tokens)]))
      "~@" (skip+parse tokens
                       #([ (std/symbol "splice-unquote") (read* tokens)]))
      "^" (skip+parse tokens
                      (fn []
                        (set! tmp (read* tokens))
                        [(std/symbol "with-meta")
                                    (read* tokens) tmp]))
      "@" (skip+parse tokens
                      #([ (std/symbol "deref") (read* tokens)]))
      "#" (skip+parse tokens
                      #([ (std/symbol "lambda") (read* tokens)]))
      ")" (throwE token "unexpected ')'")
      "(" (readList token tokens)
      "]" (throwE token "unexpected ']'")
      "[" (readVector token tokens)
      "}" (throwE token "unexpected '}'")
      "{" (readMap token tokens)
      (";" ",") (do->undef (nextToken tokens))
      ;else
      (readAtom tokens))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- addAst "" [ast f] (if-not (undef? f) (std/conj! ast f)) ast)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn parser "" [source & [fname]]
  (var tokens (rdr/lexer source
                         (std/opt fname "**adhoc**"))
       f nil ast [] tlen (alen tokens))
  (set! tokens.pos 0)
  (do-with [ast []]
    (comment
      (for [i 0 :while (< i tlen) :recur (+1 i)]
        (println "token=" (.-name (nth tokens i)))))
    (while (< tokens.pos tlen)
      (addAst ast (read* tokens)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn dumpTree "" [tree & [indent]]
  (var pad (.repeat " " (std/opt indent 0)))
  (for [i 0 :while (< i (alen tree)) :recur (+1 i)]
    (println (prn (nth tree i)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

