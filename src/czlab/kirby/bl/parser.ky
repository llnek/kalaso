;; Copyright (c) 2013-2017, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author "Kenneth Leung"}

  czlab.kirby.bl.parser

  (require ["./stdlib"
            :as std
            :refer [lambda-arg
                    object?
                    nichts?
                    into
                    vector
                    conj!
                    opt??
                    symbol
                    keyword]]
           ["./lexer" :as rdr]))

(def- tnodeEx (rdr/tnodeEx))
(def- tnode (rdr/tnode))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- throwE "" [token msg]
  (if token
    (raise! msg "\nnear line " token.line "\nin file " token.source)
    (raise! msg "\nnear EOF ")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- nextToken "" [tokens]
  (var t (peekToken tokens)) (++ tokens.pos) t)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- peekToken "" [tokens] (nth tokens tokens.pos))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- copyTokenData "" [token node]
  (if (object? node)
    (set-in! node
             :source token.source
             :line token.line
             :column token.column)) node)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- readAtom "" [tokens]
  (var ret nil tn ""
       token (nextToken tokens))
  (if token
    (set! tn token.name))
  (cond
    (empty? tn)
    (set! ret undefined)
    (rdr/REGEX.float.test tn)
    (set! ret (float tn))
    (or (rdr.REGEX.hex.test tn)
        (rdr.REGEX.int.test tn))
    (set! ret (int tn))
    (and (tn.startsWith "\"")
         (tn.endsWith "\""))
    (set! ret tn)
    (tn.startsWith ":")
    (set! ret (keyword tn))
    (tn.startsWith "%")
    (set! ret (lambda-arg tn))
    (or (= "nil" tn)
        (= "null" tn))
    (set! ret nil)
    (= "true" tn)
    (set! ret true)
    (= "false" tn)
    (set! ret false)
    :else (set! ret (symbol tn)))
  (copyTokenData token ret))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- readBlock "" [tokens head tail]
  (var token (nextToken tokens)
       ast (tree)
       ok? true ret nil tn "" cur nil)
  (if token (set! tn token.name))
  (if (not= tn head)
    (throwE token (str "expected '" head "'")))
  (set! cur (peekToken tokens))
  (while ok?
    (when (or (nichts? cur)
              (= tail cur.name))
      (if cur
        (copyTokenData token ast)
        (throwE cur (str "expected '" tail "', got EOF")))
      (set! ok? false))
    (when ok?
      (addAst ast (read* tokens))
      (set! cur (peekToken tokens))))
  (nextToken tokens)
  ast)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- readList
  "" [cur tokens] (readBlock tokens "(" ")"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- readVector "" [cur tokens]
  (into :vector (readBlock tokens "[" "]")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- readMap "" [cur tokens]
  (into :map (readBlock tokens "{" "}")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- skip+parse "" [tokens func]
  (copyTokenData (nextToken tokens) (func tokens)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- read* "" [tokens]
  (var tmp nil token (peekToken tokens))
  (if (nichts? token)
    undefined
    (case token.name
      "'" (skip+parse
            tokens
            #(tree (symbol "quote") (read* tokens)))
      "`" (skip+parse
            tokens
            #(tree (symbol "quasiquote") (read* tokens)))
      "~" (skip+parse
            tokens
            #(tree (symbol "unquote") (read* tokens)))
      "~@" (skip+parse
             tokens
             #(tree (symbol "splice-unquote") (read* tokens)))
      "^" (skip+parse
            tokens
            (fn []
              (set! tmp (read* tokens))
              (tree (symbol "with-meta") (read* tokens) tmp)))
      "@" (skip+parse
            tokens
            #(tree (symbol "deref") (read* tokens)))
      "#" (skip+parse
            tokens
            #(tree (symbol "lambda") (read* tokens)))
      ")" (throwE token "unexpected ')'")
      "(" (readList token tokens)
      "]" (throwE token "unexpected ']'")
      "[" (readVector token tokens)
      "}" (throwE token "unexpected '}'")
      "{" (readMap token tokens)
      (";" ",") (do->undef (nextToken tokens))
      ;else
      (readAtom tokens))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- addAst "" [ast f]
  (if-not (undef? f) (conj! ast f)) ast)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn parser "" [source & [fname]]
  (var tokens (rdr/lexer source
                         (opt?? fname "*adhoc*"))
       f nil ast [] tlen (alen tokens))
  (set! tokens.pos 0)
  (comment
    (for [i 0 :while (< i tlen) :recur (+1 i)]
      (println "token=" (.-name (nth tokens i)))))
  (while (< tokens.pos tlen)
    (addAst ast (read* tokens)))
  ast)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn dumpTree "" [tree & [indent]]
  (var pad (.repeat " " (opt?? indent 0)))
  (for [i 0 :while (< i (alen tree)) :recur (+1 i)]
    (println (prn (nth tree i)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

