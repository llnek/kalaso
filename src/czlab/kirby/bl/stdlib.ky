;; Copyright (c) 2013-2017, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author "Kenneth Leung"}

  czlab.kirby.bl.stdlib)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn not-empty "" [coll] (if (empty? coll) nil coll))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn stringify "" [obj]
  (var cache (vector))
  (if obj
    (JSON/stringify obj
                    (fn [k v]
                      (if (object? v)
                        (if (contains? cache v)
                          (undef! v)
                          (conj! cache v))) v))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn opt?? "" [cur other] (if (def? cur) cur other))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn conj! "" [coll & xs]
  (if (list? coll)
    (coll.unshift.apply coll (xs.reverse))
    (coll.push.apply coll xs)) coll)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn conj "" [coll &xs]
  (var cpy (slice coll))
  (if (vector? coll) (into :vector cpy))
  (if (list? coll) (into :list cpy))
  (if (map? coll) (into :map cpy))
  (apply conj! this (.concat [cpy] xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn pop! "" [coll]
  (var r (if (list? coll) (coll.shift) (coll.pop)))
  [r coll])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn pop "" [coll]
  (var r (if (list? coll) (first coll) (last coll)))
  [r (if (list? coll) (coll.slice 1) (coll.slice 0 -1))])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn prn "" [obj & [readable?]]
  (var _r (opt?? readable? true)
       pa (fn [arr s e]
            (str s (join " "
                         (map #(prn % _r) arr)) e)))
  (case (typeid obj)
    :lambda-arg (str "%" (+1 (int obj.value)))
    :atom (str "(atom " (prn obj.value _r) ")")
    :keyword (str ":" obj.value)
    :symbol obj.value
    :object (stringify obj)
    :vector (pa obj "[" "]")
    :map (pa obj "{" "}")
    :list (pa obj "(" ")")
    :array (pa obj "(" ")")
    :string obj
    (:null :nil) "null"
    (obj.toString)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deftype LambdaArg [][]
  ""
  (constructor [arg]
    (var name (if (= arg "%")
                "1" (rest arg))
         v (int name))
    (if-not (> v 0)
      (raise! "Bad lambda-arg: " arg))
    ;;zero based arg so minus 1
    (-- v)
    (set! this.value (str v))
    this)
  (toString [] this.value))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deftype Primitive [][]
  ""
  (constructor [v]
    (set! this.value v) this)
  (toString [] this.value))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deftype Keyword [][]
  ""
  (constructor [name]
    (set! this.value (rest name)) this)
  (toString [] this.value))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deftype Symbol [][]
  ""
  (constructor [name]
    (set! this.value name) this)
  (toString [] this.value))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn primitive? "" [obj] (inst? Primitive obj))
(defn primitive "" [v] (new Primitive v))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn symbol? "" [obj] (inst? Symbol obj))
(defn symbol "" [name] (new Symbol name))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn keyword? "" [obj] (inst? Keyword obj))
(defn keyword "" [name] (new Keyword name))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn lambda-arg? "" [obj] (inst? LambdaArg obj))
(defn lambda-arg "" [name] (new LambdaArg name))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deftype Atom [][]
  ""
  (constructor [val] (set! this.value val) this))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn atom? "" [atm] (inst? Atom atm))
(defn atom "" [val] (new Atom val))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn reset! "" [a v] (set! a.value v))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn deref "" [a] (.-value a))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn swap! "" [a f &xs]
  (->> (concat [a.value] xs)
       (apply f this)
       (set! a.value )) (get a :value))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn typeid "" [obj]
  (cond
    (lambda-arg? obj) :lambda-arg
    (keyword? obj) :keyword
    (symbol? obj) :symbol
    (vector? obj) :vector
    (atom? obj) :atom
    (list? obj) :list
    (map? obj) :map
    (nil? obj) :null
    (true? obj) :true
    (false? obj) :false
    (fn? obj) :function
    (string? obj) :string
    (number? obj) :number
    (array? obj) :array
    (object? obj) :object
    :else
    (raise! "Unknown type [" (type obj) "]")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn value? "" [obj]
  (or (nil? obj)
      (vector? obj)
      (list? obj)
      (map? obj)
      (false? obj)
      (true? obj)
      (string? obj)
      (number? obj)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn sequential? "" [arr]
  (and (array? arr) (not (map? arr))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn eq? "" [a b]
  (var ta (isa a)
       tb (isa b))
  (if-not (or (= ta tb)
              (and (sequential? a) (sequential? b)))
    false
    (case ta
      (:map :list :vector)
      (do-with [ok? true]
        (if (not= (alen a)
                  (alen b))
          (set! ok? false)
          (for [i 0
                :while (< i (alen a))
                :recur (+1 i)]
            (when-not (eq? (nth a i)
                           (nth b i))
              (set! ok? false)
              (break-out-of-loop!)))))
      :object
      (do-with [ok? true]
        (if-not (= (count a)
                   (count b))
          (set! ok? false)
          (for [i 0 k nil ks (keys a)
                :while (< i (alen ks)) :recur (+1 i)]
            (set! k (nth ks i))
            (when-not (eq? (get a k)
                           (get b k))
              (set! ok? false)
              (break-out-of-loop!)))))
      (:symbol :keyword)
      (= a.value b.value)
      ;else
      (= a b))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn object? "" [obj]
  (if-not (or (nil? obj)
              (array? obj)) (= (type obj) "object")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn last "" [coll]
  (if coll (nth coll (last-index coll))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn into "" [type coll]
  (case type
    :vector (set-in! coll :____vec true)
    :list (set-in! coll :____list true)
    :map (set-in! coll :____map true))
  coll)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn pairs? "" [obj]
  (and (array? obj)
       (not (vector? obj))
       (not (map? obj))
       (not (list? obj))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn list? "" [obj] (and (array? obj) obj.____list))
(defn list "" [&xs] (set-in! xs :____list true) xs)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn vector? "" [obj] (and (array? obj) obj.____vec))
(defn vector "" [&xs] (set-in! xs :____vec true) xs)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn map? "" [obj] (and (array? obj) obj.____map))
(defn hashmap "" [&xs]
  (if (= 1 (mod (alen xs) 2))
    (raise! "Odd number of hash map arguments"))
  (set-in! xs :____map true) xs)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn seq "" [obj]
  (cond
    (string? obj) (obj.split "")
    (array? obj) (obj.slice 0)
    (object? obj) (Object.entries obj)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn contains? "" [obj x]
  (cond
    (or (array? obj)
        (string? obj)) (obj.includes x)
    (object? obj) (obj.hasOwnProperty x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn nichts? "" [obj] (or (undef? obj) (nil? obj)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn some? "" [obj] (and (def? obj) (not= nil obj)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn count "" [coll]
  (if coll
    (alen (if (or (string? coll)
                  (array? coll)) coll (keys coll))) 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn concat* "" [coll & xs]
  (if coll (coll.concat.apply coll xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- every "" [coll start step]
  (var ret (vector))
  (for [i start
        :while (< i (alen coll)) :recur (+ i step)]
    (conj! ret (nth coll i)))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn evens "" [coll] (every coll 0 2))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn odds "" [coll] (every coll 1 2))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn interleave "" [c1 c2]
  (var cz (if (< (alen c2)
                 (alen c1)) (alen c2) (alen c1))
       ret (vector))
  (for [i 0
        :while (< i cz) :recur (+1 i)]
    (conj! ret (nth c1 i) (nth c2 i)))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;monads
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def m-identity
  {:bind (fn [mv mf] (mf mv))
   :result (fn [v] v)})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def m-maybe
  {:bind (fn [mv mf] (if (nil? mv) nil (mf mv)))
   :result (fn [v] v)
   :zero nil})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def m-array
  {:bind (fn [mv mf]
           (reduce
             (fn [acc v]
               (acc.concat v))
             (vector)
             (map mf mv)))
   :result (fn [v] (.concat (vector) v))
   :zero (vector)
   :plus #(reduce
            (fn [acc v]
              (acc.concat v))
            (vector)
            (slice arguments))})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def m-state
  {:bind (fn [mv mf]
           (fn [s]
             (var x (mv s))
             ((mf (nth x 0)) (nth x 1))))
   :result (fn [v]
             (fn [s]
               (.concat (vector) (vector v s))))})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def m-continuation
  {:bind (fn [mv mf]
           (fn [c]
             (mv (fn [v] ((mf v) c)))))
   :result (fn [v] (fn [c] (c v)))})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

