/*Auto generated by Kirby - v1.0.0 czlab.kirby.bl.parser Sun Oct 29 2017 14:23:24 GMT-0700 (PDT)*/

var types= require("./types");
var std= require("./stdlib");
var rdr= require("./lexer");
;
//
function throwE(token,msg) {
return (token ?
  (function (){ throw new Error([ msg,"\nnear line ",token.line,"\nin file ",token.source ].join("")); }).call(this) :
  (function (){ throw new Error([ msg,"\nnear EOF " ].join("")); }).call(this));
}

//
function nextToken(tokens) {
return (function() {
let t;
t= peekToken(tokens);
;
++tokens.pos;
return t;
}).call(this);
}

//
function peekToken(tokens) {
return tokens[tokens.pos];
}

//
function copyTokenData(token,node) {
(std.object_QUERY(node) ?
    (function() {
  node.source = token.source;
  node.line = token.line;
  return node.column = token.column;
  }).call(this) :
  null);
return node;
}

//
function readAtom(tokens) {
let ret,tn,token;
ret= null;
tn= "";
token= nextToken(tokens);
;
(token ?
  tn = token.name :
  null);
(std.empty_QUERY(tn) ?
  ret = undefined :
  (rdr.REGEX.float.test(tn) ?
    ret = parseFloat(tn) :
    ((rdr.REGEX.hex.test(tn)||rdr.REGEX.int.test(tn)) ?
      ret = parseInt(tn) :
      ((tn.startsWith("\"")&&tn.endsWith("\"")) ?
        ret = tn :
        (tn.startsWith(":") ?
          ret = types.keyword(tn) :
          (tn.startsWith("%") ?
            ret = types.lambda_arg(tn) :
            ((("nil" === tn)||("null" === tn)) ?
              ret = null :
              (("true" === tn) ?
                ret = true :
                (("false" === tn) ?
                  ret = false :
                  (true ?
                    ret = types.symbol(tn) :
                    null))))))))));
return copyTokenData(token,ret);
}

//
function readBlock(tokens,head,tail) {
let token,ok_QUERY,ret,tn,cur;
token= nextToken(tokens);
ok_QUERY= true;
ret= null;
tn= "";
cur= null;
;
(token ?
  tn = token.name :
  null);
((tn !== head) ?
  throwE(token,["expected '",head,"'"].join("")) :
  null);
return (function() {
let ast;
ast= [];
;
cur = peekToken(tokens);
(function () {let ____break=false;
for (; (!____break && ok_QUERY) ;) {
    ((std.nichts_QUERY(cur)||(tail === cur.name)) ?
        (function() {
    (cur ?
      copyTokenData(token,ast) :
      throwE(cur,["expected '",tail,"', got EOF"].join("")));
    return ok_QUERY = false;
    }).call(this) :
    null);
  (ok_QUERY ?
        (function() {
    addAst(ast,readTokens(tokens));
    return cur = peekToken(tokens);
    }).call(this) :
    null);
;
}
}).call(this);
nextToken(tokens);
return ast;
}).call(this);
}

//
function readList(cur,tokens) {
return readBlock(tokens,"(",")");
}

//
function readVector(cur,tokens) {
return (function() {
let v;
v= readBlock(tokens,"[","]");
;
v["____vec"] = true;
return v;
}).call(this);
}

//
function readObject(cur,tokens) {
return (function() {
let v;
v= readBlock(tokens,"{","}");
;
v["____map"] = true;
return v;
}).call(this);
}

//
function skipAndParse(tokens,func) {
return copyTokenData(nextToken(tokens),func(tokens));
}

//
function readTokens(tokens) {
let tmp,token;
tmp= null;
token= peekToken(tokens);
;
return (std.nichts_QUERY(token) ?
  undefined :
  (function() { let ____x;
switch (token.name) {
case "'":
____x= skipAndParse(tokens,function () {
  let ____args;
____args= Array.prototype.slice.call(arguments);
;
  return [ types.symbol("quote"),readTokens(tokens) ];
  });
break;
case "`":
____x= skipAndParse(tokens,function () {
  let ____args;
____args= Array.prototype.slice.call(arguments);
;
  return [ types.symbol("quasiquote"),readTokens(tokens) ];
  });
break;
case "~":
____x= skipAndParse(tokens,function () {
  let ____args;
____args= Array.prototype.slice.call(arguments);
;
  return [ types.symbol("unquote"),readTokens(tokens) ];
  });
break;
case "~@":
____x= skipAndParse(tokens,function () {
  let ____args;
____args= Array.prototype.slice.call(arguments);
;
  return [ types.symbol("splice-unquote"),readTokens(tokens) ];
  });
break;
case "^":
____x= skipAndParse(tokens,function () {
  tmp = readTokens(tokens);
  return [ types.symbol("with-meta"),readTokens(tokens),tmp ];
  });
break;
case "@":
____x= skipAndParse(tokens,function () {
  let ____args;
____args= Array.prototype.slice.call(arguments);
;
  return [ types.symbol("deref"),readTokens(tokens) ];
  });
break;
case "#":
____x= skipAndParse(tokens,function () {
  let ____args;
____args= Array.prototype.slice.call(arguments);
;
  return [ types.symbol("lambda"),readTokens(tokens) ];
  });
break;
case ")":
____x= throwE(token,"unexpected ')'");
break;
case "(":
____x= readList(token,tokens);
break;
case "]":
____x= throwE(token,"unexpected ']'");
break;
case "[":
____x= readVector(token,tokens);
break;
case "}":
____x= throwE(token,"unexpected '}'");
break;
case "{":
____x= readObject(token,tokens);
break;
case ";":
case ",":
____x=   (function() {
  let G__1;
G__1= undefined;
;
  nextToken(tokens);
  return G__1;
  }).call(this);
break;
default:
____x= readAtom(tokens);
break;
}
return ____x;}).call(this));
}

//
function addAst(ast,f) {
((!(typeof(f) === "undefined")) ?
  ast.push(f) :
  null);
return ast;
}

//
function parser(source) {
let G____1=Array.prototype.slice.call(arguments,1);
let G____2= G____1;
let fname;
fname=G____2[0];
let tokens,f,ast,tlen;
tokens= rdr.lexer(source,std.maybe(fname,"**adhoc**"));
f= null;
ast= [];
tlen= tokens.length;
;
tokens.pos = 0;
return (function() {
let ast;
ast= [];
;
;
(function () {let ____break=false;
for (; (!____break && (tokens.pos < tlen)) ;) {
    addAst(ast,readTokens(tokens));
;
}
}).call(this);
return ast;
}).call(this);
}

//
function dumpTree(tree) {
let G____3=Array.prototype.slice.call(arguments,1);
let G____4= G____3;
let indent;
indent=G____4[0];
let pad;
pad= " ".repeat(std.maybe(indent,0));
;
return (function () {let ____break=false;
for (let i = 0; (!____break && (i < tree.length)); i = (i+1)) {
    (console ?
    console.log([ types.pr_obj(tree[i]) ].join("")) :
    null);
;
}
}).call(this);
}



module.exports = {
  parser: parser,
  dumpTree: dumpTree
};

