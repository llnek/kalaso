/*Auto generated by Kirby - v1.0.0 czlab.kirby.bl.parser Sat Nov 11 2017 22:29:12 GMT-0800 (PST)*/

const std = require("./stdlib");
const lambda_DASH_arg = std["lambda_DASH_arg"];
const object_QUERY = std["object_QUERY"];
const nichts_QUERY = std["nichts_QUERY"];
const into = std["into"];
const vector = std["vector"];
const conj_BANG = std["conj_BANG"];
const opt_QUERY__QUERY = std["opt_QUERY__QUERY"];
const symbol = std["symbol"];
const keyword = std["keyword"];
const rdr = require("./lexer");
const kirbystdlibref = std;

const tnodeEx = rdr.tnodeEx();

const tnode = rdr.tnode();

//Raise an error
function throwE(token) {
  let msgs = Array.prototype.slice.call(arguments, 1);
  let s = msgs.join("");
  return (token ?
    (function() {
      throw new Error([s, "\nnear line: ", token.line, "\nin file: ", token.source].join("")) ;
    }).call(this) :
    (function() {
      throw new Error([s, "\nnear EOF "].join("")) ;
    }).call(this));
}

//Returns the next token,
//updates the token index
function nextToken(tokens) {
  let t = peekToken(tokens);
  ++tokens.pos;
  return t;
}

//Returns the next token,
//without moving the token index
function peekToken(tokens) {
  return tokens[tokens.pos];
}

//Attach source level information
//to the node
function copyTokenData(token, node) {
  if (object_QUERY(node)) {
    (node["source"] = token.source, node["line"] = token.line, node["column"] = token.column);
  }
  return node;
}

//Process an atom
function readAtom(tokens) {
  let ret = null;
  let tn = "";
  let token = nextToken(tokens);
  if (token) {
    tn = token.name;
  }
  if ( (0 === kirbystdlibref.count(tn)) ) {
    ret = undefined;
  } else {
    if (rdr.REGEX.float.test(tn)) {
      ret = parseFloat(tn);
    } else {
      if ( (rdr.REGEX.hex.test(tn) || rdr.REGEX.int.test(tn)) ) {
        ret = parseInt(tn);
      } else {
        if ( (tn.startsWith("\"") && tn.endsWith("\"")) ) {
          ret = tn;
        } else {
          if (tn.startsWith(":")) {
            ret = keyword(tn);
          } else {
            if (tn.startsWith("%")) {
              ret = lambda_DASH_arg(tn);
            } else {
              if ( (("nil" === tn) || ("null" === tn)) ) {
                ret = null;
              } else {
                if ( ("true" === tn) ) {
                  ret = true;
                } else {
                  if ( ("false" === tn) ) {
                    ret = false;
                  } else {
                    if (true) {
                      ret = symbol(tn);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return copyTokenData(token, ret);
}

//Process a LISP form
function readBlock(tokens, head, tail) {
  let ast = [];
  let ok_QUERY = true;
  let token = nextToken(tokens);
  let ret,
    cur,
    tn;
  if (token) {
    tn = token.name;
  }
  if ( (tn !== head) ) {
    throwE(token, "expected '", head, "'");
  }
  cur = peekToken(tokens);
  for (let ____break = false; ((!____break) && ok_QUERY);) {
    if ( (nichts_QUERY(cur) || (tail === cur.name)) ) {
      if (cur) {
        copyTokenData(token, ast);
      } else {
        throwE(cur, "expected '", tail, "', got EOF");
      }
      ok_QUERY = false;
    }
    if (ok_QUERY) {
      addAst(ast, read_STAR(tokens));
      cur = peekToken(tokens);
    }
  }
  nextToken(tokens);
  return ast;
}

//Process a LISP expression
function readList(cur, tokens) {
  return readBlock(tokens, "(", ")");
}

//Process a Vector
function readVector(cur, tokens) {
  return into_BANG("vector", readBlock(tokens, "[", "]"));
}

//Process a Hashmap
function readMap(cur, tokens) {
  return into_BANG("map", readBlock(tokens, "{", "}"));
}

//Advance the token index,
//then continue to parse
function skip_PLUS_parse(tokens, func) {
  return copyTokenData(nextToken(tokens), func(tokens));
}

//Main parser routine
function read_STAR(tokens) {
  let tmp = null;
  let token = peekToken(tokens);
  return (nichts_QUERY(token) ?
    undefined :
    (function() {
      let S____3;
      switch (token.name) {
        case "'":
          S____3 = skip_PLUS_parse(tokens, function() {
            let ____args = Array.prototype.slice.call(arguments);
            return [symbol("quote"), read_STAR(tokens)];
          });
          break;
        case "`":
          S____3 = skip_PLUS_parse(tokens, function() {
            let ____args = Array.prototype.slice.call(arguments);
            return [symbol("quasiquote"), read_STAR(tokens)];
          });
          break;
        case "~":
          S____3 = skip_PLUS_parse(tokens, function() {
            let ____args = Array.prototype.slice.call(arguments);
            return [symbol("unquote"), read_STAR(tokens)];
          });
          break;
        case "~@":
          S____3 = skip_PLUS_parse(tokens, function() {
            let ____args = Array.prototype.slice.call(arguments);
            return [symbol("splice-unquote"), read_STAR(tokens)];
          });
          break;
        case "^":
          S____3 = skip_PLUS_parse(tokens, function() {
            tmp = read_STAR(tokens);
            return [symbol("with-meta"), read_STAR(tokens), tmp];
          });
          break;
        case "@":
          S____3 = skip_PLUS_parse(tokens, function() {
            let ____args = Array.prototype.slice.call(arguments);
            return [symbol("deref"), read_STAR(tokens)];
          });
          break;
        case "#":
          S____3 = skip_PLUS_parse(tokens, function() {
            let ____args = Array.prototype.slice.call(arguments);
            return [symbol("lambda"), read_STAR(tokens)];
          });
          break;
        case ")":
          S____3 = throwE(token, "unexpected ')'");
          break;
        case "(":
          S____3 = readList(token, tokens);
          break;
        case "]":
          S____3 = throwE(token, "unexpected ']'");
          break;
        case "[":
          S____3 = readVector(token, tokens);
          break;
        case "}":
          S____3 = throwE(token, "unexpected '}'");
          break;
        case "{":
          S____3 = readMap(token, tokens);
          break;
        case ";":
        case ",":
          S____3 = (function() {
            let G__1 = undefined;
            nextToken(tokens);
            return G__1;
          }).call(this);
          break;
        default:
          S____3 = readAtom(tokens);
          break;
      }
      return S____3;
    }).call(this));
}

//
function addAst(ast, f) {
  if ( (!(typeof (f) === "undefined")) ) {
    conj_BANG(ast, f);
  }
  return ast;
}

//AST Parser
function parser(source) {
  let G____4 = Array.prototype.slice.call(arguments, 1);
  let G____5 = G____4;
  let fname;
  fname = G____5[0];
  let tokens = rdr.lexer(source, opt_QUERY__QUERY(fname, "*adhoc*"));
  let f = null;
  let ast = [];
  let tlen = tokens.length;
  tokens.pos = 0;
  for (let ____break = false; ((!____break) && (tokens.pos < tlen));) {
    addAst(ast, read_STAR(tokens));
  }
  return ast;
}

//Debug and dump the AST
function dumpTree(tree) {
  return (function() {
    for (let i = 0, ____break = false; ((!____break) && (i < tree.length)); i = (i + 1)) {
      if (console) {
        console.log([prn(tree[i])].join(""));
      }
    }
  }).call(this);
}



module.exports = {
  parser: parser,
  dumpTree: dumpTree
};

