/*Auto generated by Kirby - v1.0.0 czlab.kirby.bl.parser Thu Nov 09 2017 18:50:36 GMT-0800 (PST)*/

var std = require("./stdlib");
var lambda_DASH_arg = std["lambda_DASH_arg"];
var object_QUERY = std["object_QUERY"];
var nichts_QUERY = std["nichts_QUERY"];
var vector = std["vector"];
var conj_BANG = std["conj_BANG"];
var opt_QUERY__QUERY = std["opt_QUERY__QUERY"];
var list = std["list"];
var symbol = std["symbol"];
var keyword = std["keyword"];
var rdr = require("./lexer");
var kirbystdlibref = std;

let tnodeEx;
tnodeEx = rdr.tnodeEx();

let tnode;
tnode = rdr.tnode();

//
function throwE(token, msg) {
  return (token ?
    (function() {
      throw new Error([msg, "\nnear line ", token.line, "\nin file ", token.source].join("")) ;
    }).call(this) :
    (function() {
      throw new Error([msg, "\nnear EOF "].join("")) ;
    }).call(this));
}

//
function nextToken(tokens) {
  let t;
  t = peekToken(tokens);
  ++tokens.pos;
  return t;
}

//
function peekToken(tokens) {
  return tokens[tokens.pos];
}

//
function copyTokenData(token, node) {
  if (object_QUERY(node)) {
    (node["source"] = token.source, node["line"] = token.line, node["column"] = token.column);
  }
  return node;
}

//
function readAtom(tokens) {
  let ret,
    tn,
    token;
  ret = null;
  tn = "";
  token = nextToken(tokens);
  if (token) {
    tn = token.name;
  }
  if ( (0 === kirbystdlibref.count(tn)) ) {
    ret = undefined;
  } else {
    if (rdr.REGEX.float.test(tn)) {
      ret = parseFloat(tn);
    } else {
      if ( (rdr.REGEX.hex.test(tn) || rdr.REGEX.int.test(tn)) ) {
        ret = parseInt(tn);
      } else {
        if ( (tn.startsWith("\"") && tn.endsWith("\"")) ) {
          ret = tn;
        } else {
          if (tn.startsWith(":")) {
            ret = keyword(tn);
          } else {
            if (tn.startsWith("%")) {
              ret = lambda_DASH_arg(tn);
            } else {
              if ( (("nil" === tn) || ("null" === tn)) ) {
                ret = null;
              } else {
                if ( ("true" === tn) ) {
                  ret = true;
                } else {
                  if ( ("false" === tn) ) {
                    ret = false;
                  } else {
                    if (true) {
                      ret = symbol(tn);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return copyTokenData(token, ret);
}

//
function readBlock(tokens, head, tail) {
  let token,
    ast,
    ok_QUERY,
    ret,
    tn,
    cur;
  token = nextToken(tokens);
  ast = list();
  ok_QUERY = true;
  ret = null;
  tn = "";
  cur = null;
  if (token) {
    tn = token.name;
  }
  if ( (tn !== head) ) {
    throwE(token, ["expected '", head, "'"].join(""));
  }
  cur = peekToken(tokens);
  for (let ____break = false; ((!____break) && ok_QUERY);) {
    if ( (nichts_QUERY(cur) || (tail === cur.name)) ) {
      if (cur) {
        copyTokenData(token, ast);
      } else {
        throwE(cur, ["expected '", tail, "', got EOF"].join(""));
      }
      ok_QUERY = false;
    }
    if (ok_QUERY) {
      addAst(ast, read_STAR(tokens));
      cur = peekToken(tokens);
    }
  }
  nextToken(tokens);
  return ast;
}

//
function readList(cur, tokens) {
  return readBlock(tokens, "(", ")");
}

//
function readVector(cur, tokens) {
  let v;
  v = readBlock(tokens, "[", "]");
  v["____vec"] = true;
  return v;
}

//
function readMap(cur, tokens) {
  let v;
  v = readBlock(tokens, "{", "}");
  v["____map"] = true;
  return v;
}

//
function skip_PLUS_parse(tokens, func) {
  return copyTokenData(nextToken(tokens), func(tokens));
}

//
function read_STAR(tokens) {
  let tmp,
    token;
  tmp = null;
  token = peekToken(tokens);
  return (nichts_QUERY(token) ?
    undefined :
    (function() {
      let S____3;
      switch (token.name) {
        case "'":
          S____3 = skip_PLUS_parse(tokens, function() {
            let ____args;
            ____args = Array.prototype.slice.call(arguments);
            return list(symbol("quote"), read_STAR(tokens));
          });
          break;
        case "`":
          S____3 = skip_PLUS_parse(tokens, function() {
            let ____args;
            ____args = Array.prototype.slice.call(arguments);
            return list(symbol("quasiquote"), read_STAR(tokens));
          });
          break;
        case "~":
          S____3 = skip_PLUS_parse(tokens, function() {
            let ____args;
            ____args = Array.prototype.slice.call(arguments);
            return list(symbol("unquote"), read_STAR(tokens));
          });
          break;
        case "~@":
          S____3 = skip_PLUS_parse(tokens, function() {
            let ____args;
            ____args = Array.prototype.slice.call(arguments);
            return list(symbol("splice-unquote"), read_STAR(tokens));
          });
          break;
        case "^":
          S____3 = skip_PLUS_parse(tokens, function() {
            tmp = read_STAR(tokens);
            return list(symbol("with-meta"), read_STAR(tokens), tmp);
          });
          break;
        case "@":
          S____3 = skip_PLUS_parse(tokens, function() {
            let ____args;
            ____args = Array.prototype.slice.call(arguments);
            return list(symbol("deref"), read_STAR(tokens));
          });
          break;
        case "#":
          S____3 = skip_PLUS_parse(tokens, function() {
            let ____args;
            ____args = Array.prototype.slice.call(arguments);
            return list(symbol("lambda"), read_STAR(tokens));
          });
          break;
        case ")":
          S____3 = throwE(token, "unexpected ')'");
          break;
        case "(":
          S____3 = readList(token, tokens);
          break;
        case "]":
          S____3 = throwE(token, "unexpected ']'");
          break;
        case "[":
          S____3 = readVector(token, tokens);
          break;
        case "}":
          S____3 = throwE(token, "unexpected '}'");
          break;
        case "{":
          S____3 = readMap(token, tokens);
          break;
        case ";":
        case ",":
          S____3 = (function() {
            let G__1;
            G__1 = undefined;
            nextToken(tokens);
            return G__1;
          }).call(this);
          break;
        default:
          S____3 = readAtom(tokens);
          break;
      }
      return S____3;
    }).call(this));
}

//
function addAst(ast, f) {
  if ( (!(typeof (f) === "undefined")) ) {
    conj_BANG(ast, f);
  }
  return ast;
}

//
function parser(source) {
  let G____4 = Array.prototype.slice.call(arguments, 1);
  let G____5 = G____4;
  let fname;
  fname = G____5[0];
  let tokens,
    f,
    ast,
    tlen;
  tokens = rdr.lexer(source, opt_QUERY__QUERY(fname, "*adhoc*"));
  f = null;
  ast = list();
  tlen = tokens.length;
  tokens.pos = 0;
  for (let ____break = false; ((!____break) && (tokens.pos < tlen));) {
    addAst(ast, read_STAR(tokens));
  }
  return ast;
}

//
function dumpTree(tree) {
  let G____6 = Array.prototype.slice.call(arguments, 1);
  let G____7 = G____6;
  let indent;
  indent = G____7[0];
  let pad;
  pad = " ".repeat(opt_QUERY__QUERY(indent, 0));
  return (function() {
    for (let i = 0, ____break = false; ((!____break) && (i < tree.length)); i = (i + 1)) {
      if (console) {
        console.log([prn(tree[i])].join(""));
      }
    }
  }).call(this);
}



module.exports = {
  parser: parser,
  dumpTree: dumpTree
};

