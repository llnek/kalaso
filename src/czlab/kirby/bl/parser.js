/*Auto generated by Kirby - v1.0.0 czlab.kirby.bl.parser Mon Nov 06 2017 23:09:30 GMT-0800 (PST)*/

var std= require("./stdlib");
var rdr= require("./lexer");
var kirbystdlibref=std;

let tnodeEx;
tnodeEx= rdr.tnodeEx();

let tnode;
tnode= rdr.tnode();

//
function throwE(token,msg) {
return (token ?
(function (){ throw new Error([ msg,"\nnear line ",token.line,"\nin file ",token.source ].join("")); })(this) :
(function (){ throw new Error([ msg,"\nnear EOF " ].join("")); })(this));
}

//
function nextToken(tokens) {
return (function() {
let t;
t= peekToken(tokens);

++tokens.pos;
return t;
}).call(this);
}

//
function peekToken(tokens) {
return tokens[tokens.pos];
}

//
function copyTokenData(token,node) {
(std.object_QUERY(node) ?
(function() {
node.source=token.source;
node.line=token.line;
return node.column=token.column;
}).call(this) :
null);
return node;
}

//
function readAtom(tokens) {
let ret,tn,token;
ret= null;
tn= "";
token= nextToken(tokens);

(token ?
tn=token.name :
null);
((0 === kirbystdlibref.count(tn)) ?
ret=undefined :
(rdr.REGEX.float.test(tn) ?
ret=parseFloat(tn) :
((rdr.REGEX.hex.test(tn)||rdr.REGEX.int.test(tn)) ?
ret=parseInt(tn) :
((tn.startsWith("\"")&&tn.endsWith("\"")) ?
ret=tn :
(tn.startsWith(":") ?
ret=std.keyword(tn) :
(tn.startsWith("%") ?
ret=std.lambda_DASHarg(tn) :
((("nil" === tn)||("null" === tn)) ?
ret=null :
(("true" === tn) ?
ret=true :
(("false" === tn) ?
ret=false :
(true ?
ret=std.symbol(tn) :
null))))))))));
return copyTokenData(token,ret);
}

//
function readBlock(tokens,head,tail) {
let token,ok_QUERY,ret,tn,cur;
token= nextToken(tokens);
ok_QUERY= true;
ret= null;
tn= "";
cur= null;

(token ?
tn=token.name :
null);
((tn !== head) ?
throwE(token,["expected '",head,"'"].join("")) :
null);
return (function() {
let ast;
ast= [];

cur=peekToken(tokens);
(function() {
for (let ____break=false; ((!____break)&&ok_QUERY); ){
((std.nichts_QUERY(cur)||(tail === cur.name)) ?
(function() {
(cur ?
copyTokenData(token,ast) :
throwE(cur,["expected '",tail,"', got EOF"].join("")));
return ok_QUERY=false;
}).call(this) :
null);
(ok_QUERY ?
(function() {
addAst(ast,read_STAR(tokens));
return cur=peekToken(tokens);
}).call(this) :
null);
}
}).call(this);
nextToken(tokens);
return ast;
}).call(this);
}

//
function readList(cur,tokens) {
return readBlock(tokens,"(",")");
}

//
function readVector(cur,tokens) {
return (function() {
let v;
v= readBlock(tokens,"[","]");

v["____vec"]=true;
return v;
}).call(this);
}

//
function readMap(cur,tokens) {
return (function() {
let v;
v= readBlock(tokens,"{","}");

v["____map"]=true;
return v;
}).call(this);
}

//
function skip_PLUSparse(tokens,func) {
return copyTokenData(nextToken(tokens),func(tokens));
}

//
function read_STAR(tokens) {
let tmp,token;
tmp= null;
token= peekToken(tokens);

return (std.nichts_QUERY(token) ?
undefined :
(function() { let ____x;
switch (token.name) {
case "'":
____x= skip_PLUSparse(tokens,function () {
let ____args;
____args= Array.prototype.slice.call(arguments);

return [ std.symbol("quote"),read_STAR(tokens) ];
});
break;
case "`":
____x= skip_PLUSparse(tokens,function () {
let ____args;
____args= Array.prototype.slice.call(arguments);

return [ std.symbol("quasiquote"),read_STAR(tokens) ];
});
break;
case "~":
____x= skip_PLUSparse(tokens,function () {
let ____args;
____args= Array.prototype.slice.call(arguments);

return [ std.symbol("unquote"),read_STAR(tokens) ];
});
break;
case "~@":
____x= skip_PLUSparse(tokens,function () {
let ____args;
____args= Array.prototype.slice.call(arguments);

return [ std.symbol("splice-unquote"),read_STAR(tokens) ];
});
break;
case "^":
____x= skip_PLUSparse(tokens,function () {
tmp=read_STAR(tokens);
return [ std.symbol("with-meta"),read_STAR(tokens),tmp ];
});
break;
case "@":
____x= skip_PLUSparse(tokens,function () {
let ____args;
____args= Array.prototype.slice.call(arguments);

return [ std.symbol("deref"),read_STAR(tokens) ];
});
break;
case "#":
____x= skip_PLUSparse(tokens,function () {
let ____args;
____args= Array.prototype.slice.call(arguments);

return [ std.symbol("lambda"),read_STAR(tokens) ];
});
break;
case ")":
____x= throwE(token,"unexpected ')'");
break;
case "(":
____x= readList(token,tokens);
break;
case "]":
____x= throwE(token,"unexpected ']'");
break;
case "[":
____x= readVector(token,tokens);
break;
case "}":
____x= throwE(token,"unexpected '}'");
break;
case "{":
____x= readMap(token,tokens);
break;
case ";":
case ",":
____x=   (function() {
let G__1;
G__1= undefined;

nextToken(tokens);
return G__1;
}).call(this);
break;
default:
____x= readAtom(tokens);
break;
}
return ____x;}).call(this));
}

//
function addAst(ast,f) {
((!(typeof(f) === "undefined")) ?
std.conj_BANG(ast,f) :
null);
return ast;
}

//
function parser(source) {
let G____3=Array.prototype.slice.call(arguments,1);
let G____4= G____3;
let fname;
fname=G____4[0];
let tokens,f,ast,tlen;
tokens= rdr.lexer(source,std.opt(fname,"**adhoc**"));
f= null;
ast= [];
tlen= tokens.length;

tokens.pos=0;
return (function() {
let ast;
ast= [];


(function() {
for (let ____break=false; ((!____break)&&(tokens.pos < tlen)); ){
addAst(ast,read_STAR(tokens));
}
}).call(this);
return ast;
}).call(this);
}

//
function dumpTree(tree) {
let G____5=Array.prototype.slice.call(arguments,1);
let G____6= G____5;
let indent;
indent=G____6[0];
let pad;
pad= " ".repeat(std.opt(indent,0));

return (function() {
for (let i=0,____break=false; ((!____break)&&(i < tree.length)); i=(i+1)){
(console ?
console.log([ prn(tree[i]) ].join("")) :
null);
}
}).call(this);
}



module.exports = {
parser: parser,
dumpTree: dumpTree
};

