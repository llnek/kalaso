/*Auto generated by Kirby - v1.0.0 czlab.kirby.bl.env Wed Nov 22 2017 10:43:51 GMT+1100 (AEDT)*/

const std = require("./stdlib");
const contains_QUERY = std["contains_QUERY"];
const conj_BANG = std["conj_BANG"];
const some_QUERY = std["some_QUERY"];
const count = std["count"];
const last = std["last"];
const pop_BANG = std["pop_BANG"];
const opt_QUERY__QUERY = std["opt_QUERY__QUERY"];
const vector = std["vector"];
const Symbol = std["Symbol"];
const kirbystdlibref = std;
//Lexical Environment
class LEXEnv {
  //Create and initialize
  //a new env with these symbols,
  //and optionally a parent env
  constructor(parent, vars, exprs) {
    (this["nspaces"] = [], this["data"] = {}, this["parent"] = null);
    if (parent) {
      this["parent"] = parent;
    }
    for (let i = 0, e = null, ev = null, sz = kirbystdlibref.count(vars), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
      (e = vars[i], ev = e.value);
      if ( (ev === "&") ) {
        this.data[[vars[i + 1]].join("")] = Array.prototype.slice.call(exprs, i);
        ____break = true;
      } else {
        if (ev.startsWith("&")) {
          this.data[ev.slice(1)] = Array.prototype.slice.call(exprs, i);
          ____break = true;
        } else {
          if (true) {
            this.data[ev] = exprs[i];
          }
        }
      }
    }
    return this;
  }
  //Find the env
  //containing this symbol
  find(k) {
    if ( (!(k instanceof Symbol)) ) {
      throw new Error("env.xxx key must be a symbol");
    }
    return (contains_QUERY(this.data, k.value) ?
      this :
      (some_QUERY(this.parent) ?
        this.parent.find(k) :
        null));
  }
  //Bind this symbol,
  //value to this env
  set(k, v) {
    if ( (!(k instanceof Symbol)) ) {
      throw new Error("env.xxx key must be a symbol");
    }
    this.data[k.value] = v;
    return v;
  }
  //Get value of
  //this symbol
  get(k) {
    if ( (!(k instanceof Symbol)) ) {
      throw new Error("env.xxx key must be a symbol");
    }
    let env = this.find(k);
    if ( (!env) ) {
      throw new Error([k.value, " not found"].join(""));
    }
    return env.data[k.value];
  }
  //Add a namespace
  pushNSP(nsp) {
    return conj_BANG(this.nspaces, [nsp].join(""));
  }
  //Returns the
  //last added namespace
  peekNSP() {
    return last(this.nspaces);
  }
  //Return and remove
  //the last added namespace
  popNSP() {
    return pop_BANG(this.nspaces)[0];
  }
  //Get the first
  //added namespace
  firstNSP() {
    return this.nspaces[0];
  }
  //Count n# of
  //added namespaces
  countNSPCache() {
    return kirbystdlibref.count(this.nspaces);
  }
  //Clear all namespaces
  resetNSPCache() {
    this["nspaces"] = [];
    return null;
  }
}
module.exports = {
  LEXEnv: LEXEnv
};