/*Auto generated by Kirby - v1.0.0 czlab.kirby.bl.env Mon Nov 06 2017 02:50:31 GMT-0800 (PST)*/

var std= require("./stdlib");
var Symbol=std["Symbol"];
var kirbystdlibref=std;


class LEXEnv {
constructor (parent,vars,exprs) {
this["data"]={},this["parent"]=std.opt(parent,null);
((vars&&exprs) ?
(function() {
return (function() {
for (let i=0,e=null,ev=null,____break=false; ((!____break)&&(i < vars.length)); i=(i+1)){
(e=vars[i],ev=e.value);
((ev === "&") ?
(function() {
this.data[vars[(i+1)].toString()]=Array.prototype.slice.call(exprs,i);
return ____break=true;
}).call(this) :
(ev.startsWith("&") ?
(function() {
this.data[ev.slice(1)]=Array.prototype.slice.call(exprs,i);
return ____break=true;
}).call(this) :
(true ?
this.data[ev]=exprs[i] :
null)));
}
}).call(this)

}).call(this) :
null);
return this;
}

find (k) {
((!(k instanceof Symbol)) ?
(function (){ throw new Error("env.xxx key must be a symbol"); })(this) :
null);
return (std.contains_QUERY(this.data,k.value) ?
this :
(std.some_QUERY(this.parent) ?
this.parent.find(k) :
null));
}

set (k,v) {
((!(k instanceof Symbol)) ?
(function (){ throw new Error("env.xxx key must be a symbol"); })(this) :
null);
this.data[k.value]=v;
return v;
}

get (k) {
((!(k instanceof Symbol)) ?
(function (){ throw new Error("env.xxx key must be a symbol"); })(this) :
null);
let env;
env= this.find(k);

((!env) ?
(function (){ throw new Error([ k.value," not found" ].join("")); })(this) :
null);
return env.data[k.value];
}

pushNSP (nsp) {
return std.conj_BANG(this.nspaces,nsp.toString());
}

peekNSP () {
return std.last(this.nspaces);
}

popNSP () {
pop_BANG(this.nspaces);
return [ 0 ];
}

firstNSP () {
return this.nspaces[0];
}

countNSPCache () {
return this.nspaces.length;
}

resetNSPCache () {
return this.nspaces=std.vector();
}

}



module.exports = {
LEXEnv: LEXEnv
};

