/*Auto generated by Kirby - v1.0.0 czlab.kirby.bl.env Thu Nov 09 2017 17:19:17 GMT-0800 (PST)*/

var std = require("./stdlib");
var contains_QUERY = std["contains_QUERY"];
var conj_BANG = std["conj_BANG"];
var some_QUERY = std["some_QUERY"];
var count = std["count"];
var last = std["last"];
var pop_BANG = std["pop_BANG"];
var opt_QUERY__QUERY = std["opt_QUERY__QUERY"];
var vector = std["vector"];
var Symbol = std["Symbol"];
var kirbystdlibref = std;


//Lexical Environment
class LEXEnv {
  constructor(parent, vars, exprs) {
    (this["data"] = {}, this["parent"] = opt_QUERY__QUERY(parent, null));
    for (let i = 0, e = null, ev = null, len = count(vars), ____break = false; ((!____break) && (i < len)); i = (i + 1)) {
      (e = vars[i], ev = e.value);
      if ( (ev === "&") ) {
        this.data[[vars[(i + 1)]].join("")] = Array.prototype.slice.call(exprs, i);
        ____break = true;
      } else {
        if (ev.startsWith("&")) {
          this.data[ev.slice(1)] = Array.prototype.slice.call(exprs, i);
          ____break = true;
        } else {
          if (true) {
            this.data[ev] = exprs[i];
          }
        }
      }
    }
    return this;
  }

  find(k) {
    if ( (!(k instanceof Symbol)) ) {
      throw new Error("env.xxx key must be a symbol");
    }
    return (contains_QUERY(this.data, k.value) ?
      this :
      (some_QUERY(this.parent) ?
        this.parent.find(k) :
        null));
  }

  set(k, v) {
    if ( (!(k instanceof Symbol)) ) {
      throw new Error("env.xxx key must be a symbol");
    }
    this.data[k.value] = v;
    return v;
  }

  get(k) {
    if ( (!(k instanceof Symbol)) ) {
      throw new Error("env.xxx key must be a symbol");
    }
    let env;
    env = this.find(k);
    if ( (!env) ) {
      throw new Error([k.value, " not found"].join(""));
    }
    return env.data[k.value];
  }

  pushNSP(nsp) {
    return conj_BANG(this.nspaces, [nsp].join(""));
  }

  peekNSP() {
    return last(this.nspaces);
  }

  popNSP() {
    return pop_BANG(this.nspaces)[0];
  }

  firstNSP() {
    return this.nspaces[0];
  }

  countNSPCache() {
    return count(this.nspaces);
  }

  resetNSPCache() {
    return this.nspaces = vector();
  }

}



module.exports = {
  LEXEnv: LEXEnv
};

