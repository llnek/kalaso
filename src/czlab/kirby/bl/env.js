/*Auto generated by Kirby - v1.0.0 czlab.kirby.bl.env Sat Nov 04 2017 01:13:19 GMT-0700 (PDT)*/

var std= require("./stdlib");
var Symbol=std["Symbol"];
var kirbystdlibref=std;


class LEXEnv {
constructor (parent,vars,exprs) {
this["data"]={},this["parent"]=std.opt(parent,null);
((vars&&exprs) ?
(function() {
return (function() {
for (let i=0,e=null,ev=null,____break=false; ((!____break)&&(i < vars.length)); i=(i+1)){
e=vars[i],ev=e.value;
((ev === "&") ?
(function() {
this.data[vars[(i+1)].toString()]=Array.prototype.slice.call(exprs,i);
return break_out_of_loop_BANG();
}).call(this) :
(ev.startsWith("&") ?
(function() {
this.data[ev.slice(1)]=Array.prototype.slice.call(exprs,i);
return break_out_of_loop_BANG();
}).call(this) :
(true ?
this.data[ev]=exprs[i] :
null)));
}
})(this);

}).call(this) :
null);
return this;
}

find (k) {
((!(k instanceof Symbol)) ?
(function (){ throw new Error("env.xxx key must be a symbol"); }).call(this) :
null);
return (std.contains_QUERY(this.data,key.value) ?
this :
(std.some_QUERY(this.parent) ?
this.parent.find(k) :
null));
}

set (k,v) {
((!(k instanceof Symbol)) ?
(function (){ throw new Error("env.xxx key must be a symbol"); }).call(this) :
null);
this.data[k.value]=v;
return v;
}

get (k) {
((!(k instanceof Symbol)) ?
(function (){ throw new Error("env.xxx key must be a symbol"); }).call(this) :
null);
let env;
env= this.find(k);

((!env) ?
(function (){ throw new Error([ k.value," not found" ].join("")); }).call(this) :
null);
return env.data[k.value];
}

pushNSP (nsp) {
return conj_BANG(this.nspaces,nsp.toString());
}

peekNSP () {
return last(this.nspaces);
}

popNSP () {
pop_BANG(this.nspaces);
return [ 0 ];
}

firstNSP () {
return this.nspaces[0];
}

countNSPCache () {
return this.nspaces.length;
}

resetNSPCache () {
return this.nspaces=std.vector();
}

}



module.exports = {
LEXEnv: LEXEnv
};

