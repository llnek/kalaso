/*Auto generated by Kirby - v1.0.0 czlab.kirby.bl.env Mon Oct 30 2017 21:48:15 GMT-0700 (PDT)*/

var std= require("./stdlib");
var types= require("./types");
var Symbol=types["Symbol"];

//
function LEXEnv(parent,vars,exprs) {
this.parent = std.maybe(parent,null);
this.data = {};
((vars&&exprs) ?
(function() {
return (function () {let ____break=false;
for (let i = 0,e = null; (!____break && (i < vars.length)); i = (i+1)) {
e = vars[i].value;
(("&" === e) ?
(function() {
this.data[vars[(i+1)].value] = Array.prototype.slice.call(exprs,i);
return ____break = true;
}).call(this) :
(e.startsWith("&") ?
(function() {
this.data[e.slice(1)] = Array.prototype.slice.call(exprs,i);
return ____break = true;
}).call(this) :
(true ?
this.data[e] = exprs[i] :
null)));

}
}).call(this);
}).call(this) :
null);
return this;
}


//
LEXEnv.prototype.find = function (key) {
((!(key instanceof Symbol)) ?
(function (){ throw new Error([ "env.xxx key must be a symbol" ].join("")); }).call(this) :
null);
return (std.contains_QUERY(this.data,key.value) ?
this :
(std.some_QUERY(this.parent) ?
this.parent.find(key) :
null));
}

//
LEXEnv.prototype.set = function (key,value) {
((!(key instanceof Symbol)) ?
(function (){ throw new Error([ "env.xxx key must be a symbol" ].join("")); }).call(this) :
null);
this.data[key.value] = value;
return value;
}

//
LEXEnv.prototype.get = function (key) {
((!(key instanceof Symbol)) ?
(function (){ throw new Error([ "env.xxx key must be a symbol" ].join("")); }).call(this) :
null);
let env;
env= this.find(key);

((!env) ?
(function (){ throw new Error([ key.value,"' not found" ].join("")); }).call(this) :
null);
return env.data[key.value];
}



module.exports = {
LEXEnv: LEXEnv
};

