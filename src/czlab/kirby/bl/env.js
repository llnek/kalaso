/*Auto generated by Kirby - v1.0.0 czlab.kirby.bl.env Sun Nov 12 2017 17:36:42 GMT-0800 (PST)*/

const std = require("./stdlib");
const contains_QUERY = std["contains_QUERY"];
const conj_BANG = std["conj_BANG"];
const some_QUERY = std["some_QUERY"];
const count = std["count"];
const last = std["last"];
const pop_BANG = std["pop_BANG"];
const opt_QUERY__QUERY = std["opt_QUERY__QUERY"];
const vector = std["vector"];
const Symbol = std["Symbol"];
const kirbystdlibref = std;


//Lexical Environment
class LEXEnv {
  constructor(parent, vars, exprs) {
    (this["nspaces"] = [], this["data"] = {}, this["parent"] = null);
    if (parent) {
      this["parent"] = parent;
    }
    for (let i = 0, e = null, ev = null, sz = kirbystdlibref.count(vars), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
      (e = vars[i], ev = e.value);
      if ( (ev === "&") ) {
        this.data[[vars[i + 1]].join("")] = Array.prototype.slice.call(exprs, i);
        ____break = true;
      } else {
        if (ev.startsWith("&")) {
          this.data[ev.slice(1)] = Array.prototype.slice.call(exprs, i);
          ____break = true;
        } else {
          if (true) {
            this.data[ev] = exprs[i];
          }
        }
      }
    }
    return this;
  }

  find(k) {
    if ( (!(k instanceof Symbol)) ) {
      throw new Error("env.xxx key must be a symbol");
    }
    return (contains_QUERY(this.data, k.value) ?
      this :
      (some_QUERY(this.parent) ?
        this.parent.find(k) :
        null));
  }

  set(k, v) {
    if ( (!(k instanceof Symbol)) ) {
      throw new Error("env.xxx key must be a symbol");
    }
    this.data[k.value] = v;
    return v;
  }

  get(k) {
    if ( (!(k instanceof Symbol)) ) {
      throw new Error("env.xxx key must be a symbol");
    }
    let env = this.find(k);
    if ( (!env) ) {
      throw new Error([k.value, " not found"].join(""));
    }
    return env.data[k.value];
  }

  pushNSP(nsp) {
    return conj_BANG(this.nspaces, [nsp].join(""));
  }

  peekNSP() {
    return last(this.nspaces);
  }

  popNSP() {
    return pop_BANG(this.nspaces)[0];
  }

  firstNSP() {
    return this.nspaces[0];
  }

  countNSPCache() {
    return kirbystdlibref.count(this.nspaces);
  }

  resetNSPCache() {
    return this["nspaces"] = [];
  }

}



module.exports = {
  LEXEnv: LEXEnv
};

