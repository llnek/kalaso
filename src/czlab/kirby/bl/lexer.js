/*Auto generated by Kirby - v1.0.0 czlab.kirby.bl.lexer Sun Oct 29 2017 14:23:12 GMT-0700 (PDT)*/

var tn= require("./tnode");
var std= require("./stdlib");
;
let REGEX;
REGEX= { noret: /^def\b|^var\b|^set!\b|^throw\b/,id: /^[a-zA-Z_$][\/.?\-*!0-9a-zA-Z_'<>%#@$]*$/,id2: /^[*\-][\/.?\-*!0-9a-zA-Z_'<>%#@$]+$/,float: /^[-+]?[0-9]+\.[0-9]+$/,int: /^[-+]?[0-9]+$/,hex: /^[-+]?0x/,dquoteHat: /^"/,dquoteEnd: /"$/,func: /^function\b/,slash: /\//g,query: /\?/g,perc: /%/g,bang: /!/g,plus: /\+/g,dash: /-/g,quote: /'/g,hash: /#/g,at: /@/g,less: /</g,greater: />/g,star: /\*/g,wspace: /\s/ };
;
//
function testid_QUERY(name) {
return (REGEX.id.test(name)||REGEX.id2.test(name));
}

//
function jsid(name) {
let pfx;
pfx= "";
;
(((typeof(name) === "string")&&("-" === name.charAt(0))) ?
    (function() {
  pfx = "-";
  return name = name.slice(1);
  }).call(this) :
  null);
return (testid_QUERY(name) ?
  [pfx,name].join("").replace(REGEX.query,"_query").replace(REGEX.slash,".").replace(REGEX.bang,"_bang").replace(REGEX.dash,"_dash").replace(REGEX.quote,"_quote").replace(REGEX.hash,"_hash").replace(REGEX.plus,"_plus").replace(REGEX.perc,"_perc").replace(REGEX.at,"_at").replace(REGEX.less,"_lt").replace(REGEX.greater,"_gt").replace(REGEX.star,"_star") :
  ((pfx === "") ?
    name :
    [pfx,name].join("")));
}

//
function lexer(source,fname) {
let len,token,line,tcol,col,pos,ch,nx,esc_QUERY,str_QUERY,regex_QUERY,comment_QUERY;
len= source.length;
token= "";
line= 1;
tcol= 0;
col= 0;
pos= 0;
ch= null;
nx= null;
esc_QUERY= false;
str_QUERY= false;
regex_QUERY= false;
comment_QUERY= false;
;
return (function() {
let tree;
tree= [];
;
let toke;
toke= function (ln,col,s,s_QUERY) {
(std.maybe(s_QUERY,std.not_empty(s)) ?
  tree.push(tn.tnode(fname,ln,col,s,s)) :
  null);
return "";
};
;
(function () {let ____break=false;
for (; (!____break && (pos < len)) ;) {
    ch = source.charAt(pos);
  ++col;
  ++pos;
  nx = source.charAt(pos);
  ((ch === "\n") ?
        (function() {
    col = 0;
    ++line;
    return (comment_QUERY ?
      comment_QUERY = false :
      null);
    }).call(this) :
    null);
  (comment_QUERY ?
    null :
    (esc_QUERY ?
            (function() {
      esc_QUERY = false;
      return token += ch;
      }).call(this) :
      (regex_QUERY ?
                (function() {
        ((ch === "\\") ?
          esc_QUERY = true :
          null);
        token += ch;
        return ((ch === "/") ?
                    (function() {
          regex_QUERY = false;
          ("gimuy".includes(nx) ?
                        (function() {
            token += nx;
            return ++pos;
            }).call(this) :
            null);
          return token = toke(line,tcol,token);
          }).call(this) :
          null);
        }).call(this) :
        ((ch === "\"") ?
          ((!str_QUERY) ?
                        (function() {
            tcol = col;
            str_QUERY = true;
            return token += ch;
            }).call(this) :
                        (function() {
            str_QUERY = false;
            token += ch;
            return token = toke(line,tcol,token,true);
            }).call(this)) :
          (str_QUERY ?
                        (function() {
            ((ch === "\n") ?
              ch = "\\n" :
              null);
            ((ch === "\\") ?
              esc_QUERY = true :
              null);
            return token += ch;
            }).call(this) :
            (((ch === "'")||(ch === "`")||(ch === "@")||(ch === "^")) ?
              ((std.empty_QUERY(token)&&(!REGEX.wspace.test(nx))) ?
                                (function() {
                tcol = col;
                return toke(line,tcol,ch);
                }).call(this) :
                token += ch) :
              (((ch === "&")&&(nx === "&")) ?
                                (function() {
                (std.empty_QUERY(token) ?
                  tcol = col :
                  null);
                token += [ch,nx].join("");
                return ++pos;
                }).call(this) :
                ((ch === "~") ?
                  ((std.empty_QUERY(token)&&(!REGEX.wspace.test(nx))) ?
                                        (function() {
                    tcol = col;
                    return ((nx === "@") ?
                                            (function() {
                      ++pos;
                      return toke(line,tcol,"~@");
                      }).call(this) :
                      toke(line,tcol,ch));
                    }).call(this) :
                    token += ch) :
                  (((ch === "/")&&std.empty_QUERY(token)) ?
                                        (function() {
                    regex_QUERY = true;
                    tcol = col;
                    return token += ch;
                    }).call(this) :
                    (((ch === "[")||(ch === "]")||(ch === "{")||(ch === "}")||(ch === "(")||(ch === ")")) ?
                                            (function() {
                      token = toke(line,tcol,token);
                      tcol = col;
                      return toke(line,tcol,ch);
                      }).call(this) :
                      ((ch === ";") ?
                                                (function() {
                        token = toke(line,tcol,token);
                        tcol = col;
                        return comment_QUERY = true;
                        }).call(this) :
                        (((ch === ",")||REGEX.wspace.test(ch)) ?
                          token = toke(((ch === "\n") ?
                            (line-1) :
                            line),tcol,token) :
                          (true ?
                                                        (function() {
                            (std.empty_QUERY(token) ?
                              tcol = col :
                              null);
                            return token += ch;
                            }).call(this) :
                            null)))))))))))));
;
}
}).call(this);
return tree;
}).call(this);
}



module.exports = {
  REGEX: REGEX,
  testid_QUERY: testid_QUERY,
  jsid: jsid,
  lexer: lexer
};

