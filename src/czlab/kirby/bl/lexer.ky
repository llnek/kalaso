;; Copyright (c) 2013-2017, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author "Kenneth Leung"}

  czlab.kirby.bl.lexer

  (require ["source-map" :as smap]
           ["./stdlib"
            :as std
            :refer [contains?
                    opt??
                    conj!
                    list
                    not-empty]]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn tnodeEx
"Create a token"
  [chunk name] (tnode nil nil nil chunk name))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn tnode
"Create a token with source information"
  [&[source line col chunk name]]
  (new smap/SourceNode
       line col source chunk (opt?? name "")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- REGEX {
  noret /^def\b|^var\b|^set!\b|^set-in!\b|^throw\b/
  id /^[a-zA-Z_$][\/.?\-*!0-9a-zA-Z_'<>%#@$\+]*$/
  id2 /^[*\-][\/.?\-*!0-9a-zA-Z_'<>%#@$\+]+$/
  float /^[-+]?[0-9]+\.[0-9]+$/
  int /^[-+]?[0-9]+$/
  hex /^[-+]?0x/
  dquoteHat /^"/
  dquoteEnd /"$/
  func /^function\b/
  slash /\//g
  query /\?/g
  perc /%/g
  bang /!/g
  plus /\+/g
  dash /-/g
  quote /'/g
  hash /#/g
  at /@/g
  less /</g
  greater />/g
  star /\*/g
  wspace /\s/})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- REPLACERS
  [[REGEX.query "_QUERY_"]
        [REGEX.bang "_BANG_"]
        [REGEX.dash "_DASH_"]
        [REGEX.quote "_QUOTE_"]
        [REGEX.hash "_HASH_"]
        [REGEX.plus "_PLUS_"]
        [REGEX.perc "_PERC_"]
        [REGEX.at "_AT_"]
        [REGEX.less "_LT_"]
        [REGEX.greater "_GT_"]
        [REGEX.star "_STAR_"]])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn testid?
"Returns true if a valid js identifier"
  [name]
  (or (REGEX.id.test name)
      (REGEX.id2.test name)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn jsid
"Escape to compliant js identifier"
  [name]
  (var pfx "")
  (when (and (string? name)
             (= "-" (ch@ name 0)))
    (set! pfx "-"
          name (rest name)))
  (if (testid? name)
    (reduce
      (fn [acc x]
        (set! acc
              (acc.replace (first x) (second x)))
        (if (acc.endsWith (second x))
          (acc.slice 0 -1)
          acc))
      (.replace (str pfx name)
                REGEX.slash ".") REPLACERS)
    (if (= pfx "") name (str pfx name))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn lexer
"Lexical analyzer"
  [source fname]
  (var len (alen source)
       tree []
       ch nil nx nil
       token "" line 1
       tcol 0 col 0 pos 0
       esc? false str? false
       regex? false comment? false
       toke
       (fn [ln col s s?]
         (if (opt?? s? (not-empty s))
           (conj! tree (tnode fname ln col s s))) ""))
  (while (< pos len)
    (set! ch (ch@ source pos))
    (++ col)
    (++ pos)
    (set! nx (ch@ source pos))
    (when (= ch "\n")
      (set! col 0)
      (++ line)
      (if comment? (false! comment?)))
    (cond
      comment? nil
      esc? (do (false! esc?)
               (+= token ch))
      regex?
      (do (if (= ch "\\")
            (true! esc?))
          (+= token ch)
          (when (= ch "/")
            (false! regex?)
            (when (contains? "gimuy" nx)
              (+= token nx)
              (++ pos))
            (set! token (toke line tcol token))))
      (= ch "\"")
      (if-not str?
        (do (set! tcol col)
            (true! str?)
            (+= token ch))
        (do (false! str?)
            (+= token ch)
            (set! token
                  (toke line tcol token true))))
      str?
      (do (if (= ch "\n") (set! ch "\\n"))
          (if (= ch "\\") (set! esc? true))
          (+= token ch))
      (or (= ch "'") (= ch "`")
          (= ch "$") (= ch "@") (= ch "^"))
      (if (and (empty? token)
               (not (REGEX.wspace.test nx)))
        (do (set! tcol col)
            (toke line tcol ch))
        (+= token ch))
      (and (= ch "&")
           (= nx "&"))
      (do (if (empty? token) (set! tcol col))
          (+= token (str ch nx))
          (++ pos))
      (= ch "~")
      (if (and (empty? token)
               (not (REGEX.wspace.test nx)))
        (do (set! tcol col)
            (if (= nx "@")
              (do (++ pos)
                  (toke line tcol "~@"))
              (toke line tcol ch)))
        (+= token ch))
      (and (= ch "/")
           (empty? token))
      (do (true! regex?)
          (set! tcol col)
          (+= token ch))
      (or (= ch "[")(= ch "]")
          (= ch "{")(= ch "}")
          (= ch "(")(= ch ")"))
      (do (set! token (toke line
                            tcol token)
                tcol col)
          (toke line tcol ch))
      (= ch ";")
      (set! token (toke line
                        tcol token)
            tcol col
            comment? true)
      (or (= ch ",")
          (REGEX.wspace.test ch))
      (->> (-> (if (= ch "\n")
                 (-1 line) line)
               (toke tcol token))
           (set! token))
      :else
      (do (if (empty? token)
            (set! tcol col))
          (+= token ch))))
  tree)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

