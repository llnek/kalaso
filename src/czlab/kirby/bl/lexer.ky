;; Copyright (c) 2013-2017, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author "Kenneth Leung"}

  czlab.kirby.bl.lexer

  (require ["./stdlib" :as std]
           ["source-map" :rename {SourceNode TreeNode}]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn tnodeEx "" [chunk name] (tnode nil nil nil chunk name))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn tnode "" [&[source line col chunk name]]
  (new TreeNode line col source chunk (std/opt name "")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def REGEX {
  noret /^def\b|^var\b|^set!\b|^set-in!\b|^throw\b/
  id /^[a-zA-Z_$][\/.?\-*!0-9a-zA-Z_'<>%#@$\+]*$/
  id2 /^[*\-][\/.?\-*!0-9a-zA-Z_'<>%#@$\+]+$/
  float /^[-+]?[0-9]+\.[0-9]+$/
  int /^[-+]?[0-9]+$/
  hex /^[-+]?0x/
  dquoteHat /^"/
  dquoteEnd /"$/
  func /^function\b/
  slash /\//g
  query /\?/g
  perc /%/g
  bang /!/g
  plus /\+/g
  dash /-/g
  quote /'/g
  hash /#/g
  at /@/g
  less /</g
  greater />/g
  star /\*/g
  wspace /\s/})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn testid? "" [name]
  (or (REGEX.id.test name) (REGEX.id2.test name)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn jsid "" [name]
  (var pfx "")
  (when (and (string? name)
             (= "-" (name.charAt 0)))
    (set! pfx "-")
    (set! name (rest name)))
  (if (testid? name)
    (-> (str pfx name)
        (.replace REGEX.query "_QUERY")
        (.replace REGEX.slash ".")
        (.replace REGEX.bang "_BANG")
        (.replace REGEX.dash "_DASH")
        (.replace REGEX.quote "_QUOTE")
        (.replace REGEX.hash "_HASH")
        (.replace REGEX.plus "_PLUS")
        (.replace REGEX.perc "_PERC")
        (.replace REGEX.at "_AT")
        (.replace REGEX.less "_LT")
        (.replace REGEX.greater "_GT")
        (.replace REGEX.star "_STAR"))
    (if (= pfx "") name (str pfx name))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn lexer "" [source fname]
  (var len (alen source)
       token ""
       line 1
       tcol 0
       col 0
       pos 0
       ch nil
       nx nil
       esc? false
       str? false
       regex? false
       comment? false)
  (do-with [tree (std/vector)]
    (var toke (fn [ln col s s?]
                (if (std/opt s? (std/not-empty s))
                  (conj! tree (tnode fname ln col s s))) ""))
    (while (< pos len)
      (set! ch (source.charAt pos))
      (++ col)
      (++ pos)
      (set! nx (source.charAt pos))
      (when (= ch "\n")
        (set! col 0)
        (++ line)
        (if comment? (set! comment? false)))
      (cond
        comment? nil
        esc? (do (set! esc? false)
                 (+= token ch))
        regex?
        (do (if (= ch "\\") (set! esc? true))
            (+= token ch)
            (when (= ch "/")
              (set! regex? false)
              (when (.includes "gimuy" nx)
                (+= token nx)
                (++ pos))
              (set! token (toke line tcol token))))
        (= ch "\"")
        (if-not str?
          (do (set! tcol col)
              (set! str? true)
              (+= token ch))
          (do (set! str? false)
              (+= token ch)
              (set! token
                    (toke line tcol token true))))
        str?
        (do (if (= ch "\n") (set! ch "\\n"))
            (if (= ch "\\") (set! esc? true))
            (+= token ch))
        (or (= ch "'")
            (= ch "`")
            (= ch "@")
            (= ch "^"))
        (if (and (empty? token)
                 (not (REGEX.wspace.test nx)))
          (do (set! tcol col)
              (toke line tcol ch))
          (+= token ch))
        (and (= ch "&")
             (= nx "&"))
        (do (if (empty? token) (set! tcol col))
            (+= token (str ch nx))
            (++ pos))
        (= ch "~")
        (if (and (empty? token)
                 (not (REGEX.wspace.test nx)))
          (do (set! tcol col)
              (if (= nx "@")
                (do (++ pos)
                    (toke line tcol "~@"))
                (toke line tcol ch)))
          (+= token ch))
        (and (= ch "/")
             (empty? token))
        (do (set! regex? true)
            (set! tcol col)
            (+= token ch))
        (or (= ch "[")(= ch "]")
            (= ch "{")(= ch "}")
            (= ch "(")(= ch ")"))
        (do (set! token (toke line tcol token))
            (set! tcol col)
            (toke line tcol ch))
        (= ch ";")
        (do (set! token (toke line tcol token))
            (set! tcol col)
            (set! comment? true))
        (or (= ch ",")
            (REGEX.wspace.test ch))
        (->> (-> (if (= ch "\n") (-1 line) line)
                 (toke tcol token))
             (set! token))
        :else
        (do (if (empty? token) (set! tcol col)) (+= token ch))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

