;; Copyright (c) 2013-2017, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author "Kenneth Leung"}

  czlab.kirby.bl.types

  (require ["./stdlib" :as std]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn wrap-str "" [s]
  (str "\""
       (-> (.replace s /\\/g "\\\\")
           (.replace /"/g "\\\"")
           (.replace /\n/g "\\n")) "\""))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn unwrap-str "" [s]
  (if (and (s.startsWith "\"")
           (s.endsWith "\""))
    (-> (s.slice 1 (last-index s))
        (.replace /\\"/g "\"")
        (.replace /\\n/g "\n")
        (.replace /\\\\/g "\\")) s))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn pr-obj "" [obj & [readable?]]
  (var _r (if (isdef? readable?) readable? true))
  (var pa #(-> (map #(pr-obj % _r) obj)(.join " ")))

  (case (obj-type obj)
    :list (str "(" (pa) ")")
    :vector (str "[" (pa) "]")
    :hash-map (str "{" (pa) "}")
    :object
    (str "{"
         (reduce
           (fn [acc k]
             (acc.push (pr-obj k _r)
                       (pr-obj (nth obj k) _r)) acc)
           []
           (obj-keys obj)) "}")
    :string
    (if (and false _r) (wrap-str obj) obj)
    (:null :nil) "null"
    :atom
    (str "(atom " (pr-obj (.-value obj) _r)  ")")
    :keyword
    (str ":" (.-value obj))
    ;;else
    (.toString obj)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn obj-type "" [obj]
  (cond
    (keyword? obj) :keyword
    (symbol? obj) :symbol
    (list? obj) :list
    (vector? obj) :vector
    (object? obj) :object
    (map? obj) :hash-map
    (nil? obj) :null
    (true? obj) :true
    (false? obj) :false
    (atom? obj) :atom
    (fn? obj) :function
    (string? obj) :string
    (number? obj) :number
    :else
    (raise! "Unknown type '" (type obj) "'")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn value? "" [obj]
  (or (nil? obj)
      (true? obj)
      (vector? obj)
      (map? obj)
      (false? obj)
      (string? obj)
      (number? obj)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn sequential? "" [arr] (or (list? arr) (vector? arr)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn eq? "" [a b]
  (var ta (obj-type a)
       tb (obj-type b))
  (if-not (or (= ta tb)
              (and (sequential? a) (sequential? b)))
    false
    (case ta
      :symbol (= (.-value a)(.-value b))
      (:hash-map :list :vector)
      (do-with [ok? true]
        (if (not= (alen a)
                  (alen b))
          (set! ok? false)
          (forlet ((i 0)
                   (< i (alen a)) (i (inc i)))
            (when-not (eq? (nth a i)
                           (nth b i))
              (set! ok? false)
              (set! ____break true)))))
      :object
      (do-with [ok? true]
        (if-not (= (count a)
                   (count b))
          (set! ok? false)
          (forlet ((i 0
                    k nil
                    ks (obj-keys a))
                   (< i (alen ks)) (i (inc i)))
            (set! k (nth ks i))
            (when-not (eq? (get a k)
                           (get b k))
              (set! ok? false)
              (set! ____break true)))))
      ;else
      (= a b))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn clone "" [obj]
  (do-with [ret nil]
    (case (obj-type obj)
      :list
      (set! ret (slice obj))
      :vector
      (do (set! ret (slice obj))
          (set! ret :__isvector__ true))
      :hash-map
      (do (set! ret (slice obj))
          (set! ret :__ismap__ true))
      :object
      (do (set! ret {})
          (reduce
            (fn [acc n] (set! acc n (get obj n)) acc)
            ret (obj-keys obj)))
      :function
      (set! ret (obj.clone))
      ;else
      (raise! "clone of non-collection: " (obj-type obj)))
    (Object.defineProperty ret
                           "__meta__"
                           {:enumerable false :writable true })))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn LambdaArg "" [arg]
  (var name (arg.slice 1)
       v (parseInt name))
  (if (empty? name) (set! name "1"))
  (if-not (> v 0)
    (raise! "Bad lambda-arg: " arg))
  ;;zero based arg so minus 1
  (-- v)
  (set! this.value (str v))
  this)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn Keyword "" [name]
  (set! this.value (name.slice 1)) this)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn Symbol "" [name] (set! this.value name) this)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn Symbol.prototype.toString "" [] (.-value this))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn symbol "" [name] (new Symbol name))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn symbol? "" [obj] (inst? Symbol obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn symbol-s "" [s]
  (if (symbol? s)
    (.-value s)
    (if s (s.toString) "")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn Keyword.prototype.toString "" [] (.-value this))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn keyword "" [name] (new Keyword name))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn keyword? "" [obj] (inst? Keyword obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn keyword-s "" [k]
  (if (keyword? k)
    (.-value k)
    (if k (k.toString) "")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn LambdaArg.prototype.toString "" [] (.-value this))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn lambda-arg "" [name] (new LambdaArg name))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn lambda-arg? "" [obj] (inst? LambdaArg obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn lambda-arg-s "" [k]
  (if (lambda-arg? k) (.-value k) (if k (k.toString) "")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn fn-wrap "" [run Env ast env params]
  (do-with [f #(run ast (new Env env params arguments))]
    (set! f :_ismacro_ false)
    (set! f :__meta__ nil)
    (set! f :__ast__ ast)
    (set! f :__gen_env__  (fn [args] (new Env env params args)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn Function.prototype.clone "" []
  (var that this)
  (do-with [tmp #(.apply that this arguments)]
    (each-key
      (fn [k] (set! tmp k (get that k))) that)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn list "" [&xs] xs)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn list? "" [obj]
  (and (array? obj)
       (not obj.__isvector__) (not obj.__ismap__)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn vector "" [&xs]
  (set! xs :__isvector__ true) xs)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn vector? "" [obj]
  (and (array? obj)
       (true? obj.__isvector__)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn map? "" [obj]
  (and (array? obj)
       (true? obj.__ismap__)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn hashmap "" [&xs]
  (if (= 1 (mod (alen xs) 2))
    (raise! "Odd number of hash map arguments"))
  (assoc.apply this (concat [ {} ] xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn isObject? "" [m]
  (and (object? m)
       (not (inst? LambdaArg m))
       (not (inst? Atom m))
       (not (inst? Symbol m))
       (not (inst? Keyword m))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn assoc "" [m & xs]
  (if (not= 0 (mod (alen xs) 2))
    (raise! "Odd number of assoc arguments"))
  (forlet ((i 0 k nil v nil)
           (< i (alen xs)) (i (+ i 2)))
    (set! k (str "" (nth xs i)))
    (set! v (nth xs (+ i 1)))
    (if-not (string? k)
      (raise! "expected string, got: " (type k)))
    (set! m k v))
  m)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn dissoc "" [m & xs]
  (forlet ((i 0) (< i (alen xs)) (i (+ i 1)))
    (delete! m (str "\"" (nth xs i) "\"")))
  m)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn Atom "" [val] (set! this.value val))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn atom "" [val] (new Atom val))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn atom? "" [atm] (inst? Atom atm))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

