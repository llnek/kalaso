;; Copyright (c) 2013-2017, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author "Kenneth Leung"}

  czlab.kirby.bl.types

  (require ["./stdlib" :as std]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn wrap-str "" [s]
  (str "\""
       (-> (s.replace /\\/g "\\\\")
           (.replace /"/g "\\\"")
           (.replace /\n/g "\\n")) "\""))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn unwrap-str "" [s]
  (if (and (s.startsWith "\"")
           (s.endsWith "\""))
    (-> (s.slice 1 (last-index s))
        (.replace /\\"/g "\"")
        (.replace /\\n/g "\n")
        (.replace /\\\\/g "\\")) s))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn pr-obj "" [obj & [readable?]]
  (var _r (std/maybe readable? true)
       pa (fn [] (join " " (map #(pr-obj % _r) obj))))
  (case (obj-type obj)
    :vector (str "[" (pa) "]")
    :list (str "(" (pa) ")")
    :map (str "{" (pa) "}")
    :object
    (str "{"
         (reduce
           (fn [acc k]
             (acc.push (pr-obj k _r)
                       (pr-obj (nth obj k) _r)) acc)
           []
           (keys obj)) "}")
    :atom (str "(atom " (pr-obj (.-value obj) _r) ")")
    :keyword (str ":" (.-value obj))
    :string (if (and false _r) (wrap-str obj) obj)
    (:null :nil) "null"
    ;;else
    (obj.toString)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn obj-type "" [obj]
  (cond
    (lambda-arg? obj) :lambda-arg
    (keyword? obj) :keyword
    (symbol? obj) :symbol
    (list? obj) :list
    (vector? obj) :vector
    (std/object? obj) :object
    (map? obj) :map
    (nil? obj) :null
    (true? obj) :true
    (false? obj) :false
    (atom? obj) :atom
    (fn? obj) :function
    (string? obj) :string
    (number? obj) :number
    :else
    (raise! "Unknown type '" (type obj) "'")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn value? "" [obj]
  (or (nil? obj)
      (true? obj)
      (vector? obj)
      (map? obj)
      (false? obj)
      (string? obj)
      (number? obj)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn sequential? "" [arr]
  (or (list? arr) (vector? arr)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn eq? "" [a b]
  (var ta (obj-type a)
       tb (obj-type b))
  (if-not (or (= ta tb)
              (and (sequential? a) (sequential? b)))
    false
    (case ta
      :symbol (= (.-value a)(.-value b))
      (:map :list :vector)
      (do-with [ok? true]
        (if (not= (alen a)
                  (alen b))
          (set! ok? false)
          (forlet ((i 0)
                   (< i (alen a)) (i (inc i)))
            (when-not (eq? (nth a i)
                           (nth b i))
              (set! ok? false)
              (break!)))))
      :object
      (do-with [ok? true]
        (if-not (= (std/count a)
                   (std/count b))
          (set! ok? false)
          (forlet ((i 0
                    k nil
                    ks (keys a))
                   (< i (alen ks)) (i (inc i)))
            (set! k (nth ks i))
            (when-not (eq? (get a k)
                           (get b k))
              (set! ok? false)
              (break!)))))
      ;else
      (= a b))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn LambdaArg "" [arg]
  (var v 0 name (arg.slice 1))
  (if (empty? name)
    (set! name "1"))
  (set! v (parseInt name))
  (if-not (> v 0)
    (raise! "Bad lambda-arg: " arg))
  ;;zero based arg so minus 1
  (-- v)
  (set! this.value (str v))
  this)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn Keyword "" [name]
  (set! this.value (name.slice 1)) this)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn Symbol "" [name] (set! this.value name) this)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn Symbol.prototype.toString "" [] (.-value this))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn symbol "" [name] (new Symbol name))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn symbol? "" [obj] (inst? Symbol obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn symbol-s "" [s]
  (if (symbol? s) (.-value s) (str s)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn Keyword.prototype.toString "" [] (.-value this))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn keyword "" [name] (new Keyword name))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn keyword? "" [obj] (inst? Keyword obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn keyword-s "" [k]
  (if (keyword? k) (.-value k) (str k)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn LambdaArg.prototype.toString "" [] (.-value this))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn lambda-arg "" [name] (new LambdaArg name))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn lambda-arg? "" [obj] (inst? LambdaArg obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn lambda-arg-s "" [k]
  (if (lambda-arg? k) (.-value k) (str k)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn fn-wrap "" [run Env ast env params]
  (do-with [f #(run ast (new Env env params arguments))]
    (set! f :____macro false)
    (set! f :____meta nil)
    (set! f :____ast ast)
    (set! f :____genenv (fn [args] (new Env env params args)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn Function.prototype.clone "" []
  (var that this)
  (do-with [tmp #(that.apply this arguments)]
    (each-key
      (fn [k] (set! tmp k (get that k))) that)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn list "" [&xs] xs)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn list? "" [obj]
  (and (array? obj)
       (not obj.____vec) (not obj.____map)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn vector "" [&xs] (set! xs :____vec true) xs)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn vector? "" [obj] (and (array? obj) (true? obj.____vec)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn hashmap "" [&xs]
  (if (= 1 (mod (alen xs) 2))
    (raise! "Odd number of hash map arguments"))
  (set! xs :____map true) xs)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn map? "" [obj] (and (array? obj) (true? obj.____map)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn jsObject? "" [m]
  (and (std/object? m)
       (not (inst? LambdaArg m))
       (not (inst? Atom m))
       (not (inst? Symbol m))
       (not (inst? Keyword m))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn Atom "" [val] (set! this.value val))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn atom "" [val] (new Atom val))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn atom? "" [atm] (inst? Atom atm))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

