;; Copyright (c) 2013-2017, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns ^{:doc ""
      :author "Kenneth Leung"}
  czlab.kirby.engine
  (require ["readline" :as readline])
  (require ["fs" :as fs])
  (require ["./parser" :as parser]
           ["./stdlib"
            :as std
            :refer [pairs? stringify contains?
                    LambdaArg Keyword
                    not-empty object?
                    Symbol into! prn
                    Atom symbol swap!
                    atom vector vector?
                    list? map? some?
                    typeid sequential?
                    conj! count
                    last pop! opt??
                    keyword? symbol? seq]]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- macro_assert ```
  (macro* assert* [c msg] (if* c true (throw* msg))) ```)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- macro_cond ```
  (macro* cond* [&xs]
    (if* (> (count* xs) 0)
      (list* 'if*
            (first* xs)
            (nth* xs 1)
            (cons* 'cond* (rest* (rest* xs)))))) ```)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- macro_andp ```
  (macro* _andp_* [&xs]
    (if* (= 1 (count* xs)) `~(first* xs) `(and ~@xs))) ```)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- GLOBAL (if (undef? window) undefined  window))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- prefix "kirby> ")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- expect! "" [k]
  (if-not (inst? Symbol k)
    (raise! "expecting symbol")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deftype LEXEnv [][nspaces []
                   data {} parent nil]
  "Lexical Environment"
  (constructor "Create and initialize
               a new env with these symbols,
               and optionally a parent env"
    [parent vars vals]
    (if parent (set-in! this :parent parent))
    (for [i 0 e nil ev nil sz (n# vars)
          :while (< i sz) :recur (+1 i)]
      (set! e (.@i vars)
            ev (.-value e))
      (cond
        (= ev "&")
        (do (set-in! this.data
                     $(.@+i vars) (slice vals i))
            (break-out-of-loop!))
        (starts? ev "&")
        (do (set-in! this.data
                     (rest ev) (slice vals i))
            (break-out-of-loop!))
        :else
        (set-in! this.data ev (.@i vals)))))
  (find "Find the env
        containing this symbol"
    ^LEXEnv [k]
    (expect! k)
    (cond
      (contains? this.data k.value) this
      (some? this.parent) (.find this.parent k)))
  (set "Bind this symbol,
       value to this env"
    ^Any [k v]
    (expect! k)
    (set-in! this.data k.value v) v)
  (get "Get value of
       this symbol"
    ^Any [k]
    (expect! k)
    (var env (.find this k))
    (if env (get env.data k.value) k.value))
  (select ""
    ^Map [what]
    (reduce (fn [acc [k v]]
              (if (case what
                    :fn (fn? v)
                    :var (not (fn? v)) true)
                (set-in! acc $(k) v)) acc) {} (seq this.data)))
  (prn "Print set of vars"
    ^String []
    (std/prn this.data))
  (pushNSP "Add a namespace"
    [nsp]
    (conj! this.nspaces $(nsp)) nil)
  (peekNSP "Returns the
           last added namespace"
    ^String []
    (last this.nspaces))
  (popNSP "Return and remove
          the last added namespace"
    ^String []
    (1st (pop! this.nspaces)))
  (firstNSP "Get the first
            added namespace"
    ^String []
    (1st this.nspaces))
  (countNSPCache "Count n# of
                 added namespaces"
    ^Integer []
    (n# this.nspaces))
  (resetNSPCache "Clear all namespaces"
    []
    (set-in! this :nspaces []) nil))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro prnArr "" [arr] `(map #(prn %) ~arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn Function.prototype.clone "" ^Function []
  ;;run the old function with the new 'this'
  (var orig this
       cloned #(apply orig this ____args))
  (each-key
    (fn [v k] (=>> cloned k v)) orig) cloned)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- prnStr "" ^String [&xs] (join " " (prnArr xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- prnLn "" [&xs] (each #(println %) (prnArr xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn slurp "" ^String [f] (fs/readFileSync f "utf-8"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn spit "" [f s] (fs/writeFileSync f s "utf-8") nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- clone "" ^Any [obj]
  (var oid (typeid obj))
  (case oid
    (:vector :map :list)
    (into! oid (slice obj))
    :array
    (slice obj)
    :object
    (reduce
      (fn [acc [k v]]
        (set-in! acc k v) acc) {} (seq obj))
    :function
    (obj.clone)
    ;;else
    (raise! "clone of non-collection: " oid)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- cons "" ^Array [a b] (concat [a] b))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- conj "" ^Array [arr & xs]
  (cond
    (list? arr)
    (into! :list
           (-> (xs.reverse)
               (concat arr)))
    (some? arr)
    (into! :vector
           (concat arr xs))
    :else arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fapply "" ^Any [f & xs] (f.apply this xs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fmap "" ^Array [f arr] (map f arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- resolveJS "" ^Array [s]
  [(if (contains? s ".")
     (-> (.exec #/^(.*)\.[^\.]*$/g s)
         (nth 1) (eval))
     GLOBAL)
   (eval s)])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- filterJS "" ^Any [obj]
  (var s (stringify obj))
  (if (not-empty s) (JSON/parse s)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- withMeta "" ^Object [obj m]
  (var ret (clone obj))
  (set-in! ret :____meta m) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- meta "" ^Map [obj]
  (if-not (or (array? obj)
              (object? obj)
              (fn? obj))
    (raise! "can't get meta from: " (typeid obj)))
  (get obj :____meta))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- evalJS "" ^Any [s]
  (filterJS (eval (s.toString))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- invokeJS "" ^Any [method & xs]
  (var [obj f] (resolveJS method))
  (filterJS (apply f obj xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- *runtime-funcs* {
  "macroexpand*" (fn [code & [env]]
                    (println
                      (std/prn (inflateMacro
                                 code (or env g_env)))))
  "macros*" (fn [&[fout]]
               (var s (std/prn CACHE))
               (if fout
                 (spit fout s)
                 (println s)))
  "env*" (fn [what & [env fout]]
               (var s (std/prn (.select (or env g_env) what)))
               (if fout
                 (spit fout s)
                 (println s)))
  "is-same?"  (fn [a b] (== a b))
  "is-nil?"  (fn [x] (nil? x))
  "obj-type*"  std/typeid
  "gensym*"  std/gensym
  "is-eq?"  std/eq?
  "is-some?"  std/some?
  "str*" (fn [&xs] (join "" xs))
  "slice*"  (fn [arr & xs]
              (Array.prototype.slice.apply arr xs))
  "throw*"  (fn [&xs]
              (throw (new Error (.join xs ""))))
  "#f?"  (fn [x] (false? x))
  "#t?"  (fn [x] (true? x))
  "is-str?"  (fn [x] (string? x))
  "is-keyword?"  std/keyword?
  "is-symbol?"  std/symbol?
  "keyword*"  std/keyword
  "symbol*"  std/symbol
  "println*"  prnLn
  "prn*"  prnStr
  "slurp*"  slurp
  "spit*" spit
  "<"   (fn [a b] (< a b))
  "<="  (fn [a b] (<= a b))
  ">"   (fn [a b] (> a b))
  ">="  (fn [a b] (>= a b))
  "/"   (fn [a &xs] (reduce (fn [acc n] (div acc n)) a xs))
  "+"   (fn [&xs] (reduce (fn [acc n] (+ acc n)) 0 xs))
  "-"   (fn [a &xs] (reduce (fn [acc n] (- acc n)) a xs))
  "*"   (fn [&xs] (reduce (fn [acc n] (* acc n)) 1 xs))
  "not=" (fn [a b] (not= a b))
  "=" (fn [a b] (= a b))
  "is-contains?" std/contains?
  "is-vector?"  std/vector?
  "is-list?"  std/list?
  "is-map?"  std/map?
  "hash-map*"  std/hashmap
  "vector*"  std/vector
  "list*"  std/list
  "values*"  (fn [x] (Object.values x))
  "keys*"  (fn [x] (Object.keys x))
  "get*"  (fn [m k] (get m k))
  "not*"  (fn [x] (if x #f #t))
  "dec*"  (fn [x] (-1 x))
  "inc*"  (fn [x] (+1 x))
  "is-even?"  (fn [n] (= 0 (std/modulo n 2)))
  "is-odd?"  (fn [n]  (= 1 (std/modulo n 2)))
  "is-sequential?"  std/sequential?
  "concat*"  std/concat*
  "count*"  std/count
  "cons*"  cons
  "rest*"  (fn [arr]
              (if arr (arr.slice 1) []))
  "nth*"  (fn [arr i] (get arr i))
  "first*"  (fn [arr] (get arr 0))
  "is-empty?" (fn [x] (= 0 (std/count x)))
  "not-empty*" std/not-empty
  "apply*"  fapply
  "map*"  fmap
  "evens*" std/evens
  "odds*" std/odds
  "meta*"  meta
  "conj*"  conj
  "seq*"  std/seq
  "is-atom?"  std/atom?
  "atom*"  std/atom
  "deref*"  std/deref
  "reset*"  std/reset!
  "swap*"  std/swap!
  "with-meta*"  withMeta
  "js-eval*"  evalJS
  "js*"  invokeJS
  "type*" (fn [x] (typeof x)) })

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- loadedMacros? false)
(const- CACHE {})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- loadMacros "" []
  (when-not loadedMacros?
    (true! loadedMacros?)
    (require "./macros.ky")) loadedMacros?)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn setMacro "Register a new macro"
  [cmd func]
  (when (and cmd func)
    (set! cmd $(cmd))
    (when-not (contains? cmd "/")
      (var c (g_env.peekNSP))
      (if-not c (raise! "missing namespace"))
      (=> cmd (str c "/" cmd)))
    ;;(println "adding macro ==== " cmd)
    (set-in! CACHE cmd func)) nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getMacro "Get macro"
  ^Function [cmd]
  (var nsp nil ret nil)
  (=> cmd $(cmd))
  (if (contains? cmd "/")
    (=> ret (get CACHE cmd))
    (do (=> nsp (g_env.peekNSP))
        (if nsp
          (=> ret (get CACHE
                       (str nsp "/" cmd))))
        (if-not ret
          (=> ret (get CACHE
                       (str "czlab.kirby.macros/" cmd)))))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- dbg "" [obj] (println "DBG-RT: " (prn obj)) nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- readAST "Returns the AST"
  ^Array [s]
  (var ret (parser/parse s))
  (if (= 1 (n# ret))
    (=> ret (1st ret))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- isList? "Returns true
               if a non-empty list"
  ^Boolean [x]
  (and (sequential? x) (not-empty x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- backtick "" ^Array [ast]
  (cond
    (not (isList? ast))
    ['quote ast]
    (and (symbol? (1st ast))
         (== (1st ast) "unquote"))
    (2nd ast)
    (and (isList? (1st ast))
         (== (1st (1st ast))
             "splice-unquote"))
    ['concat* (2nd (1st ast)) (backtick (rest ast))]
    :else
    (let [a0 (1st ast)
          a1 (rest ast)]
      ['cons* (backtick a0) (backtick a1)])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- isMacroCall? "" ^Boolean [ast env]
  (and (pairs? ast)
       (symbol? (1st ast))
       (getMacro $(1st ast))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn inflateMacro "" ^Any [ast env]
  (var isM? (isMacroCall? ast env)
       mac nil
       cmd (if isM? (1st ast) ""))
  (while (isMacroCall? ast env)
    (=> cmd $(1st ast)
        mac (getMacro cmd)
        ast (mac.apply mac (rest ast)))) ast)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- eval* "" ^Any [ast env]
  (cond
    (keyword? ast)
    (.-value ast)
    (string? ast)
    (std.unwrap-str ast)
    (symbol? ast)
    (env.get ast)
    (pairs? ast)
    (map #(compute %1 env) ast)
    (list? ast)
    (into! :list (map #(compute %1 env) ast))
    (vector? ast)
    (into! :vector (map #(compute %1 env) ast))
    (and #f (map? ast))
    (reduce
      (fn [acc en]
        (=>> acc
             (compute (1st en) env)
             (compute (last en) env)) acc)
      {}
      (seq ast))
    (map? ast)
    (do-with [m {}]
      (for [i 0 sz (n# ast)
            :while (< i sz) :recur (+2 i)]
        (=>> m
             (compute (.@i ast) env)
             (compute (.@+i ast) env))))
    :else ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- doAND "" ^Boolean [ast env]
  (var ret #t)
  (for [i 1 sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (=> ret (compute (.@i ast) env))
    (if-not ret (break-out-of-loop!))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- doOR "" ^Boolean [ast env]
  (var ret nil)
  (for [i 1 sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (=> ret (compute (.@i ast) env))
    (if ret (break-out-of-loop!))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- doLET "" ^Array [ast env]
  (var e (new LEXEnv env)
       a1 (.@1 ast))
  (for [i 0 sz (n# a1)
        :while (< i sz) :recur (+2 i)]
    (e.set (.@i a1)
           (compute (.@+i a1) e)))
  [(.@2 ast) e])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- doMACRO "" [ast env]
  (var rc [(1st ast)
           (2nd ast)
           (concat ['lambda* (.@2 ast)] (ast.slice 3))]
       a2 (.@2 rc)
       a1 (.@1 rc)
       cmd (str "czlab.kirby.macros/" a1)
       func (compute  a2 env))
  (=>> func :____macro #t)
  (setMacro cmd func) nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- doTRY "" ^Any [ast env]
  (var a1 (.@1 ast)
       a2 (.@2 ast))
  (try
    (compute a1 env)
    (catch ex
      (if (and a2 (== "catch*"
                      (1st a2)))
        (if (inst? Error ex)
          (=> ex (.-message ex)))
        (compute (.@2 a2)
                 (new LEXEnv
                      env [(.@1 a2)] [ex]))
        (throw ex)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- doIF "" ^Any [ast env]
  (var c (compute (.@1 ast) env)
       a2 (.@2 ast)
       a3 (.@3 ast))
  (if (or (nil? c)
          (false? c))
    (if-not (undef? a3) a3) a2))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- read* "" ^Array [ast env]
  (var f nil
       el (eval* ast env))
  (cond
    (or (vector? ast)
        (map? ast)
        (list? ast))
    [false el]
    (array? el)
    (do (=> f (1st el))
        (cond
          (and f (.-____ast f))
          [true (.-____ast f) (f.____genenv (rest el))]
          :else
          [false (if (fn? f)
                   (apply f f (rest el)) el) env]))
    :else [false el]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fn-wrap "" ^Function [run ast env params]
  (var f #(run ast
               (new LEXEnv
                    env params ____args)))
  (=>> f
       :____macro false
       :____meta nil
       :____ast ast
       :____genenv #(new LEXEnv env params %)) f)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- *spec-forms* {
  "and*" (fn [a e] [(doAND a e)])
  "or*" (fn [a e] [(doOR a e)])
  "def*" (fn [a e] [(e.set (.@1 a) (compute (.@2 a) e))])
  "let*" (fn [a e] (doLET a e))
  "quote" (fn [a e] [(2nd a)])
  "syntax-quote" (fn [a e] [(backtick (2nd a)) e])
  "macro*" (fn [a e] [(doMACRO a e)])
  "try*" (fn [a e] [(doTRY a e)])
  "do*" (fn [a e]
          (eval* (a.slice 1 -1) e)
          [(nth a (last-index a)) e])
  "if*" (fn [a e] [(doIF a e) e])
  "lambda*" (fn [a e]
          [(fn-wrap compute
                    (.@2 a) e (.@1 a))]) })

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn compute "Interpret a expression" ^Any [expr cenv]
  (var g1 #(if (pairs? %) (1st %) ""))
  (var~ ret res tmp cmd fc)
  (if-not cenv (set! cenv g_env))
  (loop [env cenv
         ast (inflateMacro expr cenv)]
    (set! cmd $(g1 ast)
          fc (get *spec-forms* cmd)
          res (cond
                (not (arr? ast)) [(eval* ast env)]
                (empty? ast) [ast]
                (fn? fc) (fc ast env)
                :else
                (do (set! tmp (read* ast env))
                    (if (1st tmp)
                      (slice tmp 1)
                      (slice tmp 1 2)))))
    (if (single? res)
      (do->true (set! ret (1st res)))
      (recur (2nd res)
             (inflateMacro (1st res) (2nd res)))))
  (if (undef? ret) nil ret))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn newEnv "Create a new interpreter environment" ^LEXEnv []
  (do-with [ret (new LEXEnv)]
    (each-key (fn [v k]
                (ret.set (symbol k) v)) *runtime-funcs*)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn runRepl "Start a interactive session" []
  (var ss (readline/createInterface process.stdin
                                    process.stdout)
       z (alen prefix)
       pt #(do (ss.setPrompt prefix z)
               (ss.prompt ))
       rl (fn [line]
            (try (if line (println (reval line)))
                 (catch e (println e))) (pt))
       cl #(do (println "Bye!") (process.exit 0)))
  (ss.on :close cl)
  (ss.on :line rl)
  (init)
  (println prefix "Kirby REPL v" *version*) (pt))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- reval "Eval one or more expressions" ^Any [expr & xs]
  (var f (comp prn
               compute readAST) ret (f expr))
  (doseq [e xs] (set! ret (f e))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- inited? false
      *version* "" g_env nil)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn init "Set up the runtime environment" ^Boolean [ver]
  (when-not inited?
    (set! *version* ver g_env (newEnv))
    (reval macro_cond
           macro_assert macro_andp)
    (loadMacros)
    (true! inited?)) inited?)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn globalEnv "Returns the runtime environment" [] g_env)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

