;; Copyright (c) 2013-2017, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns ^{:doc ""
      :author "Kenneth Leung"}
  czlab.kirby.engine
  (require ["readline" :as readline])
  (require ["fs" :as fs])
  (require ["./parser" :as parser]
           ["./stdlib"
            :as std
            :refer [pairs? stringify contains?
                    LambdaArg Keyword
                    not-empty object?
                    Symbol into! prn
                    Atom symbol swap!
                    atom vector vector?
                    list? map? some?
                    typeid sequential?
                    conj! count
                    last pop! opt??
                    keyword? symbol? seq]]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- macro_assert ```
  (macro* assert* [c msg] (if* c true (throw* msg))) ```)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- macro_cond ```
  (macro* cond* [&xs]
    (if* (> (count* xs) 0)
      (list* 'if*
            (first* xs)
            (nth* xs 1)
            (cons* 'cond* (rest* (rest* xs)))))) ```)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- GLOBAL (if (undef? window) undefined  window))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- prefix "kirby> ")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- assertSymbol "" ^Any [k]
  (if-not (inst? Symbol k)
    (raise! "env.xxx key must be a symbol")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deftype LEXEnv [][nspaces []
                   data {} parent nil]
  "Lexical Environment"
  (constructor "Create and initialize
               a new env with these symbols,
               and optionally a parent env"
    [parent vars exprs]
    (if parent (=>> this :parent parent))
    (for [i 0 e nil ev nil
          sz (n# vars)
          :while (< i sz) :recur (+1 i)]
      (=> e (.@i vars)
          ev (.-value e))
      (cond
        (= ev "&")
        (do (=>> this.data
                 $(.@+i vars) (slice exprs i))
            (break-out-of-loop!))
        (starts? ev "&")
        (do (=>> this.data
                 (rest ev) (slice exprs i))
            (break-out-of-loop!))
        :else
        (=>> this.data ev (.@i exprs)))))
  (find "Find the env
        containing this symbol"
    ^Boolean [k]
    (assertSymbol k)
    (cond
      (contains? this.data k.value) this
      (some? this.parent) (.find this.parent k)))
  (set "Bind this symbol,
       value to this env"
    ^Any [k v]
    (assertSymbol k)
    (=>> this.data k.value v) v)
  (get "Get value of
       this symbol"
    ^Any [k]
    (assertSymbol k)
    (var env (.find this k))
    (if env (get env.data k.value) k.value))
  (select ""
    ^Map [what]
    (reduce (fn [acc [k v]]
              (if (case what
                    :fn (fn? v)
                    :var (not (fn? v))
                    true)
                (=>> acc $(k) v)) acc) {} (seq this.data)))
  (prn "Print set of vars"
    ^String []
    (std/prn this.data))
  (pushNSP "Add a namespace"
    [nsp]
    (conj! this.nspaces $(nsp)) nil)
  (peekNSP "Returns the
           last added namespace"
    ^String []
    (last this.nspaces))
  (popNSP "Return and remove
          the last added namespace"
    ^String []
    (1st (pop! this.nspaces)))
  (firstNSP "Get the first
            added namespace"
    ^String []
    (1st this.nspaces))
  (countNSPCache "Count n# of
                 added namespaces"
    ^Integer []
    (n# this.nspaces))
  (resetNSPCache "Clear all namespaces"
    []
    (=>> this :nspaces []) nil))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro prnArr "" [arr] `(map #(prn %) ~arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn Function.prototype.clone "" ^Function []
  (var that this
       tmp #(apply that this ____args))
  (each-key
    (fn [v k] (=>> tmp k v)) that) tmp)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- prnStr "" ^String [&xs] (join " " (prnArr xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- prnLn "" [&xs] (each #(println %) (prnArr xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn slurp "" ^String [f] (fs/readFileSync f "utf-8"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn spit "" [f s] (fs/writeFileSync f s "utf-8") nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- clone "" ^Any [obj]
  (var oid (typeid obj))
  (case oid
    (:vector :map :list)
    (into! oid (slice obj))
    :array
    (slice obj)
    :object
    (reduce
      (fn [acc en]
        (=>> acc (1st en) (last en)) acc)
      {}
      (seq obj))
    :function
    (obj.clone)
    ;else
    (raise! "clone of non-collection: " oid)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- cons "" ^Array [a b] (concat [a] b))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- conj "" ^Array [arr &xs]
  (cond
    (list? arr)
    (into! :list
           (-> (xs.reverse)
               (concat arr)))
    (some? arr)
    (into! :vector
           (concat arr xs))
    :else arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fapply "" ^Any [f & xs] (f.apply this xs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fmap "" ^Array [f arr] (map f arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- resolveJS "" ^Array [s]
  [(if (contains? s ".")
     (-> (.exec #/^(.*)\.[^\.]*$/g s)
         (nth 1) (eval))
     GLOBAL)
   (eval s)])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- filterJS "" ^Any [obj]
  (var s (stringify obj))
  (if (not-empty s) (JSON/parse s)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- withMeta "" ^Object [obj m]
  (var ret (clone obj))
  (=>> ret :____meta m) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- meta "" ^Map [obj]
  (if-not (or (array? obj)
              (object? obj)
              (fn? obj))
    (raise! "can't get metadata from: " (typeid obj)))
  (get obj :____meta))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- evalJS "" ^Any [s]
  (filterJS (eval (s.toString))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- invokeJS "" ^Any [method &xs]
  (var [obj f] (resolveJS method))
  (filterJS (apply f obj xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- toolkit {

  "macroexpand*" (fn [code & [env]]
                    (println
                      (std/prn (expandMacro
                                 code (or env g_env)))))

  "macros*" (fn [&[fout]]
               (var s (std/prn CACHE))
               (if fout
                 (spit fout s)
                 (println s)))

  "env*" (fn [what & [env fout]]
               (var s (std/prn (.select (or env g_env) what)))
               (if fout
                 (spit fout s)
                 (println s)))

  "is-same?"  (fn [a b] (== a b))
  "is-nil?"  (fn [x] (nil? x))

  "obj-type*"  std/typeid
  "gensym*"  std/gensym
  "is-eq?"  std/eq?
  "is-some?"  std/some?

  "str*" (fn [&xs] (join "" xs))

  "slice*"  (fn [arr & xs]
              (Array.prototype.slice.apply arr xs))

  "throw*"  (fn [&xs]
              (throw (new Error (.join xs ""))))

  "#f?"  (fn [x] (false? x))
  "#t?"  (fn [x] (true? x))
  "is-str?"  (fn [x] (string? x))

  "is-keyword?"  std/keyword?
  "is-symbol?"  std/symbol?
  "keyword*"  std/keyword
  "symbol*"  std/symbol

  "println*"  prnLn
  "prn*"  prnStr

  "slurp*"  slurp
  "spit*" spit

  "<"   (fn [a b] (< a b))
  "<="  (fn [a b] (<= a b))
  ">"   (fn [a b] (> a b))
  ">="  (fn [a b] (>= a b))

  "/"   (fn [a &xs] (reduce (fn [acc n] (div acc n)) a xs))
  "+"   (fn [&xs] (reduce (fn [acc n] (+ acc n)) 0 xs))
  "-"   (fn [a &xs] (reduce (fn [acc n] (- acc n)) a xs))
  "*"   (fn [&xs] (reduce (fn [acc n] (* acc n)) 1 xs))

  "not=" (fn [a b] (not= a b))
  "=" (fn [a b] (= a b))

  "is-contains?" std/contains?

  "is-vector?"  std/vector?
  "is-list?"  std/list?
  "is-map?"  std/map?
  "hash-map*"  std/hashmap
  "vector*"  std/vector
  "list*"  std/list

  "values*"  (fn [x] (Object.values x))
  "keys*"  (fn [x] (Object.keys x))
  "get*"  (fn [m k] (get m k))

  "not*"  (fn [x] (if x #f #t))
  "dec*"  (fn [x] (-1 x))
  "inc*"  (fn [x] (+1 x))

  "is-even?"  (fn [n] (= 0 (std/modulo n 2)))
  "is-odd?"  (fn [n]  (= 1 (std/modulo n 2)))

  "is-sequential?"  std/sequential?
  "concat*"  std/concat*
  "count*"  std/count
  "cons*"  cons

  "rest*"  (fn [arr]
              (if arr (arr.slice 1) []))
  "nth*"  (fn [arr i] (get arr i))
  "first*"  (fn [arr] (get arr 0))

  "is-empty?" (fn [x] (= 0 (std/count x)))
  "not-empty*" std/not-empty

  "apply*"  fapply
  "map*"  fmap

  "evens" (fn [n] (= 0 (mod n 2)))
  "odds" (fn [n]  (= 1 (mod n 2)))
  "type*" (fn [x] (typeof x))

  "meta*"  meta
  "conj*"  conj
  "seq*"  std/seq

  "is-atom?"  std/atom?
  "atom*"  std/atom
  "deref*"  std/deref
  "reset*"  std/reset!
  "swap*"  std/swap!

  "with-meta*"  withMeta
  "js-eval*"  evalJS
  "js*"  invokeJS

})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- loadedMacros? false)
(def- CACHE {})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- loadMacros "" []
  (when-not loadedMacros?
    (true! loadedMacros?)
    (require "./macros.ky")) nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn setMacro "Register a new macro"
  [cmd func]
  (when (and cmd func)
    (=> cmd $(cmd))
    (when-not (contains? cmd "/")
      (var c (g_env.peekNSP))
      (if-not c (raise! "missing namespace"))
      (=> cmd (str c "/" cmd)))
    ;;(println "adding macro ==== " cmd)
    (=>> CACHE cmd func)) nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getMacro "Get macro"
  ^Function [cmd]
  (var nsp nil ret nil)
  (=> cmd $(cmd))
  (if (contains? cmd "/")
    (=> ret (get CACHE cmd))
    (do (=> nsp (g_env.peekNSP))
        (if nsp
          (=> ret (get CACHE
                       (str nsp "/" cmd))))
        (if-not ret
          (=> ret (get CACHE
                       (str "czlab.kirby.macros/" cmd)))))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- dbg "" [obj] (println "DBG-RT: " (prn obj)) nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- readAST "Returns the AST"
  ^Array [s]
  (var ret (parser/parse s))
  (if (= 1 (n# ret))
    (=> ret (1st ret))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- isList? "Returns true
               if a non-empty list"
  ^Boolean [x]
  (and (sequential? x) (not-empty x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quasiquote "" ^Array [ast]
  (cond
    (not (isList? ast))
    ['quote ast]
    (and (symbol? (1st ast))
         (== (1st ast) "unquote"))
    (2nd ast)
    (and (isList? (1st ast))
         (== (1st (1st ast))
             "splice-unquote"))
    ['concat* (2nd (1st ast)) (quasiquote (rest ast))]
    :else
    (let [a0 (1st ast)
          a1 (rest ast)]
      ['cons* (quasiquote a0) (quasiquote a1)])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- isMacroCall? "" ^Boolean [ast env]
  (and (pairs? ast)
       (symbol? (1st ast))
       (getMacro $(1st ast))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn expandMacro "" ^Any [ast env]
  (var isM? (isMacroCall? ast env)
       mac nil
       cmd (if isM? (1st ast) ""))
  (while (isMacroCall? ast env)
    (=> cmd $(1st ast)
        mac (getMacro cmd)
        ast (mac.apply mac (rest ast)))) ast)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- evalAst "" ^Any [ast env]
  (cond
    (keyword? ast)
    (.-value ast)
    (string? ast)
    (std.unwrap-str ast)
    (symbol? ast)
    (env.get ast)
    (pairs? ast)
    (map #(compute %1 env) ast)
    (list? ast)
    (into! :list (map #(compute %1 env) ast))
    (vector? ast)
    (into! :vector (map #(compute %1 env) ast))
    (and #f (map? ast))
    (reduce
      (fn [acc en]
        (=>> acc
             (compute (1st en) env)
             (compute (last en) env)) acc)
      {}
      (seq ast))
    (map? ast)
    (do-with [m {}]
      (for [i 0 sz (n# ast)
            :while (< i sz) :recur (+2 i)]
        (=>> m
             (compute (.@i ast) env)
             (compute (.@+i ast) env))))
    :else ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- handleAND "" ^Boolean [ast env]
  (var ret #t)
  (for [i 1 sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (=> ret (compute (.@i ast) env))
    (if-not ret (break-out-of-loop!))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- handleOR "" ^Boolean [ast env]
  (var ret nil)
  (for [i 1 sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (=> ret (compute (.@i ast) env))
    (if ret (break-out-of-loop!))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- handleLet "" ^Array [ast env]
  (var e (new LEXEnv env)
       a1 (.@1 ast))
  (for [i 0 sz (n# a1)
        :while (< i sz) :recur (+2 i)]
    (e.set (.@i a1)
           (compute (.@+i a1) e)))
  [(.@2 ast) e])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- handleMacro "" [ast env]
  (var rc [(1st ast)
           (2nd ast)
           (concat ['fn* (.@2 ast)] (ast.slice 3))]
       a2 (.@2 rc)
       a1 (.@1 rc)
       cmd (str "czlab.kirby.macros/" a1)
       func (compute  a2 env))
  (=>> func :____macro #t)
  (setMacro cmd func) nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- handleTry "" ^Any [ast env]
  (var a1 (.@1 ast)
       a2 (.@2 ast))
  (try
    (compute a1 env)
    (catch ex
      (if (and a2 (== "catch*"
                      (1st a2)))
        (if (inst? Error ex)
          (=> ex (.-message ex)))
        (compute (.@2 a2)
                 (new LEXEnv
                      env [(.@1 a2)] [ex]))
        (throw ex)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- handleIf "" ^Any [ast env]
  (var c (compute (.@1 ast) env)
       a2 (.@2 ast)
       a3 (.@3 ast))
  (if (or (nil? c)
          (false? c))
    (if-not (undef? a3) a3) a2))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- handleForm "" ^Array [ast env]
  (var f nil
       el (evalAst ast env))
  (cond
    (or (vector? ast)
        (map? ast)
        (list? ast))
    [false el]
    (array? el)
    (do (=> f (1st el))
        (cond
          (and f (.-____ast f))
          [true (.-____ast f) (f.____genenv (rest el))]
          :else
          [false (if (fn? f)
                   (apply f f (rest el)) el) env]))
    :else [false el]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fn-wrap "" ^Function [run ast env params]
  (var f #(run ast
               (new LEXEnv
                    env params ____args)))
  (=>> f
       :____macro false
       :____meta nil
       :____ast ast
       :____genenv #(new LEXEnv env params %)) f)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- compute* "" ^Any [ast env]
  (var ok? #t
       cmd ""
       ret nil
       g1 (fn [a] (if (pairs? a) (1st a) "")))
  (for []
    (=> ast (expandMacro ast env)
        cmd (g1 ast))
    (->>
      (cond
        (not (array? ast))
        (do->true
          (=> ret (evalAst ast env)))
        (empty? ast)
        (do->true
          (=> ret ast))
        (== "and*" cmd)
        (do->true
          (=> ret (handleAND ast env)))
        (== "or*" cmd)
        (do->true
          (=> ret (handleOR ast env)))
        (== "def*" cmd)
        (do->true
          (=> ret (env.set a1
                           (compute a2 env))))
        (== "let*" cmd)
        (do->false
          (var rc (handleLet ast env))
          (=> ast (1st rc)
              env (2nd rc)))
        (== "quote" cmd)
        (do->true
          (=> ret (2nd ast)))
        (== "quasiquote" cmd)
        (do->false
          (=> ast
              (quasiquote (2nd ast))))
        (== "macro*" cmd)
        (do->true
          (=> ret (handleMacro ast env)))
        (== "macroexpand" cmd)
        (do->true
          (=> ret (expandMacro (2nd ast) env)))
        (== "try*" cmd)
        (do->true
          (=> ret (handleTry ast env)))
        (== "do*" cmd)
        (do->false
          (evalAst (ast.slice 1 -1) env)
          (=> ast (nth ast (last-index ast))))
        (== "if*" cmd)
        (do->false
          (=> ast (handleIf ast env)))
        (== "fn*" cmd)
        (do->true
          (=> ret
              (fn-wrap compute
                       (.@2 ast) env (.@1 ast))))
        :else
        (let [rc (handleForm ast env)
              a1 (.@1 rc)
              a2 (.@2 rc)]
          (if (1st rc)
            (do->false
              (=> ast a1 env a2))
            (do->true
              (=> ret a1)))))
      (=> ____break ))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn compute "" ^Any [ast env]
  (if-not env (=> env g_env))
  (var ret (compute* ast env))
  (if (undef? ret) nil ret))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn newEnv "" ^LEXEnv []
  (do-with [ret (new LEXEnv)]
    (each-key (fn [v k]
                (ret.set (symbol k) v)) toolkit)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn runRepl "" []
  (var rl (readline.createInterface process.stdin
                                    process.stdout))
  (rl.on
    :line
    (fn [line]
      (try
        (if line (println (reval line)))
        (catch e (println e)))
      (rl.setPrompt prefix  (alen prefix))
      (rl.prompt )))
  (rl.on
    :close
    (fn []
      (println "Bye!")
      (process.exit 0)))
  (init)
  (println prefix "Kirby REPL v" version)
  (rl.setPrompt prefix  (alen prefix))
  (rl.prompt ) nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- reval "" ^Any [c & xs]
  (var f (comp prn compute readAST)
       r (f c))
  (doseq [x xs]
    (=> r (f x))) r)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- inited? false
      version "" g_env nil)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn init "" ^Boolean [ver]
  (when-not inited?
    (=> version ver g_env (newEnv))
    (reval macro_cond macro_assert)
    (loadMacros)
    (true! inited? )) inited?)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn globalEnv "" [] g_env)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

