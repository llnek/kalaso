/*Auto generated by Kirby - v1.0.0 czlab.kirby.cg.transpiler Sat Oct 28 2017 23:13:01 GMT-0700 (PDT)*/

var macros= require("../bl/macros");
var types= require("../bl/types");
var std= require("../bl/stdlib");
var tn= require("../bl/tnode");
var rdr= require("../bl/lexer");
var psr= require("../bl/parser");
var rt= require("../rt/runtime");
var fs= require("fs");
var path= require("path");
;
let gensym_counter;
gensym_counter= 1;
;
let ERRORS_MAP;
ERRORS_MAP= { "e0": "Syntax Error","e1": "Empty statement","e2": "Invalid characters in function name","e3": "End of File encountered, unterminated string","e4": "Closing square bracket, without an opening square bracket","e5": "End of File encountered, unterminated array","e6": "Closing curly brace, without an opening curly brace","e7": "End of File encountered, unterminated javascript object '}'","e8": "End of File encountered, unterminated parenthesis","e9": "Invalid character in var name","e10": "Extra chars at end of file. Maybe an extra ')'.","e11": "Cannot Open include File","e12": "Invalid no of arguments to ","e13": "Invalid Argument type to ","e14": "End of File encountered, unterminated regular expression","e15": "Invalid vararg position, must be last argument.","e16": "Invalid arity (args > expected) to ","e17": "Invalid arity (args < expected) to " };
;
let RESERVED;
RESERVED= { "compare": [ "not=","!=","==","=",">",">=","<","<=" ],"arith": [ "+","-","*","div","%","mod" ],"logic": [ "||","&&" ],"bitwise": [ "^","&","|","<<",">>",">>>" ],"incdec": [ "++","--" ],"unary": [ "not","~","!" ],"assign": [ "+=","-=","*=","/=","%=","<<=",">>=",">>>=","&=","|=","^=" ],"builtin": [ "quote","syntax-quote","quasi-quote","backtick","unquote","unquote-splice","repeat-n","do","doto","case","apply","range","def-","def","var","forlet","new","throw","while","lambda","inst?","delete!","aset","set!","fn","def!","defn-","defn","try","if","get","aget","str","list","[","vec","{","hash-map","ns","comment","for","cons","js#","macro","defmacro" ] };
;
let MODULE_VERSION,nosemi_QUERY,tabspace,indent,EXTERNS,NSPACES,SPEC_OPS;
MODULE_VERSION= "1.0.0";
nosemi_QUERY= false;
tabspace= 2;
indent= (-tabspace);
EXTERNS= null;
NSPACES= null;
SPEC_OPS= {};
;
//
function gensym() {
let G____1=Array.prototype.slice.call(arguments,0);
let G____2= G____1;
let pfx;
pfx=G____2[0];
let x;
x= gensym_counter;
;
++gensym_counter;
return [std.maybe(pfx,"G____"),x].join("");
}

//
function regoBuiltins(f,group) {
return RESERVED[group].forEach(function () {
let ____args;
____args= Array.prototype.slice.call(arguments);
;
return SPEC_OPS[____args[0]] = f;
});
}

//
function error_BANG(e,line,file,msg) {
return (function (){ throw new Error([ ERRORS_MAP[e],(msg ?
    [" : ",msg].join("") :
    ""),(line ?
    ["\nLine no ",line].join("") :
    ""),(file ?
    ["\nFile ",file].join("") :
    "") ].join("")); }).call(this);
}

//
function syntax_BANG(ecode,ast,cmd) {
return error_BANG(ecode,(ast ?
  ast.line :
  0),(ast ?
  ast.source :
  0),cmd);
}

//
function pad(z) {
return " ".repeat(z);
}

//
function testre_QUERY(re,x) {
return (x ?
  re.test(x) :
  false);
}

//
function nodeTag(obj,src) {
((obj&&src&&(!(typeof(obj) === "boolean"))&&(!(typeof(obj) === "number"))) ?
    (function() {
  obj.source = src.source;
  obj.column = src.column;
  return obj.line = src.line;
  }).call(this) :
  null);
return obj;
}

//
function destruct1(lhs) {
let as,out,keys;
as= "";
out= [];
keys= {};
;
(types.vector_QUERY(lhs) ?
  (function () {let ____break=false;
for (let i = 0,e = null,ev = null; (!____break && (i < lhs.length)); i = (i+1)) {
        e = lhs[i];
    ev = e.value;
    (types.symbol_QUERY(e) ?
      ((ev === "_") ?
        null :
        ((ev === "&") ?
                    (function() {
          keys[["&",lhs[(i+1)]].join("")] = i;
          return ++i;
          }).call(this) :
          (ev.startsWith("&") ?
            keys[ev] = i :
            (true ?
              keys[ev] = i :
              null)))) :
      (types.keyword_QUERY(e) ?
        ((ev === "as") ?
                    (function() {
          ++i;
          return as = lhs[i].toString();
          }).call(this) :
          (function (){ throw new Error([ "bad keyword: :",ev ].join("")); }).call(this)) :
        null));
;
  }
}).call(this) :
  (types.map_QUERY(lhs) ?
    (function () {let ____break=false;
for (let i = 0,e = null,ev = null; (!____break && (i < lhs.length)); i = (i+1)) {
            e = lhs[i];
      ev = e.value;
      (types.keyword_QUERY(e) ?
        (((ev === "keys")||(ev === "strs")) ?
                    (function() {
          let ks;
ks= lhs[(i+1)];
;
          ++i;
          return (function () {let ____break=false;
for (let j = 0; (!____break && (j < ks.length)); j = (j+1)) {
                        keys[ks[j].toString()] = null;
;
          }
}).call(this);
          }).call(this) :
          ((ev === "as") ?
                        (function() {
            ++i;
            return as = lhs[i].toString();
            }).call(this) :
            null)) :
        (function (){ throw new Error([ "bad destruct field: ",types.obj_type(e) ].join("")); }).call(this));
;
    }
}).call(this) :
    (types.symbol_QUERY(lhs) ?
      keys[lhs.toString()] = null :
      (true ?
        (function (){ throw new Error([ "cant destruct with: ",types.obj_type(lhs) ].join("")); }).call(this) :
        null))));
return [ as,keys ];
}

//
function destruct0(cmd,lhs,rhs,env) {
let d,as,kdefs,ka,kvals,keys;
d= destruct1(lhs);
as= d[0];
kdefs= [];
ka= null;
kvals= tn.tnode();
keys= d[1];
;
(std.empty_QUERY(as) ?
  as = gensym() :
  null);
as = rdr.jsid(as);
Object.entries(keys).forEach(function (x) {
let name,n,pos,rest_QUERY;
name= x[0];
n= null;
pos= null;
rest_QUERY= false;
;
(name.startsWith("&") ?
    (function() {
  rest_QUERY = true;
  return name = name.slice(1);
  }).call(this) :
  null);
n = rdr.jsid(name);
kdefs.push(n);
pos = x[1];
((pos === null) ?
  ka = [n,"=",as,"[\"",name,"\"];\n"].join("") :
  (rest_QUERY ?
    ka = [n,"=",as,".slice(",pos,");\n"].join("") :
    (true ?
      ka = [n,"=",as,"[",pos,"];\n"].join("") :
      null)));
return kvals.add(ka);
});
kvals.prepend([cmd," ",kdefs.join(","),";\n"].join(""));
return [ [ tn.tnodeEx([ cmd," ",rdr.jsid(as),"= ",transpile_STAR(rhs,env),";\n" ]),kvals ],kdefs ];
}

//
function transpileTree(root,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),root);
;
let pstr,treeSize,endx;
pstr= "";
treeSize= root.length;
endx= (root.length-1);
;
indent += tabspace;
pstr = pad(indent);
root.forEach(function (ast) {
let tmp;
tmp= ast;
;
(Array.isArray(ast) ?
  tmp = transpileList(ast,env) :
  null);
return (tmp ?
    (function() {
  ret.add([ pstr,tmp,(nosemi_QUERY ?
      "" :
      ";"),"\n" ]);
  return nosemi_QUERY = false;
  }).call(this) :
  null);
});
indent -= tabspace;
return ret;
}).call(this);
}

//
function transpileAtoms(atoms,env) {
return atoms.forEach(function (a,i,arr) {
return arr[i] = (Array.isArray(a) ?
  transpileList(a,env) :
  transpileSingle(a));
});
}

//
function transpileSingle(a) {
return (types.symbol_QUERY(a) ?
  rdr.jsid(types.symbol_s(a)) :
  (types.keyword_QUERY(a) ?
    ["\"",types.keyword_s(a),"\""].join("") :
    (types.lambda_arg_QUERY(a) ?
      ["____args[",types.lambda_arg_s(a),"]"].join("") :
      ((typeof(a) === "string") ?
        a :
        ((a === null) ?
          "null" :
          (true ?
            ["",a].join("") :
            null))))));
}

//
function transpile_STAR(x,env) {
return (Array.isArray(x) ?
  transpileList(x,env) :
  transpileSingle(x));
}

//
function findCmd(ast) {
return (function() {
let cmd;
cmd= "";
;
(types.vector_QUERY(ast) ?
  cmd = "[" :
  (types.map_QUERY(ast) ?
    cmd = "{" :
    (types.list_QUERY(ast) ?
      cmd = types.symbol_s(ast[0]) :
      null)));
return cmd;
}).call(this);
}

//
function transpileList(ast,env) {
let cmd,mc,tmp;
cmd= findCmd(ast);
mc= macros.get(cmd);
tmp= null;
;
return (function() {
let ret;
ret= tn.tnode();
;
(mc ?
    (function() {
  ast = rt.expandMacro(ast,env,mc);
  return cmd = findCmd(ast);
  }).call(this) :
  null);
(cmd.startsWith(".-") ?
  ret.add([ transpile_STAR(ast[1],env),".",transpileSingle(types.symbol(cmd.slice(2))) ]) :
  (("." === cmd.charAt(0)) ?
        (function() {
    ret.add(transpile_STAR(ast[1],env));
    ret.add([ cmd,"(" ]);
    (function () {let ____break=false;
for (let n = 2; (!____break && (n < ast.length)); n = (n+1)) {
            ((n !== 2) ?
        ret.add(",") :
        null);
      ret.add(transpile_STAR(ast[n],env));
;
    }
}).call(this);
    return ret.add(")");
    }).call(this) :
    (SPEC_OPS.hasOwnProperty(cmd) ?
      ret = SPEC_OPS[cmd](ast,env) :
      (true ?
                (function() {
        (types.list_QUERY(ast) ?
                    (function() {
          transpileAtoms(ast,env);
          return cmd = ast[0];
          }).call(this) :
          cmd = transpileSingle(ast));
        (cmd ?
          null :
          syntax_BANG("e1",ast));
        return (types.list_QUERY(ast) ?
                    (function() {
          (testre_QUERY(rdr.REGEX.func,cmd) ?
            cmd = tn.tnodeEx([ "(",cmd,")" ]) :
            null);
          return ret.add([ cmd,"(",tn.tnodeEx(ast.slice(1)).join(","),")" ]);
          }).call(this) :
          ret.add(cmd));
        }).call(this) :
        null))));
ret = nodeTag(ret,ast);
return ret;
}).call(this);
}

let _lambdaFuncCount;
_lambdaFuncCount= 0;
;
//
function sf_lambda(ast,env) {
((0 !== _lambdaFuncCount) ?
  (function (){ throw new Error([ "Cant nest lambdas" ].join("")); }).call(this) :
  ++_lambdaFuncCount);
let x,body;
x= [ types.symbol("fn"),types.vector(),[ "let","____args","Array.prototype.slice.call(arguments)" ].map(function (s) {
  return types.symbol(s);
  }) ];
body= ast[1];
;
((body.length === 0) ?
  body = [ null ] :
  null);
(((1 === body.length)&&types.value_QUERY(body[0])) ?
  null :
  body = ast.slice(1));
x = x.concat(body);
return (function() {
try {
return sf_fn(x,env);

} finally {
return --_lambdaFuncCount;
;
}
}).call(this);
}

SPEC_OPS["lambda"] = sf_lambda;
//
function sf_apply(ast,env) {
let args,f,ret;
args= ast.slice(2);
f= ast[1];
ret= nodeTag(tn.tnode(),ast);
;
(function () {let ____break=false;
for (let i = 0; (!____break && (i < args.length)); i = (i+1)) {
    ret.add(transpile_STAR(args[i],env));
;
}
}).call(this);
((args.length > 1) ?
  ret.join(",") :
  null);
return (function() {
let G__1;
G__1= ret;
;
G__1.prepend("[");
G__1.add("]");
G__1.prepend([ transpile_STAR(f,env),".apply(this," ]);
G__1.add(ret,")");
return G__1;
}).call(this);
}

SPEC_OPS["apply"] = sf_apply;
//
function sf_compOp(ast,env) {
let cmd;
cmd= ast[0];
;
(((cmd === "not=")||(cmd === "!=")) ?
  ast[0] = types.symbol("!==") :
  null);
((cmd === "=") ?
  ast[0] = types.symbol("===") :
  null);
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);
;
transpileAtoms(ast,env);
(function () {let ____break=false;
for (let i = 0,op = ast.shift(); (!____break && (i < (ast.length-1))); i = (i+1)) {
    ret.add(tn.tnodeEx([ ast[i]," ",op," ",ast[(i+1)] ]));
;
}
}).call(this);
ret.join(" && ");
ret.prepend("(");
ret.add(")");
return ret;
}).call(this);
}

regoBuiltins(sf_compOp,"compare");
//
function sf_arithOp(ast,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);
;
transpileAtoms(ast,env);
let op,e1,cmd;
op= tn.tnode();
e1= ast.shift();
cmd= types.symbol_s(e1);
;
((cmd === "mod") ?
  cmd = "%" :
  null);
((cmd === "div") ?
  cmd = "/" :
  null);
((1 === ast.length) ?
  (("-" === cmd) ?
    ret.add("-") :
    null) :
  op.add([ "",cmd,"" ]));
ret.add(ast);
((ast.length > 1) ?
  ret.join(op) :
  null);
ret.prepend("(");
ret.add(")");
return ret;
}).call(this);
}

regoBuiltins(sf_arithOp,"bitwise");
regoBuiltins(sf_arithOp,"logic");
regoBuiltins(sf_arithOp,"arith");
//
function sf_repeat(ast,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);
;
transpileAtoms(ast,env);
(function () {let ____break=false;
for (let i = 0,end = parseInt(ast[1]); (!____break && (i < end)); i = (i+1)) {
    ((i !== 0) ?
    ret.add(",") :
    null);
  ret.add(ast[2]);
;
}
}).call(this);
ret.prepend("[");
ret.add("]");
return ret;
}).call(this);
}

SPEC_OPS["repeat-n"] = sf_repeat;
//
function transpileDo(ast,env) {
let G____3=Array.prototype.slice.call(arguments,2);
let G____4= G____3;
let return_QUERY;
return_QUERY=G____4[0];
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);
;
return_QUERY = std.maybe(return_QUERY,true);
let p,e,end;
p= pad(indent);
e= null;
end= (ast.length-1);
;
(function () {let ____break=false;
for (let i = 0; (!____break && (i < end)); i = (i+1)) {
    e = ast[i];
  ret.add([ p,transpileList(e,env),";\n" ]);
;
}
}).call(this);
((end >= 0) ?
    (function() {
  e = transpile_STAR(ast[end],env);
  return (return_QUERY ?
    ret.add([ p,"return ",e,";\n" ]) :
    ret.add([ p,e,";\n" ]));
  }).call(this) :
  null);
return ret;
}).call(this);
}

//
function sf_do(ast,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);
;
let p;
p= pad(indent);
;
ret.add([p,"(function() {\n"].join(""));
ret.add(transpileDo(ast.slice(1),env));
ret.add([p,"}).call(this)"].join(""));
return ret;
}).call(this);
}

SPEC_OPS["do"] = sf_do;
//
function sf_case(ast,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);
;
let tst,e,t,c,dft;
tst= ast[1];
e= null;
t= null;
c= null;
dft= null;
;
((!(0 === (ast.length%2))) ?
  dft = ast.pop() :
  null);
(function () {let ____break=false;
for (let i = 2; (!____break && (i < ast.length)); i = (i+2)) {
    c = ast[(i+1)];
  e = ast[i];
  (types.list_QUERY(e) ?
    (function () {let ____break=false;
for (let j = 0; (!____break && (j < e.length)); i = (null+1)) {
            ret.add([ "case ",transpileSingle(e[j]),":\n" ]);
      ((j === (e.length-1)) ?
        ret.add([ "____x= ",transpile_STAR(c,env),";\nbreak;\n" ]) :
        null);
;
    }
}).call(this) :
        (function() {
    ret.add([ "case ",transpileSingle(e),":\n" ]);
    return ret.add([ "____x= ",transpile_STAR(c,env),";\nbreak;\n" ]);
    }).call(this));
;
}
}).call(this);
(dft ?
    (function() {
  ret.add("default:\n");
  return ret.add([ "____x= ",transpile_STAR(dft,env),";\nbreak;\n" ]);
  }).call(this) :
  null);
ret.prepend([ "switch (",transpile_STAR(tst,env),") {\n" ]);
ret.add("}\n");
ret.prepend("(function() { let ____x;\n");
ret.add("return ____x;}).call(this)");
return ret;
}).call(this);
}

SPEC_OPS["case"] = sf_case;
//
function sf_range(ast,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);
;
let len,start,step,end;
len= 0;
start= 0;
step= 1;
end= 0;
;
transpileAtoms(ast,env);
len = ast.length;
end = parseInt(ast[1]);
((len > 2) ?
    (function() {
  start = parseInt(ast[1]);
  return end = parseInt(ast[2]);
  }).call(this) :
  null);
((len > 3) ?
  step = parseInt(ast[3]) :
  null);
(function () {let ____break=false;
for (let i = start; (!____break && (i < end)); i = (i+step)) {
    ((i !== start) ?
    ret.add(",") :
    null);
  ret.add(i.toString());
;
}
}).call(this);
ret.prepend("[");
ret.add("]");
return ret;
}).call(this);
}

SPEC_OPS["range"] = sf_range;
//
function sf_var(ast,env,cmd) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);
;
let vname,keys,kks,public_QUERY;
vname= null;
keys= [];
kks= {};
public_QUERY= ("global" == cmd);
;
ast = ast.slice(1);
((public_QUERY||("local" == cmd)) ?
  cmd = "var" :
  null);
(function () {let ____break=false;
for (let i = 0; (!____break && (i < ast.length)); i = (i+2)) {
    (types.symbol_QUERY(ast[i]) ?
    keys.push(ast[i]) :
    null);
;
}
}).call(this);
(std.not_empty(keys) ?
  ret.add([ "let ",keys.map(function (s) {
    let ss;
ss= transpileSingle(s);
;
    kks[ss] = null;
    return ss;
    }).join(","),";\n" ]) :
  null);
(function () {let ____break=false;
for (let rc = null,i = 0,lhs = null,rhs = null; (!____break && (i < ast.length)); i = (i+2)) {
    rhs = ast[(i+1)];
  lhs = ast[i];
  (types.symbol_QUERY(lhs) ?
    ret.add([ transpileSingle(lhs),"= ",transpile_STAR(rhs,env),";\n" ]) :
        (function() {
    rc = destruct0(cmd,lhs,rhs,env);
    ret.add(rc[0]);
    return rc[1].map(function (s) {
    return kks[rdr.jsid(s)] = null;
    });
    }).call(this));
;
}
}).call(this);
((public_QUERY&&(1 === NSPACES.length)) ?
    (function() {
  return   (function() {
  let G__2;
G__2= kks;
;
  return Object.entries(G__2).forEach(function (e) {
  return (function (v,k) {
  return EXTERNS[k] = k;
  })(e[1],e[0]);
  });
  }).call(this);
  }).call(this) :
  null);
return ret;
}).call(this);
}

//
function sf_var_local(ast,env) {
return sf_var(ast,env,"local");
}

SPEC_OPS["def-"] = sf_var_local;
//
function sf_var_global(ast,env) {
return sf_var(ast,env,"global");
}

SPEC_OPS["def"] = sf_var_global;
//
function sf_var_let(ast,env) {
return sf_var(ast,env,"let");
}

SPEC_OPS["var"] = sf_var_let;
//
function sf_inst_QUERY(ast,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);
;
ret.add([ "(",transpile_STAR(ast[2],env)," instanceof ",transpile_STAR(ast[1],env),")" ]);
return ret;
}).call(this);
}

SPEC_OPS["inst?"] = sf_inst_QUERY;
//
function sf_delete(ast,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);
;
ret.add([ "delete ",transpile_STAR(ast[1],env) ]);
((ast.length > 2) ?
  ret.add([ "[",transpile_STAR(ast[2]),"]" ]) :
  null);
return ret;
}).call(this);
}

SPEC_OPS["delete!"] = sf_delete;
//
function sf_new(ast,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);
;
ret.add(transpileList(ast.slice(1),env));
ret.prepend("new ");
return ret;
}).call(this);
}

SPEC_OPS["new"] = sf_new;
//
function sf_throw(ast,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);
;
ret.add([ "throw ",transpile_STAR(ast[1],env),";" ]);
ret.prepend("(function (){ ");
ret.add(" }).call(this)");
return ret;
}).call(this);
}

SPEC_OPS["throw"] = sf_throw;
//
function sf_x_opop(ast,env) {
transpileAtoms(ast,env);
return nodeTag(tn.tnodeEx([ ast[0],ast[1] ]),ast);
}

regoBuiltins(sf_x_opop,"incdec");
//
function sf_x_eq(ast,env) {
transpileAtoms(ast,env);
return nodeTag(tn.tnodeEx([ ast[1]," ",ast[0]," ",ast[2] ]));
}

regoBuiltins(sf_x_eq,"assign");
//
function sf_set(ast,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);
;
let e1;
e1= transpile_STAR(ast[1],env);
;
((4 === ast.length) ?
    (function() {
  let G__3;
G__3= ret;
;
  G__3.add(e1);
  G__3.add("[");
  G__3.add(transpile_STAR(ast[2],env));
  G__3.add("]");
  return G__3;
  }).call(this) :
  ret.add(e1));
ret.add([ " = ",transpile_STAR(ast[(ast.length-1)],env) ]);
return ret;
}).call(this);
}

SPEC_OPS["aset"] = sf_set;
SPEC_OPS["set!"] = sf_set;
//
function parseFuncArgs(args) {
return (function() {
let ret;
ret= [];
;
(function () {let ____break=false;
for (let i = 0,e = null,ev = null; (!____break && (i < args.length)); i = (i+1)) {
    e = args[i];
  ev = e.value;
  (types.symbol_QUERY(e) ?
    ((ev === "_") ?
      ret.push(types.symbol(gensym("_"))) :
      ((ev === "&") ?
                (function() {
        e = args[(i+1)];
        (types.symbol_QUERY(e) ?
          ret.push([ e,i,e ]) :
          ret.push([ types.symbol(["&",gensym()].join("")),i,e ]));
        return ++i;
        }).call(this) :
        (ev.startsWith("&") ?
                    (function() {
          e = types.symbol(ev.slice(1));
          return ret.push([ e,i,e ]);
          }).call(this) :
          (true ?
            ret.push(e) :
            null)))) :
    (types.keyword_QUERY(e) ?
      (function (){ throw new Error([ "bad function args destructure: ",types.obj_type(e) ].join("")); }).call(this) :
      (Array.isArray(e) ?
        ret.push([ types.symbol(gensym()),i,e ]) :
        (true ?
          (function (){ throw new Error([ "bad function args destructure: ",types.obj_type(e) ].join("")); }).call(this) :
          null))));
;
}
}).call(this);
return ret;
}).call(this);
}

//
function handleFuncArgs(fargs,env) {
return (function() {
let out;
out= [];
;
let misc,keys,ret,knode;
misc= [];
keys= [];
ret= tn.tnode();
knode= tn.tnode();
;
fargs.forEach(function (arg) {
return (types.symbol_QUERY(arg) ?
  keys.push(arg) :
  ((types.symbol_QUERY(arg[0])&&(!arg[0].toString().startsWith("&"))&&Array.isArray(arg[2])) ?
        (function() {
    keys.push(arg[0]);
    return misc.push(arg);
    }).call(this) :
    (true ?
      misc.push(arg) :
      null)));
});
misc.forEach(function (arr) {
let a0,name,varg_QUERY,pos,a2;
a0= arr[0];
name= a0.toString();
varg_QUERY= name.startsWith("&");
pos= arr[1].toString();
a2= arr[2];
;
(varg_QUERY ?
  name = name.slice(1) :
  null);
name = rdr.jsid(name);
return ((types.symbol_QUERY(a0)&&types.symbol_QUERY(a2)) ?
  ret.add([ "let ",name,"=Array.prototype.slice.call(arguments,",pos,");\n" ]) :
  (Array.isArray(a2) ?
        (function() {
    (varg_QUERY ?
      ret.add([ "let ",name,"=Array.prototype.slice.call(arguments,",pos,");\n" ]) :
      null);
    return ret.add(destruct0("let",a2,name,env)[0]);
    }).call(this) :
    null));
});
knode.add(keys.map(function () {
let ____args;
____args= Array.prototype.slice.call(arguments);
;
return rdr.jsid(____args[0].toString());
}).join(","));
out.push(knode);
out.push(ret);
return out;
}).call(this);
}

//
function sf_fn(ast,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);
;
let args,body,fargs;
args= ast[1];
body= ast.slice(2);
fargs= handleFuncArgs(parseFuncArgs(args),env);
;
ret.add("function (");
ret.add(fargs[0]);
ret.add([ ") {\n",fargs[1],transpileDo(body,env),pad(indent),"}" ]);
return ret;
}).call(this);
}

SPEC_OPS["fn"] = sf_fn;
//
function sf_func(ast,env,public_QUERY) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);
;
let fname,dot_QUERY,fargs,e3,e2,doc,attrs,args,body;
fname= transpileSingle(ast[1]);
dot_QUERY= fname.includes(".");
fargs= null;
e3= ast[3];
e2= ast[2];
doc= null;
attrs= null;
args= 2;
body= 3;
;
((typeof(e2) === "string") ?
    (function() {
  doc = 2;
  args = 3;
  return (types.map_QUERY(e3) ?
        (function() {
    attrs = 3;
    return args = 4;
    }).call(this) :
    null);
  }).call(this) :
  (types.map_QUERY(e2) ?
        (function() {
    attrs = 2;
    return args = 3;
    }).call(this) :
    null));
body = (args+1);
(doc ?
  doc = ast[doc] :
  null);
(attrs ?
  attrs = ast[attrs] :
  null);
args = ast[args];
fargs = handleFuncArgs(parseFuncArgs(args),env);
body = ast.slice(body);
(dot_QUERY ?
  ret.add([ fname," = function (" ]) :
  ret.add(["function ",fname,"("].join("")));
ret.add(fargs[0]);
ret.add([ ") {\n",fargs[1],transpileDo(body,env),pad(indent),"}\n" ]);
((false&&attrs) ?
    (function() {
  return null;
  }).call(this) :
  null);
(doc ?
    (function() {
  doc = doc.replace(rdr.REGEX.dquoteHat,"");
  doc = doc.replace(rdr.REGEX.dquoteEnd,"");
  return ret.prepend(doc.split("\\n").map(function () {
  let ____args;
____args= Array.prototype.slice.call(arguments);
;
  return ["//",____args[0],"\n"].join("");
  }));
  }).call(this) :
  null);
((public_QUERY&&(!dot_QUERY)&&(1 === NSPACES.length)) ?
  EXTERNS[fname] = fname :
  null);
nosemi_QUERY = true;
return ret;
}).call(this);
}

//
function sf_func_private(ast,env) {
return sf_func(ast,env,false);
}

SPEC_OPS["defn-"] = sf_func_private;
//
function sf_func_public(ast,env) {
return sf_func(ast,env,true);
}

SPEC_OPS["defn"] = sf_func_public;
//
function sf_try(ast,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);
;
let sz,t,f,c,ind;
sz= ast.length;
t= null;
f= null;
c= null;
ind= pad(indent);
;
f = std.last(ast);
((Array.isArray(f)&&("finally" == f[0])) ?
    (function() {
  f = ast.pop();
  return sz = ast.length;
  }).call(this) :
  f = null);
c = null;
((sz > 1) ?
  c = ast[(sz-1)] :
  null);
((Array.isArray(c)&&("catch" == c[0])) ?
    (function() {
  (((c.length < 2)||(!types.symbol_QUERY(c[1]))) ?
    syntax_BANG("e0",ast) :
    null);
  return c = ast.pop();
  }).call(this) :
  c = null);
(((f === null)&&(c === null)) ?
  syntax_BANG("e0",ast) :
  null);
ret.add([ ["(function() {\n",ind,"try {\n"].join(""),transpileDo(ast.slice(1),env),["\n",ind,"} "].join("") ]);
(c ?
    (function() {
  t = c[1];
  return ret.add([ ["catch (",t,") {\n"].join(""),transpileDo(c.slice(2),env),[";\n",ind,"}\n"].join("") ]);
  }).call(this) :
  null);
(f ?
    (function() {
  return ret.add([ "finally {\n",transpileDo(f.slice(1),env),[";\n",ind,"}\n"].join("") ]);
  }).call(this) :
  null);
ret.add([ind,"}).call(this)"].join(""));
return ret;
}).call(this);
}

SPEC_OPS["try"] = sf_try;
//
function sf_if(ast,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);
;
let a1,a2,a3;
a1= ast[1];
a2= ast[2];
a3= ((ast.length > 3) ?
  ast[3] :
  null);
;
indent += tabspace;
ret.add([ "(",transpile_STAR(a1,env),[" ?\n",pad(indent)].join(""),transpile_STAR(a2,env),[" :\n",pad(indent)].join(""),(transpile_STAR(a3,env)||"null"),")" ]);
indent -= tabspace;
return ret;
}).call(this);
}

SPEC_OPS["if"] = sf_if;
//
function sf_nth(ast,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);
;
transpileAtoms(ast,env);
ret.add([ ast[1],"[",ast[2],"]" ]);
return ret;
}).call(this);
}

SPEC_OPS["nth"] = sf_nth;
//
function sf_get(ast,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);
;
transpileAtoms(ast,env);
ret.add([ ast[1],"[",ast[2],"]" ]);
return ret;
}).call(this);
}

SPEC_OPS["aget"] = sf_get;
SPEC_OPS["get"] = sf_get;
//
function sf_str(ast,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);
;
let args;
args= ast.slice(1);
;
transpileAtoms(args,env);
((args.length > 1) ?
    (function() {
  let G__4;
G__4= ret;
;
  G__4.add(args);
  G__4.join(",");
  G__4.prepend("[");
  G__4.add("].join(\"\")");
  return G__4;
  }).call(this) :
  ((args.length > 0) ?
    ret.add([ "",args[0],".toString()" ]) :
    null));
return ret;
}).call(this);
}

SPEC_OPS["str"] = sf_str;
//
function sf_array(ast,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);
;
let p,epilog;
p= pad(indent);
epilog= ["\n",p,"]"].join("");
;
(std.empty_QUERY(ast) ?
  ret.add("[]") :
    (function() {
  (types.vector_QUERY(ast) ?
    null :
    ast.splice(0,1));
  indent += tabspace;
  transpileAtoms(ast,env);
  p = pad(indent);
  ret.add(["[\n",p].join(""));
  (function () {let ____break=false;
for (let i = 0; (!____break && (i < ast.length)); i = (i+1)) {
        ((i > 0) ?
      ret.add([",\n",p].join("")) :
      null);
    ret.add(ast[i]);
;
  }
}).call(this);
  ret.add(epilog);
  return indent -= tabspace;
  }).call(this));
return ret;
}).call(this);
}

SPEC_OPS["vec"] = sf_array;
//
function sf_object(ast,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);
;
let p,epilog;
p= pad(indent);
epilog= ["\n",p,"}"].join("");
;
(std.empty_QUERY(ast) ?
  ret.add("{}") :
    (function() {
  (types.map_QUERY(ast) ?
    null :
    ast.splice(0,1));
  indent += tabspace;
  transpileAtoms(ast,env);
  p = pad(indent);
  ret.add(["{\n",p].join(""));
  (function () {let ____break=false;
for (let i = 0; (!____break && (i < ast.length)); i = (i+2)) {
        ((i > 0) ?
      ret.add([",\n",p].join("")) :
      null);
    ret.add([ ast[i],": ",ast[(i+1)] ]);
;
  }
}).call(this);
  ret.add(epilog);
  return indent -= tabspace;
  }).call(this));
return ret;
}).call(this);
}

SPEC_OPS["hash-map"] = sf_object;
let includeFile;
includeFile= (function () {
let icache;
icache= [];
;
return function (fname) {
return (std.contains_QUERY(icache,fname) ?
  tn.tnode() :
    (function() {
  let src;
src= fs.readFileSync(fname,"utf-8");
;
  icache.push(fname);
  return transpileTree(psr.parser(src,fname),rt.globalEnv());
  }).call(this));
};
})();
;
//
function sf_include(ast,env) {
let ret,fname,dir;
ret= [];
fname= null;
dir= path.dirname(ast.source);
;
(function () {let ____break=false;
for (let i = 1,e = null; (!____break && (i < ast.length)); i = (i+1)) {
    e = ast[i];
  (((!Array.isArray(e))||(1 !== e.length)) ?
    syntax_BANG("e0",ast) :
    null);
  fname = e[0];
  (fname ?
    fname = fname.replace(/[\"]/g,"") :
    null);
  (function() {
  try {
  return fname = fs.realpathSync([dir,"/",fname].join(""));

  } catch (e) {
  return syntax_BANG("e11",ast);
;
  }
  }).call(this);
  (function() {
  try {
  indent -= tabspace;
  return ret.push(includeFile(fname));

  } finally {
  NSPACES.pop();
  return indent += tabspace;
;
  }
  }).call(this);
;
}
}).call(this);
return (std.empty_QUERY(ret) ?
  tn.tnode() :
  ret);
}

//
function sf_require(ast,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);
;
let path,v,e;
path= null;
v= null;
e= null;
;
(function () {let ____break=false;
for (let i = 1; (!____break && (i < ast.length)); i = (i+1)) {
    e = ast[i];
  (((!Array.isArray(e))||(3 !== e.length)) ?
    syntax_BANG("e0",ast) :
    null);
  path = e[0];
  v = e[2];
  ret.add([ "var ",transpileSingle(v,env),"= require(",transpileSingle(path,env),");\n" ]);
;
}
}).call(this);
return ret;
}).call(this);
}

//
function sf_ns(ast,env) {
return (function() {
let ret;
ret= [];
;
(function () {let ____break=false;
for (let i = 1,e = null,nsp = null; (!____break && (i < ast.length)); i = (i+1)) {
    e = ast[i];
  (types.symbol_QUERY(e) ?
    (nsp ?
      syntax_BANG("e0",ast) :
      NSPACES.push(e.toString())) :
    ((types.list_QUERY(e)&&("with-meta" == e[0])&&types.symbol_QUERY(e[1])) ?
      (nsp ?
        syntax_BANG("e0",ast) :
        NSPACES.push(e[1].toString())) :
      ((types.list_QUERY(e)&&("include" == e[0])) ?
        ret.push(sf_include(e)) :
        ((types.list_QUERY(e)&&("require" == e[0])) ?
          ret.push(sf_require(e)) :
          null))));
;
}
}).call(this);
return ret;
}).call(this);
}

SPEC_OPS["ns"] = sf_ns;
//
function sf_comment(ast,env) {
return nodeTag(tn.tnode(),ast);
}

SPEC_OPS["comment"] = sf_comment;
//
function sf_floop(ast,env,hint) {
return (function() {
let ret;
ret= nodeTag(tn.tnodeEx("for ("),ast);
;
let c1,c2,c3,c,ind;
c1= null;
c2= null;
c3= null;
c= ast[1];
ind= pad(indent);
;
(((!Array.isArray(c))||(3 !== c.length)) ?
  syntax_BANG("e0",ast) :
  null);
c1 = c[0];
c2 = c[1];
c3 = c[2];
indent += tabspace;
(Array.isArray(c1) ?
  (function () {let ____break=false;
for (let i = 0; (!____break && (i < c1.length)); i = (i+2)) {
        ((i === 0) ?
      ret.add([hint," "].join("")) :
      null);
    ((i > 0) ?
      ret.add(",") :
      null);
    ret.add([ transpileSingle(c1[i],env)," = ",transpile_STAR(c1[(i+1)],env) ]);
;
  }
}).call(this) :
  null);
ret.add("; ");
(Array.isArray(c2) ?
  ret.add([ "(!____break && ",transpileList(c2,env),")" ]) :
  ret.add(" !___break "));
ret.add("; ");
(Array.isArray(c3) ?
  (function () {let ____break=false;
for (let i = 0; (!____break && (i < c3.length)); i = (i+2)) {
        ((i > 0) ?
      ret.add(",") :
      null);
    ret.add([ transpileSingle(c3[i],env)," = ",transpile_STAR(c3[(i+1)],env) ]);
;
  }
}).call(this) :
  null);
ret.add(") {\n");
((ast.length > 2) ?
  ret.add([ ind,pad(tabspace),transpileDo(ast.slice(2),env,false),";" ]) :
  null);
ret.add(["\n",ind,"}\n"].join(""));
ret.prepend("(function () {let ____break=false;\n");
ret.add("}).call(this)");
indent -= tabspace;
return ret;
}).call(this);
}

SPEC_OPS["forlet"] = function (ast,env) {
return sf_floop(ast,env,"let");
};
SPEC_OPS["for"] = function (ast,env) {
return sf_floop(ast,env,"");
};
//
function sf_wloop(ast,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnodeEx("for (;"),ast);
;
let cond,ind;
cond= ast[1];
ind= pad(indent);
;
ret.add([ " (!____break && ",transpile_STAR(cond,env),") " ]);
ret.add(";) {\n");
indent += tabspace;
((ast.length > 2) ?
  ret.add([ ind,pad(tabspace),transpileDo(ast.slice(2),env,false),";" ]) :
  null);
ret.add(["\n",ind,"}\n"].join(""));
ret.prepend("(function () {let ____break=false;\n");
ret.add("}).call(this)");
indent -= tabspace;
return ret;
}).call(this);
}

SPEC_OPS["while"] = sf_wloop;
//
function sf_jscode(ast,env) {
nosemi_QUERY = true;
return nodeTag(tn.tnodeEx(ast[1].toString().replace(rdr.REGEX.dquoteHat,"").replace(rdr.REGEX.dquoteEnd,"")),ast);
}

SPEC_OPS["js#"] = sf_jscode;
//
function sf_macro(ast,env) {
let pms,args,body;
pms= types.vector();
args= ast[2];
body= ast.slice(3);
;
((typeof(args) === "string") ?
    (function() {
  doc = args;
  args = ast[3];
  return body = ast.slice(4);
  }).call(this) :
  null);
(function () {let ____break=false;
for (let i = 0,e = null,ev = null; (!____break && (i < args.length)); i = (i+1)) {
    e = args[i];
  ev = e.value;
  ((ev === "&") ?
    (Array.isArray(args[(i+1)]) ?
            (function() {
      e = args[(i+1)];
      ++i;
      return (function () {let ____break=false;
for (let j = 0,x = null; (!____break && (j < e.length)); j = (j+1)) {
                x = e[j];
        (types.symbol_QUERY(x) ?
          null :
          (function (){ throw new Error([ "Bad optional arg for macro" ].join("")); }).call(this));
        pms.push(x);
;
      }
}).call(this);
      }).call(this) :
            (function() {
      pms.push(e,args[(i+1)]);
      return ++i;
      }).call(this)) :
    ((!types.symbol_QUERY(e)) ?
      (function (){ throw new Error([ "Bad optional arg for macro" ].join("")); }).call(this) :
      (true ?
        pms.push(e) :
        null)));
;
}
}).call(this);
ast = [ ast[0],ast[1],[ types.symbol("fn*"),pms ].concat(body) ];
let a2,a1,func;
a2= ast[2];
a1= ast[1].toString();
func= rt.compute(a2,env);
;
func["____macro"] = true;
(doc ?
  func["____doc"] = doc :
  null);
macros.set(a1,func);
return nodeTag(tn.tnode(),ast);
}

SPEC_OPS["defmacro"] = sf_macro;
//
function sf_unary(ast,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);
;
let G____5= ast;
let a0,a1;
a0=G____5[0];
a1=G____5[1];
;
((a0 == "not") ?
  a0 = types.symbol("!") :
  null);
ret.add([ "(",transpile_STAR(a0,env),transpile_STAR(a1,env),")" ]);
return ret;
}).call(this);
}

regoBuiltins(sf_unary,"unary");
//
function sf_doseq(ast,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);
;
let args,body,loopvar,loopexpr,escvar,idxvar,exprvar;
args= ast[1];
body= ast.slice(2);
loopvar= args[0];
loopexpr= args[1];
escvar= gensym();
idxvar= gensym();
exprvar= gensym();
;
ret.add([ "let ",transpileSingle(loopvar),"= ",exprvar,"[",idxvar,"];\n" ]);
(function () {let ____break=false;
for (let i = 2,v = null,ev = null; (!____break && (i < args.length)); i = (i+1)) {
    v = args[i];
  ev = v.value;
  ((ev === "while") ?
    ret.add([ "if (! ",transpile_STAR(args[(i+1)],env),") {",escvar,"=true;}\n" ]) :
    ((ev === "when") ?
            (function() {
      let G__5;
G__5= ret;
;
      G__5.add([ "if (!",escvar,") {\n" ]);
      G__5.add([ "if (! ",transpile_STAR(args[(i+1)],env),") {continue;}\n" ]);
      G__5.add("}\n");
      return G__5;
      }).call(this) :
      ((ev === "let") ?
        ret.add(sf_var_let([ types.symbol("var") ].concat(args[(i+1)]),env)) :
        null)));
;
}
}).call(this);
ret.add([ "if (!",escvar,") {\n" ]);
ret.add(transpileDo(body,env,false));
ret.add("}\n");
ret.add("}\n");
ret.prepend([ "for(var ",escvar,"=false,",idxvar,"=0; ","(!",escvar," && ",idxvar," < ",exprvar,".length); ++",idxvar,") {\n" ]);
ret.prepend([ "let ",exprvar,"= ",transpile_STAR(loopexpr,env),";\n" ]);
ret.prepend("(function() {\n");
ret.add("})(this);\n");
return ret;
}).call(this);
}

SPEC_OPS["doseq"] = sf_doseq;
//
function spitExterns() {
return (function() {
let s;
s= "";
;
let ks,p;
ks= Object.keys(EXTERNS);
p= pad(tabspace);
;
((ks.length > 0) ?
    (function() {
  s = ks.map(function () {
  let ____args;
____args= Array.prototype.slice.call(arguments);
;
  return [p,____args[0],": ",____args[0]].join("");
  }).join(",\n");
  return s = ["\n\nmodule.exports = {\n",s,"\n};\n\n"].join("");
  }).call(this) :
  null);
return s;
}).call(this);
}

//
function banner() {
return ["/*","Auto generated by Kirby - v",MODULE_VERSION," ",NSPACES[0]," - ",new Date(),"*/\n\n"].join("");
}

//
function transpileCode(codeStr,fname,srcMap_QUERY) {
indent = (-tabspace);
EXTERNS = {};
NSPACES = [];
let outNode,extra;
outNode= transpileTree(psr.parser(codeStr,fname),rt.globalEnv());
extra= spitExterns();
;
outNode.prepend(banner());
return (srcMap_QUERY ?
    (function() {
  let outFile,srcMap,output;
outFile= [path.basename(fname,".ky"),".js"].join("");
srcMap= [outFile,".map"].join("");
output= outNode.toStringWithSourceMap({ "file": outFile });
;
  fs.writeFileSync(srcMap,output.map);
  return [output.code,extra,"\n//# sourceMappingURL=",path.relative(path.dirname(fname),srcMap)].join("");
  }).call(this) :
  [outNode,extra].join(""));
}

//
function transpileXXX(code,file,smap_QUERY) {
return (function() {
try {
return transpileCode(code,file,smap_QUERY);

} catch (e) {
return (e ?
    (function() {
  (console ?
    console.log([ e.stack ].join("")) :
    null);
  return (function (){ throw e; }).call(this);
  }).call(this) :
  null);
;
}
}).call(this);
}

//
function transpileWithSrcMap(code,file) {
return transpileXXX(code,file,true);
}

//
function transpile(code,file) {
return transpileXXX(code,file,false);
}

//
function parseWithSourceMap(codeStr,fname) {
let outNode;
outNode= transpileTree(psr.parser(codeStr,fname));
;
outNode.prepend(banner());
return outNode.toStringWithSourceMap();
}

let version;
version= MODULE_VERSION;
;


module.exports = {
  transpileWithSrcMap: transpileWithSrcMap,
  transpile: transpile,
  parseWithSourceMap: parseWithSourceMap,
  version: version
};

