/*Auto generated by Kirby - v1.0.0 czlab.kirby.cg.transpiler Wed Nov 01 2017 02:37:11 GMT-0700 (PDT)*/

var macros= require("../bl/macros");
var types= require("../bl/types");
var std= require("../bl/stdlib");
var tn= require("../bl/tnode");
var rdr= require("../bl/lexer");
var psr= require("../bl/parser");
var rt= require("../rt/runtime");
var fs= require("fs");
var path= require("path");
var esfmt= require("esformatter");

let gensym_counter;
gensym_counter= 1;

let ERRORS_MAP;
ERRORS_MAP= { "e0": "Syntax Error","e1": "Empty statement","e2": "Invalid characters in function name","e3": "End of File encountered, unterminated string","e4": "Closing square bracket, without an opening square bracket","e5": "End of File encountered, unterminated array","e6": "Closing curly brace, without an opening curly brace","e7": "End of File encountered, unterminated javascript object '}'","e8": "End of File encountered, unterminated parenthesis","e9": "Invalid character in var name","e10": "Extra chars at end of file. Maybe an extra ')'.","e11": "Cannot Open include File","e12": "Invalid no of arguments to ","e13": "Invalid Argument type to ","e14": "End of File encountered, unterminated regular expression","e15": "Invalid vararg position, must be last argument.","e16": "Invalid arity (args > expected) to ","e17": "Invalid arity (args < expected) to " };

let RESERVED;
RESERVED= { "compare": [ "not=","!=","==","=",">",">=","<","<=" ],"arith": [ "+","-","*","div","%","mod" ],"logic": [ "||","&&" ],"bitwise": [ "^","&","|","<<",">>",">>>" ],"incdec": [ "++","--" ],"unary": [ "not","~","!" ],"assign": [ "+=","-=","*=","/=","%=","<<=",">>=",">>>=","&=","|=","^=" ],"builtin": [ "quote","syntax-quote","quasi-quote","backtick","unquote","unquote-splice","repeat-n","do","doto","case","apply","range","def-","def","var","forlet","new","throw","while","lambda","inst?","delete!","aset","set!","fn","def!","defn-","defn","try","if","get","aget","str","list","[","vec","{","hash-map","ns","comment","for","cons","js#","macro","defmacro" ] };

let MODULE_VERSION,tabspace,indent,EXTERNS,NSPACES,SPEC_OPS;
MODULE_VERSION= "1.0.0";
tabspace= 2;
indent= (-tabspace);
EXTERNS= null;
NSPACES= null;
SPEC_OPS= {};

//
function gensym() {
let G____3=Array.prototype.slice.call(arguments,0);
let G____4= G____3;
let pfx;
pfx=G____4[0];
let x;
x= gensym_counter;

++gensym_counter;
return [std.maybe(pfx,"G____"),x].join("");
}

//
function regoBuiltins(f,group) {
return RESERVED[group].forEach(function () {
let ____args;
____args= Array.prototype.slice.call(arguments);

return SPEC_OPS[____args[0]] = f;
});
}

//
function error_BANG(e,line,file,msg) {
return (function (){ throw new Error([ ERRORS_MAP[e],(msg ?
[" : ",msg].join("") :
""),(line ?
["\nLine no ",line].join("") :
""),(file ?
["\nFile ",file].join("") :
"") ].join("")); }).call(this);
}

//
function syntax_BANG(ecode,ast,cmd) {
return error_BANG(ecode,(ast ?
ast.line :
0),(ast ?
ast.source :
0),cmd);
}

//
function pad(z) {
return " ".repeat(z);
}

//
function testre_QUERY(re,x) {
return (x ?
re.test(x) :
false);
}

//
function nodeTag(obj,src) {
((obj&&src&&(!(typeof(obj) === "boolean"))&&(!(typeof(obj) === "number"))) ?
(function() {
obj.source = src.source;
obj.column = src.column;
return obj.line = src.line;
}).call(this) :
null);
return obj;
}

//
function destruct1(lhs) {
let as,out,keys;
as= "";
out= [];
keys= {};

(types.vector_QUERY(lhs) ?
forlet(i(0,e,null,ev,null)((i < lhs.length),i((i+1))),e = lhs[i],ev = e.value,(types.symbol_QUERY(e) ?
((ev === "_") ?
null :
((ev === "&") ?
(function() {
keys[["&",lhs[(i+1)]].join("")] = i;
return ++i;
}).call(this) :
(ev.startsWith("&") ?
keys[ev] = i :
(true ?
keys[ev] = i :
null)))) :
(types.keyword_QUERY(e) ?
((ev === "as") ?
(function() {
++i;
return as = lhs[i].toString();
}).call(this) :
(function (){ throw new Error([ "bad keyword: :",ev ].join("")); }).call(this)) :
null))) :
(types.map_QUERY(lhs) ?
forlet(i(0,e,null,ev,null)((i < lhs.length),i((i+1))),e = lhs[i],ev = e.value,(types.keyword_QUERY(e) ?
(((ev === "keys")||(ev === "strs")) ?
(function() {
let ks;
ks= lhs[(i+1)];

++i;
return forlet(j(0)((j < ks.length),j((j+1))),keys[ks[j].toString()] = null);
}).call(this) :
((ev === "as") ?
(function() {
++i;
return as = lhs[i].toString();
}).call(this) :
null)) :
(function (){ throw new Error([ "bad destruct field: ",types.obj_type(e) ].join("")); }).call(this))) :
(types.symbol_QUERY(lhs) ?
keys[lhs.toString()] = null :
(true ?
(function (){ throw new Error([ "cant destruct with: ",types.obj_type(lhs) ].join("")); }).call(this) :
null))));
return [ as,keys ];
}

//
function destruct0(cmd,lhs,rhs,env) {
let d,as,kdefs,ka,kvals,keys;
d= destruct1(lhs);
as= d[0];
kdefs= [];
ka= null;
kvals= tn.tnode();
keys= d[1];

(std.empty_QUERY(as) ?
as = gensym() :
null);
as = rdr.jsid(as);
Object.entries(keys).forEach(function (x) {
let name,n,pos,rest_QUERY;
name= x[0];
n= null;
pos= null;
rest_QUERY= false;

(name.startsWith("&") ?
(function() {
rest_QUERY = true;
return name = name.slice(1);
}).call(this) :
null);
n = rdr.jsid(name);
kdefs.push(n);
pos = x[1];
((pos === null) ?
ka = [n,"=",as,"[\"",name,"\"];\n"].join("") :
(rest_QUERY ?
ka = [n,"=",as,".slice(",pos,");\n"].join("") :
(true ?
ka = [n,"=",as,"[",pos,"];\n"].join("") :
null)));
return kvals.add(ka);
});
kvals.prepend([cmd," ",kdefs.join(","),";\n"].join(""));
return [ [ tn.tnodeEx([ cmd," ",rdr.jsid(as),"= ",transpile_STAR(rhs,env),";\n" ]),kvals ],kdefs ];
}

//
function transpileTree(root,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),root);

let pstr,treeSize,endx;
pstr= "";
treeSize= root.length;
endx= (root.length-1);

indent += tabspace;
pstr = pad(indent);
root.forEach(function (ast) {
let tmp;
tmp= ast;

(Array.isArray(ast) ?
tmp = transpileList(ast,env) :
null);
return (tmp ?
(function() {
return ret.add([ pstr,tmp,"\n" ]);
}).call(this) :
null);
});
indent -= tabspace;
return ret;
}).call(this);
}

//
function transpileAtoms(atoms,env) {
return atoms.forEach(function (a,i,arr) {
return arr[i] = (Array.isArray(a) ?
transpileList(a,env) :
transpileSingle(a));
});
}

//
function transpileSingle(a) {
return (types.symbol_QUERY(a) ?
rdr.jsid(types.symbol_s(a)) :
(types.keyword_QUERY(a) ?
["\"",types.keyword_s(a),"\""].join("") :
(types.lambda_arg_QUERY(a) ?
(function() {
return ["____args[",types.lambda_arg_s(a),"]"].join("");
}).call(this) :
((typeof(a) === "string") ?
a :
((a === null) ?
"null" :
(true ?
["",a].join("") :
null))))));
}

//
function transpile_STAR(x,env) {
return (Array.isArray(x) ?
transpileList(x,env) :
transpileSingle(x));
}

//
function findCmd(ast) {
return (function() {
let cmd;
cmd= "";

(types.vector_QUERY(ast) ?
cmd = "vec" :
(types.map_QUERY(ast) ?
cmd = "hash-map" :
(types.list_QUERY(ast) ?
cmd = types.symbol_s(ast[0]) :
null)));
return cmd;
}).call(this);
}

//
function transpileList(ast,env) {
let cmd,mc,tmp;
cmd= findCmd(ast);
mc= macros.get(cmd);
tmp= null;

return (function() {
let ret;
ret= tn.tnode();

(mc ?
(function() {
ast = rt.expandMacro(ast,env,mc);
return cmd = findCmd(ast);
}).call(this) :
null);
(cmd.startsWith(".-") ?
ret.add([ transpile_STAR(ast[1],env),".",transpileSingle(types.symbol(cmd.slice(2))) ]) :
(("." === cmd.charAt(0)) ?
(function() {
ret.add(transpile_STAR(ast[1],env));
ret.add([ cmd,"(" ]);
forlet(n(2)((n < ast.length),n((n+1))),((n !== 2) ?
ret.add(",") :
null),ret.add(transpile_STAR(ast[n],env)));
return ret.add(")");
}).call(this) :
(SPEC_OPS.hasOwnProperty(cmd) ?
ret = SPEC_OPS[cmd](ast,env) :
(rdr.REGEX.int.test(cmd) ?
(function() {
let c0;
c0= cmd.charAt(0);

(((c0 !== "-")&&(c0 !== "+")) ?
cmd = ["+",cmd].join("") :
null);
ast = [ types.symbol(cmd.charAt(0)),ast[1],parseInt(cmd.slice(1)) ];
cmd = ast[0].toString();
return ret = SPEC_OPS[cmd](ast,env);
}).call(this) :
(true ?
(function() {
(types.list_QUERY(ast) ?
(function() {
transpileAtoms(ast,env);
return cmd = ast[0];
}).call(this) :
cmd = transpileSingle(ast));
((!cmd) ?
syntax_BANG("e1",ast) :
null);
return (types.list_QUERY(ast) ?
(function() {
(testre_QUERY(rdr.REGEX.func,cmd) ?
cmd = tn.tnodeEx([ "(",cmd,")" ]) :
null);
return ret.add([ cmd,"(",tn.tnodeEx(ast.slice(1)).join(","),")" ]);
}).call(this) :
ret.add(cmd));
}).call(this) :
null)))));
ret = nodeTag(ret,ast);
return ret;
}).call(this);
}

//
function sf_deftype(ast,env) {
return (function() {
let ret;
ret= nodeTag(tnode(),ast);

let cz,par,args,mtds;
cz= transpile_STAR(ast[1],env);
par= ast[2][0];
args= ast[3];
mtds= ast.slice(4);

ret.add([ "class ",cz ]);
(par ?
ret.add([ " extends ",transpile_STAR(par,env) ]) :
null);
ret.add(" {\n");
(function() {
for (let i=0,n=null,m=null,____break=false; ((!____break)&&(i < mtds.length)); i=(i+1)){
m = mtds[i];
m.unshift(types.symbol("method"));
ret.add(sf_func(m,env,false));
ret.add("\n");
}
})(this);

ret.add("}\n");
return ret;
}).call(this);
}

SPEC_OPS["deftype"] = sf_deftype
let _lambdaFuncCount;
_lambdaFuncCount= 0;

//
function sf_lambda(ast,env) {
((0 !== _lambdaFuncCount) ?
(function (){ throw new Error([ "Cant nest lambdas" ].join("")); }).call(this) :
++_lambdaFuncCount);
let x,body;
x= [ types.symbol("fn"),types.vector(),[ types.symbol("var"),types.symbol("____args"),[ types.symbol("Array.prototype.slice.call"),types.symbol("arguments") ] ] ];
body= ast[1];

((body.length === 0) ?
body = [ null ] :
null);
(((1 === body.length)&&types.value_QUERY(body[0])) ?
null :
body = ast.slice(1));
x = x.concat(body);
return (function() {
try {
return sf_fn(x,env);

} finally {
--_lambdaFuncCount;

}
}).call(this);
}

SPEC_OPS["lambda"] = sf_lambda
//
function sf_apply(ast,env) {
let args,f,ret;
args= ast.slice(2);
f= ast[1];
ret= nodeTag(tn.tnode(),ast);

forlet(i(0)((i < args.length),i((i+1))),ret.add(transpile_STAR(args[i],env)));
((args.length > 1) ?
ret.join(",") :
null);
return (function() {
let G__1;
G__1= ret;

G__1.prepend("[");
G__1.add("]");
G__1.prepend([ transpile_STAR(f,env),".apply(this," ]);
G__1.add(ret,")");
return G__1;
}).call(this);
}

SPEC_OPS["apply"] = sf_apply
//
function sf_compOp(ast,env) {
let cmd;
cmd= ast[0];

(((cmd == "not=")||(cmd == "!=")) ?
ast[0] = types.symbol("!==") :
null);
((cmd == "=") ?
ast[0] = types.symbol("===") :
null);
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);

transpileAtoms(ast,env);
forlet(i(0,op,ast.shift())((i < (ast.length-1)),i((i+1))),ret.add(tn.tnodeEx([ ast[i]," ",op," ",ast[(i+1)] ])));
ret.join(" && ");
ret.prepend("(");
ret.add(")");
return ret;
}).call(this);
}

regoBuiltins(sf_compOp,"compare")
//
function sf_arithOp(ast,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);

transpileAtoms(ast,env);
let op,e1,cmd;
op= tn.tnode();
e1= ast.shift();
cmd= types.symbol_s(e1);

((cmd == "mod") ?
cmd = "%" :
null);
((cmd == "div") ?
cmd = "/" :
null);
((1 === ast.length) ?
(("-" == cmd) ?
ret.add("-") :
null) :
op.add([ "",cmd,"" ]));
ret.add(ast);
((ast.length > 1) ?
ret.join(op) :
null);
ret.prepend("(");
ret.add(")");
return ret;
}).call(this);
}

regoBuiltins(sf_arithOp,"bitwise")
regoBuiltins(sf_arithOp,"logic")
regoBuiltins(sf_arithOp,"arith")
//
function sf_repeat(ast,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);

transpileAtoms(ast,env);
forlet(i(0,end,parseInt(ast[1]))((i < end),i((i+1))),((i !== 0) ?
ret.add(",") :
null),ret.add(ast[2]));
ret.prepend("[");
ret.add("]");
return ret;
}).call(this);
}

SPEC_OPS["repeat-n"] = sf_repeat
//
function transpileDo(ast,env) {
let G____5=Array.prototype.slice.call(arguments,2);
let G____6= G____5;
let return_QUERY;
return_QUERY=G____6[0];
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);

return_QUERY = std.maybe(return_QUERY,true);
let p,e,end;
p= pad(indent);
e= null;
end= (ast.length-1);

forlet(i(0)((i < end),i((i+1))),e = ast[i],ret.add([ p,transpileList(e,env),";\n" ]));
((end >= 0) ?
(function() {
e = transpile_STAR(ast[end],env);
return ((!return_QUERY) ?
ret.add([ p,e,";\n" ]) :
ret.add([ p,"return ",e,";\n" ]));
}).call(this) :
null);
return ret;
}).call(this);
}

//
function sf_do(ast,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);

let p;
p= pad(indent);

ret.add([p,"(function() {\n"].join(""));
ret.add(transpileDo(ast.slice(1),env));
ret.add([p,"}).call(this)"].join(""));
return ret;
}).call(this);
}

SPEC_OPS["do"] = sf_do
//
function sf_case(ast,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);

let tst,e,t,c,dft;
tst= ast[1];
e= null;
t= null;
c= null;
dft= null;

((!(0 === (ast.length%2))) ?
dft = ast.pop() :
null);
forlet(i(2)((i < ast.length),i((i+2))),c = ast[(i+1)],e = ast[i],(types.list_QUERY(e) ?
forlet(j(0)((j < e.length),i((null+1))),ret.add([ "case ",transpileSingle(e[j]),":\n" ]),((j === (e.length-1)) ?
ret.add([ "____x= ",transpile_STAR(c,env),";\nbreak;\n" ]) :
null)) :
(function() {
ret.add([ "case ",transpileSingle(e),":\n" ]);
return ret.add([ "____x= ",transpile_STAR(c,env),";\nbreak;\n" ]);
}).call(this)));
(dft ?
(function() {
ret.add("default:\n");
return ret.add([ "____x= ",transpile_STAR(dft,env),";\nbreak;\n" ]);
}).call(this) :
null);
ret.prepend([ "switch (",transpile_STAR(tst,env),") {\n" ]);
ret.add("}\n");
ret.prepend("(function() { let ____x;\n");
ret.add("return ____x;}).call(this)");
return ret;
}).call(this);
}

SPEC_OPS["case"] = sf_case
//
function sf_range(ast,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);

let len,start,step,end;
len= 0;
start= 0;
step= 1;
end= 0;

transpileAtoms(ast,env);
len = ast.length;
end = parseInt(ast[1]);
((len > 2) ?
(function() {
start = parseInt(ast[1]);
return end = parseInt(ast[2]);
}).call(this) :
null);
((len > 3) ?
step = parseInt(ast[3]) :
null);
forlet(i(start)((i < end),i((i+step))),((i !== start) ?
ret.add(",") :
null),ret.add(i.toString()));
ret.prepend("[");
ret.add("]");
return ret;
}).call(this);
}

SPEC_OPS["range"] = sf_range
//
function sf_vardefs(ast,env,cmd) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);

let kks,public_QUERY;
kks= {};
public_QUERY= ("global" == cmd);

((!("let" == cmd)) ?
cmd = "var" :
null);
forlet(i(1,s,null)((i < ast.length),i((i+1))),s = transpileSingle(ast[i]),ret.add([s,"=undefined"].join("")),kks[s] = null);
(function() {
let G__2;
G__2= ret;

G__2.join(",");
G__2.prepend([cmd," "].join(""));
G__2.add(";\n");
return G__2;
}).call(this);
((public_QUERY&&(1 === NSPACES.length)) ?
(function() {
let G__3;
G__3= kks;

return Object.entries(G__3).forEach(function (e) {
return (function (v,k) {
return EXTERNS[k] = k;
})(e[1],e[0]);
});
}).call(this) :
null);
return ret;
}).call(this);
}

SPEC_OPS["def~-"] = function (ast,env) {
return sf_vardefs(ast,env,"local");
}
SPEC_OPS["def~"] = function (ast,env) {
return sf_vardefs(ast,env,"global");
}
SPEC_OPS["var~"] = function (ast,env) {
return sf_vardefs(ast,env,"let");
}
//
function sf_var(ast,env,cmd) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);

let vname,keys,kks,public_QUERY;
vname= null;
keys= [];
kks= {};
public_QUERY= ("global" == cmd);

ast = ast.slice(1);
((public_QUERY||("local" == cmd)) ?
cmd = "var" :
null);
forlet(i(0)((i < ast.length),i((i+2))),(types.symbol_QUERY(ast[i]) ?
keys.push(ast[i]) :
null));
(std.not_empty(keys) ?
ret.add([ "let ",keys.map(function (s) {
let ss;
ss= transpileSingle(s);

kks[ss] = null;
return ss;
}).join(","),";\n" ]) :
null);
forlet(rc(null,i,0,lhs,null,rhs,null)((i < ast.length),i((i+2))),rhs = ast[(i+1)],lhs = ast[i],(types.symbol_QUERY(lhs) ?
ret.add([ transpileSingle(lhs),"= ",transpile_STAR(rhs,env),";\n" ]) :
(function() {
rc = destruct0(cmd,lhs,rhs,env);
ret.add(rc[0]);
return rc[1].map(function (s) {
return kks[rdr.jsid(s)] = null;
});
}).call(this)));
((public_QUERY&&(1 === NSPACES.length)) ?
(function() {
return   (function() {
let G__4;
G__4= kks;

return Object.entries(G__4).forEach(function (e) {
return (function (v,k) {
return EXTERNS[k] = k;
})(e[1],e[0]);
});
}).call(this);
}).call(this) :
null);
return ret;
}).call(this);
}

//
function sf_var_local(ast,env) {
return sf_var(ast,env,"local");
}

SPEC_OPS["def-"] = sf_var_local
//
function sf_var_global(ast,env) {
return sf_var(ast,env,"global");
}

SPEC_OPS["def"] = sf_var_global
//
function sf_var_let(ast,env) {
return sf_var(ast,env,"let");
}

SPEC_OPS["var"] = sf_var_let
//
function sf_inst_QUERY(ast,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);

ret.add([ "(",transpile_STAR(ast[2],env)," instanceof ",transpile_STAR(ast[1],env),")" ]);
return ret;
}).call(this);
}

SPEC_OPS["inst?"] = sf_inst_QUERY
//
function sf_delete(ast,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);

ret.add([ "delete ",transpile_STAR(ast[1],env) ]);
((ast.length > 2) ?
ret.add([ "[",transpile_STAR(ast[2]),"]" ]) :
null);
return ret;
}).call(this);
}

SPEC_OPS["delete!"] = sf_delete
//
function sf_new(ast,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);

ret.add(transpileList(ast.slice(1),env));
ret.prepend("new ");
return ret;
}).call(this);
}

SPEC_OPS["new"] = sf_new
//
function sf_throw(ast,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);

ret.add([ "throw ",transpile_STAR(ast[1],env),";" ]);
ret.prepend("(function (){ ");
ret.add(" }).call(this)");
return ret;
}).call(this);
}

SPEC_OPS["throw"] = sf_throw
//
function sf_x_opop(ast,env) {
transpileAtoms(ast,env);
return nodeTag(tn.tnodeEx([ ast[0],ast[1] ]),ast);
}

regoBuiltins(sf_x_opop,"incdec")
//
function sf_x_eq(ast,env) {
transpileAtoms(ast,env);
return nodeTag(tn.tnodeEx([ ast[1]," ",ast[0]," ",ast[2] ]));
}

regoBuiltins(sf_x_eq,"assign")
//
function sf_set(ast,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);

let e1;
e1= transpile_STAR(ast[1],env);

((4 === ast.length) ?
(function() {
let G__5;
G__5= ret;

G__5.add(e1);
G__5.add("[");
G__5.add(transpile_STAR(ast[2],env));
G__5.add("]");
return G__5;
}).call(this) :
ret.add(e1));
ret.add([ " = ",transpile_STAR(ast[(ast.length-1)],env) ]);
return ret;
}).call(this);
}

SPEC_OPS["aset"] = sf_set
SPEC_OPS["set!"] = sf_set
//
function parseFuncArgs(args) {
return (function() {
let ret;
ret= [];

forlet(i(0,e,null,ev,null)((i < args.length),i((i+1))),e = args[i],ev = e.value,(types.symbol_QUERY(e) ?
((ev === "_") ?
ret.push(types.symbol(gensym("_"))) :
((ev === "&") ?
(function() {
e = args[(i+1)];
(types.symbol_QUERY(e) ?
ret.push([ e,i,e ]) :
ret.push([ types.symbol(["&",gensym()].join("")),i,e ]));
return ++i;
}).call(this) :
(ev.startsWith("&") ?
(function() {
e = types.symbol(ev.slice(1));
return ret.push([ e,i,e ]);
}).call(this) :
(true ?
ret.push(e) :
null)))) :
(types.keyword_QUERY(e) ?
(function (){ throw new Error([ "bad function args destructure: ",types.obj_type(e) ].join("")); }).call(this) :
(Array.isArray(e) ?
ret.push([ types.symbol(gensym()),i,e ]) :
(true ?
(function (){ throw new Error([ "bad function args destructure: ",types.obj_type(e) ].join("")); }).call(this) :
null)))));
return ret;
}).call(this);
}

//
function handleFuncArgs(fargs,env) {
return (function() {
let out;
out= [];

let misc,keys,ret,knode;
misc= [];
keys= [];
ret= tn.tnode();
knode= tn.tnode();

fargs.forEach(function (arg) {
return (types.symbol_QUERY(arg) ?
keys.push(arg) :
((types.symbol_QUERY(arg[0])&&(!arg[0].toString().startsWith("&"))&&Array.isArray(arg[2])) ?
(function() {
keys.push(arg[0]);
return misc.push(arg);
}).call(this) :
(true ?
misc.push(arg) :
null)));
});
misc.forEach(function (arr) {
let a0,name,varg_QUERY,pos,a2;
a0= arr[0];
name= a0.toString();
varg_QUERY= name.startsWith("&");
pos= arr[1].toString();
a2= arr[2];

(varg_QUERY ?
name = name.slice(1) :
null);
name = rdr.jsid(name);
return ((types.symbol_QUERY(a0)&&types.symbol_QUERY(a2)) ?
ret.add([ "let ",name,"=Array.prototype.slice.call(arguments,",pos,");\n" ]) :
(Array.isArray(a2) ?
(function() {
(varg_QUERY ?
ret.add([ "let ",name,"=Array.prototype.slice.call(arguments,",pos,");\n" ]) :
null);
return ret.add(destruct0("let",a2,name,env)[0]);
}).call(this) :
null));
});
knode.add(keys.map(function () {
let ____args;
____args= Array.prototype.slice.call(arguments);

return rdr.jsid(____args[0].toString());
}).join(","));
out.push(knode);
out.push(ret);
return out;
}).call(this);
}

//
function sf_fn(ast,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);

let args,body,fargs;
args= ast[1];
body= ast.slice(2);
fargs= handleFuncArgs(parseFuncArgs(args),env);

ret.add("function (");
ret.add(fargs[0]);
ret.add([ ") {\n",fargs[1],transpileDo(body,env),pad(indent),"}" ]);
return ret;
}).call(this);
}

SPEC_OPS["fn"] = sf_fn
//
function sf_func(ast,env,public_QUERY) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);

let fname,fnameMeta,mtd_QUERY,dot_QUERY,fargs,e3,e2,doc,attrs,args,body;
fname= transpile_STAR(getMetaTarget(ast[1]),env);
fnameMeta= (getMeta(ast[1],env)||{});
mtd_QUERY= (ast[0] == "method");
dot_QUERY= fname.includes(".");
fargs= null;
e3= ast[3];
e2= ast[2];
doc= null;
attrs= null;
args= 2;
body= 3;

((typeof(e2) === "string") ?
(function() {
doc = 2;
args = 3;
return (types.map_QUERY(e3) ?
(function() {
attrs = 3;
return args = 4;
}).call(this) :
null);
}).call(this) :
(types.map_QUERY(e2) ?
(function() {
attrs = 2;
return args = 3;
}).call(this) :
null));
body = (args+1);
(doc ?
doc = ast[doc] :
null);
(attrs ?
attrs = ast[attrs] :
null);
args = ast[args];
fargs = handleFuncArgs(parseFuncArgs(args),env);
body = ast.slice(body);
(mtd_QUERY ?
(function() {
(fnameMeta.static ?
ret.add("static ") :
null);
return ret.add([ fname," (" ]);
}).call(this) :
(dot_QUERY ?
ret.add([ fname," = function (" ]) :
(true ?
ret.add(["function ",fname,"("].join("")) :
null)));
ret.add(fargs[0]);
ret.add([ ") {\n",fargs[1],transpileDo(body,env),pad(indent),"}\n" ]);
((false&&attrs) ?
(function() {
return null;
}).call(this) :
null);
(doc ?
(function() {
doc = doc.replace(rdr.REGEX.dquoteHat,"");
doc = doc.replace(rdr.REGEX.dquoteEnd,"");
return ret.prepend(doc.split("\\n").map(function () {
let ____args;
____args= Array.prototype.slice.call(arguments);

return ["//",____args[0],"\n"].join("");
}));
}).call(this) :
null);
((public_QUERY&&(!dot_QUERY)&&(1 === NSPACES.length)) ?
EXTERNS[fname] = fname :
null);
return ret;
}).call(this);
}

//
function sf_func_private(ast,env) {
return sf_func(ast,env,false);
}

SPEC_OPS["defn-"] = sf_func_private
//
function sf_func_public(ast,env) {
return sf_func(ast,env,true);
}

SPEC_OPS["defn"] = sf_func_public
//
function sf_try(ast,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);

let sz,t,f,c,ind;
sz= ast.length;
t= null;
f= null;
c= null;
ind= pad(indent);

f = std.last(ast);
((Array.isArray(f)&&("finally" == f[0])) ?
(function() {
f = ast.pop();
return sz = ast.length;
}).call(this) :
f = null);
c = null;
((sz > 1) ?
c = ast[(sz-1)] :
null);
((Array.isArray(c)&&("catch" == c[0])) ?
(function() {
(((c.length < 2)||(!types.symbol_QUERY(c[1]))) ?
syntax_BANG("e0",ast) :
null);
return c = ast.pop();
}).call(this) :
c = null);
(((f === null)&&(c === null)) ?
syntax_BANG("e0",ast) :
null);
ret.add([ ["(function() {\n",ind,"try {\n"].join(""),transpileDo(ast.slice(1),env),["\n",ind,"} "].join("") ]);
(c ?
(function() {
t = c[1];
return ret.add([ ["catch (",t,") {\n"].join(""),transpileDo(c.slice(2),env),[";\n",ind,"}\n"].join("") ]);
}).call(this) :
null);
(f ?
(function() {
return ret.add([ "finally {\n",transpileDo(f.slice(1),env,false),[";\n",ind,"}\n"].join("") ]);
}).call(this) :
null);
ret.add([ind,"}).call(this)"].join(""));
return ret;
}).call(this);
}

SPEC_OPS["try"] = sf_try
//
function sf_if(ast,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);

let a1,a2,a3;
a1= ast[1];
a2= ast[2];
a3= ((ast.length > 3) ?
ast[3] :
null);

indent += tabspace;
ret.add([ "(",transpile_STAR(a1,env),[" ?\n",pad(indent)].join(""),transpile_STAR(a2,env),[" :\n",pad(indent)].join(""),(transpile_STAR(a3,env)||"null"),")" ]);
indent -= tabspace;
return ret;
}).call(this);
}

SPEC_OPS["if"] = sf_if
//
function sf_nth(ast,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);

transpileAtoms(ast,env);
ret.add([ ast[1],"[",ast[2],"]" ]);
return ret;
}).call(this);
}

SPEC_OPS["nth"] = sf_nth
//
function sf_get(ast,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);

transpileAtoms(ast,env);
ret.add([ ast[1],"[",ast[2],"]" ]);
return ret;
}).call(this);
}

SPEC_OPS["aget"] = sf_get
SPEC_OPS["get"] = sf_get
//
function sf_str(ast,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);

let args;
args= ast.slice(1);

transpileAtoms(args,env);
((args.length > 1) ?
(function() {
let G__6;
G__6= ret;

G__6.add(args);
G__6.join(",");
G__6.prepend("[");
G__6.add("].join(\"\")");
return G__6;
}).call(this) :
((args.length > 0) ?
ret.add([ "",args[0],".toString()" ]) :
null));
return ret;
}).call(this);
}

SPEC_OPS["str"] = sf_str
//
function sf_array(ast,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);

let p,epilog;
p= pad(indent);
epilog= ["\n",p,"]"].join("");

(std.empty_QUERY(ast) ?
ret.add("[]") :
(function() {
((!types.vector_QUERY(ast)) ?
ast.splice(0,1) :
null);
indent += tabspace;
transpileAtoms(ast,env);
p = pad(indent);
ret.add(["[\n",p].join(""));
forlet(i(0)((i < ast.length),i((i+1))),((i > 0) ?
ret.add([",\n",p].join("")) :
null),ret.add(ast[i]));
ret.add(epilog);
return indent -= tabspace;
}).call(this));
return ret;
}).call(this);
}

SPEC_OPS["vec"] = sf_array
//
function sf_object(ast,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);

let p,epilog;
p= pad(indent);
epilog= ["\n",p,"}"].join("");

(std.empty_QUERY(ast) ?
ret.add("{}") :
(function() {
((!types.map_QUERY(ast)) ?
ast.splice(0,1) :
null);
indent += tabspace;
transpileAtoms(ast,env);
p = pad(indent);
ret.add(["{\n",p].join(""));
forlet(i(0)((i < ast.length),i((i+2))),((i > 0) ?
ret.add([",\n",p].join("")) :
null),ret.add([ ast[i],": ",ast[(i+1)] ]));
ret.add(epilog);
return indent -= tabspace;
}).call(this));
return ret;
}).call(this);
}

SPEC_OPS["hash-map"] = sf_object
let includeFile;
includeFile= (function () {
let icache;
icache= [];

return function (fname) {
return (std.contains_QUERY(icache,fname) ?
tn.tnode() :
(function() {
let src;
src= fs.readFileSync(fname,"utf-8");

icache.push(fname);
return transpileTree(psr.parser(src,fname),rt.globalEnv());
}).call(this));
};
})();

//
function sf_include(ast,env) {
let ret,fname,dir;
ret= [];
fname= null;
dir= path.dirname(ast.source);

forlet(i(1,e,null)((i < ast.length),i((i+1))),e = ast[i],(((!Array.isArray(e))||(1 !== e.length)) ?
syntax_BANG("e0",ast) :
null),fname = e[0],(fname ?
fname = fname.replace(/[\"]/g,"") :
null),(function() {
try {
return fname = fs.realpathSync([dir,"/",fname].join(""));

} catch (e) {
return syntax_BANG("e11",ast);

}
}).call(this),(function() {
try {
indent -= tabspace;
return ret.push(includeFile(fname));

} finally {
NSPACES.pop();
indent += tabspace;

}
}).call(this));
return (std.empty_QUERY(ret) ?
tn.tnode() :
ret);
}

//
function sf_require(ast,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);

let path=undefined,v=undefined,e=undefined,refers=undefined,renames=undefined;

let as;
as= gensym();

forlet(i(1)((i < ast.length),i((i+1))),e = ast[i],(((!Array.isArray(e))||(e.length < 3)) ?
syntax_BANG("e0",ast) :
null),path = e[0],forlet(j(1)((j < e.length),j((j+1))),v = e[j],((v == "as") ?
(function() {
as = e[(j+1)].toString();
return ++j;
}).call(this) :
((v == "refer") ?
(function() {
refers = e[(j+1)];
return ++j;
}).call(this) :
((v == "rename") ?
(function() {
renames = e[(j+1)];
return ++j;
}).call(this) :
null)))),ret.add([ "var ",rdr.jsid(as),"= require(",transpileSingle(path),");\n" ]),forlet(i(0)((refers&&(i < refers.length)),i((i+1))),v = transpileSingle(refers[i]),ret.add([ "var ",v,"=",as,"[\"",v,"\"];\n" ])),forlet(i(0)((renames&&(i < renames.length)),i((i+2))),e = transpileSingle(renames[i]),v = transpileSingle(renames[(i+1)]),ret.add([ "var ",v,"=",as,"[\"",e,"\"];\n" ])));
return ret;
}).call(this);
}

//
function sf_withMeta(ast,env) {
let target,v;
target= ast[1];
v= getMeta(ast,env);

target["____meta"] = v;
return transpile_STAR(target,env);
}

//
function getMetaTarget(ast) {
return ((Array.isArray(ast)&&("with-meta" == ast[0])) ?
ast[1] :
ast);
}

//
function getMeta(ast,env) {
return ((Array.isArray(ast)&&("with-meta" == ast[0])) ?
(function() {
let r,v,mv;
r= null;
v= null;
mv= ast[2];

return (Array.isArray(mv) ?
JSON.parse(["",transpile_STAR(mv,env)].join("")) :
(types.keyword_QUERY(mv) ?
(function() {
r = [ mv,true ];
r["____map"] = true;
return JSON.parse(["",transpile_STAR(r,env)].join(""));
}).call(this) :
(types.symbol_QUERY(mv) ?
(function() {
r = [ types.symbol("tag"),mv ];
r["____map"] = true;
return JSON.parse(["",transpile_STAR(r,env)].join(""));
}).call(this) :
(true ?
(function (){ throw new Error([ "Bad meta value",types.pr_obj(mv) ].join("")); }).call(this) :
null))));
}).call(this) :
{  });
}

//
function sf_ns(ast,env) {
return (function() {
let ret;
ret= [];

forlet(i(1,e,null,nsp,null)((i < ast.length),i((i+1))),e = ast[i],(types.symbol_QUERY(e) ?
(nsp ?
syntax_BANG("e0",ast) :
NSPACES.push(e.toString())) :
((types.list_QUERY(e)&&("with-meta" == e[0])&&types.symbol_QUERY(e[1])) ?
(nsp ?
syntax_BANG("e0",ast) :
NSPACES.push(e[1].toString())) :
((types.list_QUERY(e)&&("include" == e[0])) ?
ret.push(sf_include(e)) :
((types.list_QUERY(e)&&("require" == e[0])) ?
ret.push(sf_require(e)) :
null)))));
return ret;
}).call(this);
}

SPEC_OPS["ns"] = sf_ns
//
function sf_comment(ast,env) {
return nodeTag(tn.tnode(),ast);
}

SPEC_OPS["comment"] = sf_comment
//
function sf_for(ast,env) {
return (function() {
let ret;
ret= nodeTag(tnode(),ast);

let body;
body= ast.slice(2);

(not_empty(body) ?
sf_floop(ret,ast[1],body,env) :
null);
return ret;
}).call(this);
}

//
function sf_floop(ret,args,body,env) {
let vars,recurs;
vars= [];
recurs= [];

let tst=undefined,nb=undefined;

(function() {
for (let i=0,e=null,____break=false; ((!____break)&&(i < args.length)); i=(i+1)){
e = args[i];
((e == "while") ?
(function() {
tst = args[(i+1)];
return ++i;
}).call(this) :
((e == "recur") ?
(function() {
recurs = args.slice((i+1));
return i = a1.length;
}).call(this) :
(types.symbol_QUERY(e) ?
(function() {
vars.push(e,args[(i+1)]);
return ++i;
}).call(this) :
null)));
}
})(this);

ret.add("for (");
(function() {
for (let i=0,____break=false; ((!____break)&&(i < vars.length)); i=(i+2)){
((i === 0) ?
ret.add("let ") :
null);
((i !== 0) ?
ret.add(",") :
null);
ret.add([ transpileSingle(vars[i]),"=",transpile_STAR(vars[(i+1)],env) ]);
}
})(this);

(not_empty(vars) ?
ret.add(",____break=false") :
ret.add("let ____break=false"));
ret.add("; ");
nb = [ types.symbol("not"),types.symbol("____break") ];
(tst ?
tst = [ types.symbol("and"),nb,tst ] :
tst = nb);
ret.add(transpile_STAR(tst,env));
ret.add("; ");
(function() {
for (let i=0,k=0,____break=false; ((!____break)&&(i < recurs.length)); i=(i+1),k=(k+2)){
((i !== 0) ?
ret.add(",") :
null);
ret.add([ transpileSingle(vars[k]),"=",transpile_STAR(recurs[i],env) ]);
}
})(this);

return (function() {
let G__7;
G__7= ret;

G__7.add("){\n");
G__7.add(transpileDo(body,env,false));
G__7.add("}\n");
G__7.prepend("(function() {\n");
G__7.add("})(this);\n");
return G__7;
}).call(this);
}

SPEC_OPS["for"] = sf_for
//
function sf_jscode(ast,env) {
return nodeTag(tn.tnodeEx(ast[1].toString().replace(rdr.REGEX.dquoteHat,"").replace(rdr.REGEX.dquoteEnd,"")),ast);
}

SPEC_OPS["js#"] = sf_jscode
//
function sf_macro(ast,env) {
let pms,args,body;
pms= types.vector();
args= ast[2];
body= ast.slice(3);

((typeof(args) === "string") ?
(function() {
doc = args;
args = ast[3];
return body = ast.slice(4);
}).call(this) :
null);
forlet(i(0,e,null,ev,null)((i < args.length),i((i+1))),e = args[i],ev = e.value,((ev === "&") ?
(Array.isArray(args[(i+1)]) ?
(function() {
e = args[(i+1)];
++i;
return forlet(j(0,x,null)((j < e.length),j((j+1))),x = e[j],((!types.symbol_QUERY(x)) ?
(function (){ throw new Error([ "Bad optional arg for macro" ].join("")); }).call(this) :
null),pms.push(x));
}).call(this) :
(function() {
pms.push(e,args[(i+1)]);
return ++i;
}).call(this)) :
((!types.symbol_QUERY(e)) ?
(function (){ throw new Error([ "Bad optional arg for macro" ].join("")); }).call(this) :
(true ?
pms.push(e) :
null))));
ast = [ ast[0],ast[1],[ types.symbol("fn*"),pms ].concat(body) ];
let a2,a1,func;
a2= ast[2];
a1= ast[1].toString();
func= rt.compute(a2,env);

func["____macro"] = true;
(doc ?
func["____doc"] = doc :
null);
macros.set(a1,func);
return nodeTag(tn.tnode(),ast);
}

SPEC_OPS["defmacro"] = sf_macro
//
function sf_unary(ast,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);

let G____7= ast;
let a0,a1;
a0=G____7[0];
a1=G____7[1];

((a0 == "not") ?
a0 = types.symbol("!") :
null);
ret.add([ "(",transpile_STAR(a0,env),transpile_STAR(a1,env),")" ]);
return ret;
}).call(this);
}

regoBuiltins(sf_unary,"unary")
//
function sf_doseq(ast,env) {
return (function() {
let ret;
ret= nodeTag(tn.tnode(),ast);

let args,body,loopvar,loopexpr,escvar,idxvar,exprvar;
args= ast[1];
body= ast.slice(2);
loopvar= args[0];
loopexpr= args[1];
escvar= gensym();
idxvar= gensym();
exprvar= gensym();

ret.add([ "let ",transpileSingle(loopvar),"= ",exprvar,"[",idxvar,"];\n" ]);
forlet(i(2,v,null,ev,null)((i < args.length),i((i+1))),v = args[i],ev = v.value,((ev === "while") ?
ret.add([ "if (! ",transpile_STAR(args[(i+1)],env),") {",escvar,"=true;}\n" ]) :
((ev === "when") ?
(function() {
let G__8;
G__8= ret;

G__8.add([ "if (!",escvar,") {\n" ]);
G__8.add([ "if (! ",transpile_STAR(args[(i+1)],env),") {continue;}\n" ]);
G__8.add("}\n");
return G__8;
}).call(this) :
((ev === "let") ?
ret.add(sf_var_let([ types.symbol("var") ].concat(args[(i+1)]),env)) :
null))));
ret.add([ "if (!",escvar,") {\n" ]);
ret.add(transpileDo(body,env,false));
ret.add("}\n");
ret.add("}\n");
ret.prepend([ "for(var ",escvar,"=false,",idxvar,"=0; ","(!",escvar," && ",idxvar," < ",exprvar,".length); ++",idxvar,") {\n" ]);
ret.prepend([ "let ",exprvar,"= ",transpile_STAR(loopexpr,env),";\n" ]);
ret.prepend("(function() {\n");
ret.add("})(this);\n");
return ret;
}).call(this);
}

SPEC_OPS["doseq"] = sf_doseq
//
function spitExterns() {
return (function() {
let s;
s= "";

let ks,p;
ks= Object.keys(EXTERNS);
p= pad(tabspace);

((ks.length > 0) ?
(function() {
s = ks.map(function () {
let ____args;
____args= Array.prototype.slice.call(arguments);

return [p,____args[0],": ",____args[0]].join("");
}).join(",\n");
return s = ["\n\nmodule.exports = {\n",s,"\n};\n\n"].join("");
}).call(this) :
null);
return s;
}).call(this);
}

//
function banner() {
return ["/*","Auto generated by Kirby - v",MODULE_VERSION," ",NSPACES[0]," - ",new Date(),"*/\n\n"].join("");
}

//
function cleanCode(code) {
let arr;
arr= [];

code.split("\n").forEach(function (s) {
s = s.trim();
return ((s !== ";") ?
arr.push(s) :
null);
});
return arr.join("\n");
}

//
function transpileCode(codeStr,fname,srcMap_QUERY) {
indent = (-tabspace);
EXTERNS = {};
NSPACES = [];
let outNode,options,cstr,extra;
outNode= transpileTree(psr.parser(codeStr,fname),rt.globalEnv());
options= {};
cstr= "";
extra= spitExterns();

outNode.prepend(banner());
cstr = (srcMap_QUERY ?
(function() {
let outFile,srcMap,output;
outFile= [path.basename(fname,".ky"),".js"].join("");
srcMap= [outFile,".map"].join("");
output= outNode.toStringWithSourceMap({ "file": outFile });

fs.writeFileSync(srcMap,output.map);
return [output.code,extra,"\n//# sourceMappingURL=",path.relative(path.dirname(fname),srcMap)].join("");
}).call(this) :
[outNode,extra].join(""));
cstr = cleanCode(cstr);
return (true ?
esfmt.format(cstr,options) :
cstr);
}

//
function transpileXXX(code,file,smap_QUERY) {
return (function() {
try {
return transpileCode(code,file,smap_QUERY);

} catch (e) {
return (e ?
(function() {
(console ?
console.log([ e.stack ].join("")) :
null);
return (function (){ throw e; }).call(this);
}).call(this) :
null);

}
}).call(this);
}

//
function transpileWithSrcMap(code,file) {
return transpileXXX(code,file,true);
}

//
function transpile(code,file) {
return transpileXXX(code,file,false);
}

//
function parseWithSourceMap(codeStr,fname) {
let outNode;
outNode= transpileTree(psr.parser(codeStr,fname));

outNode.prepend(banner());
return outNode.toStringWithSourceMap();
}

let version;
version= MODULE_VERSION;



module.exports = {
transpileWithSrcMap: transpileWithSrcMap,
transpile: transpile,
parseWithSourceMap: parseWithSourceMap,
version: version
};

