/*Auto generated by Kirby - v1.0.0 czlab.kirby.cg.transpiler Tue Nov 07 2017 23:02:50 GMT-0800 (PST)*/

var std = require("../bl/stdlib");
var rdr = require("../bl/lexer");
var tnode = rdr["tnode"];
var tnodeEx = rdr["tnodeEx"];
var psr = require("../bl/parser");
var rt = require("../rt/runtime");
var fs = require("fs");
var path = require("path");
var esfmt = require("esformatter");
var kirbystdlibref = std;

let gensym_DASH_counter;
gensym_DASH_counter = 1;

let ERRORS_DASH_MAP;
ERRORS_DASH_MAP = {
  "e0": "Syntax Error",
  "e1": "Empty statement",
  "e2": "Invalid characters in function name",
  "e3": "End of File encountered, unterminated string",
  "e4": "Closing square bracket, without an opening square bracket",
  "e5": "End of File encountered, unterminated array",
  "e6": "Closing curly brace, without an opening curly brace",
  "e7": "End of File encountered, unterminated javascript object '}'",
  "e8": "End of File encountered, unterminated parenthesis",
  "e9": "Invalid character in var name",
  "e10": "Extra chars at end of file. Maybe an extra ')'.",
  "e11": "Cannot Open include File",
  "e12": "Invalid no of arguments to ",
  "e13": "Invalid Argument type to ",
  "e14": "End of File encountered, unterminated regular expression",
  "e15": "Invalid vararg position, must be last argument.",
  "e16": "Invalid arity (args > expected) to ",
  "e17": "Invalid arity (args < expected) to "
};

let MODULE_VERSION,
  EXTERNS,
  SPEC_DASH_OPS;
MODULE_VERSION = "1.0.0";
EXTERNS = null;
SPEC_DASH_OPS = {};

//
function gensym() {
  let G____8 = Array.prototype.slice.call(arguments, 0);
  let G____9 = G____8;
  let pfx;
  pfx = G____9[0];
  let x;
  x = gensym_DASH_counter;
  ++gensym_DASH_counter;
  return [std.opt(pfx, "G____"), x].join("");
}

//
function error_BANG(e) {
  let G____10 = Array.prototype.slice.call(arguments, 1);
  let G____11 = G____10;
  let line,
    file,
    msg;
  line = G____11[0];
  file = G____11[1];
  msg = G____11[2];
  return (function() {
    throw new Error([ERRORS_DASH_MAP[e],(msg ?
      [" : ", msg].join("") :
      null),(line ?
      ["\nLine no ", line].join("") :
      null),(file ?
      ["\nFile ", file].join("") :
      null)].join("")) ;
  }).call(this);
}

//
function syntax_BANG(ecode) {
  let G____12 = Array.prototype.slice.call(arguments, 1);
  let G____13 = G____12;
  let ast,
    cmd;
  ast = G____13[0];
  cmd = G____13[1];
  return error_BANG(ecode, (ast ?
    ast.line :
    0), (ast ?
    ast.source :
    0), cmd);
}

//
function pad(z) {
  return " ".repeat(z);
}

//
function testre_QUERY(re, x) {
  return (x ?
    re.test(x) :
    false);
}

//
function nodeTag(obj, src) {
  if ( (obj && src && (!(typeof (obj) === "boolean")) && (!(typeof (obj) === "number"))) ) {
    {
      obj.source = src.source;
      obj.column = src.column;
      obj.line = src.line;
    }
  }
  return obj;
}

//
function destructVec(lhs, keys) {
  let as;
  as = null;
  for (let i = 0, e = null, ev = null, ____break = false; ((!____break) && (i < lhs.length)); i = (i + 1)) {
    (e = lhs[i], ev = e.toString());
    if (std.symbol_QUERY(e)) {
      if ( (ev === "_") ) {
        null;
      } else {
        if ( (ev === "&") ) {
          {
            keys[["&", lhs[(i + 1)]].join("")] = i;
            ++i;
          }
        } else {
          if (ev.startsWith("&")) {
            keys[ev] = i;
          } else {
            if (true) {
              keys[ev] = i;
            }
          }
        }
      }
    } else {
      if (std.keyword_QUERY(e)) {
        if ( (ev === "as") ) {
          {
            ++i;
            as = lhs[i].toString();
          }
        } else {
          throw new Error(["bad keyword: :", ev].join(""));
        }
      } else {
        null;
      }
    }
  }
  return as;
}

//
function destructMap(lhs, keys) {
  let as;
  as = null;
  for (let i = 0, e = null, ev = null, ____break = false; ((!____break) && (i < lhs.length)); i = (i + 1)) {
    (e = lhs[i], ev = e.toString());
    if (std.keyword_QUERY(e)) {
      if ( ((ev === "keys") || (ev === "strs")) ) {
        {
          let ks;
          ks = lhs[(i + 1)];
          ++i;
          for (let j = 0, ____break = false; ((!____break) && (j < ks.length)); j = (j + 1)) {
            keys[ks[j].toString()] = null;
          }
        }
      } else {
        if ( (ev === "as") ) {
          {
            ++i;
            as = lhs[i].toString();
          }
        } else {
          null;
        }
      }
    } else {
      throw new Error(["bad destruct field: ", std.typeid(e)].join(""));
    }
  }
  return as;
}

//
function destruct1(lhs) {
  let as,
    out,
    keys;
  as = null;
  out = [];
  keys = {};
  if (std.vector_QUERY(lhs)) {
    as = destructVec(lhs, keys);
  } else {
    if (std.map_QUERY(lhs)) {
      as = destructMap(lhs, keys);
    } else {
      if (std.symbol_QUERY(lhs)) {
        keys[lhs.toString()] = null;
      } else {
        if (true) {
          throw new Error(["cant destruct with: ", std.typeid(lhs)].join(""));
        }
      }
    }
  }
  return [as, keys];
}

//
function destruct0(cmd, lhs, rhs, env) {
  let kdefs,
    ka,
    kvals;
  let G____14 = destruct1(lhs);
  let as,
    keys;
  as = G____14[0];
  keys = G____14[1];
  kdefs = [];
  ka = null;
  kvals = tnode();
  if ( (0 === kirbystdlibref.count(as)) ) {
    as = gensym();
  }
  as = rdr.jsid(as);
  {
    let G__1;
    G__1 = keys;
    Object.entries(G__1).forEach(function(e) {
      return (function(v, k) {
        let rest_QUERY;
        rest_QUERY = false;
        if (k.startsWith("&")) {
          {
            (rest_QUERY = true, k = k.slice(1));
          }
        }
        k = rdr.jsid(k);
        std.conj_BANG(kdefs, k);
        return kvals.add([((v === null) ?
          ["[\"", k, "\"];\n"].join("") :
          (rest_QUERY ?
            [".slice(", v, ");\n"].join("") :
            (true ?
              ["[", v, "];\n"].join("") :
              null))), k, "=", as].join(""));
      })(e[1], e[0]);
    });
  }
  kvals.prepend([cmd, " ", kdefs.join(","), ";\n"].join(""));
  return [[tnodeEx([cmd, " ", rdr.jsid(as), "= ", transpile_STAR(rhs, env), ";\n"]), kvals], kdefs];
}

//
function transpileTree(root, env) {
  let ret;
  ret = nodeTag(tnode(), root);
  let treeSize,
    endx;
  treeSize = root.length;
  endx = (root.length - 1);
  root.forEach(function(ast) {
    let tmp;
    tmp = ast;
    if (Array.isArray(ast)) {
      tmp = transpileList(ast, env);
    }
    return (tmp ?
      (function() {
        return ret.add([tmp, "\n"]);
      }).call(this) :
      null);
  });
  return ret;
}

//
function transpileAtoms(atoms, env) {
  return atoms.forEach(function(a, i, arr) {
    return arr[i] = transpile_STAR(a, env);
  });
}

//
function transpileSingle(a) {
  return (std.lambda_DASH_arg_QUERY(a) ?
    ["____args[", a.toString(), "]"].join("") :
    (std.keyword_QUERY(a) ?
      ["\"", a.toString(), "\""].join("") :
      (std.symbol_QUERY(a) ?
        rdr.jsid(a.toString()) :
        ((typeof (a) === "string") ?
          a :
          ((a === null) ?
            "null" :
            (true ?
              ["", a].join("") :
              null))))));
}

//
function transpile_STAR(x, env) {
  return (Array.isArray(x) ?
    transpileList(x, env) :
    transpileSingle(x));
}

//
function findCmd(ast) {
  let cmd;
  cmd = "";
  if (std.vector_QUERY(ast)) {
    cmd = "vec";
  } else {
    if (std.map_QUERY(ast)) {
      cmd = "hashmap";
    } else {
      if (std.list_QUERY(ast)) {
        cmd = ast[0].toString();
      } else {
        null;
      }
    }
  }
  return cmd;
}

//
function quoteSingle(a) {
  return (std.keyword_QUERY(a) ?
    ["\"", a, "\""].join("") :
    (std.symbol_QUERY(a) ?
      rdr.jsid(a.toString()) :
      ((typeof (a) === "string") ?
        a :
        ((a === null) ?
          "null" :
          (true ?
            a.toString() :
            null)))));
}

function quote_BANG(a, env) {
  return (Array.isArray(a) ?
    (std.map_QUERY(a) ?
      quoteMap(a, env) :
      quoteBlock(a, env)) :
    quoteSingle(a));
}

//
function quoteMap(a, env) {
  let ret;
  ret = tnode();
  for (let i = 0, ____break = false; ((!____break) && (i < a.length)); i = (i + 2)) {
    if ( (i > 0) ) {
      ret.add(",");
    }
    ret.add([quote_BANG(a[i], env), " : ", quote_BANG(a[(i + 1)], env)]);
  }
  ret.prepend("{");
  ret.add("}");
  return ret;
}

//
function quoteBlock(a, env) {
  let ret;
  ret = tnode();
  for (let i = 0, ____break = false; ((!____break) && (i < a.length)); i = (i + 1)) {
    if ( (i > 0) ) {
      ret.add(",");
    }
    ret.add(quote_BANG(a[i], env));
  }
  ret.prepend("[");
  ret.add("]");
  return ret;
}

//
function sf_DASH_quote(ast, env) {
  let ret;
  ret = nodeTag(tnode(), ast);
  ret.add(quote_BANG(ast[1], env));
  return ret;
}
SPEC_DASH_OPS["quote"] = sf_DASH_quote;

//
function transpileList(ast, env) {
  let cmd,
    mc,
    tmp;
  cmd = findCmd(ast);
  mc = rt.getMacro(cmd);
  tmp = null;
  let ret;
  ret = tnode();
  if (mc) {
    {
      ast = rt.expandMacro(ast, env, mc);
      cmd = findCmd(ast);
    }
  }
  if (cmd.startsWith(".-")) {
    ret.add([transpile_STAR(ast[1], env), ".", transpileSingle(std.symbol(cmd.slice(2)))]);
  } else {
    if ( ("." === cmd.charAt(0)) ) {
      {
        ret.add(transpile_STAR(ast[1], env));
        ret.add([cmd, "("]);
        for (let n = 2, ____break = false; ((!____break) && (n < ast.length)); n = (n + 1)) {
          if ( (n !== 2) ) {
            ret.add(",");
          }
          ret.add(transpile_STAR(ast[n], env));
        }
        ret.add(")");
      }
    } else {
      if (std.contains_QUERY(SPEC_DASH_OPS, cmd)) {
        ret = SPEC_DASH_OPS[cmd](ast, env);
      } else {
        if (rdr.REGEX.int.test(cmd)) {
          {
            let c0;
            c0 = cmd.charAt(0);
            if ( ((c0 !== "-") && (c0 !== "+")) ) {
              cmd = ["+", cmd].join("");
            }
            ast = [std.symbol(cmd.charAt(0)), ast[1], parseInt(cmd.slice(1))];
            cmd = ast[0].toString();
            ret = SPEC_DASH_OPS[cmd](ast, env);
          }
        } else {
          if (true) {
            {
              if (std.list_QUERY(ast)) {
                {
                  transpileAtoms(ast, env);
                  cmd = ast[0];
                }
              } else {
                cmd = transpileSingle(ast);
              }
              if ( (!cmd) ) {
                syntax_BANG("e1", ast);
              }
              cmd = maybeStripStdlib(cmd);
              if (std.list_QUERY(ast)) {
                {
                  if (testre_QUERY(rdr.REGEX.func, cmd)) {
                    cmd = tnodeEx(["(", cmd, ")"]);
                  }
                  ret.add([cmd, "(", tnodeEx(ast.slice(1)).join(","), ")"]);
                }
              } else {
                ret.add(cmd);
              }
            }
          }
        }
      }
    }
  }
  ret = nodeTag(ret, ast);
  return ret;
}

//
function sf_DASH_deftype(ast, env, public_QUERY) {
  let ret;
  ret = nodeTag(tnode(), ast);
  let cz,
    par,
    args,
    mtds;
  cz = transpile_STAR(ast[1], env);
  par = ast[2][0];
  args = ast[3];
  mtds = ast.slice(4);
  ret.add(["class ", cz]);
  if (par) {
    ret.add([" extends ", transpile_STAR(par, env)]);
  }
  ret.add(" {\n");
  for (let i = 0, n = null, m = null, ____break = false; ((!____break) && (i < mtds.length)); i = (i + 1)) {
    m = mtds[i];
    m.unshift(std.symbol("method"));
    ret.add(sf_DASH_func(m, env, false));
    ret.add("\n");
  }
  ret.add("}\n");
  if ( (public_QUERY && (1 === rt.globalEnv().countNSPCache())) ) {
    EXTERNS[cz] = cz;
  }
  return ret;
}

//
function prv_DASH_deftype(a, e) {
  return sf_DASH_deftype(a, e, false);
}
SPEC_DASH_OPS["deftype-"] = prv_DASH_deftype;

//
function pub_DASH_deftype(a, e) {
  return sf_DASH_deftype(a, e, true);
}
SPEC_DASH_OPS["deftype"] = pub_DASH_deftype;

let _lambdaFuncCount;
_lambdaFuncCount = 0;

//
function sf_DASH_lambda(ast, env) {
  if ( (0 !== _lambdaFuncCount) ) {
    throw new Error("Can't nest lambdas");
  } else {
    ++_lambdaFuncCount;
  }
  let x,
    body;
  x = [std.symbol("fn"), [], [std.symbol("var"), std.symbol("____args"), [std.symbol("slice"), std.symbol("arguments")]]];
  body = ast[1];
  if ( (0 === body.length) ) {
    body = [null];
  }
  if ( (!((1 === body.length) && std.value_QUERY(body[0]))) ) {
    body = ast.slice(1);
  }
  x = x.concat(body);
  return (function() {
    try {
      sf_DASH_fn(x, env);

    } finally {
      --_lambdaFuncCount;
    }
  }).call(this);
}
SPEC_DASH_OPS["lambda"] = sf_DASH_lambda;

//
function sf_DASH_apply(ast, env) {
  let args,
    f,
    ret;
  args = ast.slice(2);
  f = ast[1];
  ret = nodeTag(tnode(), ast);
  for (let i = 0, ____break = false; ((!____break) && (i < args.length)); i = (i + 1)) {
    ret.add(transpile_STAR(args[i], env));
  }
  if ( (args.length > 1) ) {
    ret.join(",");
  }
  return (function() {
    let G__2;
    G__2 = ret;
    G__2.prepend("[");
    G__2.add("]");
    G__2.prepend([transpile_STAR(f, env), ".apply(this,"]);
    G__2.add(")");
    return G__2;
  }).call(this);
}
SPEC_DASH_OPS["apply"] = sf_DASH_apply;

//
function sf_DASH_compOp(ast, env) {
  let cmd;
  cmd = ast[0];
  if ( ((cmd == "not=") || (cmd == "!=")) ) {
    ast[0] = std.symbol("!==");
  }
  if ( (cmd == "=") ) {
    ast[0] = std.symbol("===");
  }
  let ret;
  ret = nodeTag(tnode(), ast);
  transpileAtoms(ast, env);
  for (let i = 0, op = ast.shift(), ____break = false; ((!____break) && (i < (ast.length - 1))); i = (i + 1)) {
    ret.add(tnodeEx([ast[i], " ", op, " ", ast[(i + 1)]]));
  }
  ret.join(" && ");
  ret.prepend("(");
  ret.add(")");
  return ret;
}
SPEC_DASH_OPS["not="] = sf_DASH_compOp;
SPEC_DASH_OPS["!="] = sf_DASH_compOp;
SPEC_DASH_OPS["=="] = sf_DASH_compOp;
SPEC_DASH_OPS["="] = sf_DASH_compOp;
SPEC_DASH_OPS[">"] = sf_DASH_compOp;
SPEC_DASH_OPS[">="] = sf_DASH_compOp;
SPEC_DASH_OPS["<"] = sf_DASH_compOp;
SPEC_DASH_OPS["<="] = sf_DASH_compOp;

//
function sf_DASH_arithOp(ast, env) {
  let ret;
  ret = nodeTag(tnode(), ast);
  transpileAtoms(ast, env);
  let op,
    e1,
    cmd;
  op = tnode();
  e1 = ast.shift();
  cmd = e1.toString();
  if ( (cmd == "mod") ) {
    cmd = "%";
  }
  if ( (cmd == "div") ) {
    cmd = "/";
  }
  if ( (1 === ast.length) ) {
    if ( ("-" == cmd) ) {
      ret.add("-");
    }
  } else {
    op.add(["", cmd, ""]);
  }
  ret.add(ast);
  if ( (ast.length > 1) ) {
    ret.join(op);
  }
  ret.prepend("(");
  ret.add(")");
  return ret;
}
SPEC_DASH_OPS["+"] = sf_DASH_arithOp;
SPEC_DASH_OPS["-"] = sf_DASH_arithOp;
SPEC_DASH_OPS["*"] = sf_DASH_arithOp;
SPEC_DASH_OPS["div"] = sf_DASH_arithOp;
SPEC_DASH_OPS["%"] = sf_DASH_arithOp;
SPEC_DASH_OPS["mod"] = sf_DASH_arithOp;
SPEC_DASH_OPS["||"] = sf_DASH_arithOp;
SPEC_DASH_OPS["&&"] = sf_DASH_arithOp;
SPEC_DASH_OPS["^"] = sf_DASH_arithOp;
SPEC_DASH_OPS["&"] = sf_DASH_arithOp;
SPEC_DASH_OPS["|"] = sf_DASH_arithOp;
SPEC_DASH_OPS["<<"] = sf_DASH_arithOp;
SPEC_DASH_OPS[">>"] = sf_DASH_arithOp;
SPEC_DASH_OPS[">>>"] = sf_DASH_arithOp;

//
function sf_DASH_repeat(ast, env) {
  let ret;
  ret = nodeTag(tnode(), ast);
  transpileAtoms(ast, env);
  for (let i = 0, end = parseInt(ast[1]), ____break = false; ((!____break) && (i < end)); i = (i + 1)) {
    if ( (i !== 0) ) {
      ret.add(",");
    }
    ret.add(ast[2]);
  }
  ret.prepend("[");
  ret.add("]");
  return ret;
}
SPEC_DASH_OPS["repeat-n"] = sf_DASH_repeat;

//
function transpileDo(ast, env) {
  let G____15 = Array.prototype.slice.call(arguments, 2);
  let G____16 = G____15;
  let return_QUERY;
  return_QUERY = G____16[0];
  return_QUERY = std.opt(return_QUERY, true);
  let ret,
    e,
    end;
  ret = nodeTag(tnode(), ast);
  e = null;
  end = (ast.length - 1);
  for (let i = 0, ____break = false; ((!____break) && (i < end)); i = (i + 1)) {
    e = ast[i];
    e["____expr"] = false;
    ret.add([transpileList(e, env), ";\n"]);
  }
  return ((end >= 0) ?
    (function() {
      e = transpile_STAR(ast[end], env);
      return ((!return_QUERY) ?
        ret.add([e, ";\n"]) :
        ret.add(["return ", e, ";\n"]));
    }).call(this) :
    null);
}

//
function sf_DASH_do(ast, env) {
  let ret,
    stmt_QUERY;
  ret = nodeTag(tnode(), ast);
  stmt_QUERY = (false === ast.____expr);
  ret.add(transpileDo(ast.slice(1), env, (!stmt_QUERY)));
  if ( (!stmt_QUERY) ) {
    ret.prepend("{\n");
  } else {
    ret.prepend("(function() {\n");
  }
  if ( (!stmt_QUERY) ) {
    ret.add("}");
  } else {
    ret.add("}).call(this)");
  }
  return ret;
}
SPEC_DASH_OPS["do"] = sf_DASH_do;

//
function sf_DASH_case(ast, env) {
  let ret;
  ret = nodeTag(tnode(), ast);
  let tst,
    _x,
    e,
    t,
    c,
    dft;
  tst = ast[1];
  _x = gensym();
  e = null;
  t = null;
  c = null;
  dft = null;
  if ( (!(0 === (ast.length % 2))) ) {
    dft = ast.pop();
  }
  for (let i = 2, ____break = false; ((!____break) && (i < ast.length)); i = (i + 2)) {
    (c = ast[(i + 1)], e = ast[i]);
    if (std.list_QUERY(e)) {
      for (let j = 0, ____break = false; ((!____break) && (j < e.length)); j = (i + 1)) {
        ret.add(["case ", transpileSingle(e[j]), ":\n"]);
        if ( (j === (e.length - 1)) ) {
          ret.add([_x, "=", transpile_STAR(c, env), ";\nbreak;\n"]);
        }
      }
    } else {
      {
        ret.add(["case ", transpileSingle(e), ":\n"]);
        ret.add([_x, "=", transpile_STAR(c, env), ";\nbreak;\n"]);
      }
    }
  }
  if (dft) {
    {
      ret.add("default:\n");
      ret.add([_x, "=", transpile_STAR(dft, env), ";\nbreak;\n"]);
    }
  }
  ret.prepend(["switch (", transpile_STAR(tst, env), ") {\n"]);
  ret.add("}\n");
  ret.prepend(["(function() { let ", _x, ";\n"]);
  ret.add(["return ", _x, ";}).call(this)"]);
  return ret;
}
SPEC_DASH_OPS["case"] = sf_DASH_case;

//
function sf_DASH_range(ast, env) {
  let ret;
  ret = nodeTag(tnode(), ast);
  let len,
    start,
    step,
    end;
  len = 0;
  start = 0;
  step = 1;
  end = 0;
  transpileAtoms(ast, env);
  len = ast.length;
  end = parseInt(ast[1]);
  if ( (len > 2) ) {
    {
      start = parseInt(ast[1]);
      end = parseInt(ast[2]);
    }
  }
  if ( (len > 3) ) {
    step = parseInt(ast[3]);
  }
  for (let i = start, ____break = false; ((!____break) && (i < end)); i = (i + step)) {
    if ( (i !== start) ) {
      ret.add(",");
    }
    ret.add(i.toString());
  }
  ret.prepend("[");
  ret.add("]");
  return ret;
}
SPEC_DASH_OPS["range"] = sf_DASH_range;

//
function sf_DASH_vardefs(ast, env, cmd) {
  let ret;
  ret = nodeTag(tnode(), ast);
  let kks,
    public_QUERY;
  kks = {};
  public_QUERY = ("global" == cmd);
  if ( (!("let" == cmd)) ) {
    cmd = "var";
  }
  for (let i = 1, s = null, ____break = false; ((!____break) && (i < ast.length)); i = (1 + i)) {
    s = transpileSingle(ast[i]);
    ret.add([s, "=undefined"].join(""));
    kks[s] = null;
  }
  {
    let G__3;
    G__3 = ret;
    G__3.join(",");
    G__3.prepend([cmd, " "].join(""));
    G__3.add(";\n");
    G__3;
  }
  if ( (public_QUERY && (1 === rt.globalEnv().countNSPCache())) ) {
    {
      let G__4;
      G__4 = kks;
      Object.entries(G__4).forEach(function(e) {
        return (function(v, k) {
          return EXTERNS[k] = k;
        })(e[1], e[0]);
      });
    }
  }
  return ret;
}

//
function local_DASH_vardefs(ast, env) {
  return sf_DASH_vardefs(ast, env, "local");
}
SPEC_DASH_OPS["def~-"] = local_DASH_vardefs;

//
function global_DASH_vardefs(ast, env) {
  return sf_DASH_vardefs(ast, env, "global");
}
SPEC_DASH_OPS["def~"] = global_DASH_vardefs;

//
function let_DASH_vardefs(ast, env) {
  return sf_DASH_vardefs(ast, env, "let");
}
SPEC_DASH_OPS["var~"] = let_DASH_vardefs;

//
function sf_DASH_var(ast, env, cmd) {
  let ret;
  ret = nodeTag(tnode(), ast);
  let vname,
    keys,
    kks,
    public_QUERY;
  vname = null;
  keys = [];
  kks = {};
  public_QUERY = ("global" == cmd);
  ast = ast.slice(1);
  if ( (public_QUERY || ("local" == cmd)) ) {
    cmd = "var";
  }
  for (let i = 0, ____break = false; ((!____break) && (i < ast.length)); i = (i + 2)) {
    if (std.symbol_QUERY(ast[i])) {
      std.conj_BANG(keys, ast[i]);
    }
  }
  ret.add(";\n");
  if (std.not_DASH_empty(keys)) {
    ret.add(["let ", keys.map(function(s) {
      let ss;
      ss = transpileSingle(s);
      kks[ss] = null;
      return ss;
    }).join(","), ";\n"]);
  }
  for (let i = 0, rc = null, lhs = null, rhs = null, ____break = false; ((!____break) && (i < ast.length)); i = (i + 2)) {
    (lhs = ast[i], rhs = ast[(i + 1)]);
    if (std.symbol_QUERY(lhs)) {
      ret.add([transpileSingle(lhs), "= ", transpile_STAR(rhs, env), ";\n"]);
    } else {
      {
        rc = destruct0(cmd, lhs, rhs, env);
        ret.add(rc[0]);
        rc[1].map(function(s) {
          return kks[rdr.jsid(s)] = null;
        });
      }
    }
  }
  ret.add(";");
  if ( (public_QUERY && (1 === rt.globalEnv().countNSPCache())) ) {
    {
      {
        let G__5;
        G__5 = kks;
        Object.entries(G__5).forEach(function(e) {
          return (function(v, k) {
            return EXTERNS[k] = k;
          })(e[1], e[0]);
        });
      }
    }
  }
  return ret;
}

//
function sf_DASH_var_DASH_local(ast, env) {
  return sf_DASH_var(ast, env, "local");
}
SPEC_DASH_OPS["def-"] = sf_DASH_var_DASH_local;

//
function sf_DASH_var_DASH_global(ast, env) {
  return sf_DASH_var(ast, env, "global");
}
SPEC_DASH_OPS["def"] = sf_DASH_var_DASH_global;

//
function sf_DASH_var_DASH_let(ast, env) {
  return sf_DASH_var(ast, env, "let");
}
SPEC_DASH_OPS["var"] = sf_DASH_var_DASH_let;

//
function sf_DASH_inst_QUERY(ast, env) {
  let ret;
  ret = nodeTag(tnode(), ast);
  ret.add(["(", transpile_STAR(ast[2], env), " instanceof ", transpile_STAR(ast[1], env), ")"]);
  return ret;
}
SPEC_DASH_OPS["inst?"] = sf_DASH_inst_QUERY;

//
function sf_DASH_delete(ast, env) {
  let ret;
  ret = nodeTag(tnode(), ast);
  ret.add(["delete ", transpile_STAR(ast[1], env)]);
  if ( (ast.length > 2) ) {
    ret.add(["[", transpile_STAR(ast[2]), "]"]);
  }
  return ret;
}
SPEC_DASH_OPS["delete!"] = sf_DASH_delete;

//
function sf_DASH_new(ast, env) {
  let ret;
  ret = nodeTag(tnode(), ast);
  ret.add(transpileList(ast.slice(1), env));
  ret.prepend("new ");
  return ret;
}
SPEC_DASH_OPS["new"] = sf_DASH_new;

//
function sf_DASH_throw(ast, env) {
  let ret;
  ret = nodeTag(tnode(), ast);
  ret.add(["throw ", transpile_STAR(ast[1], env), ";"]);
  ret.prepend("(function (){ ");
  ret.add(" })(this)");
  return ret;
}
SPEC_DASH_OPS["throw"] = sf_DASH_throw;

//
function sf_DASH_x_DASH_opop(ast, env) {
  transpileAtoms(ast, env);
  return nodeTag(tnodeEx([ast[0], ast[1]]), ast);
}
SPEC_DASH_OPS["++"] = sf_DASH_x_DASH_opop;
SPEC_DASH_OPS["--"] = sf_DASH_x_DASH_opop;

//
function sf_DASH_x_DASH_eq(ast, env) {
  transpileAtoms(ast, env);
  return nodeTag(tnodeEx([ast[1], " ", ast[0], " ", ast[2]]));
}
SPEC_DASH_OPS["+="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS["-="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS["*="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS["/="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS["%="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS["<<="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS[">>="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS[">>>="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS["&="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS["|="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS["^="] = sf_DASH_x_DASH_eq;

//
function sf_DASH_set_DASH_in(ast, env) {
  if ( (0 === (ast.length % 2)) ) {
    true;
  } else {
    throw new Error("set-in: bad arg count");
  }
  let ret;
  ret = nodeTag(tnode(), ast);
  let obj;
  obj = transpile_STAR(ast[1], env);
  for (let i = 2, ____break = false; ((!____break) && (i < ast.length)); i = (i + 2)) {
    if ( (i > 2) ) {
      ret.add(",");
    }
    ret.add([obj, "[", transpile_STAR(ast[i], env), "]", "=", transpile_STAR(ast[(i + 1)], env)]);
  }
  return ret;
}
SPEC_DASH_OPS["set-in!"] = sf_DASH_set_DASH_in;

//
function sf_DASH_set(ast, env) {
  if ( (!(0 === (ast.length % 2))) ) {
    true;
  } else {
    throw new Error("set: bad arg count");
  }
  let more,
    ret;
  more = false;
  ret = nodeTag(tnode(), ast);
  for (let i = 1, ____break = false; ((!____break) && (i < ast.length)); i = (i + 2)) {
    if ( (i > 1) ) {
      {
        ret.add(",");
        more = true;
      }
    }
    ret.add([transpile_STAR(ast[i], env), "=", transpile_STAR(ast[(i + 1)], env)]);
  }
  if (more) {
    {
      ret.prepend("(");
      ret.add(")");
    }
  }
  return ret;
}
SPEC_DASH_OPS["set!"] = sf_DASH_set;

//
function parseFuncArgs(args) {
  let ret;
  ret = [];
  for (let i = 0, e = null, ev = null, ____break = false; ((!____break) && (i < args.length)); i = (i + 1)) {
    (e = args[i], ev = e.toString());
    if (std.symbol_QUERY(e)) {
      if ( (ev === "_") ) {
        std.conj_BANG(ret, std.symbol(gensym("_")));
      } else {
        if ( (ev === "&") ) {
          {
            e = args[(i + 1)];
            if (std.symbol_QUERY(e)) {
              std.conj_BANG(ret, [e, i, e]);
            } else {
              std.conj_BANG(ret, [std.symbol(["&", gensym()].join("")), i, e]);
            }
            ++i;
          }
        } else {
          if (ev.startsWith("&")) {
            {
              e = std.symbol(ev.slice(1));
              std.conj_BANG(ret, [e, i, e]);
            }
          } else {
            if (true) {
              std.conj_BANG(ret, e);
            }
          }
        }
      }
    } else {
      if (std.keyword_QUERY(e)) {
        throw new Error(["bad function args destructure: ", std.typeid(e)].join(""));
      } else {
        if (Array.isArray(e)) {
          std.conj_BANG(ret, [std.symbol(gensym()), i, e]);
        } else {
          if (true) {
            throw new Error(["bad function args destructure: ", std.typeid(e)].join(""));
          }
        }
      }
    }
  }
  return ret;
}

//
function handleFuncArgs(fargs, env) {
  let out;
  out = [];
  let misc,
    keys,
    ret,
    knode;
  misc = [];
  keys = [];
  ret = tnode();
  knode = tnode();
  fargs.forEach(function(arg) {
    return (std.symbol_QUERY(arg) ?
      std.conj_BANG(keys, arg) :
      ((std.symbol_QUERY(arg[0]) && (!arg[0].toString().startsWith("&")) && Array.isArray(arg[2])) ?
        (function() {
          std.conj_BANG(keys, arg[0]);
          return std.conj_BANG(misc, arg);
        }).call(this) :
        (true ?
          std.conj_BANG(misc, arg) :
          null)));
  });
  misc.forEach(function(arr) {
    let a0,
      name,
      varg_QUERY,
      pos,
      a2;
    a0 = arr[0];
    name = a0.toString();
    varg_QUERY = name.startsWith("&");
    pos = arr[1].toString();
    a2 = arr[2];
    if (varg_QUERY) {
      name = name.slice(1);
    }
    name = rdr.jsid(name);
    return ((std.symbol_QUERY(a0) && std.symbol_QUERY(a2)) ?
      ret.add(["let ", name, "=Array.prototype.slice.call(arguments,", pos, ");\n"]) :
      (Array.isArray(a2) ?
        (function() {
          if (varg_QUERY) {
            ret.add(["let ", name, "=Array.prototype.slice.call(arguments,", pos, ");\n"]);
          }
          return ret.add(destruct0("let", a2, name, env)[0]);
        }).call(this) :
        null));
  });
  knode.add(keys.map(function() {
    let ____args;
    ____args = Array.prototype.slice.call(arguments);
    return rdr.jsid(____args[0].toString());
  }).join(","));
  std.conj_BANG(out, knode);
  std.conj_BANG(out, ret);
  return out;
}

//
function sf_DASH_fn(ast, env) {
  let ret;
  ret = nodeTag(tnode(), ast);
  let args,
    fargs,
    hints,
    body;
  args = ast[1];
  fargs = null;
  hints = {};
  body = ast.slice(2);
  if ( ((3 === args.length) && ("with-meta" == args[0]) && Array.isArray(args[1])) ) {
    {
      hints = resolveMeta(args[2], env);
      args = args[1];
    }
  }
  fargs = handleFuncArgs(parseFuncArgs(args), env);
  ret.add("function (");
  ret.add(fargs[0]);
  ret.add([") {\n", fargs[1], transpileDo(body, env), "}"]);
  return ret;
}
SPEC_DASH_OPS["fn"] = sf_DASH_fn;

//
function fmtRegoSpecOps(alias, fname) {
  return [rdr.jsid("SPEC-OPS"), "[\"", alias, "\"] = ", fname].join("");
}

//
function fmtSpecOps(fname, attrs) {
  let ks,
    out;
  ks = (attrs["opcode"] || []);
  out = ks.map(function() {
    let ____args;
    ____args = Array.prototype.slice.call(arguments);
    return fmtRegoSpecOps(____args[0].toString(), fname);
  }).join(";\n");
  return (std.not_DASH_empty(ks) ?
    [out, ";\n"].join("") :
    out);
}

//
function sf_DASH_func(ast, env, public_QUERY) {
  let ret;
  ret = nodeTag(tnode(), ast);
  let fname,
    mtd_QUERY,
    dot_QUERY,
    hints,
    fargs,
    e3,
    e2,
    doc,
    attrs,
    args,
    body;
  fname = transpile_STAR(ast[1], env);
  mtd_QUERY = (ast[0] == "method");
  dot_QUERY = fname.includes(".");
  hints = {};
  fargs = null;
  e3 = ast[3];
  e2 = ast[2];
  doc = null;
  attrs = null;
  args = 2;
  body = 3;
  if ( (typeof (e2) === "string") ) {
    {
      (doc = 2, args = 3);
      if (std.map_QUERY(e3)) {
        {
          (attrs = 3, args = 4);
        }
      }
    }
  } else {
    if (std.map_QUERY(e2)) {
      {
        (attrs = 2, args = 3);
      }
    } else {
      null;
    }
  }
  body = (args + 1);
  if (doc) {
    doc = ast[doc];
  }
  if (attrs) {
    attrs = ast[attrs];
  }
  (args = ast[args], body = ast.slice(body));
  if ( ((3 === args.length) && ("with-meta" == args[0]) && Array.isArray(args[1])) ) {
    {
      (hints = resolveMeta(args[2], env), args = args[1]);
    }
  }
  fargs = handleFuncArgs(parseFuncArgs(args), env);
  if (mtd_QUERY) {
    {
      if (hints.static) {
        ret.add("static ");
      }
      ret.add([fname, " ("]);
    }
  } else {
    if (dot_QUERY) {
      ret.add([fname, " = function ("]);
    } else {
      if (true) {
        ret.add(["function ", fname, "("].join(""));
      }
    }
  }
  ret.add(fargs[0]);
  ret.add([") {\n", fargs[1], transpileDo(body, env), "}\n"]);
  if ( (!(0 === kirbystdlibref.count(hints))) ) {
    ret.add(fmtSpecOps(fname, hints));
  }
  if (doc) {
    {
      doc = doc.replace(rdr.REGEX.dquoteHat, "").replace(rdr.REGEX.dquoteEnd, "");
      ret.prepend(doc.split("\\n").map(function() {
        let ____args;
        ____args = Array.prototype.slice.call(arguments);
        return ["//", ____args[0], "\n"].join("");
      }));
    }
  }
  if ( (public_QUERY && (!dot_QUERY) && (1 === rt.globalEnv().countNSPCache())) ) {
    EXTERNS[fname] = fname;
  }
  return ret;
}

//
function sf_DASH_func_DASH_private(ast, env) {
  return sf_DASH_func(ast, env, false);
}
SPEC_DASH_OPS["defn-"] = sf_DASH_func_DASH_private;

//
function sf_DASH_func_DASH_public(ast, env) {
  return sf_DASH_func(ast, env, true);
}
SPEC_DASH_OPS["defn"] = sf_DASH_func_DASH_public;

//
function sf_DASH_try(ast, env) {
  let ret;
  ret = nodeTag(tnode(), ast);
  let sz,
    t,
    f,
    c;
  sz = ast.length;
  t = null;
  f = null;
  c = null;
  f = std.last(ast);
  if ( (Array.isArray(f) && ("finally" == f[0])) ) {
    (f = ast.pop(), sz = ast.length);
  } else {
    f = null;
  }
  c = null;
  if ( (sz > 1) ) {
    c = ast[(sz - 1)];
  }
  if ( (Array.isArray(c) && ("catch" == c[0])) ) {
    {
      if ( ((c.length < 2) || (!std.symbol_QUERY(c[1]))) ) {
        syntax_BANG("e0", ast);
      }
      c = ast.pop();
    }
  } else {
    c = null;
  }
  if ( ((f === null) && (c === null)) ) {
    syntax_BANG("e0", ast);
  }
  ret.add(["(function() {\ntry {\n", transpileDo(ast.slice(1), env), "\n}"]);
  if (c) {
    {
      t = c[1];
      ret.add([["catch (", t, ") {\n"].join(""), transpileDo(c.slice(2), env), ";\n}\n"]);
    }
  }
  if (f) {
    {
      ret.add(["finally {\n", transpileDo(f.slice(1), env, false), ";\n}\n"]);
    }
  }
  ret.add("}).call(this)");
  return ret;
}
SPEC_DASH_OPS["try"] = sf_DASH_try;

//
function sf_DASH_if(ast, env) {
  let ret;
  ret = nodeTag(tnode(), ast);
  let a1,
    a2,
    a3;
  a1 = ast[1];
  a2 = ast[2];
  a3 = ((ast.length > 3) ?
    ast[3] :
    null);
  ret.add(["(", transpile_STAR(a1, env), " ?\n", transpile_STAR(a2, env), " :\n",(transpile_STAR(a3, env) || "null"), ")"]);
  return ret;
}
SPEC_DASH_OPS["if"] = sf_DASH_if;

//
function sf_DASH_nth(ast, env) {
  let ret;
  ret = nodeTag(tnode(), ast);
  transpileAtoms(ast, env);
  ret.add([ast[1], "[", ast[2], "]"]);
  return ret;
}
SPEC_DASH_OPS["nth"] = sf_DASH_nth;

//
function sf_DASH_get(ast, env) {
  let ret;
  ret = nodeTag(tnode(), ast);
  transpileAtoms(ast, env);
  ret.add([ast[1], "[", ast[2], "]"]);
  return ret;
}
SPEC_DASH_OPS["aget"] = sf_DASH_get;
SPEC_DASH_OPS["get"] = sf_DASH_get;

//
function sf_DASH_str(ast, env) {
  let ret;
  ret = nodeTag(tnode(), ast);
  let args;
  args = ast.slice(1);
  transpileAtoms(args, env);
  if ( (args.length > 1) ) {
    {
      let G__6;
      G__6 = ret;
      G__6.add(args);
      G__6.join(",");
      G__6.prepend("[");
      G__6.add("].join(\"\")");
      G__6;
    }
  } else {
    if (std.not_DASH_empty(args)) {
      ret.add(["", args[0], ".toString()"]);
    }
  }
  return ret;
}
SPEC_DASH_OPS["str"] = sf_DASH_str;

//
function sf_DASH_array(ast, env) {
  let ret;
  ret = nodeTag(tnode(), ast);
  let epilog;
  epilog = "\n]";
  if ( (0 === kirbystdlibref.count(ast)) ) {
    ret.add("[]");
  } else {
    {
      if ( (!std.vector_QUERY(ast)) ) {
        ast.splice(0, 1);
      }
      transpileAtoms(ast, env);
      ret.add("[\n");
      for (let i = 0, ____break = false; ((!____break) && (i < ast.length)); i = (i + 1)) {
        if ( (i > 0) ) {
          ret.add(",\n");
        }
        ret.add(ast[i]);
      }
      ret.add(epilog);
    }
  }
  return ret;
}
SPEC_DASH_OPS["vec"] = sf_DASH_array;

//
function sf_DASH_object(ast, env) {
  let ret;
  ret = nodeTag(tnode(), ast);
  let epilog;
  epilog = "\n}";
  if ( (0 === kirbystdlibref.count(ast)) ) {
    ret.add("{}");
  } else {
    {
      if ( (!std.map_QUERY(ast)) ) {
        ast.splice(0, 1);
      }
      transpileAtoms(ast, env);
      ret.add("{\n");
      for (let i = 0, ____break = false; ((!____break) && (i < ast.length)); i = (i + 2)) {
        if ( (i > 0) ) {
          ret.add(",\n");
        }
        ret.add([ast[i], ": ", ast[(i + 1)]]);
      }
      ret.add(epilog);
    }
  }
  return ret;
}
SPEC_DASH_OPS["hashmap"] = sf_DASH_object;

let includeFile;
includeFile = (function() {
  let icache;
  icache = [];
  return function(fname) {
    return (std.contains_QUERY(icache, fname) ?
      tnode() :
      (function() {
        let src;
        src = fs.readFileSync(fname, "utf-8");
        std.conj_BANG(icache, fname);
        return transpileTree(psr.parser(src, fname), rt.globalEnv());
      }).call(this));
  };
})();

//
function sf_DASH_include(ast, env) {
  let ret,
    fname,
    dir;
  ret = [];
  fname = null;
  dir = path.dirname(ast.source);
  for (let i = 1, e = null, ____break = false; ((!____break) && (i < ast.length)); i = (i + 1)) {
    e = ast[i];
    if ( ((!Array.isArray(e)) || (1 !== e.length)) ) {
      syntax_BANG("e0", ast);
    }
    fname = e[0];
    if (fname) {
      fname = fname.replace(/[\"]/g, "");
    }
    try {
      fname = fs.realpathSync([dir, "/", fname].join(""));

    } catch (e) {
      syntax_BANG("e11", ast);
    }
    try {
      std.conj_BANG(ret, includeFile(fname));

    } finally {
      rt.globalEnv().popNSP();
    }
  }
  return ((0 === kirbystdlibref.count(ret)) ?
    tnode() :
    ret);
}

//
function sf_DASH_require(ast, env) {
  let ret;
  ret = nodeTag(tnode(), ast);
  let path,
    v,
    e,
    refers,
    renames;
  let as;
  as = null;
  for (let i = 1, ____break = false; ((!____break) && (i < ast.length)); i = (i + 1)) {
    (e = ast[i], as = gensym());
    (refers = null, renames = null);
    if ( ((!Array.isArray(e)) || (e.length < 3)) ) {
      syntax_BANG("e0", ast);
    }
    path = e[0];
    for (let j = 1, ____break = false; ((!____break) && (j < e.length)); j = (j + 1)) {
      v = e[j];
      if ( (v == "as") ) {
        {
          as = e[(j + 1)].toString();
          ++j;
        }
      } else {
        if ( (v == "refer") ) {
          {
            refers = e[(j + 1)];
            ++j;
          }
        } else {
          if ( (v == "rename") ) {
            {
              renames = e[(j + 1)];
              ++j;
            }
          } else {
            null;
          }
        }
      }
    }
    ret.add(";");
    ret.add(["var ", rdr.jsid(as), "= require(", transpileSingle(path), ");\n"]);
    for (let i = 0, ____break = false; ((!____break) && (refers && (i < refers.length))); i = (i + 1)) {
      v = transpileSingle(refers[i]);
      ret.add(["var ", v, "=", as, "[\"", v, "\"];\n"]);
    }
    ret.add(";");
    for (let i = 0, ____break = false; ((!____break) && (renames && (i < renames.length))); i = (i + 2)) {
      e = transpileSingle(renames[i]);
      v = transpileSingle(renames[(i + 1)]);
      ret.add(["var ", v, "=", as, "[\"", e, "\"];\n"]);
    }
    ret.add(";");
  }
  return ret;
}

//
function resolveMeta(ast, env) {
  return (Array.isArray(ast) ?
    JSON.parse(["", transpile_STAR(ast, env)].join("")) :
    (std.keyword_QUERY(ast) ?
      JSON.parse(["", transpile_STAR(std.hashmap(ast, true), env)].join("")) :
      (std.symbol_QUERY(ast) ?
        JSON.parse(["", transpile_STAR(std.hashmap(std.symbol("tag"), ast), env)].join("")) :
        (true ?
          (function() {
            throw new Error(["Bad meta value", std.prn(ast)].join("")) ;
          }).call(this) :
          null))));
}

//
function sf_DASH_ns(ast, env) {
  let ret;
  ret = [];
  let hints,
    nsp;
  hints = {};
  nsp = ast[1];
  if ( (Array.isArray(nsp) && (3 === nsp.length) && ("with-meta" == nsp[0]) && std.symbol_QUERY(nsp[1])) ) {
    {
      hints = resolveMeta(nsp[2], env);
      nsp = nsp[1];
    }
  }
  rt.globalEnv().pushNSP(nsp.toString());
  ast = ast.slice(2);
  for (let i = 0, e = null, ____break = false; ((!____break) && (i < ast.length)); i = (i + 1)) {
    e = ast[i];
    if ( (std.list_QUERY(e) && ("include" == e[0])) ) {
      std.conj_BANG(ret, sf_DASH_include(e));
    } else {
      if ( (std.list_QUERY(e) && ("require" == e[0])) ) {
        std.conj_BANG(ret, sf_DASH_require(e));
      } else {
        null;
      }
    }
  }
  nsp = rt.globalEnv().peekNSP();
  if ( ((nsp === "czlab.kirby.bl.macros") || (nsp === "czlab.kirby.bl.stdlib")) ) {
    null;
  } else {
    if (nsp.startsWith("czlab.kirby.")) {
      std.conj_BANG(ret, tnodeEx("const kirbystdlibref=std;\n"));
    } else {
      if (true) {
        std.conj_BANG(ret, sf_DASH_require([std.symbol("require"), ["\"kirby\"", std.keyword(":as"), std.symbol("kirbystdlibref")]]));
      }
    }
  }
  return ret;
}
SPEC_DASH_OPS["ns"] = sf_DASH_ns;

//
function maybeStripStdlib(cmd) {
  let nsp,
    lib;
  nsp = rt.globalEnv().peekNSP();
  lib = "kirbystdlibref.";
  cmd = cmd.toString();
  return ((cmd.startsWith(lib) && (nsp === "czlab.kirby.bl.stdlib")) ?
    cmd.slice(lib.length) :
    cmd);
}

//
function sf_DASH_comment(ast, env) {
  return nodeTag(tnode(), ast);
}
SPEC_DASH_OPS["comment"] = sf_DASH_comment;

//
function sf_DASH_for(ast, env) {
  let ret;
  ret = nodeTag(tnode(), ast);
  let body;
  body = ast.slice(2);
  if ( (0 === kirbystdlibref.count(body)) ) {
    tnode();
  } else {
    sf_DASH_floop(ret, ast[1], body, env);
  }
  return ret;
}
SPEC_DASH_OPS["for"] = sf_DASH_for;

//
function sf_DASH_floop(ret, args, body, env) {
  let vars,
    recurs;
  vars = [];
  recurs = [];
  let tst,
    nb,
    e;
  for (let i = 0, ____break = false; ((!____break) && (i < args.length)); i = (i + 1)) {
    e = args[i];
    if ( (e == "while") ) {
      {
        tst = args[(i + 1)];
        ++i;
      }
    } else {
      if ( (e == "recur") ) {
        {
          recurs = args.slice((i + 1));
          ____break = true;
        }
      } else {
        if (std.symbol_QUERY(e)) {
          {
            std.conj_BANG(vars, e, args[(i + 1)]);
            ++i;
          }
        } else {
          null;
        }
      }
    }
  }
  ret.add("for (");
  for (let i = 0, ____break = false; ((!____break) && (i < vars.length)); i = (i + 2)) {
    if ( (i === 0) ) {
      ret.add("let ");
    }
    if ( (i !== 0) ) {
      ret.add(",");
    }
    ret.add([transpileSingle(vars[i]), "=", transpile_STAR(vars[(i + 1)], env)]);
  }
  if ( (0 === kirbystdlibref.count(vars)) ) {
    ret.add("let ____break=false;");
  } else {
    ret.add(",____break=false;");
  }
  nb = [std.symbol("not"), std.symbol("____break")];
  if (tst) {
    tst = [std.symbol("and"), nb, tst];
  } else {
    tst = nb;
  }
  ret.add(transpile_STAR(tst, env));
  ret.add("; ");
  for (let i = 0, k = 0, ____break = false; ((!____break) && (i < recurs.length)); i = (i + 1), k = (k + 2)) {
    if ( (i !== 0) ) {
      ret.add(",");
    }
    ret.add([transpileSingle(vars[k]), "=", transpile_STAR(recurs[i], env)]);
  }
  return (function() {
    let G__7;
    G__7 = ret;
    G__7.add("){\n");
    G__7.add(transpileDo(body, env, false));
    G__7.add("}\n");
    G__7.prepend("(function() {\n");
    G__7.add("})(this)");
    return G__7;
  }).call(this);
}

//
function sf_DASH_jscode(ast, env) {
  return nodeTag(tnodeEx(ast[1].toString().replace(rdr.REGEX.dquoteHat, "").replace(rdr.REGEX.dquoteEnd, "")), ast);
}
SPEC_DASH_OPS["js#"] = sf_DASH_jscode;

//
function sf_DASH_macro(ast, env) {
  let pms,
    args,
    body;
  pms = [];
  args = ast[2];
  body = ast.slice(3);
  if ( (typeof (args) === "string") ) {
    {
      (doc = args, args = ast[3], body = ast.slice(4));
    }
  }
  for (let i = 0, e = null, ev = null, ____break = false; ((!____break) && (i < args.length)); i = (i + 1)) {
    (e = args[i], ev = e.toString());
    if ( (ev === "&") ) {
      if (Array.isArray(args[(i + 1)])) {
        {
          e = args[(i + 1)];
          ++i;
          for (let j = 0, x = null, ____break = false; ((!____break) && (j < e.length)); j = (j + 1)) {
            x = e[j];
            if ( (!std.symbol_QUERY(x)) ) {
              throw new Error("Bad optional arg for macro");
            }
            std.conj_BANG(pms, x);
          }
        }
      } else {
        {
          std.conj_BANG(pms, e, args[(i + 1)]);
          ++i;
        }
      }
    } else {
      if ( (!std.symbol_QUERY(e)) ) {
        throw new Error("Bad optional arg for macro");
      } else {
        if (true) {
          std.conj_BANG(pms, e);
        }
      }
    }
  }
  ast = [ast[0], ast[1], [std.symbol("fn*"), pms].concat(body)];
  let a2,
    a1,
    func;
  a2 = ast[2];
  a1 = ast[1].toString();
  func = rt.compute(a2, env);
  func["____macro"] = true;
  if (doc) {
    func["____doc"] = doc;
  }
  rt.setMacro(a1, func);
  return nodeTag(tnode(), ast);
}
SPEC_DASH_OPS["defmacro"] = sf_DASH_macro;

//
function sf_DASH_unary(ast, env) {
  let ret;
  ret = nodeTag(tnode(), ast);
  let G____17 = ast;
  let a0,
    a1;
  a0 = G____17[0];
  a1 = G____17[1];
  if ( (a0 == "not") ) {
    a0 = std.symbol("!");
  }
  ret.add(["(", transpile_STAR(a0, env), transpile_STAR(a1, env), ")"]);
  return ret;
}
SPEC_DASH_OPS["not"] = sf_DASH_unary;
SPEC_DASH_OPS["~"] = sf_DASH_unary;
SPEC_DASH_OPS["!"] = sf_DASH_unary;

//
function sf_DASH_doseq(ast, env) {
  let ret;
  ret = nodeTag(tnode(), ast);
  let args,
    body,
    escvar,
    idxvar,
    exprvar;
  args = ast[1];
  body = ast.slice(2);
  let G____18 = args;
  let loopvar,
    loopexpr;
  loopvar = G____18[0];
  loopexpr = G____18[1];
  escvar = gensym();
  idxvar = gensym();
  exprvar = gensym();
  ret.add(["let ", transpileSingle(loopvar), "= ", exprvar, "[", idxvar, "];\n"]);
  for (let i = 2, v = null, ev = null, ____break = false; ((!____break) && (i < args.length)); i = (i + 1)) {
    (v = args[i], ev = v.toString());
    if ( (ev === "while") ) {
      ret.add(["if (! ", transpile_STAR(args[(i + 1)], env), ") {", escvar, "=true;}\n"]);
    } else {
      if ( (ev === "when") ) {
        {
          let G__8;
          G__8 = ret;
          G__8.add(["if (!", escvar, ") {\n"]);
          G__8.add(["if (! ", transpile_STAR(args[(i + 1)], env), ") {continue;}\n"]);
          G__8.add("}\n");
          G__8;
        }
      } else {
        if ( (ev === "let") ) {
          ret.add(sf_DASH_var_DASH_let([std.symbol("var")].concat(args[(i + 1)]), env));
        } else {
          null;
        }
      }
    }
  }
  {
    let G__9;
    G__9 = ret;
    G__9.add(["if (!", escvar, ") {\n"]);
    G__9.add(transpileDo(body, env, false));
    G__9.add("}\n");
    G__9.add("}\n");
    G__9.prepend(["for(let ", escvar, "=false,", idxvar, "=0; ", "(!", escvar, " && ", idxvar, " < ", exprvar, ".length); ++", idxvar, ") {\n"]);
    G__9.prepend(["let ", exprvar, "= ", transpile_STAR(loopexpr, env), ";\n"]);
    G__9.prepend("(function() {\n");
    G__9.add("})(this);\n");
    G__9;
  }
  return ret;
}
SPEC_DASH_OPS["doseq"] = sf_DASH_doseq;

//
function spitExterns() {
  let s;
  s = "";
  let ks;
  ks = Object.keys(EXTERNS);
  if (std.not_DASH_empty(ks)) {
    {
      s = ks.map(function() {
        let ____args;
        ____args = Array.prototype.slice.call(arguments);
        return [____args[0], ": ", ____args[0]].join("");
      }).join(",\n");
      s = ["\n\nmodule.exports = {\n", s, "\n};\n\n"].join("");
    }
  }
  return s;
}

//
function banner() {
  return ["/*", "Auto generated by Kirby - v", MODULE_VERSION, " ", rt.globalEnv().firstNSP(), " - ", new Date(), "*/\n\n"].join("");
}

//
function cleanCode(code) {
  let arr;
  arr = [];
  code.split("\n").forEach(function(s) {
    s = s.trim();
    return ((s !== ";") ?
      std.conj_BANG(arr, s) :
      null);
  });
  return arr.join("\n");
}

//
function transpileCode(codeStr, fname, srcMap_QUERY) {
  rt.globalEnv().resetNSPCache();
  EXTERNS = {};
  let outNode,
    options,
    cstr,
    extra;
  outNode = transpileTree(psr.parser(codeStr, fname), rt.globalEnv());
  options = {};
  cstr = "";
  extra = spitExterns();
  outNode.prepend(banner());
  cstr = (srcMap_QUERY ?
    (function() {
      let outFile,
        srcMap,
        output;
      outFile = [path.basename(fname, ".ky"), ".js"].join("");
      srcMap = [outFile, ".map"].join("");
      output = outNode.toStringWithSourceMap({
        "file": outFile
      });
      fs.writeFileSync(srcMap, output.map);
      return [output.code, extra, "\n//# sourceMappingURL=", path.relative(path.dirname(fname), srcMap)].join("");
    }).call(this) :
    [outNode, extra].join(""));
  cstr = cleanCode(cstr);
  return (false ?
    esfmt.format(cstr, options) :
    cstr);
}

//
function transpileXXX(code, file, smap_QUERY) {
  return (function() {
    try {
      transpileCode(code, file, smap_QUERY);

    } catch (e) {
      return (e ?
        (function() {
          if (console) {
            console.log([e.stack].join(""));
          }
          return (function() {
            throw e ;
          }).call(this);
        }).call(this) :
        null);
    }
  }).call(this);
}

//
function transpileWithSrcMap(code, file) {
  return transpileXXX(code, file, true);
}

//
function transpile(code, file) {
  return transpileXXX(code, file, false);
}

//
function parseWithSourceMap(codeStr, fname) {
  let outNode;
  outNode = transpileTree(psr.parser(codeStr, fname));
  outNode.prepend(banner());
  return outNode.toStringWithSourceMap();
}

let version;
version = MODULE_VERSION;



module.exports = {
  transpileWithSrcMap: transpileWithSrcMap,
  transpile: transpile,
  parseWithSourceMap: parseWithSourceMap,
  version: version
};

