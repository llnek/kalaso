/*Auto generated by Kirby - v1.0.0 czlab.kirby.cg.transpiler Mon Nov 06 2017 23:09:50 GMT-0800 (PST)*/

var std= require("../bl/stdlib");
var rdr= require("../bl/lexer");
var tnode=rdr["tnode"];
var tnodeEx=rdr["tnodeEx"];
var psr= require("../bl/parser");
var rt= require("../rt/runtime");
var fs= require("fs");
var path= require("path");
var esfmt= require("esformatter");
var kirbystdlibref=std;

let gensym_DASHcounter;
gensym_DASHcounter= 1;

let ERRORS_DASHMAP;
ERRORS_DASHMAP= { "e0": "Syntax Error","e1": "Empty statement","e2": "Invalid characters in function name","e3": "End of File encountered, unterminated string","e4": "Closing square bracket, without an opening square bracket","e5": "End of File encountered, unterminated array","e6": "Closing curly brace, without an opening curly brace","e7": "End of File encountered, unterminated javascript object '}'","e8": "End of File encountered, unterminated parenthesis","e9": "Invalid character in var name","e10": "Extra chars at end of file. Maybe an extra ')'.","e11": "Cannot Open include File","e12": "Invalid no of arguments to ","e13": "Invalid Argument type to ","e14": "End of File encountered, unterminated regular expression","e15": "Invalid vararg position, must be last argument.","e16": "Invalid arity (args > expected) to ","e17": "Invalid arity (args < expected) to " };

let MODULE_VERSION,EXTERNS,SPEC_DASHOPS;
MODULE_VERSION= "1.0.0";
EXTERNS= null;
SPEC_DASHOPS= {};

//
function gensym() {
let G____8=Array.prototype.slice.call(arguments,0);
let G____9= G____8;
let pfx;
pfx=G____9[0];
let x;
x= gensym_DASHcounter;

++gensym_DASHcounter;
return [std.opt(pfx,"G____"),x].join("");
}

//
function error_BANG(e) {
let G____10=Array.prototype.slice.call(arguments,1);
let G____11= G____10;
let line,file,msg;
line=G____11[0];
file=G____11[1];
msg=G____11[2];
return (function (){ throw new Error([ ERRORS_DASHMAP[e],(msg ?
[" : ",msg].join("") :
null),(line ?
["\nLine no ",line].join("") :
null),(file ?
["\nFile ",file].join("") :
null) ].join("")); })(this);
}

//
function syntax_BANG(ecode) {
let G____12=Array.prototype.slice.call(arguments,1);
let G____13= G____12;
let ast,cmd;
ast=G____13[0];
cmd=G____13[1];
return error_BANG(ecode,(ast ?
ast.line :
0),(ast ?
ast.source :
0),cmd);
}

//
function pad(z) {
return " ".repeat(z);
}

//
function testre_QUERY(re,x) {
return (x ?
re.test(x) :
false);
}

//
function nodeTag(obj,src) {
((obj&&src&&(!(typeof(obj) === "boolean"))&&(!(typeof(obj) === "number"))) ?
(function() {
obj.source=src.source;
obj.column=src.column;
return obj.line=src.line;
}).call(this) :
null);
return obj;
}

//
function destructVec(lhs,keys) {
return (function() {
let as;
as= null;

(function() {
for (let i=0,e=null,ev=null,____break=false; ((!____break)&&(i < lhs.length)); i=(i+1)){
(e=lhs[i],ev=e.toString());
(std.symbol_QUERY(e) ?
((ev === "_") ?
null :
((ev === "&") ?
(function() {
keys[["&",lhs[(i+1)]].join("")]=i;
return ++i;
}).call(this) :
(ev.startsWith("&") ?
keys[ev]=i :
(true ?
keys[ev]=i :
null)))) :
(std.keyword_QUERY(e) ?
((ev === "as") ?
(function() {
++i;
return as=lhs[i].toString();
}).call(this) :
(function (){ throw new Error([ "bad keyword: :",ev ].join("")); })(this)) :
null));
}
}).call(this);
return as;
}).call(this);
}

//
function destructMap(lhs,keys) {
return (function() {
let as;
as= null;

(function() {
for (let i=0,e=null,ev=null,____break=false; ((!____break)&&(i < lhs.length)); i=(i+1)){
(e=lhs[i],ev=e.toString());
(std.keyword_QUERY(e) ?
(((ev === "keys")||(ev === "strs")) ?
(function() {
let ks;
ks= lhs[(i+1)];

++i;
return (function() {
for (let j=0,____break=false; ((!____break)&&(j < ks.length)); j=(j+1)){
keys[ks[j].toString()]=null;
}
}).call(this);
}).call(this) :
((ev === "as") ?
(function() {
++i;
return as=lhs[i].toString();
}).call(this) :
null)) :
(function (){ throw new Error([ "bad destruct field: ",std.typeid(e) ].join("")); })(this));
}
}).call(this);
return as;
}).call(this);
}

//
function destruct1(lhs) {
let as,out,keys;
as= null;
out= [];
keys= {};

(std.vector_QUERY(lhs) ?
as=destructVec(lhs,keys) :
(std.map_QUERY(lhs) ?
as=destructMap(lhs,keys) :
(std.symbol_QUERY(lhs) ?
keys[lhs.toString()]=null :
(true ?
(function (){ throw new Error([ "cant destruct with: ",std.typeid(lhs) ].join("")); })(this) :
null))));
return [ as,keys ];
}

//
function destruct0(cmd,lhs,rhs,env) {
let kdefs,ka,kvals;
let G____14= destruct1(lhs);
let as,keys;
as=G____14[0];
keys=G____14[1];
kdefs= [];
ka= null;
kvals= tnode();

((0 === kirbystdlibref.count(as)) ?
as=gensym() :
null);
as=rdr.jsid(as);
(function() {
let G__1;
G__1= keys;

return Object.entries(G__1).forEach(function (e) {
return (function (v,k) {
let rest_QUERY;
rest_QUERY= false;

(k.startsWith("&") ?
(function() {
return (rest_QUERY=true,k=k.slice(1));
}).call(this) :
null);
k=rdr.jsid(k);
std.conj_BANG(kdefs,k);
return kvals.add([((v === null) ?
["[\"",k,"\"];\n"].join("") :
(rest_QUERY ?
[".slice(",v,");\n"].join("") :
(true ?
["[",v,"];\n"].join("") :
null))),k,"=",as].join(""));
})(e[1],e[0]);
});
}).call(this);
kvals.prepend([cmd," ",kdefs.join(","),";\n"].join(""));
return [ [ tnodeEx([ cmd," ",rdr.jsid(as),"= ",transpile_STAR(rhs,env),";\n" ]),kvals ],kdefs ];
}

//
function transpileTree(root,env) {
return (function() {
let ret;
ret= nodeTag(tnode(),root);

let treeSize,endx;
treeSize= root.length;
endx= (root.length-1);

root.forEach(function (ast) {
let tmp;
tmp= ast;

(Array.isArray(ast) ?
tmp=transpileList(ast,env) :
null);
return (tmp ?
(function() {
return ret.add([ tmp,"\n" ]);
}).call(this) :
null);
});
return ret;
}).call(this);
}

//
function transpileAtoms(atoms,env) {
return atoms.forEach(function (a,i,arr) {
return arr[i]=transpile_STAR(a,env);
});
}

//
function transpileSingle(a) {
return (std.lambda_DASHarg_QUERY(a) ?
["____args[",a.toString(),"]"].join("") :
(std.keyword_QUERY(a) ?
["\"",a.toString(),"\""].join("") :
(std.symbol_QUERY(a) ?
rdr.jsid(a.toString()) :
((typeof(a) === "string") ?
a :
((a === null) ?
"null" :
(true ?
["",a].join("") :
null))))));
}

//
function transpile_STAR(x,env) {
return (Array.isArray(x) ?
transpileList(x,env) :
transpileSingle(x));
}

//
function findCmd(ast) {
return (function() {
let cmd;
cmd= "";

(std.vector_QUERY(ast) ?
cmd="vec" :
(std.map_QUERY(ast) ?
cmd="hashmap" :
(std.list_QUERY(ast) ?
cmd=ast[0].toString() :
null)));
return cmd;
}).call(this);
}

//
function quoteSingle(a) {
return (std.keyword_QUERY(a) ?
["\"",a,"\""].join("") :
(std.symbol_QUERY(a) ?
rdr.jsid(a.toString()) :
((typeof(a) === "string") ?
a :
((a === null) ?
"null" :
(true ?
a.toString() :
null)))));
}

function quote_BANG(a,env) {
return (Array.isArray(a) ?
(std.map_QUERY(a) ?
quoteMap(a,env) :
quoteBlock(a,env)) :
quoteSingle(a));
}

//
function quoteMap(a,env) {
return (function() {
let ret;
ret= tnode();

(function() {
for (let i=0,____break=false; ((!____break)&&(i < a.length)); i=(i+2)){
((i > 0) ?
ret.add(",") :
null);
ret.add([ quote_BANG(a[i],env)," : ",quote_BANG(a[(i+1)],env) ]);
}
}).call(this);
ret.prepend("{");
ret.add("}");
return ret;
}).call(this);
}

//
function quoteBlock(a,env) {
return (function() {
let ret;
ret= tnode();

(function() {
for (let i=0,____break=false; ((!____break)&&(i < a.length)); i=(i+1)){
((i > 0) ?
ret.add(",") :
null);
ret.add(quote_BANG(a[i],env));
}
}).call(this);
ret.prepend("[");
ret.add("]");
return ret;
}).call(this);
}

//
function sf_DASHquote(ast,env) {
return (function() {
let ret;
ret= nodeTag(tnode(),ast);

ret.add(quote_BANG(ast[1],env));
return ret;
}).call(this);
}
SPEC_DASHOPS["quote"] = sf_DASHquote;

//
function transpileList(ast,env) {
let cmd,mc,tmp;
cmd= findCmd(ast);
mc= rt.getMacro(cmd);
tmp= null;

return (function() {
let ret;
ret= tnode();

(mc ?
(function() {
ast=rt.expandMacro(ast,env,mc);
return cmd=findCmd(ast);
}).call(this) :
null);
(cmd.startsWith(".-") ?
ret.add([ transpile_STAR(ast[1],env),".",transpileSingle(std.symbol(cmd.slice(2))) ]) :
(("." === cmd.charAt(0)) ?
(function() {
ret.add(transpile_STAR(ast[1],env));
ret.add([ cmd,"(" ]);
(function() {
for (let n=2,____break=false; ((!____break)&&(n < ast.length)); n=(n+1)){
((n !== 2) ?
ret.add(",") :
null);
ret.add(transpile_STAR(ast[n],env));
}
}).call(this);
return ret.add(")");
}).call(this) :
(std.contains_QUERY(SPEC_DASHOPS,cmd) ?
ret=SPEC_DASHOPS[cmd](ast,env) :
(rdr.REGEX.int.test(cmd) ?
(function() {
let c0;
c0= cmd.charAt(0);

(((c0 !== "-")&&(c0 !== "+")) ?
cmd=["+",cmd].join("") :
null);
ast=[ std.symbol(cmd.charAt(0)),ast[1],parseInt(cmd.slice(1)) ];
cmd=ast[0].toString();
return ret=SPEC_DASHOPS[cmd](ast,env);
}).call(this) :
(true ?
(function() {
(std.list_QUERY(ast) ?
(function() {
transpileAtoms(ast,env);
return cmd=ast[0];
}).call(this) :
cmd=transpileSingle(ast));
((!cmd) ?
syntax_BANG("e1",ast) :
null);
cmd=maybeStripStdlib(cmd);
return (std.list_QUERY(ast) ?
(function() {
(testre_QUERY(rdr.REGEX.func,cmd) ?
cmd=tnodeEx([ "(",cmd,")" ]) :
null);
return ret.add([ cmd,"(",tnodeEx(ast.slice(1)).join(","),")" ]);
}).call(this) :
ret.add(cmd));
}).call(this) :
null)))));
ret=nodeTag(ret,ast);
return ret;
}).call(this);
}

//
function sf_DASHdeftype(ast,env,public_QUERY) {
return (function() {
let ret;
ret= nodeTag(tnode(),ast);

let cz,par,args,mtds;
cz= transpile_STAR(ast[1],env);
par= ast[2][0];
args= ast[3];
mtds= ast.slice(4);

ret.add([ "class ",cz ]);
(par ?
ret.add([ " extends ",transpile_STAR(par,env) ]) :
null);
ret.add(" {\n");
(function() {
for (let i=0,n=null,m=null,____break=false; ((!____break)&&(i < mtds.length)); i=(i+1)){
m=mtds[i];
m.unshift(std.symbol("method"));
ret.add(sf_DASHfunc(m,env,false));
ret.add("\n");
}
}).call(this);
ret.add("}\n");
((public_QUERY&&(1 === rt.globalEnv().countNSPCache())) ?
EXTERNS[cz]=cz :
null);
return ret;
}).call(this);
}

//
function prv_DASHdeftype(a,e) {
return sf_DASHdeftype(a,e,false);
}
SPEC_DASHOPS["deftype-"] = prv_DASHdeftype;

//
function pub_DASHdeftype(a,e) {
return sf_DASHdeftype(a,e,true);
}
SPEC_DASHOPS["deftype"] = pub_DASHdeftype;

let _lambdaFuncCount;
_lambdaFuncCount= 0;

//
function sf_DASHlambda(ast,env) {
((0 !== _lambdaFuncCount) ?
(function (){ throw new Error("Can't nest lambdas"); })(this) :
++_lambdaFuncCount);
let x,body;
x= [ std.symbol("fn"),[],[ std.symbol("var"),std.symbol("____args"),[ std.symbol("slice"),std.symbol("arguments") ] ] ];
body= ast[1];

((0 === body.length) ?
body=[ null ] :
null);
((!((1 === body.length)&&std.value_QUERY(body[0]))) ?
body=ast.slice(1) :
null);
x=x.concat(body);
return (function() {
try {
return sf_DASHfn(x,env);

} finally {
--_lambdaFuncCount;

}
}).call(this);
}
SPEC_DASHOPS["lambda"] = sf_DASHlambda;

//
function sf_DASHapply(ast,env) {
let args,f,ret;
args= ast.slice(2);
f= ast[1];
ret= nodeTag(tnode(),ast);

(function() {
for (let i=0,____break=false; ((!____break)&&(i < args.length)); i=(i+1)){
ret.add(transpile_STAR(args[i],env));
}
}).call(this);
((args.length > 1) ?
ret.join(",") :
null);
return (function() {
let G__2;
G__2= ret;

G__2.prepend("[");
G__2.add("]");
G__2.prepend([ transpile_STAR(f,env),".apply(this," ]);
G__2.add(")");
return G__2;
}).call(this);
}
SPEC_DASHOPS["apply"] = sf_DASHapply;

//
function sf_DASHcompOp(ast,env) {
let cmd;
cmd= ast[0];

(((cmd == "not=")||(cmd == "!=")) ?
ast[0]=std.symbol("!==") :
null);
((cmd == "=") ?
ast[0]=std.symbol("===") :
null);
return (function() {
let ret;
ret= nodeTag(tnode(),ast);

transpileAtoms(ast,env);
(function() {
for (let i=0,op=ast.shift(),____break=false; ((!____break)&&(i < (ast.length-1))); i=(i+1)){
ret.add(tnodeEx([ ast[i]," ",op," ",ast[(i+1)] ]));
}
}).call(this);
ret.join(" && ");
ret.prepend("(");
ret.add(")");
return ret;
}).call(this);
}
SPEC_DASHOPS["not="] = sf_DASHcompOp;
SPEC_DASHOPS["!="] = sf_DASHcompOp;
SPEC_DASHOPS["=="] = sf_DASHcompOp;
SPEC_DASHOPS["="] = sf_DASHcompOp;
SPEC_DASHOPS[">"] = sf_DASHcompOp;
SPEC_DASHOPS[">="] = sf_DASHcompOp;
SPEC_DASHOPS["<"] = sf_DASHcompOp;
SPEC_DASHOPS["<="] = sf_DASHcompOp;

//
function sf_DASHarithOp(ast,env) {
return (function() {
let ret;
ret= nodeTag(tnode(),ast);

transpileAtoms(ast,env);
let op,e1,cmd;
op= tnode();
e1= ast.shift();
cmd= e1.toString();

((cmd == "mod") ?
cmd="%" :
null);
((cmd == "div") ?
cmd="/" :
null);
((1 === ast.length) ?
(("-" == cmd) ?
ret.add("-") :
null) :
op.add([ "",cmd,"" ]));
ret.add(ast);
((ast.length > 1) ?
ret.join(op) :
null);
ret.prepend("(");
ret.add(")");
return ret;
}).call(this);
}
SPEC_DASHOPS["+"] = sf_DASHarithOp;
SPEC_DASHOPS["-"] = sf_DASHarithOp;
SPEC_DASHOPS["*"] = sf_DASHarithOp;
SPEC_DASHOPS["div"] = sf_DASHarithOp;
SPEC_DASHOPS["%"] = sf_DASHarithOp;
SPEC_DASHOPS["mod"] = sf_DASHarithOp;
SPEC_DASHOPS["||"] = sf_DASHarithOp;
SPEC_DASHOPS["&&"] = sf_DASHarithOp;
SPEC_DASHOPS["^"] = sf_DASHarithOp;
SPEC_DASHOPS["&"] = sf_DASHarithOp;
SPEC_DASHOPS["|"] = sf_DASHarithOp;
SPEC_DASHOPS["<<"] = sf_DASHarithOp;
SPEC_DASHOPS[">>"] = sf_DASHarithOp;
SPEC_DASHOPS[">>>"] = sf_DASHarithOp;

//
function sf_DASHrepeat(ast,env) {
return (function() {
let ret;
ret= nodeTag(tnode(),ast);

transpileAtoms(ast,env);
(function() {
for (let i=0,end=parseInt(ast[1]),____break=false; ((!____break)&&(i < end)); i=(i+1)){
((i !== 0) ?
ret.add(",") :
null);
ret.add(ast[2]);
}
}).call(this);
ret.prepend("[");
ret.add("]");
return ret;
}).call(this);
}
SPEC_DASHOPS["repeat-n"] = sf_DASHrepeat;

//
function transpileDo(ast,env) {
let G____15=Array.prototype.slice.call(arguments,2);
let G____16= G____15;
let return_QUERY;
return_QUERY=G____16[0];
return_QUERY=std.opt(return_QUERY,true);
let ret,e,end;
ret= nodeTag(tnode(),ast);
e= null;
end= (ast.length-1);

(function() {
for (let i=0,____break=false; ((!____break)&&(i < end)); i=(i+1)){
e=ast[i];
ret.add([ transpileList(e,env),";\n" ]);
}
}).call(this);
ret.add(";");
return ((end >= 0) ?
(function() {
e=transpile_STAR(ast[end],env);
return ((!return_QUERY) ?
ret.add([ e,";\n" ]) :
ret.add([ "return ",e,";\n" ]));
}).call(this) :
null);
}

//
function sf_DASHdo(ast,env) {
let ret;
ret= nodeTag(tnode(),ast);

ret.add("(function() {\n".toString());
ret.add(transpileDo(ast.slice(1),env));
ret.add("}).call(this)".toString());
return ret;
}
SPEC_DASHOPS["do"] = sf_DASHdo;

//
function sf_DASHcase(ast,env) {
return (function() {
let ret;
ret= nodeTag(tnode(),ast);

let tst,_x,e,t,c,dft;
tst= ast[1];
_x= gensym();
e= null;
t= null;
c= null;
dft= null;

((!(0 === (ast.length%2))) ?
dft=ast.pop() :
null);
(function() {
for (let i=2,____break=false; ((!____break)&&(i < ast.length)); i=(i+2)){
(c=ast[(i+1)],e=ast[i]);
(std.list_QUERY(e) ?
(function() {
for (let j=0,____break=false; ((!____break)&&(j < e.length)); j=(i+1)){
ret.add([ "case ",transpileSingle(e[j]),":\n" ]);
((j === (e.length-1)) ?
ret.add([ _x,"=",transpile_STAR(c,env),";\nbreak;\n" ]) :
null);
}
}).call(this) :
(function() {
ret.add([ "case ",transpileSingle(e),":\n" ]);
return ret.add([ _x,"=",transpile_STAR(c,env),";\nbreak;\n" ]);
}).call(this));
}
}).call(this);
(dft ?
(function() {
ret.add("default:\n");
return ret.add([ _x,"=",transpile_STAR(dft,env),";\nbreak;\n" ]);
}).call(this) :
null);
ret.prepend([ "switch (",transpile_STAR(tst,env),") {\n" ]);
ret.add("}\n");
ret.prepend([ "(function() { let ",_x,";\n" ]);
ret.add([ "return ",_x,";}).call(this)" ]);
return ret;
}).call(this);
}
SPEC_DASHOPS["case"] = sf_DASHcase;

//
function sf_DASHrange(ast,env) {
return (function() {
let ret;
ret= nodeTag(tnode(),ast);

let len,start,step,end;
len= 0;
start= 0;
step= 1;
end= 0;

transpileAtoms(ast,env);
len=ast.length;
end=parseInt(ast[1]);
((len > 2) ?
(function() {
start=parseInt(ast[1]);
return end=parseInt(ast[2]);
}).call(this) :
null);
((len > 3) ?
step=parseInt(ast[3]) :
null);
(function() {
for (let i=start,____break=false; ((!____break)&&(i < end)); i=(i+step)){
((i !== start) ?
ret.add(",") :
null);
ret.add(i.toString());
}
}).call(this);
ret.prepend("[");
ret.add("]");
return ret;
}).call(this);
}
SPEC_DASHOPS["range"] = sf_DASHrange;

//
function sf_DASHvardefs(ast,env,cmd) {
return (function() {
let ret;
ret= nodeTag(tnode(),ast);

let kks,public_QUERY;
kks= {};
public_QUERY= ("global" == cmd);

((!("let" == cmd)) ?
cmd="var" :
null);
(function() {
for (let i=1,s=null,____break=false; ((!____break)&&(i < ast.length)); i=(1+i)){
s=transpileSingle(ast[i]);
ret.add([s,"=undefined"].join(""));
kks[s]=null;
}
}).call(this);
(function() {
let G__3;
G__3= ret;

G__3.join(",");
G__3.prepend([cmd," "].join(""));
G__3.add(";\n");
return G__3;
}).call(this);
((public_QUERY&&(1 === rt.globalEnv().countNSPCache())) ?
(function() {
let G__4;
G__4= kks;

return Object.entries(G__4).forEach(function (e) {
return (function (v,k) {
return EXTERNS[k]=k;
})(e[1],e[0]);
});
}).call(this) :
null);
return ret;
}).call(this);
}

//
function local_DASHvardefs(ast,env) {
return sf_DASHvardefs(ast,env,"local");
}
SPEC_DASHOPS["def~-"] = local_DASHvardefs;

//
function global_DASHvardefs(ast,env) {
return sf_DASHvardefs(ast,env,"global");
}
SPEC_DASHOPS["def~"] = global_DASHvardefs;

//
function let_DASHvardefs(ast,env) {
return sf_DASHvardefs(ast,env,"let");
}
SPEC_DASHOPS["var~"] = let_DASHvardefs;

//
function sf_DASHvar(ast,env,cmd) {
return (function() {
let ret;
ret= nodeTag(tnode(),ast);

let vname,keys,kks,public_QUERY;
vname= null;
keys= [];
kks= {};
public_QUERY= ("global" == cmd);

ast=ast.slice(1);
((public_QUERY||("local" == cmd)) ?
cmd="var" :
null);
(function() {
for (let i=0,____break=false; ((!____break)&&(i < ast.length)); i=(i+2)){
(std.symbol_QUERY(ast[i]) ?
std.conj_BANG(keys,ast[i]) :
null);
}
}).call(this);
ret.add(";\n");
(std.not_DASHempty(keys) ?
ret.add([ "let ",keys.map(function (s) {
let ss;
ss= transpileSingle(s);

kks[ss]=null;
return ss;
}).join(","),";\n" ]) :
null);
(function() {
for (let i=0,rc=null,lhs=null,rhs=null,____break=false; ((!____break)&&(i < ast.length)); i=(i+2)){
(lhs=ast[i],rhs=ast[(i+1)]);
(std.symbol_QUERY(lhs) ?
ret.add([ transpileSingle(lhs),"= ",transpile_STAR(rhs,env),";\n" ]) :
(function() {
rc=destruct0(cmd,lhs,rhs,env);
ret.add(rc[0]);
return rc[1].map(function (s) {
return kks[rdr.jsid(s)]=null;
});
}).call(this));
}
}).call(this);
ret.add(";");
((public_QUERY&&(1 === rt.globalEnv().countNSPCache())) ?
(function() {
return   (function() {
let G__5;
G__5= kks;

return Object.entries(G__5).forEach(function (e) {
return (function (v,k) {
return EXTERNS[k]=k;
})(e[1],e[0]);
});
}).call(this);
}).call(this) :
null);
return ret;
}).call(this);
}

//
function sf_DASHvar_DASHlocal(ast,env) {
return sf_DASHvar(ast,env,"local");
}
SPEC_DASHOPS["def-"] = sf_DASHvar_DASHlocal;

//
function sf_DASHvar_DASHglobal(ast,env) {
return sf_DASHvar(ast,env,"global");
}
SPEC_DASHOPS["def"] = sf_DASHvar_DASHglobal;

//
function sf_DASHvar_DASHlet(ast,env) {
return sf_DASHvar(ast,env,"let");
}
SPEC_DASHOPS["var"] = sf_DASHvar_DASHlet;

//
function sf_DASHinst_QUERY(ast,env) {
return (function() {
let ret;
ret= nodeTag(tnode(),ast);

ret.add([ "(",transpile_STAR(ast[2],env)," instanceof ",transpile_STAR(ast[1],env),")" ]);
return ret;
}).call(this);
}
SPEC_DASHOPS["inst?"] = sf_DASHinst_QUERY;

//
function sf_DASHdelete(ast,env) {
return (function() {
let ret;
ret= nodeTag(tnode(),ast);

ret.add([ "delete ",transpile_STAR(ast[1],env) ]);
((ast.length > 2) ?
ret.add([ "[",transpile_STAR(ast[2]),"]" ]) :
null);
return ret;
}).call(this);
}
SPEC_DASHOPS["delete!"] = sf_DASHdelete;

//
function sf_DASHnew(ast,env) {
return (function() {
let ret;
ret= nodeTag(tnode(),ast);

ret.add(transpileList(ast.slice(1),env));
ret.prepend("new ");
return ret;
}).call(this);
}
SPEC_DASHOPS["new"] = sf_DASHnew;

//
function sf_DASHthrow(ast,env) {
return (function() {
let ret;
ret= nodeTag(tnode(),ast);

ret.add([ "throw ",transpile_STAR(ast[1],env),";" ]);
ret.prepend("(function (){ ");
ret.add(" })(this)");
return ret;
}).call(this);
}
SPEC_DASHOPS["throw"] = sf_DASHthrow;

//
function sf_DASHx_DASHopop(ast,env) {
transpileAtoms(ast,env);
return nodeTag(tnodeEx([ ast[0],ast[1] ]),ast);
}
SPEC_DASHOPS["++"] = sf_DASHx_DASHopop;
SPEC_DASHOPS["--"] = sf_DASHx_DASHopop;

//
function sf_DASHx_DASHeq(ast,env) {
transpileAtoms(ast,env);
return nodeTag(tnodeEx([ ast[1]," ",ast[0]," ",ast[2] ]));
}
SPEC_DASHOPS["+="] = sf_DASHx_DASHeq;
SPEC_DASHOPS["-="] = sf_DASHx_DASHeq;
SPEC_DASHOPS["*="] = sf_DASHx_DASHeq;
SPEC_DASHOPS["/="] = sf_DASHx_DASHeq;
SPEC_DASHOPS["%="] = sf_DASHx_DASHeq;
SPEC_DASHOPS["<<="] = sf_DASHx_DASHeq;
SPEC_DASHOPS[">>="] = sf_DASHx_DASHeq;
SPEC_DASHOPS[">>>="] = sf_DASHx_DASHeq;
SPEC_DASHOPS["&="] = sf_DASHx_DASHeq;
SPEC_DASHOPS["|="] = sf_DASHx_DASHeq;
SPEC_DASHOPS["^="] = sf_DASHx_DASHeq;

//
function sf_DASHset_DASHin(ast,env) {
((0 === (ast.length%2)) ?
true :
(function (){ throw new Error("set-in: bad arg count"); })(this));
return (function() {
let ret;
ret= nodeTag(tnode(),ast);

let obj;
obj= transpile_STAR(ast[1],env);

(function() {
for (let i=2,____break=false; ((!____break)&&(i < ast.length)); i=(i+2)){
((i > 2) ?
ret.add(",") :
null);
ret.add([ obj,"[",transpile_STAR(ast[i],env),"]","=",transpile_STAR(ast[(i+1)],env) ]);
}
}).call(this);
return ret;
}).call(this);
}
SPEC_DASHOPS["set-in!"] = sf_DASHset_DASHin;

//
function sf_DASHset(ast,env) {
((!(0 === (ast.length%2))) ?
true :
(function (){ throw new Error("set: bad arg count"); })(this));
let more,ret;
more= false;
ret= nodeTag(tnode(),ast);

(function() {
for (let i=1,____break=false; ((!____break)&&(i < ast.length)); i=(i+2)){
((i > 1) ?
(function() {
ret.add(",");
return more=true;
}).call(this) :
null);
ret.add([ transpile_STAR(ast[i],env),"=",transpile_STAR(ast[(i+1)],env) ]);
}
}).call(this);
(more ?
(function() {
ret.prepend("(");
return ret.add(")");
}).call(this) :
null);
return ret;
}
SPEC_DASHOPS["set!"] = sf_DASHset;

//
function parseFuncArgs(args) {
return (function() {
let ret;
ret= [];

(function() {
for (let i=0,e=null,ev=null,____break=false; ((!____break)&&(i < args.length)); i=(i+1)){
(e=args[i],ev=e.toString());
(std.symbol_QUERY(e) ?
((ev === "_") ?
std.conj_BANG(ret,std.symbol(gensym("_"))) :
((ev === "&") ?
(function() {
e=args[(i+1)];
(std.symbol_QUERY(e) ?
std.conj_BANG(ret,[ e,i,e ]) :
std.conj_BANG(ret,[ std.symbol(["&",gensym()].join("")),i,e ]));
return ++i;
}).call(this) :
(ev.startsWith("&") ?
(function() {
e=std.symbol(ev.slice(1));
return std.conj_BANG(ret,[ e,i,e ]);
}).call(this) :
(true ?
std.conj_BANG(ret,e) :
null)))) :
(std.keyword_QUERY(e) ?
(function (){ throw new Error([ "bad function args destructure: ",std.typeid(e) ].join("")); })(this) :
(Array.isArray(e) ?
std.conj_BANG(ret,[ std.symbol(gensym()),i,e ]) :
(true ?
(function (){ throw new Error([ "bad function args destructure: ",std.typeid(e) ].join("")); })(this) :
null))));
}
}).call(this);
return ret;
}).call(this);
}

//
function handleFuncArgs(fargs,env) {
return (function() {
let out;
out= [];

let misc,keys,ret,knode;
misc= [];
keys= [];
ret= tnode();
knode= tnode();

fargs.forEach(function (arg) {
return (std.symbol_QUERY(arg) ?
std.conj_BANG(keys,arg) :
((std.symbol_QUERY(arg[0])&&(!arg[0].toString().startsWith("&"))&&Array.isArray(arg[2])) ?
(function() {
std.conj_BANG(keys,arg[0]);
return std.conj_BANG(misc,arg);
}).call(this) :
(true ?
std.conj_BANG(misc,arg) :
null)));
});
misc.forEach(function (arr) {
let a0,name,varg_QUERY,pos,a2;
a0= arr[0];
name= a0.toString();
varg_QUERY= name.startsWith("&");
pos= arr[1].toString();
a2= arr[2];

(varg_QUERY ?
name=name.slice(1) :
null);
name=rdr.jsid(name);
return ((std.symbol_QUERY(a0)&&std.symbol_QUERY(a2)) ?
ret.add([ "let ",name,"=Array.prototype.slice.call(arguments,",pos,");\n" ]) :
(Array.isArray(a2) ?
(function() {
(varg_QUERY ?
ret.add([ "let ",name,"=Array.prototype.slice.call(arguments,",pos,");\n" ]) :
null);
return ret.add(destruct0("let",a2,name,env)[0]);
}).call(this) :
null));
});
knode.add(keys.map(function () {
let ____args;
____args= Array.prototype.slice.call(arguments);

return rdr.jsid(____args[0].toString());
}).join(","));
std.conj_BANG(out,knode);
std.conj_BANG(out,ret);
return out;
}).call(this);
}

//
function sf_DASHfn(ast,env) {
return (function() {
let ret;
ret= nodeTag(tnode(),ast);

let args,fargs,hints,body;
args= ast[1];
fargs= null;
hints= {};
body= ast.slice(2);

(((3 === args.length)&&("with-meta" == args[0])&&Array.isArray(args[1])) ?
(function() {
hints=resolveMeta(args[2],env);
return args=args[1];
}).call(this) :
null);
fargs=handleFuncArgs(parseFuncArgs(args),env);
ret.add("function (");
ret.add(fargs[0]);
ret.add([ ") {\n",fargs[1],transpileDo(body,env),"}" ]);
return ret;
}).call(this);
}
SPEC_DASHOPS["fn"] = sf_DASHfn;

//
function fmtRegoSpecOps(alias,fname) {
return [rdr.jsid("SPEC-OPS"),"[\"",alias,"\"] = ",fname].join("");
}

//
function fmtSpecOps(fname,attrs) {
let ks,out;
ks= (attrs["opcode"]||[]);
out= ks.map(function () {
let ____args;
____args= Array.prototype.slice.call(arguments);

return fmtRegoSpecOps(____args[0].toString(),fname);
}).join(";\n");

return (std.not_DASHempty(ks) ?
[out,";\n"].join("") :
out);
}

//
function sf_DASHfunc(ast,env,public_QUERY) {
return (function() {
let ret;
ret= nodeTag(tnode(),ast);

let fname,mtd_QUERY,dot_QUERY,hints,fargs,e3,e2,doc,attrs,args,body;
fname= transpile_STAR(ast[1],env);
mtd_QUERY= (ast[0] == "method");
dot_QUERY= fname.includes(".");
hints= {};
fargs= null;
e3= ast[3];
e2= ast[2];
doc= null;
attrs= null;
args= 2;
body= 3;

((typeof(e2) === "string") ?
(function() {
(doc=2,args=3);
return (std.map_QUERY(e3) ?
(function() {
return (attrs=3,args=4);
}).call(this) :
null);
}).call(this) :
(std.map_QUERY(e2) ?
(function() {
return (attrs=2,args=3);
}).call(this) :
null));
body=(args+1);
(doc ?
doc=ast[doc] :
null);
(attrs ?
attrs=ast[attrs] :
null);
(args=ast[args],body=ast.slice(body));
(((3 === args.length)&&("with-meta" == args[0])&&Array.isArray(args[1])) ?
(function() {
return (hints=resolveMeta(args[2],env),args=args[1]);
}).call(this) :
null);
fargs=handleFuncArgs(parseFuncArgs(args),env);
(mtd_QUERY ?
(function() {
(hints.static ?
ret.add("static ") :
null);
return ret.add([ fname," (" ]);
}).call(this) :
(dot_QUERY ?
ret.add([ fname," = function (" ]) :
(true ?
ret.add(["function ",fname,"("].join("")) :
null)));
ret.add(fargs[0]);
ret.add([ ") {\n",fargs[1],transpileDo(body,env),"}\n" ]);
((!(0 === kirbystdlibref.count(hints))) ?
ret.add(fmtSpecOps(fname,hints)) :
null);
(doc ?
(function() {
doc=doc.replace(rdr.REGEX.dquoteHat,"").replace(rdr.REGEX.dquoteEnd,"");
return ret.prepend(doc.split("\\n").map(function () {
let ____args;
____args= Array.prototype.slice.call(arguments);

return ["//",____args[0],"\n"].join("");
}));
}).call(this) :
null);
((public_QUERY&&(!dot_QUERY)&&(1 === rt.globalEnv().countNSPCache())) ?
EXTERNS[fname]=fname :
null);
return ret;
}).call(this);
}

//
function sf_DASHfunc_DASHprivate(ast,env) {
return sf_DASHfunc(ast,env,false);
}
SPEC_DASHOPS["defn-"] = sf_DASHfunc_DASHprivate;

//
function sf_DASHfunc_DASHpublic(ast,env) {
return sf_DASHfunc(ast,env,true);
}
SPEC_DASHOPS["defn"] = sf_DASHfunc_DASHpublic;

//
function sf_DASHtry(ast,env) {
return (function() {
let ret;
ret= nodeTag(tnode(),ast);

let sz,t,f,c;
sz= ast.length;
t= null;
f= null;
c= null;

f=std.last(ast);
((Array.isArray(f)&&("finally" == f[0])) ?
(f=ast.pop(),sz=ast.length) :
f=null);
c=null;
((sz > 1) ?
c=ast[(sz-1)] :
null);
((Array.isArray(c)&&("catch" == c[0])) ?
(function() {
(((c.length < 2)||(!std.symbol_QUERY(c[1]))) ?
syntax_BANG("e0",ast) :
null);
return c=ast.pop();
}).call(this) :
c=null);
(((f === null)&&(c === null)) ?
syntax_BANG("e0",ast) :
null);
ret.add([ "(function() {\ntry {\n",transpileDo(ast.slice(1),env),"\n}" ]);
(c ?
(function() {
t=c[1];
return ret.add([ ["catch (",t,") {\n"].join(""),transpileDo(c.slice(2),env),";\n}\n" ]);
}).call(this) :
null);
(f ?
(function() {
return ret.add([ "finally {\n",transpileDo(f.slice(1),env,false),";\n}\n" ]);
}).call(this) :
null);
ret.add("}).call(this)");
return ret;
}).call(this);
}
SPEC_DASHOPS["try"] = sf_DASHtry;

//
function sf_DASHif(ast,env) {
return (function() {
let ret;
ret= nodeTag(tnode(),ast);

let a1,a2,a3;
a1= ast[1];
a2= ast[2];
a3= ((ast.length > 3) ?
ast[3] :
null);

ret.add([ "(",transpile_STAR(a1,env)," ?\n",transpile_STAR(a2,env)," :\n",(transpile_STAR(a3,env)||"null"),")" ]);
return ret;
}).call(this);
}
SPEC_DASHOPS["if"] = sf_DASHif;

//
function sf_DASHnth(ast,env) {
return (function() {
let ret;
ret= nodeTag(tnode(),ast);

transpileAtoms(ast,env);
ret.add([ ast[1],"[",ast[2],"]" ]);
return ret;
}).call(this);
}
SPEC_DASHOPS["nth"] = sf_DASHnth;

//
function sf_DASHget(ast,env) {
return (function() {
let ret;
ret= nodeTag(tnode(),ast);

transpileAtoms(ast,env);
ret.add([ ast[1],"[",ast[2],"]" ]);
return ret;
}).call(this);
}
SPEC_DASHOPS["aget"] = sf_DASHget;
SPEC_DASHOPS["get"] = sf_DASHget;

//
function sf_DASHstr(ast,env) {
return (function() {
let ret;
ret= nodeTag(tnode(),ast);

let args;
args= ast.slice(1);

transpileAtoms(args,env);
((args.length > 1) ?
(function() {
let G__6;
G__6= ret;

G__6.add(args);
G__6.join(",");
G__6.prepend("[");
G__6.add("].join(\"\")");
return G__6;
}).call(this) :
(std.not_DASHempty(args) ?
ret.add([ "",args[0],".toString()" ]) :
null));
return ret;
}).call(this);
}
SPEC_DASHOPS["str"] = sf_DASHstr;

//
function sf_DASHarray(ast,env) {
return (function() {
let ret;
ret= nodeTag(tnode(),ast);

let epilog;
epilog= "\n]";

((0 === kirbystdlibref.count(ast)) ?
ret.add("[]") :
(function() {
((!std.vector_QUERY(ast)) ?
ast.splice(0,1) :
null);
transpileAtoms(ast,env);
ret.add("[\n");
(function() {
for (let i=0,____break=false; ((!____break)&&(i < ast.length)); i=(i+1)){
((i > 0) ?
ret.add(",\n") :
null);
ret.add(ast[i]);
}
}).call(this);
return ret.add(epilog);
}).call(this));
return ret;
}).call(this);
}
SPEC_DASHOPS["vec"] = sf_DASHarray;

//
function sf_DASHobject(ast,env) {
return (function() {
let ret;
ret= nodeTag(tnode(),ast);

let epilog;
epilog= "\n}";

((0 === kirbystdlibref.count(ast)) ?
ret.add("{}") :
(function() {
((!std.map_QUERY(ast)) ?
ast.splice(0,1) :
null);
transpileAtoms(ast,env);
ret.add("{\n");
(function() {
for (let i=0,____break=false; ((!____break)&&(i < ast.length)); i=(i+2)){
((i > 0) ?
ret.add(",\n") :
null);
ret.add([ ast[i],": ",ast[(i+1)] ]);
}
}).call(this);
return ret.add(epilog);
}).call(this));
return ret;
}).call(this);
}
SPEC_DASHOPS["hashmap"] = sf_DASHobject;

let includeFile;
includeFile= (function () {
let icache;
icache= [];

return function (fname) {
return (std.contains_QUERY(icache,fname) ?
tnode() :
(function() {
let src;
src= fs.readFileSync(fname,"utf-8");

std.conj_BANG(icache,fname);
return transpileTree(psr.parser(src,fname),rt.globalEnv());
}).call(this));
};
})();

//
function sf_DASHinclude(ast,env) {
let ret,fname,dir;
ret= [];
fname= null;
dir= path.dirname(ast.source);

(function() {
for (let i=1,e=null,____break=false; ((!____break)&&(i < ast.length)); i=(i+1)){
e=ast[i];
(((!Array.isArray(e))||(1 !== e.length)) ?
syntax_BANG("e0",ast) :
null);
fname=e[0];
(fname ?
fname=fname.replace(/[\"]/g,"") :
null);
(function() {
try {
return fname=fs.realpathSync([dir,"/",fname].join(""));

} catch (e) {
return syntax_BANG("e11",ast);

}
}).call(this);
(function() {
try {
return std.conj_BANG(ret,includeFile(fname));

} finally {
rt.globalEnv().popNSP();

}
}).call(this);
}
}).call(this);
return ((0 === kirbystdlibref.count(ret)) ?
tnode() :
ret);
}

//
function sf_DASHrequire(ast,env) {
return (function() {
let ret;
ret= nodeTag(tnode(),ast);

let path=undefined,v=undefined,e=undefined,refers=undefined,renames=undefined;

let as;
as= null;

(function() {
for (let i=1,____break=false; ((!____break)&&(i < ast.length)); i=(i+1)){
(e=ast[i],as=gensym());
(refers=null,renames=null);
(((!Array.isArray(e))||(e.length < 3)) ?
syntax_BANG("e0",ast) :
null);
path=e[0];
(function() {
for (let j=1,____break=false; ((!____break)&&(j < e.length)); j=(j+1)){
v=e[j];
((v == "as") ?
(function() {
as=e[(j+1)].toString();
return ++j;
}).call(this) :
((v == "refer") ?
(function() {
refers=e[(j+1)];
return ++j;
}).call(this) :
((v == "rename") ?
(function() {
renames=e[(j+1)];
return ++j;
}).call(this) :
null)));
}
}).call(this);
ret.add(";");
ret.add([ "var ",rdr.jsid(as),"= require(",transpileSingle(path),");\n" ]);
(function() {
for (let i=0,____break=false; ((!____break)&&(refers&&(i < refers.length))); i=(i+1)){
v=transpileSingle(refers[i]);
ret.add([ "var ",v,"=",as,"[\"",v,"\"];\n" ]);
}
}).call(this);
ret.add(";");
(function() {
for (let i=0,____break=false; ((!____break)&&(renames&&(i < renames.length))); i=(i+2)){
e=transpileSingle(renames[i]);
v=transpileSingle(renames[(i+1)]);
ret.add([ "var ",v,"=",as,"[\"",e,"\"];\n" ]);
}
}).call(this);
ret.add(";");
}
}).call(this);
return ret;
}).call(this);
}

//
function resolveMeta(ast,env) {
return (Array.isArray(ast) ?
JSON.parse(["",transpile_STAR(ast,env)].join("")) :
(std.keyword_QUERY(ast) ?
JSON.parse(["",transpile_STAR(std.hashmap(ast,true),env)].join("")) :
(std.symbol_QUERY(ast) ?
JSON.parse(["",transpile_STAR(std.hashmap(std.symbol("tag"),ast),env)].join("")) :
(true ?
(function (){ throw new Error([ "Bad meta value",std.prn(ast) ].join("")); })(this) :
null))));
}

//
function sf_DASHns(ast,env) {
return (function() {
let ret;
ret= [];

let hints,nsp;
hints= {};
nsp= ast[1];

((Array.isArray(nsp)&&(3 === nsp.length)&&("with-meta" == nsp[0])&&std.symbol_QUERY(nsp[1])) ?
(function() {
hints=resolveMeta(nsp[2],env);
return nsp=nsp[1];
}).call(this) :
null);
rt.globalEnv().pushNSP(nsp.toString());
ast=ast.slice(2);
(function() {
for (let i=0,e=null,____break=false; ((!____break)&&(i < ast.length)); i=(i+1)){
e=ast[i];
((std.list_QUERY(e)&&("include" == e[0])) ?
std.conj_BANG(ret,sf_DASHinclude(e)) :
((std.list_QUERY(e)&&("require" == e[0])) ?
std.conj_BANG(ret,sf_DASHrequire(e)) :
null));
}
}).call(this);
nsp=rt.globalEnv().peekNSP();
(((nsp === "czlab.kirby.bl.macros")||(nsp === "czlab.kirby.bl.stdlib")) ?
null :
(nsp.startsWith("czlab.kirby.") ?
std.conj_BANG(ret,tnodeEx("const kirbystdlibref=std;\n")) :
(true ?
std.conj_BANG(ret,sf_DASHrequire([ std.symbol("require"),[ "\"kirby\"",std.keyword(":as"),std.symbol("kirbystdlibref") ] ])) :
null)));
return ret;
}).call(this);
}
SPEC_DASHOPS["ns"] = sf_DASHns;

//
function maybeStripStdlib(cmd) {
let nsp,lib;
nsp= rt.globalEnv().peekNSP();
lib= "kirbystdlibref.";

cmd=cmd.toString();
return ((cmd.startsWith(lib)&&(nsp === "czlab.kirby.bl.stdlib")) ?
cmd.slice(lib.length) :
cmd);
}

//
function sf_DASHcomment(ast,env) {
return nodeTag(tnode(),ast);
}
SPEC_DASHOPS["comment"] = sf_DASHcomment;

//
function sf_DASHfor(ast,env) {
return (function() {
let ret;
ret= nodeTag(tnode(),ast);

let body;
body= ast.slice(2);

((0 === kirbystdlibref.count(body)) ?
tnode() :
sf_DASHfloop(ret,ast[1],body,env));
return ret;
}).call(this);
}
SPEC_DASHOPS["for"] = sf_DASHfor;

//
function sf_DASHfloop(ret,args,body,env) {
let vars,recurs;
vars= [];
recurs= [];

let tst=undefined,nb=undefined,e=undefined;

(function() {
for (let i=0,____break=false; ((!____break)&&(i < args.length)); i=(i+1)){
e=args[i];
((e == "while") ?
(function() {
tst=args[(i+1)];
return ++i;
}).call(this) :
((e == "recur") ?
(function() {
recurs=args.slice((i+1));
return ____break=true;
}).call(this) :
(std.symbol_QUERY(e) ?
(function() {
std.conj_BANG(vars,e,args[(i+1)]);
return ++i;
}).call(this) :
null)));
}
}).call(this);
ret.add("for (");
(function() {
for (let i=0,____break=false; ((!____break)&&(i < vars.length)); i=(i+2)){
((i === 0) ?
ret.add("let ") :
null);
((i !== 0) ?
ret.add(",") :
null);
ret.add([ transpileSingle(vars[i]),"=",transpile_STAR(vars[(i+1)],env) ]);
}
}).call(this);
((0 === kirbystdlibref.count(vars)) ?
ret.add("let ____break=false;") :
ret.add(",____break=false;"));
nb=[ std.symbol("not"),std.symbol("____break") ];
(tst ?
tst=[ std.symbol("and"),nb,tst ] :
tst=nb);
ret.add(transpile_STAR(tst,env));
ret.add("; ");
(function() {
for (let i=0,k=0,____break=false; ((!____break)&&(i < recurs.length)); i=(i+1),k=(k+2)){
((i !== 0) ?
ret.add(",") :
null);
ret.add([ transpileSingle(vars[k]),"=",transpile_STAR(recurs[i],env) ]);
}
}).call(this);
return (function() {
let G__7;
G__7= ret;

G__7.add("){\n");
G__7.add(transpileDo(body,env,false));
G__7.add("}\n");
G__7.prepend("(function() {\n");
G__7.add("})(this)");
return G__7;
}).call(this);
}

//
function sf_DASHjscode(ast,env) {
return nodeTag(tnodeEx(ast[1].toString().replace(rdr.REGEX.dquoteHat,"").replace(rdr.REGEX.dquoteEnd,"")),ast);
}
SPEC_DASHOPS["js#"] = sf_DASHjscode;

//
function sf_DASHmacro(ast,env) {
let pms,args,body;
pms= [];
args= ast[2];
body= ast.slice(3);

((typeof(args) === "string") ?
(function() {
return (doc=args,args=ast[3],body=ast.slice(4));
}).call(this) :
null);
(function() {
for (let i=0,e=null,ev=null,____break=false; ((!____break)&&(i < args.length)); i=(i+1)){
(e=args[i],ev=e.toString());
((ev === "&") ?
(Array.isArray(args[(i+1)]) ?
(function() {
e=args[(i+1)];
++i;
return (function() {
for (let j=0,x=null,____break=false; ((!____break)&&(j < e.length)); j=(j+1)){
x=e[j];
((!std.symbol_QUERY(x)) ?
(function (){ throw new Error("Bad optional arg for macro"); })(this) :
null);
std.conj_BANG(pms,x);
}
}).call(this);
}).call(this) :
(function() {
std.conj_BANG(pms,e,args[(i+1)]);
return ++i;
}).call(this)) :
((!std.symbol_QUERY(e)) ?
(function (){ throw new Error("Bad optional arg for macro"); })(this) :
(true ?
std.conj_BANG(pms,e) :
null)));
}
}).call(this);
ast=[ ast[0],ast[1],[ std.symbol("fn*"),pms ].concat(body) ];
let a2,a1,func;
a2= ast[2];
a1= ast[1].toString();
func= rt.compute(a2,env);

func["____macro"]=true;
(doc ?
func["____doc"]=doc :
null);
rt.setMacro(a1,func);
return nodeTag(tnode(),ast);
}
SPEC_DASHOPS["defmacro"] = sf_DASHmacro;

//
function sf_DASHunary(ast,env) {
return (function() {
let ret;
ret= nodeTag(tnode(),ast);

let G____17= ast;
let a0,a1;
a0=G____17[0];
a1=G____17[1];

((a0 == "not") ?
a0=std.symbol("!") :
null);
ret.add([ "(",transpile_STAR(a0,env),transpile_STAR(a1,env),")" ]);
return ret;
}).call(this);
}
SPEC_DASHOPS["not"] = sf_DASHunary;
SPEC_DASHOPS["~"] = sf_DASHunary;
SPEC_DASHOPS["!"] = sf_DASHunary;

//
function sf_DASHdoseq(ast,env) {
return (function() {
let ret;
ret= nodeTag(tnode(),ast);

let args,body,escvar,idxvar,exprvar;
args= ast[1];
body= ast.slice(2);
let G____18= args;
let loopvar,loopexpr;
loopvar=G____18[0];
loopexpr=G____18[1];
escvar= gensym();
idxvar= gensym();
exprvar= gensym();

ret.add([ "let ",transpileSingle(loopvar),"= ",exprvar,"[",idxvar,"];\n" ]);
(function() {
for (let i=2,v=null,ev=null,____break=false; ((!____break)&&(i < args.length)); i=(i+1)){
(v=args[i],ev=v.toString());
((ev === "while") ?
ret.add([ "if (! ",transpile_STAR(args[(i+1)],env),") {",escvar,"=true;}\n" ]) :
((ev === "when") ?
(function() {
let G__8;
G__8= ret;

G__8.add([ "if (!",escvar,") {\n" ]);
G__8.add([ "if (! ",transpile_STAR(args[(i+1)],env),") {continue;}\n" ]);
G__8.add("}\n");
return G__8;
}).call(this) :
((ev === "let") ?
ret.add(sf_DASHvar_DASHlet([ std.symbol("var") ].concat(args[(i+1)]),env)) :
null)));
}
}).call(this);
(function() {
let G__9;
G__9= ret;

G__9.add([ "if (!",escvar,") {\n" ]);
G__9.add(transpileDo(body,env,false));
G__9.add("}\n");
G__9.add("}\n");
G__9.prepend([ "for(let ",escvar,"=false,",idxvar,"=0; ","(!",escvar," && ",idxvar," < ",exprvar,".length); ++",idxvar,") {\n" ]);
G__9.prepend([ "let ",exprvar,"= ",transpile_STAR(loopexpr,env),";\n" ]);
G__9.prepend("(function() {\n");
G__9.add("})(this);\n");
return G__9;
}).call(this);
return ret;
}).call(this);
}
SPEC_DASHOPS["doseq"] = sf_DASHdoseq;

//
function spitExterns() {
return (function() {
let s;
s= "";

let ks;
ks= Object.keys(EXTERNS);

(std.not_DASHempty(ks) ?
(function() {
s=ks.map(function () {
let ____args;
____args= Array.prototype.slice.call(arguments);

return [____args[0],": ",____args[0]].join("");
}).join(",\n");
return s=["\n\nmodule.exports = {\n",s,"\n};\n\n"].join("");
}).call(this) :
null);
return s;
}).call(this);
}

//
function banner() {
return ["/*","Auto generated by Kirby - v",MODULE_VERSION," ",rt.globalEnv().firstNSP()," - ",new Date(),"*/\n\n"].join("");
}

//
function cleanCode(code) {
let arr;
arr= [];

code.split("\n").forEach(function (s) {
s=s.trim();
return ((s !== ";") ?
std.conj_BANG(arr,s) :
null);
});
return arr.join("\n");
}

//
function transpileCode(codeStr,fname,srcMap_QUERY) {
rt.globalEnv().resetNSPCache();
EXTERNS={};
let outNode,options,cstr,extra;
outNode= transpileTree(psr.parser(codeStr,fname),rt.globalEnv());
options= {};
cstr= "";
extra= spitExterns();

outNode.prepend(banner());
cstr=(srcMap_QUERY ?
(function() {
let outFile,srcMap,output;
outFile= [path.basename(fname,".ky"),".js"].join("");
srcMap= [outFile,".map"].join("");
output= outNode.toStringWithSourceMap({ "file": outFile });

fs.writeFileSync(srcMap,output.map);
return [output.code,extra,"\n//# sourceMappingURL=",path.relative(path.dirname(fname),srcMap)].join("");
}).call(this) :
[outNode,extra].join(""));
cstr=cleanCode(cstr);
return (false ?
esfmt.format(cstr,options) :
cstr);
}

//
function transpileXXX(code,file,smap_QUERY) {
return (function() {
try {
return transpileCode(code,file,smap_QUERY);

} catch (e) {
return (e ?
(function() {
(console ?
console.log([ e.stack ].join("")) :
null);
return (function (){ throw e; })(this);
}).call(this) :
null);

}
}).call(this);
}

//
function transpileWithSrcMap(code,file) {
return transpileXXX(code,file,true);
}

//
function transpile(code,file) {
return transpileXXX(code,file,false);
}

//
function parseWithSourceMap(codeStr,fname) {
let outNode;
outNode= transpileTree(psr.parser(codeStr,fname));

outNode.prepend(banner());
return outNode.toStringWithSourceMap();
}

let version;
version= MODULE_VERSION;



module.exports = {
transpileWithSrcMap: transpileWithSrcMap,
transpile: transpile,
parseWithSourceMap: parseWithSourceMap,
version: version
};

