;; Copyright (c) 2013-2017, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author ""}
  czlab.kirby.transpiler
  (require ["../bl/macros" :as macros]
           ["../bl/types" :as types]
           ["../bl/stdlib" :as std]
           ["../bl/tnode" :as tn]
           ["../bl/lexer" :as rdr]
           ["../bl/parser" :as psr]
           ["../rt/runtime" :as rt]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- tnodeEx tn.tnodeEx)
(def- tnode tn.tnode)
(def- gensym-counter 1)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- ERRORS_MAP {
  :e0 "Syntax Error"
  :e1 "Empty statement"
  :e2 "Invalid characters in function name"
  :e3 "End of File encountered, unterminated string"
  :e4 "Closing square bracket, without an opening square bracket"
  :e5 "End of File encountered, unterminated array"
  :e6 "Closing curly brace, without an opening curly brace"
  :e7 "End of File encountered, unterminated javascript object '}'"
  :e8 "End of File encountered, unterminated parenthesis"
  :e9 "Invalid character in var name"
  :e10 "Extra chars at end of file. Maybe an extra ')'."
  :e11 "Cannot Open include File"
  :e12 "Invalid no of arguments to "
  :e13 "Invalid Argument type to "
  :e14 "End of File encountered, unterminated regular expression"
  :e15 "Invalid vararg position, must be last argument."
  :e16 "Invalid arity (args > expected) to "
  :e17 "Invalid arity (args < expected) to "})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- RESERVED {
  :compare ["not=" "!=" "==" "=" ">" ">=" "<" "<="]
  :arith ["+" "-" "*" "/" "%"  "mod"]
  :logic ["||" "&&"]
  :bitwise ["^" "&" "|" "<<" ">>" ">>>"]
  :incdec ["++" "--"]
  :unary ["not"  "~" "!"]
  :assign ["+=" "-=" "*="
         "/=" "%=" "<<="
         ">>=" ">>>=" "&=" "|=" "^="]
  :builtin
  ["quote" "syntax-quote" "quasi-quote"
  "backtick"  "unquote" "unquote-splice"
  "repeat-n"  "do"  "doto"  "case" "apply"
  "range"  "def-"  "def"  "var"  "forlet"
  "new"  "throw"  "while"  "lambda"
  "inst?"  "delete!"
  "aset"  "set!"  "fn"  "def!"
  "defn-"  "defn"
  "try"  "if"  "get"  "aget"  "str"
  "list"  "["  "vec"  "{"  "hash-map"
  "ns"  "comment"  "for"  "cons"
  "js#"  "macro"  "defmacro"]})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- MODULE_VERSION "1.0.0"
    nosemi? false
    tabspace 2
    indent (- tabspace)
    EXTERNS nil
    NSPACES nil
    SPEC_OPS {})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- gensym "" [& [pfx]]
  (var x gensym-counter)
  (++ gensym-counter)
  (str (or pfx "G____") x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- regoBuiltins "" [f group]
  (each (fn [k] (set! SPEC_OPS k f)) (get RESERVED group)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- error! "" [e line file msg]
  (std.raise! (get ERRORS_MAP e)
              (if msg (str " : " msg) "")
              (if line (str "\nLine no " line) "")
              (if file (str "\nFile " file) "")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- syntax! "" [ecode ast cmd]
  (error! ecode
          (if ast ast.line 0)
          (if ast ast.source 0) cmd))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- pad "" [z] (.repeat " " z))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- testre? "" [re x] (if x (.test re x) false))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- nodeTag "" [obj src]
  (when (and obj
             src
             (not= (type obj) "boolean")
             (not= (type obj) "number"))
    (set! obj.source src.source)
    (set! obj.column src.column)
    (set! obj.line src.line))
  obj)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destruct1 "" [lhs]
  (var as "" out [] keys {})
  (cond
    (types.vector? lhs)
    (forlet ((i 0 e nil)
             (< i (alen lhs)) (i (inc i)))
      (set! e (nth lhs i))
      (cond
        (types.symbol? e)
        (cond
          (== e "_") nil
          (== e "&") (do (set! keys
                               (str "&" (nth lhs (inc i))) i)
                         (++ i))
          (.startWith (str e) "&")
          (set! keys (str e) i)
          :else
          (set! keys (str e) i))
        (types.keyword? e)
        (if (== e "as")
          (do (++ i)
              (set! as (str (nth lhs i))))
          (std.raise! "bad keyword: " e))))
    (types.map? lhs)
    (forlet ((i 0 e nil)
             (< i (alen lhs)) (i (inc i)))
      (set! e (nth lhs i))
      (if (types.keyword? e)
        (cond
          (or (== e "keys")
              (== e "strs"))
          (let [ks (nth lhs (inc i))]
            (++ i)
            (forlet ((j 0)
                     (< j (alen ks)) (j (inc j)))
              (set! keys (str (nth ks j)) nil)))
          (== e "as")
          (do (++ i)
              (set! as (str (nth lhs i)))))
        (std.raise! "bad destruct field: "
                    (types.obj-type e))))
    (types.symbol? lhs)
    (set! keys (str lhs) nil)
    :else
    (std.raise! "cant destruct with: " (types.obj-type lhs)))
  ;;return
  [as keys])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destruct0 "" [cmd lhs rhs env]
  (var d (destruct1 lhs)
       as (nth d 0)
       kdefs []
       ka nil
       kvals (tnode)
       keys (nth d 1))
  (if (empty? as) (set! as (gensym)))
  (set! as (rdr.jsid as))
  (each (fn [x]
          (var name (nth x 0)
               n nil
               pos nil
               rest false)
          (when (.startsWith name "&")
            (set! rest true)
            (set! name (.slice name 1)))
          (set! n (rdr.jsid name))
          (.push kdefs n)
          (set! pos (nth x 1))
          (cond
            (nil? pos)
            (set! ka (str n "=" as "[\"" name "\"];\n"))
            rest
            (set! ka (str n "=" as ".slice(" pos ");\n"))
            :else
            (set! ka (str n "=" as "[" pos "];\n")))
          (.add kvals ka))
        (Object.entries keys))
  (.prepend kvals (str cmd " " (.join kdefs ",") ";\n"))
  [(tnodeEx [cmd " "
             (rdr.jsid as) "= "
             (transpile* rhs env) ";\n"]) kvals])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileTree "" [root env]
  (do-with [ret (nodeTag (tnode) root)]
    (var pstr ""
         endx (eindex root)
         treeSize (alen root))
    (+= indent tabspace)
    (set! pstr (pad indent))
    (each (fn [ast]
            (var tmp ast)
            (if (std.array? ast)
              (set! tmp (transpileList ast env)))
            (when tmp
              (.add ret [pstr tmp (if nosemi? ""  ";") "\n"])
              (set! nosemi? false))) root)
    (-= indent tabspace)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileAtoms "" [atoms env]
  (each (fn [a i arr]
          (set! arr
                i
                (if (std.array? a)
                  (transpileList a env)
                  (transpileSingle a)))) atoms))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileSingle "" [a]
  (cond
    (types.symbol? a)
    (.jsid rdr (types.symbol-s a))
    (types.keyword? a)
    (str "\"" (types.keyword-s a) "\"")
    (types.lambda-arg? a)
    (str "____args[" (types.lambda-arg-s a) "]")
    (std.string? a)
    a
    (nil? a)
    "null"
    :else
    (str "" a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpile* "" [x env]
  (if (std.array? x)
         (transpileList x env) (transpileSingle x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- findCmd "" [ast]
  (do-with [cmd ""]
    (cond
      (types.vector? ast) (set! cmd "[")
      (types.map? ast) (set! cmd "{")
      (types.list? ast) (set! cmd (types.symbol-s (first ast))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileList "" [ast env]
  (var cmd (findCmd ast)
       mc (.get macros cmd) tmp nil)
  (do-with [ret (tnode)]
    (when mc
      (set! ast (.expandMacro rt ast env mc))
      (set! cmd (findCmd ast)))
    (cond
      (.startsWith cmd ".-")
      (.add ret [(transpile* (second ast) env)
                 "."
                 (transpileSingle (types.symbol (.slice cmd 2))) ])
      (= "." (.charAt cmd 0))
      (do (.add ret (transpile* (second ast) env))
          (.add ret [cmd "("])
          (forlet ((n 2)
                   (< n (alen ast)) (n (inc n)))
            (if (not= n 2) (.add ret ","))
            (.add ret (transpile* (nth ast n) env)))
          (.add ret ")"))
      (.hasOwnProperty SPEC-OPS cmd)
      (set! ret ((get SPEC_OPS cmd) ast env))
      :else
      (do (if (types.list? ast)
            (do (transpileAtoms ast env)
                (set! cmd (first ast)))
            (set! cmd (transpileSingle ast)))
          (if-not cmd (syntax! "e1" ast))
          (if (types.list? ast)
            (do (if (testre? (rdr.REGEX.func  cmd))
                  (set! cmd (tnodeEx ["("  cmd  ")"])))
                (.add ret [cmd
                           "("
                           (-> (tnodeEx (.slice ast 1))
                               (.join ",")) ")"]))
            (.add ret cmd))))
    (set! ret (nodeTag ret ast))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- _lambdaFuncCount 0)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-lambda "" [ast env]
  (if (not= 0 _lambdaFuncCount)
    (raise! "Cant nest lambdas")
    (++ _lambdaFuncCount))
  (var x [(types/symbol "fn")
          (types/vector)
          (map (fn [s] (types.symbol s))
               ["var", "____args",
                "Array.prototype.slice.call(arguments)"])]
       body (nth ast 1))
  (if (= (alen body) 0) (set! body [nil]))
  (if (and (= 1 (alen body))
           (types/value? (nth body 0)))
    nil
    (set! body (ast.slice 1)))
  (set! x (.concat x body))
  (try
    (sf-fn x env)
    (finally (-- _lambdaFuncCount))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS "lambda" sf-lambda)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-apply "" [ast env]
  (var args (.slice ast 2)
       f (second ast)
      ret (nodeTag (tnode) ast))
  (forlet ((i 0) (< i (alen args)) (i (inc i)))
    (.add ret (transpile* (nth args i) env)))
  (if (> (alen args) 1) (.join ret ","))
  (doto ret
    (.prepend "[")
    (.add "]")
    (.prepend [(transpile* f env) ".apply(this,"])
    (.add ret ")")))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :apply sf-apply)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-compOp "" [ast env]
  (var cmd (first ast))
  (if (or (= cmd "not=")
          (= cmd "!=")) (set! ast 0 (types.symbol "!==")))
  (if (= cmd "=") (set! ast 0 (types.symbol "===")))
  (do-with [ret (nodeTag (tnode) ast)]
    (transpileAtoms ast env)
    (forlet ((i 0
              op (.shift ast))
             (< i (eindex ast)) (i (inc i)))
      (.add ret (tnodeEx [(nth ast i)
                          " " op " " (nth ast (inc i))])))
    (.join ret " && ")
    (.prepend ret "(")
    (.add ret ")")))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(regoBuiltins sf-compOp "compare")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-arithOp "" [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (transpileAtoms ast env)
    (var op (tnode)
         e1 (.shift ast)
         cmd (types.symbol-s e1))
    (if (= cmd "mod") (set! cmd "%"))
    (if (= 1 (alen ast))
      (if (= "-" cmd) (.add ret "-"))
      (.add op [""  cmd  ""]))
    (.add ret ast)
    (if (> (alen ast) 1) (.join ret op))
    (.prepend ret "(")
    (.add ret ")")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(regoBuiltins sf-arithOp "bitwise")
(regoBuiltins sf-arithOp "logic")
(regoBuiltins sf-arithOp "arith")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-repeat "" [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (transpileAtoms ast env)
    (forlet ((i 0
              end (parseInt (second ast)))
             (< i  end) (i (inc i)))
      (if (not= i 0) (.add ret ","))
      (.add ret (nth ast 2)))
    (.prepend ret "[")
    (.add ret "]")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :repeat-n sf-repeat)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileDo "" [ast env return?]
  (do-with [ret (nodeTag (tnode) ast)]
    (var p (pad indent)
         e nil
         end (eindex ast))
    (forlet ((i 0) (< i end) (i (inc i)))
      (set! e (nth ast i))
      (.add ret [p (transpileList e env) ";\n"]))
    (when  (>= end 0)
      (set! e (transpile* (nth ast end) env))
      (if-not return?
        (.add ret [p e ";\n"])
        (.add ret [p "return " e ";\n"])))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-do "" [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (var p (pad indent))
    (.add ret (str p "(function() {\n"))
    (.add ret (transpileDo (.slice ast 1) env))
    (.add ret (str p "}).call(this)"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :do sf-do)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-case "" [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (var tst (second ast)
         e nil t nil c nil dft nil)
    (if (std.odd? (alen ast))
      (set! dft (.pop ast)))
    (forlet ((i 2)
             (< i (alen ast)) (i (+ i 2)))
      (set! c (nth ast (inc i)))
      (set! e (nth ast i))
      (if (types.list? e)
        (forlet ((j 0)
                 (< j (alen e)) (i (inc)))
          (.add ret ["case " (transpileSingle (nth e j)) ":\n"])
          (if (= j (eindex e))
            (.add ret ["____x= "
                       (transpile* c env) ";\nbreak;\n"])))
        (do (.add ret ["case " (transpileSingle e) ":\n"])
            (.add ret ["____x= "
                       (transpile* c env) ";\nbreak;\n"]))))
    (when dft
      (.add ret "default:\n")
      (.add ret ["____x= "
                 (transpile* dft env) ";\nbreak;\n"]))

    (.prepend ret ["switch (",
                   (transpile* tst env) ") {\n"])
    (.add ret "}\n")
    (.prepend ret "(function() { let ____x;\n")
    (.add ret "return ____x;}).call(this)")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :case sf-case)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-range "" [ast env]
  ;;if (ast.length < 2 || ast.length > 4) syntax_E("e0",ast);
  (do-with [ret (nodeTag (tnode) ast)]
  (var len 0 start 0 step 1 end 0)
  (transpileAtoms ast env)
  (set! len (alen ast))
  (set! end (parseInt (second ast)))
  (when (> len 2)
    (set! start (parseInt (second ast)))
    (set! end (parseInt (nth ast 2))))
  (if (> len 3)
    (set! step (parseInt (nth ast 3))))

  (forlet ((i start) (< i end) (i (+ i step)))
    (if (not= i start) (.add ret ","))
    (.add ret (str i)))
  (.prepend ret "[")
  (.add ret "]")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :range sf-range)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-var "" [ast env cmd]
  (do-with [ret (nodeTag (tnode) ast)]
    (var vname nil keys []
         public? (== "global" cmd))
    (set! ast (.slice ast 1))
    (if (or public?
            (== "local" cmd)) (set! cmd "var"))

    (forlet ((i 0)
             (< i (alen ast)) (i (+ i 2)))
      (if (types.symbol? (nth ast i))
        (.push keys (nth ast i))))
    (if (std.not-empty keys)
      (.add ret
            ["let "
             (-> (map #(transpileSingle %) keys)
                 (.join ",")) ";\n"]))
    (forlet ((rc nil i 0
              lhs nil rhs nil)
             (< i (alen ast)) (i (+ i 2)))
      (set! rhs (nth ast (inc i)))
      (set! lhs (nth ast i))
      (if (types.symbol? lhs)
        (.add ret [(transpileSingle lhs) "= "
                   (transpile* rhs env) ";\n"])

        (do (set! rc (destruct0 cmd lhs rhs env))
            (.add ret (nth rc 0))
            (.add ret (nth rc 1)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-var-local "" [ast env]
  (sf-var ast env "local"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :def- sf-var-local)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-var-global "" [ast env]
  (sf-var ast env  "global"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :def sf-var-global)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-var-let "" [ast env]
  (sf-var ast env "let"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :var sf-var-let)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-inst? "" [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (.add ret ["("
               (transpile* (nth ast 2) env)
               " instanceof "
               (transpile* (nth ast 1) env) ")"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :inst? sf-inst?)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-delete "" [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (ret.add ["delete " (transpile* (nth ast 1) env)])
    (if (> (alen ast) 2)
      (ret.add ["[" (transpile* (nth ast 2)) "]"]))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :delete! sf-delete)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-new "" [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (.add ret (transpileList (.slice ast 1) env))
    (.prepend ret "new ")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :new sf-new)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-throw "" [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (.add ret ["throw " (transpile* (nth ast 1) env) ";"])
    (.prepend ret "(function (){ ")
    (.add ret " }).call(this)")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :throw sf-throw)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-x-opop "" [ast env]
  (transpileAtoms ast env)
  (nodeTag (tnodeEx [(first ast)
                     (second ast)]) ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(regoBuiltins sf-x-opop "incdec")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-x-eq "" [ast env]
  (transpileAtoms ast env)
  (nodeTag (tnodeEx [(second ast)
                     " " (first ast) " " (nth ast 2)])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(regoBuiltins sf-x-eq "assign")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-set "" [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (var e1 (transpile* (nth ast 1) env))
    (if (= 4 (alen ast))
      (doto ret
        (.add e1)
        (.add "[")
        (.add (transpile* (nth ast 2) env))
        (.add "]"))
      (.add ret e1))
    (.add ret [" = " (transpile* (nth ast (eindex ast)) env)])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :aset sf-set)
(set! SPEC-OPS :set! sf-set)
(set! SPEC-OPS :def! sf-set)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- parseFuncArgs "" [args]
  (do-with [ret []]
    (forlet ((i 0 e nil)
             (< i (alen args)) (i (inc i)))
      (set! e (nth args i))
      (cond
        (types.symbol? e)
        (cond
          (== e "_")
          (.push ret (types.symbol (gensym "_")))
          (== e "&")
          (do (set! e (nth args (inc i)))
              (if (types.symbol? e)
                (.push ret [e i e])
                (.push ret [(types.symbol (str "&" (gensym))) i e]))
              (++ i))
          (.startsWith (str e) "&")
          (do (set! e (types.symbol (.slice (str e) 1)))
              (.push ret [e, i, e]))
          :else
          (.push ret e))
        (types.keyword? e)
        (std.raise! "bad function args destructure: " (types.obj-type e))
        (std.array? e)
        (.push ret [(types.symbol (gensym)) i e])
        :else
        (std.raise! "bad function args destructure: " (types.obj-type e))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- handleFuncArgs "" [fargs env]
  (do-with [out []]
    (var misc [] keys []
         ret (tnode) knode (tnode))
    (each (fn [arg]
            (cond
              (types.symbol? arg) (.push keys arg)
              (and (types.symbol? (first arg))
                   (not (.startsWith (str (first arg)) "&"))
                   (array? (nth arg 2)))
              (do (.push keys (first arg))
                  (.push misc arg))
              :else (.push misc arg))) fargs)
    (each (fn [arr]
            (var a0 (first arr)
                 name (str a0)
                 varg? (.startsWith name "&")
                 pos (str (nth arr 1))
                 a2 (nth arr 2))
            (if varg? (set! name (.slice name 1)))
            (set! name (rdr.jsid name))
            (cond
              (and (types.symbol? a0)
                   (types.symbol? a2))
              (.add ret ["let " name
                         "=Array.prototype.slice.call(arguments," pos ");\n"])
              (array? a2)
              (do
                (if varg?
                  (.add ret ["let " name
                             "=Array.prototype.slice.call(arguments," pos ");\n"]))
                (.add ret (destruct0 "let" a2 name env))))) misc)

    (.add knode (-> (map (fn [k] (rdr.jsid (str k))) keys) (.join ",")))
    (.push out knode);
    (.push out ret)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-fn "" [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (var args (nth ast 1)
         body (.slice ast 2)
         fargs (handleFuncArgs
                 (parseFuncArgs args) env))
    (.add ret "function (")
    (.add ret (first fargs))
    (.add ret [") {\n"
               (second fargs)
               (transpileDo body env)
               (pad indent) "}"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS "fn" sf-fn)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-func "" [ast env public?]
  (do-with [ret (nodeTag (tnode) ast)]
    (var fname (transpileSingle (nth ast 1))
         dot? (.includes fname ".")
         fargs nil
         e3 (nth ast 3)
         e2 (nth ast 2)
         doc nil attrs nil args 2 body 3)
    (cond
      (string? e2)
      (do (set! doc 2)
          (set! args 3)
          (when (types.map? e3)
            (set! attrs 3)
            (set! args 4)))
      (types.map? e2)
      (do (set! attrs 2)
          (set! args 3)))
    (set! body (inc args))
    (if doc (set! doc (nth ast doc)))
    (if attrs (set! attrs (nth ast attrs)))
    (set! args (nth ast args))
    (set! fargs (handleFuncArgs
                  (parseFuncArgs args) env))
    (set! body (.slice ast body))
    (if dot?
      (.add ret [fname " = function ("])
      (.add ret (str "function " fname "(")))
    (.add ret (first fargs))
    (.add ret
          [") {\n"
           (second fargs)
           (transpileDo body env)
           (pad indent) "}\n"])
    (when (and false attrs)
      ;;//ret.add(fmtSpecOps(fname, attrs));
      ;;//ret.add(";");
      nil)
    (when doc
      (set! doc (.replace doc rdr.REGEX.dquoteHat ""))
      (set! doc (.replace doc rdr.REGEX.dquoteEnd ""))
      (.prepend ret
                (map (fn [s] (str "//" s "\n"))
                     (.split doc "\\n"))))
    (if (and public?
             (not dot?)
             (= 1 (alen NSPACES))) (set! EXTERNS fname fname))
    (set! nosemi? true)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-func-private "" [ast env] (sf-func ast env false))
(set! SPEC-OPS :defn- sf-func-private)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-func-public "" [ast env] (sf-func ast env true))
(set! SPEC-OPS :defn sf-func-public)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-try "" [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (var sz (alen ast)
         t nil
         f nil
         c nil
         ind (pad indent))
    ;;look for finally
    (set! f (std.last ast))
    (if (and (std.array? f)
             (== "finally" (first f)))
      (do (set! f (.pop ast))
          (set! sz (alen ast)))
      (set! f nil))
    ;;look for catch
    (set! c nil)
    (if (> sz 1) (set! c (nth ast (dec sz))))
    (if (and (std.array? c)
             (== "catch" (first c)))
      (do (if (or (< (alen c) 2)
                  (not (types.symbol? (second c)))) (syntax! :e0 ast))
          (set! c (.pop ast)))
      (set! c nil))
    ;;try needs either a catch or finally or both
    (if (and (nil? f) (nil? c)) (syntax! :e0 ast))
    (.add ret [(str "(function() {\n" ind "try {\n")
               (transpileDo (.slice ast 1) env)
               (str "\n" ind "} ")])
    (when c
      (set! t (second c))
      (.add ret [(str "catch (" t ") {\n")
                 (transpileDo (.slice c 2) env)
                 (str ";\n" ind "}\n")]))
    (when f
      (.add ret ["finally {\n",
                 (transpileDo (.slice f 1) env)
                 (str ";\n" ind "}\n")]))

    (.add ret (str ind "}).call(this)"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :try sf-try)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-if "" [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (var a1 (nth ast 1)
         a2 (nth ast 2)
         a3 (if (> (alen ast) 3) (nth ast 3)))
    (+= indent tabspace)
    (.add ret ["("
               (transpile* a1 env)
               (str " ?\n" (pad indent))
               (transpile* a2 env)
               (str " :\n" (pad indent))
               (or (transpile* a3 env) "null") ")"])
    (-= indent tabspace)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :if sf-if)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-nth "" [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (transpileAtoms ast env)
    (.add ret [(nth ast 1) "[" (nth ast 2) "]"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :nth sf-nth)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-get "" [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (transpileAtoms ast env)
    (.add ret [(nth ast 1) "[" (nth ast 2) "]"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :aget sf-get)
(set! SPEC-OPS :get sf-get)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-str "" [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (var args (.slice ast 1))
    (transpileAtoms args env)
    (if (> (alen args) 1)
      (doto ret
        (.add args)
        (.join ",")
        (.prepend "[")
        (.add "].join(\"\")"))
      (if (> (alen args) 0)
        (.add ret (.toString (first args)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :str sf-str)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-array "" [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (var p (pad indent)
         epilog (str "\n" p "]"))
    (if (std.empty? ast)
      (.add ret "[]")
      (do (if-not (types.vector? ast)
            (.splice ast 0 1))
          (+= indent tabspace)
          (transpileAtoms ast env)
          (set! p (pad indent))
          (.add ret (str "[\n" p))
          (forlet ((i 0) (< i (alen ast)) (i (inc i)))
            (if (> i 0) (.add ret (str ",\n" p)))
            (.add ret (nth ast i)))
          (.add ret epilog)
          (-= indent tabspace)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :vec sf-array)
(set! SPEC-OPS "[" sf-array)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-object "" [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (var p (pad indent)
         epilog (str "\n" p "}"))
    (if (std.empty? ast)
      (.add ret "{}")
      (do (if-not (types.map? ast)
            (.splice ast 0 1))
          (+= indent tabspace)
          (transpileAtoms ast env)
          (set! p (pad indent))
          (.add ret (str "{\n" p))
          (forlet ((i 0) (< i (alen ast)) (i (+ i 2)))
            (if (> i 0) (.add ret (str ",\n" p)))
            (.add ret [(nth ast i) ": " (nth ast (inc i))]))
          (.add ret epilog)
          (-= indent tabspace)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :hash-map sf-object)
(set! SPEC-OPS "{" sf-object)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- includeFile
  ((fn []
     (var icache [])
     (fn [fname]
       (if (std.contains? icache fname)
         (tnode)
         (let [src (.readFileSync fs fname "utf-8")]
           (.push icache fname)
           (transpileTree (.parser psr src fname) (.globalEnv rt))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-include "" [ast env]

  (var ret [] fname nil dir (.dirname path ast.source))
  (forlet ((i 1 e nil)
           (< i (alen ast)) (i (inc i)))
    (set! e (nth ast i))
    (if (or (not (std.array? e))
            (not= 1 (alen e))) (syntax! :e0 ast))
    (set! fname (first e))
    (if fname
      (set! fname (.replace fname (regex "[\"]" "g") "")))
    (try
      (set! fname (.realpathSync fs (str dir "/" fname)))
      (catch e
        (syntax! :e11 ast)))
    (try
      (-= indent tabspace)
      (.push ret (includeFile fname))
      (finally
        (.pop NSPACES)
        (+= indent tabspace))))
  (if (std.empty? ret) (tnode) ret))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-require "" [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (var path nil v nil e nil)
    (forlet ((i 1)
             (< i (alen ast)) (i (inc i)))
      (set! e (nth ast i))
      (if (or (not (std.array? e))
              (not= 3 (alen e))) (syntax! :e0 ast))
      (set! path (first e))
      (set! v (nth e 2))
      (.add ret ["var "
                 (transpileSingle v env)
                 "= require("
                 (transpileSingle path env) ");\n"]))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-ns "" [ast env]
  (do-with [ret []]
    (forlet ((i 1 e nil nsp nil)
             (< i (alen ast)) (i (inc i)))
      (set! e (nth ast i))
      (cond
        (types.symbol? e)
        (if nsp
          (syntax! :e0 ast)
          (.push NSPACES (.toString e)))
        (and (types.list? e)
             (== "with-meta" (nth e 0))
             (types.symbol? (nth e 1)))
        (if nsp
          (syntax! :e0 ast)
          (.push NSPACES (.toString (second e))))
        (and (types.list? e)
             (== "include" (first e)))
        (.push ret (sf_include e))
        (and (types.list? e)
             (== "require" (first e)))
        (.push ret (sf_require e))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :ns sf-ns)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-comment "" [ast env] (nodeTag (tnode) ast))
(set! SPEC-OPS :comment sf-comment)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-floop "" [ast env hint]
  (do-with [ret (nodeTag (tnodeEx "for (") ast)]
    (var c1 nil c2 nil c3 nil
         c (nth ast 1) ind (pad indent))
    (if (or (not (std.array? c))
            (not= 3 (alen c))) (syntax! :e0 ast))
    (set! c1 (first c))
    (set! c2 (second c))
    (set! c3 (nth c 2))
    (+= indent tabspace)
    (if (std.array? c1)
      (forlet ((i 0) (< i (alen c1)) (i (+ i 2)))
        (if (= i 0) (.add ret (str hint " ")))
        (if (> i 0) (.add ret ","))
        (.add ret [(transpileSingle (nth c1 i) env)
                   " = "
                   (transpile* (nth c1 (inc i)) env)])))
    (.add ret "; ")

    (if (std.array? c2)
      (.add ret ["(!____break && " (transpileList c2 env) ")"])
      (.add ret " !___break "))

    (.add ret "; ")
    (if (std.array? c3)
      (forlet ((i 0) (< i (alen c3)) (i (+ i 2)))
        (if (> i 0) (.add ret ","))
        (.add ret [(transpileSingle (nth c3 i) env)
                   " = "
                   (transpile* (nth c3 (inc i)) env)])))
    (.add ret ") {\n")
    (if (> (alen ast) 2)
      (.add ret [ind (pad tabspace)
                 (transpileDo (.slice ast 2) env false) ";"]))
    (.add ret (str "\n" ind "}\n"))
    (.prepend ret "(function () {let ____break=false;\n")
    (.add ret "}).call(this)")
    (-= indent tabspace)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :forlet (fn [ast env] (sf-floop ast env "let")))
(set! SPEC-OPS :for (fn [ast env] (sf-floop ast env "")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-wloop "" [ast env]
  (do-with [ret (nodeTag (tnodeEx "for (;") ast)]
    (var cond (second ast)
         ind (pad indent))
    (.add ret [" (!____break && " (transpile* cond env) ") "])
    (.add ret ";) {\n")
    (+= indent tabspace)
    (if (> (alen ast) 2)
      (.add ret [ind
                 (pad tabspace)
                 (transpileDo (.slice ast 2) env false) ";"]))
    (.add ret (str "\n" ind "}\n"))
    (.prepend ret "(function () {let ____break=false;\n")
    (.add ret "}).call(this)")
    (-= indent tabspace)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :while sf-wloop)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-jscode "" [ast env]
  (set! nosemi? true)
  (nodeTag (tnodeEx (-> (.toString (second ast))
                        (.replace rdr.REGEX.dquoteHat "")
                        (.replace rdr.REGEX.dquoteEnd ""))) ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS "js#" sf-jscode)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-macro "" [ast env]
  (var pms (types/vector)
       args (nth ast 2)
       body (ast.slice 3))
  (when (string? args)
    (set! doc args)
    (set! args (nth ast 3))
    (set! body (ast.slice 4)))
  (forlet ((i 0 e nil)
           (< i (alen args)) (i (inc i)))
    (set! e (nth args i))
    (cond
      (== e "&")
      (if (array? (nth args (+ i 1)))
        (do (set! e (nth args (+ i 1)))
            (++ i)
            (forlet ((j 0 x nil)
                     (< j (alen e)) (j (inc j)))
              (set! x (nth e j))
              (if-not (types/symbol? x)
                (raise! "Bad optional arg for macro"))
              (pms.push x)))
        (do (pms.push e (nth args (+ i 1)))
            (++ i)))
      (not (types/symbol? e))
      (raise! "Bad optional arg for macro")
      :else
      (pms.push e)))
  (set! ast
        [(first ast)
         (second ast)
         (.concat [(types/symbol "fn*") pms] body)])
  (var a2 (nth ast 2)
       a1 (str (nth ast 1))
       func (rt/eval a2 env))
  (set! func :____macro true)
  (if doc
    (set! func :____doc doc))
  (macros/set a1 func)
  (nodeTag (tnode) ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS "defmacro" sf-macro)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-unary "" [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (var a0 (first ast)
         a1 (second ast))
    (if (== a0 "not") (set! a0 (types.symbol "!")))
    (.add ret ["(" (transpile* a0 env) (transpile* a1 env) ")"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(regoBuiltins sf-unary "unary")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-doseq "" [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (var args (nth ast 1)
         body (.slice ast 2)
         loopvar (nth args 0)
         loopexpr (nth args 1)
         escvar (gensym)
         idxvar (gensym)
         exprvar (gensym))
    (.add ret
          ["let " (transpileSingle loopvar)
           "= " exprvar "[" idxvar "];\n"])
    (forlet ((i 2 v nil)
             (< i (alen args)) (i (inc i)))
      (set! v (nth args i))
      (cond
        (== v "while")
        (.add ret ["if (! " (transpile* (nth args (inc i)) env)
                   ") {" escvar "=true;}\n"])
        (== v "when")
        (doto ret
          (.add ["if (!" escvar ") {\n"])
          (.add ["if (! "
                     (transpile* (nth args (inc i)) env)
                     ") {continue;}\n"])
          (.add "}\n"))
        (== v "let")
        (.add ret
              (sf-var-let
                (std.concat [(types.symbol "var")]
                            (nth args (inc i))) env))))
    (.add ret ["if (!" escvar ") {\n"])
    (.add ret (transpileDo body env false))
    (.add ret "}\n")
    (.add ret "}\n")
    (.prepend ret
              ["for(var " escvar "=false," idxvar "=0; "
               "(!" escvar " && " idxvar
               " < " exprvar ".length); ++" idxvar ") {\n"])
    (.prepend ret
              ["let " exprvar "= " (transpile* loopexpr env) ";\n"])
    (.prepend ret "(function() {\n")
    (.add ret "})(this);\n")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS "doseq" sf-doseq)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- spitExterns "" []
  (do-with [s ""]
    (var ks (std.keys EXTERNS)
         p (pad tabspace))
    (when (> (alen ks) 0)
      (set! s (-> (map (fn [k] (str p  k  ": " k)) ks)
                  (.join ",\n")))
      (set! s (str "\n\nmodule.exports = {\n" s "\n};\n\n")))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- banner "" []
  (str "/*"
       "Auto generated by Kirby - v"
       MODULE_VERSION " "
       (std.first NSPACES) " - "(new Date) "*/\n\n"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileCode "" [codeStr fname srcMap?]
  (var indent (- tabspace)
       EXTERNS {}
       NSPACES []
       outNode (transpileTree
                 (.parser psr codeStr fname) (.globalEnv rt))
       extra (spitExterns))
  (.prepend outNode (banner))
  (if srcMap?
    (let [outFile (str (.basename path fname ".ky") ".js")
          srcMap (str outFile ".map")
          output (.toStringWithSourceMap outNode
                                         {:file outFile})]
      (.writeFileSync fs srcMap output.map)
      (str output.code
           extra
           "\n//# sourceMappingURL="
           (.relative path (.dirname path fname) srcMap)))
    (str outNode extra)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileXXX "" [code file smap?]
  (try
    (transpileCode code file smap?)
    (catch e
      (std.println e.stack)
      (throw e))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn transpileWithSrcMap "" [code file] (transpileXXX code file true))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn transpile "" [code file] (transpileXXX code file false))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn parseWithSourceMap "" [codeStr fname]
  (var outNode (transpileTree (.parser psr codeStr fname)))
  (.prepend outNode (banner))
  (.toStringWithSourceMap outNode))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(def version MODULE_VERSION)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

