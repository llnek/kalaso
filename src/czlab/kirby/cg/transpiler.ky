;; Copyright (c) 2013-2017, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author "Kenneth Leung"}

  czlab.kirby.cg.transpiler

  (require ["../bl/stdlib"
            :as std
            :refer [lambda-arg? hashmap pair? contains? last typeid
                    prn primitive pair? map? vector? opt??
                    primitive? not-empty conj! list?
                    symbol keyword symbol? keyword?]]
           ["../bl/lexer"
            :as rdr
            :refer
            [tnode tnodeEx]]
           ["../bl/parser" :as psr]
           ["../rt/runtime" :as rt])

  (require ["fs" :as fs]
           ["path" :as path]
           ["esformatter" :as esfmt]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- gensym-counter 1)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- ERRORS-MAP {
  :e0 "Syntax Error"
  :e1 "Empty statement"
  :e2 "Invalid characters in function name"
  :e3 "End of File encountered, unterminated string"
  :e4 "Closing square bracket, without an opening square bracket"
  :e5 "End of File encountered, unterminated array"
  :e6 "Closing curly brace, without an opening curly brace"
  :e7 "End of File encountered, unterminated javascript object '}'"
  :e8 "End of File encountered, unterminated parenthesis"
  :e9 "Invalid character in var name"
  :e10 "Extra chars at end of file. Maybe an extra ')'."
  :e11 "Cannot Open include File"
  :e12 "Invalid no of arguments to "
  :e13 "Invalid Argument type to "
  :e14 "End of File encountered, unterminated regular expression"
  :e15 "Invalid vararg position, must be last argument."
  :e16 "Invalid arity (args > expected) to "
  :e17 "Invalid arity (args < expected) to "})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- MODULE-VERSION "1.0.0")
(def- EXTERNS nil
      SPEC-OPS {}
      MATH-OP-REGEX /^[-+][0-9]+$/)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- simpleton? "" [ast]
  (or (undef? ast)
      (string? ast)
      (number? ast)
      (boolean? ast) (nil? ast)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- exprHint "" [ast flag]
  (var x ast)
  (if (simpleton? ast)
    (set! x (primitive ast)))
  (set-in! x :____expr flag)
  x)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- stmt? "" [ast]
  (if (simpleton? ast)
    (raise! "Cant test expr? on primitive"))
  (false? ast.____expr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- gensym "" [& [pfx]]
  (var x gensym-counter)
  (++ gensym-counter)
  (str (opt?? pfx "G____") x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- error! "" [e &[line file msg]]
  (raise! (get ERRORS-MAP e)
          (if msg (str " : " msg))
          (if line (str "\nLine no " line))
          (if file (str "\nFile " file))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- syntax! "" [ecode &[ast cmd]]
  (error! ecode
          (if ast ast.line 0)
          (if ast ast.source 0) cmd))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- pad "" [z] (.repeat " " z))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- testre? "" [re x] (if x (re.test x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- nodeTag "" [obj src]
  (when (and obj
             src
             (not (simpleton? obj)))
    (set! obj.source src.source
          obj.column src.column obj.line src.line)) obj)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destructVec "" [lhs keys]
  (var~ as e ev)
  (for [i 0 :while (< i (alen lhs)) :recur (+1 i)]
    (set! e (nth lhs i) ev (str e))
    (cond
      (symbol? e)
      (cond
        (= ev "_") nil
        (= ev "&")
        (do (set-in! keys (str "&" (nexth lhs i)) i)
            (++ i))
        (ev.startsWith "&")
        (set-in! keys ev i)
        :else
        (set-in! keys ev i))
      (keyword? e)
      (if (= ev "as")
        (do (++ i)
            (set! as (str (nth lhs i))))
        (raise! "bad keyword: :" ev))))
  as)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destructMap "" [lhs keys]
  (var~ as e ev)
  (for [i 0 :while (< i (alen lhs)) :recur (+1 i)]
    (set! e (nth lhs i) ev (str e))
    (if (keyword? e)
      (cond
        (or (= ev "keys")
            (= ev "strs"))
        (let [ks (nexth lhs i)]
          (++ i)
          (for [j 0 :while (< j (alen ks)) :recur (+1 j)]
            (set-in! keys (str (nth ks j)) nil)))
        (= ev "as")
        (do (++ i)
            (set! as (str (nth lhs i)))))
      (raise! "bad destruct field: " (typeid e))))
  as)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destruct1 "" [lhs]
  (var as nil out [] keys {})
  (cond
    (vector? lhs) (set! as (destructVec lhs keys))
    (map? lhs) (set! as (destructMap lhs keys))
    (symbol? lhs) (set-in! keys (str lhs) nil)
    :else
    (raise! "cant destruct with: " (typeid lhs)))
  [as keys])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destruct0 "" [cmd lhs rhs env]
  (var [as keys] (destruct1 lhs)
       kdefs [] ka nil kvals (tnode))
  (if (empty? as) (set! as (gensym "A____")))
  (set! as (rdr/jsid as))
  (each-key (fn [v k]
              (var rest? false)
              (when (k.startsWith "&")
                (set! rest? true k (rest k)))
              (set! k (rdr/jsid k))
              (conj! kdefs k)
              (->> (cond
                     (nil? v)
                     (str "[\"" k "\"];\n")
                     rest?
                     (str ".slice(" v ");\n")
                     :else
                     (str "[" v "];\n"))
                   (str k "=" as )
                   (kvals.add ))) keys)
  (kvals.prepend (str cmd " " (join "," kdefs) ";\n"))
  [[(tnodeEx [cmd " "
              (rdr/jsid as) "= "
              (transpile* rhs env) ";\n"]) kvals] kdefs])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileTree "" [root env]
  (var ret (nodeTag (tnode) root))
  (each (fn [ast]
          (if-some [tmp (transpile* ast env)]
            (ret.add [tmp "\n"]))) root)
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileAtoms "" [atoms env]
  (each (fn [a i arr] (set-in! arr i (transpile* a env))) atoms))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileSingle "" [a]
  (var s (str a))
  (cond
    (lambda-arg? a) (str "____args[" s "]")
    (keyword? a) (str "\"" s "\"")
    (symbol? a) (rdr/jsid s)
    (primitive? a)
    (do (set! a a.value)
        (cond (string? a) a
              (nil? a) "null"
              :else (str a)))
    :else s))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpile* "" [x env]
  (if (array? x) (transpileList x env) (transpileSingle x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- findCmd "" [ast]
  (var cmd "")
  (cond
    (map? ast) (set! cmd "hashmap")
    (vector? ast) (set! cmd "vec")
    (list? ast) (set! cmd "list")
    (array? ast) (set! cmd (str (first ast))))
  cmd)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quoteSingle "" [a]
  (cond
    (keyword? a) (str "keyword(\":" a "\")")
    (symbol? a) (str "symbol(\"" a "\")")
    (primitive? a)
    (do (set! a a.value)
        (cond (string? a) a
              (nil? a) "null"
              :else (str a)))
    :else (str a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quote! [a env]
  (if (array? a)
    (if (map? a) (quoteMap a env) (quoteBlock a env))
    (quoteSingle a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quoteMap "" [a env]
  (var ret (tnode) comma "")
  (for [i 0 :while (< i (alen a)) :recur (+2 i)]
    (if (> i 0) (ret.add ","))
    (ret.add [(quote! (nth a i) env)
              " : " (quote! (nexth a i) env)]))
  (if-not (empty? a) (set! comma ","))
  (ret.prepend ["[" "symbol(\"hashmap\")"  comma])
  (ret.add "]")
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quoteBlock "" [a env]
  (var ret (tnode))
  (for [i 0 :while (< i (alen a)) :recur (+1 i)]
    (if (> i 0) (ret.add ","))
    (ret.add (quote! (nth a i) env)))
  (ret.prepend "[")
  (ret.add "]")
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-quote "" ^{:opcode ["quote"]} [ast env]
  (var ret (nodeTag (tnode) ast))
  (ret.add (quote! (nth ast 1) env))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileList "" [ast env]
  (var stmtQ (stmt? ast)
       cmd (findCmd ast)
       ret (tnode)
       tmp nil
       mc (rt/getMacro cmd))
  (when mc
    (set! ast (rt/expandMacro ast env mc)
          ast (exprHint ast (not stmtQ))
          cmd (findCmd ast)))
  (cond
    (== cmd "with-meta")
    (do (set! tmp (nth ast 1))
        (if-not (simpleton? tmp)
          (do (set-in! tmp :____meta (resolveMeta (nth ast 2) env))
              (ret.add (transpile* tmp env)))
          (raise! "cant with-meta simple value")))
    (cmd.startsWith ".-")
    (ret.add [(transpile* (second ast) env)
              "."
              (transpileSingle (symbol (cmd.slice 2)))])
    (= "." (ch@ cmd 0))
    (do (ret.add (transpile* (second ast) env))
        (ret.add [cmd "("])
        (for [n 2 :while (< n (alen ast)) :recur (+1 n)]
          (if (not= n 2) (ret.add ","))
          (ret.add (transpile* (nth ast n) env)))
        (ret.add ")"))
    (contains? SPEC-OPS cmd)
    (set! ret ((get SPEC-OPS cmd) ast env))
    (rdr/REGEX.int.test cmd)
    (let [c0 (ch@ cmd 0)]
      (if (and (not= c0 "-")
               (not= c0 "+"))
        (set! cmd (str "+" cmd)))
      (set! ast [(symbol (ch@ cmd 0))
                 (nth ast 1)
                 (int (rest cmd))]
            cmd (str (first ast))
            ret ((get SPEC-OPS cmd) ast env)))
    :else
    (do (if (pair? ast)
          (do (transpileAtoms ast env)
              (set! cmd (first ast)))
          (set! cmd (transpileSingle ast)))
        (if-not cmd (syntax! :e1 ast))
        (set! cmd (maybeStripStdlib cmd))
        (if (pair? ast)
          (do (if (testre? rdr/REGEX.func cmd)
                (set! cmd (tnodeEx ["(" cmd ")"])))
              (ret.add [cmd
                        "("
                        (join "," (tnodeEx (rest ast))) ")"]))
          (ret.add cmd))))
  (set! ret (nodeTag ret ast))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- writeDoc "" [doc]
  (if doc
    (do (set! doc (doc.replace rdr/REGEX.dquoteHat ""))
        (set! doc (doc.replace rdr/REGEX.dquoteEnd ""))
        (map (fn [s] (str "//"s "\n"))
             (doc.split "\\n")))
    ""))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-deftype "" [ast env public?]
  (var ret (nodeTag (tnode) ast)
       cz (transpile* (nth ast 1) env)
       par (first (nth ast 2))
       args (nth ast 3)
       doc nil mtds nil)
  (if (string? (nth ast 4))
    (do (set! doc (nth ast 4))
        (set! mtds (ast.slice 5)))
    (set! mtds (ast.slice 4)))
  (ret.add ["class " cz])
  (if par
    (ret.add [" extends " (transpile* par env)]))
  (ret.add " {\n")
  (for [i 0 n nil m nil
        :while (< i (alen mtds)) :recur (+1 i)]
    (set! m (nth mtds i))
    (when (and (== (first m) "constructor")
               (not-empty args))
      (for [x 0 :while (< x (alen args))
                :recur (+2 x)]
        (set-in! args
                 x
                 (str "\"" (nth args x) "\"")))
      (m.splice 2 0
        (concat [(symbol "set-in!")
                 (symbol "this")] args)))
    (m.unshift (symbol "method"))
    (ret.add (sf-func m env false))
    (ret.add "\n"))
  (ret.add "}\n")
  (if doc
    (ret.prepend (writeDoc doc)))
  (if (and public? (= 1 (.countNSPCache (rt/globalEnv))))
      (set-in! EXTERNS cz cz))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- prv-deftype
  "" ^{:opcode ["deftype-"]} [a e] (sf-deftype a e false))
(defn- pub-deftype
  "" ^{:opcode ["deftype"]} [a e] (sf-deftype a e true))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-compOp ""
  ^{:opcode ["not=" "!=" "=="
             "=" ">" ">=" "<" "<="]} [ast env]
  (var ret (nodeTag (tnode) ast)
       cmd (first ast))
  (if (or (== cmd "not=")
          (== cmd "!=")) (set-in! ast 0 (symbol "!==")))
  (if (== cmd "=") (set-in! ast 0 (symbol "===")))
  (transpileAtoms ast env)
  (for [i 0 op (ast.shift)
        :while (< i (last-index ast)) :recur (+1 i)]
    (ret.add (tnodeEx [(nth ast i)
                       " " op " " (nexth ast i)])))
  (join " && " ret)
  (ret.prepend "(")
  (ret.add ")")
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-arithOp
  ""
  ^{:opcode ["+" "-" "*" "div" "%"  "mod"
             "||" "&&"
             "^" "&" "|" "<<" ">>" ">>>"]} [ast env]
  (var ret (nodeTag (tnode) ast) op (tnode))
  (transpileAtoms ast env)
  (var e1 (ast.shift) cmd (str e1))
  (if (== cmd "mod") (set! cmd "%"))
  (if (== cmd "div") (set! cmd "/"))
  (if (= 1 (alen ast))
    (if (== "-" cmd) (ret.add "-"))
    (op.add [""  cmd  ""]))
  (ret.add ast)
  (if (> (alen ast) 1) (join op ret))
  (ret.prepend "(")
  (ret.add ")")
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileDo "" [ast env & [return?]]
  (var ret (nodeTag (tnode) ast)
       stmtQ (stmt? ast)
       e nil end (last-index ast))
  (set! return?
        (if stmtQ false (opt?? return? true)))
  (for [i 0 :while (< i end) :recur (+1 i)]
    (set! e (nth ast i))
    (set! e (exprHint e false))
    (ret.add [(transpileList e env) ";\n"]))
  (when (>= end 0)
    (set! e (exprHint (nth ast end) (not stmtQ)))
    (set! e (transpile* e env))
    (if-not return?
      (ret.add [e ";\n"])
      (ret.add ["return " e ";\n"])))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-do
  "" ^{:opcode ["do"]} [ast env]
  (var ret (nodeTag (tnode) ast)
       stmtQ (stmt? ast)
       body (exprHint (rest ast) (not stmtQ)))
  (ret.add (transpileDo body env (not stmt?)))
  (if stmtQ (ret.prepend "{\n") (ret.prepend "(function() {\n"))
  (if stmtQ (ret.add "}") (ret.add "}).call(this)"))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-case
  "" ^{:opcode ["case"]} [ast env]
  (var ret (nodeTag (tnode) ast)
       stmtQ (stmt? ast) tst (second ast) _x (gensym))
  (var~ e t c dft)
  (if (odd? (alen ast))
    (set! dft (ast.pop)))
  (for [i 2
        :while (< i (alen ast)) :recur (+2 i)]
    (set! c (nexth ast i) e (nth ast i))
    (if (pair? e)
      (for [j 0 :while (< j (alen e)) :recur (+1 i)]
        (ret.add ["case " (transpileSingle (nth e j)) ":\n"])
        (if (= j (last-index e))
          (ret.add [_x "=" (transpile* c env) ";\nbreak;\n"])))
      (do (ret.add ["case " (transpileSingle e) ":\n"])
          (ret.add [_x "=" (transpile* c env) ";\nbreak;\n"]))))
  (when dft
    (ret.add "default:\n")
    (ret.add [_x "=" (transpile* dft env) ";\nbreak;\n"]))
  (ret.prepend ["switch (" (transpile* tst env) ") {\n"])
  (ret.add "}")
  (if stmtQ
    (ret.prepend ["{ let " _x ";\n"])
    (ret.prepend ["(function() { let " _x ";\n"]))
  (if stmtQ
    (ret.add "}")
    (ret.add ["return " _x ";}).call(this)"]))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-vardefs "" [ast env cmd]
  (var ret (nodeTag (tnode) ast)
       kks {}
       public? (== "global" cmd))
  (if-not (== "let" cmd) (set! cmd "var"))
  (for [i 1 s nil
        :while (< i (alen ast)) :recur (+ 1 i)]
    (set! s (transpileSingle (nth ast i)))
    (ret.add (str s "=undefined"))
    (set-in! kks s nil))
  (ret.join ",")
  (ret.prepend (str cmd " "))
  (ret.add ";\n")
  (if (and public?
           (= 1 (.countNSPCache (rt/globalEnv))))
    (each-key (fn [v k] (set-in! EXTERNS k k)) kks))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- local-vardefs
  "" ^{:opcode ["def~-"]} [ast env] (sf-vardefs ast env "local"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- global-vardefs
  "" ^{:opcode ["def~"]} [ast env] (sf-vardefs ast env "global"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- let-vardefs
  "" ^{:opcode ["var~"]} [ast env] (sf-vardefs ast env "let"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-const "" [ast env cmd]
  (var vname nil public? (== "global" cmd)
       kks {} keys []
       ret (nodeTag (tnode) ast))
  (set! ast (rest ast) cmd "const")
  (for [i 0 rc nil lhs nil rhs nil
       :while (< i (alen ast)) :recur (+2 i)]
    (set! rhs (nexth ast i)
          lhs (nth ast i))
    (if (symbol? lhs)
      (do (set! lhs (transpileSingle lhs))
          (set-in! kks lhs nil)
          (ret.add ["const " lhs
                    "= " (transpile* rhs env) ";\n"]))
      (do (set! rc (destruct0 cmd lhs rhs env))
          (ret.add (first rc))
          (each #(set-in! kks (rdr/jsid %) nil) (second rc)))))
  (when (and public?
             (= 1 (.countNSPCache (rt/globalEnv))))
    (each #(set-in! EXTERNS % %) (keys kks)))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-const-global "" ^{:opcode ["const"]} [ast env]
  (sf-const ast  env  "global"))
(defn- sf-const-local "" ^{:opcode ["const-"]} [ast env]
  (sf-const ast  env  "local"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-var "" [ast env cmd]
  (var ret (nodeTag (tnode) ast)
       vname nil keys [] kks {}
       tmp nil public? (== "global" cmd))
  (set! ast (rest ast))
  (if (or public?
          (== "local" cmd)) (set! cmd "var"))
  (comment
    (for [i 0
          :while (< i (alen ast)) :recur (+2 i)]
      (if (symbol? (nth ast i))
        (conj! keys (nth ast i))))
    (if (not-empty keys)
      (ret.add ["let "
                (join ","
                      (map (fn [s]
                             (var ss (transpileSingle s))
                             (set-in! kks ss nil) ss) keys)) ";\n"])))
  (for [i 0 rc nil
        lhs nil rhs nil
        :while (< i (alen ast)) :recur (+2 i)]
    (set! lhs (nth ast i)
          rhs (nexth ast i))
    (if (symbol? lhs)
      (do (set! lhs (transpileSingle lhs)
                tmp ["= "
                     (transpile* rhs env) ";\n"])
          (when-not (contains? kks lhs)
            (set-in! kks lhs nil)
            (.unshift tmp cmd " "))
          (ret.add tmp))
      (do (set! rc (destruct0 cmd lhs rhs env))
          (ret.add (first rc))
          (map #(set-in! kks (rdr/jsid %) nil)
               (second rc)))))
  (when (and public?
             (= 1 (.countNSPCache (rt/globalEnv))))
    (each-key (fn [v k]
                (set-in! EXTERNS k k)) kks))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-var-local
  "" ^{:opcode ["def-"]} [ast env] (sf-var ast env "local"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-var-global
  "" ^{:opcode ["def"]} [ast env] (sf-var ast env  "global"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-var-let
  "" ^{:opcode ["var"]} [ast env] (sf-var ast env "let"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-inst?
  "" ^{:opcode ["inst?"]} [ast env]
  (var ret (nodeTag (tnode) ast))
  (ret.add ["("
            (transpile* (nth ast 2) env)
            " instanceof "
            (transpile* (nth ast 1) env) ")"])
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-delete
  "" ^{:opcode ["delete!"]} [ast env]
  (var ret (nodeTag (tnode) ast))
  (ret.add ["delete " (transpile* (nth ast 1) env)])
  (if (> (alen ast) 2)
    (ret.add ["[" (transpile* (nth ast 2)) "]"]))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-new
  "" ^{:opcode ["new"]} [ast env]
  (var ret (nodeTag (tnode) ast))
  (ret.add (transpileList (rest ast) env))
  (ret.prepend "new ")
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-throw
  "" ^{:opcode ["throw"]} [ast env]
  (var ret (nodeTag (tnode) ast)
       stmtQ (stmt? ast))
  (ret.add ["throw " (transpile* (nth ast 1) env)])
  (when-not stmtQ
    (ret.prepend "(function (){ ")
    (ret.add " }).call(this)"))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-x-opop
  "" ^{:opcode ["++" "--"]} [ast env]
  (transpileAtoms ast env)
  (nodeTag (tnodeEx [(first ast)
                     (second ast)]) ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-x-eq
  "" ^{:opcode ["+=" "-=" "*="
                "/=" "%=" "<<="
                ">>=" ">>>=" "&=" "|=" "^="]} [ast env]
  (transpileAtoms ast env)
  (nodeTag (tnodeEx [(second ast)
                     " " (first ast) " " (nth ast 2)])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-set-in
  "" ^{:opcode ["set-in!"]} [ast env]
  (assert (even? (alen ast)) "set-in: bad arg count")
  (var ret (nodeTag (tnode) ast)
       more false
       obj (transpile* (nth ast 1) env))
  (for [i 2 :while (< i (alen ast)) :recur (+2 i)]
    (when (> i 2) (ret.add ",") (set! more true))
    (ret.add [obj "[" (transpile* (nth ast i) env) "]"
              "=" (transpile* (nexth ast i) env)]))
  (when more
    (ret.prepend "(") (ret.add ")"))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-set
  "" ^{:opcode ["set!"]} [ast env]
  (assert (odd? (alen ast)) "set: bad arg count")
  (var more false
       ret (nodeTag (tnode) ast))
  (for [i 1 :while (< i (alen ast)) :recur (+2 i)]
    (when (> i 1) (ret.add ",") (set! more true))
    (ret.add [(transpile* (nth ast i) env)
              "=" (transpile* (nexth ast i) env)]))
  (when more
    (ret.prepend "(") (ret.add ")"))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- parseFuncArgs "" [args]
  (var ret [])
  (var~ e ev)
  (for [i 0 :while (< i (alen args)) :recur (+1 i)]
    (set! e (nth args i) ev (str e))
    (cond
      (symbol? e)
      (cond
        (= ev "_")
        (conj! ret (symbol (gensym "_")))
        (= ev "&")
        (do (set! e (nexth args i))
            (if (symbol? e)
              (conj! ret [e i e])
              (conj! ret [(symbol (str "&" (gensym))) i e]))
              (++ i))
        (ev.startsWith "&")
        (do (set! e (symbol (rest ev)))
            (conj! ret [e i e]))
        :else
        (conj! ret e))
      (keyword? e)
      (raise! "bad function args destructure: " (typeid e))
      (array? e)
      (conj! ret [(symbol (gensym)) i e])
      :else
      (raise! "bad function args destructure: " (typeid e))))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- handleFuncArgs "" [fargs env]
  (var out [] misc []
       keys [] ret (tnode) knode (tnode))
  (each (fn [arg]
          (cond
            (symbol? arg) (conj! keys arg)
            (and (symbol? (first arg))
                 (not (.startsWith (str (first arg)) "&"))
                 (array? (nth arg 2)))
            (do (conj! keys (first arg))
                (conj! misc arg))
            :else (conj! misc arg))) fargs)
  (each (fn [arr]
          (var a0 (first arr)
               name (str a0)
               varg? (name.startsWith "&")
               pos (str (nth arr 1))
               a2 (nth arr 2))
          (if varg? (set! name (rest name)))
          (set! name (rdr/jsid name))
          (cond
            (and (symbol? a0)
                 (symbol? a2))
            (ret.add ["let " name
                      "=Array.prototype.slice.call(arguments," pos ");\n"])
            (array? a2)
            (do (if varg?
                  (ret.add ["let " name
                            "=Array.prototype.slice.call(arguments," pos ");\n"]))
                (ret.add (first (destruct0 "let" a2 name env)))))) misc)
  (knode.add (join "," (map #(rdr/jsid (str %)) keys)))
  (conj! out knode ret)
  out)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-fn
  "" ^{:opcode ["fn"]} [ast env]
  (var ret (nodeTag (tnode) ast)
       args (nth ast 1)
       fargs nil
       hints {}
       body (ast.slice 2))
  (when (and (= 3 (alen args))
             (== "with-meta" (car args))
             (array? (nth args 1)))
    (set! hints (resolveMeta (nth args 2) env)
          args (nth args 1)
          fargs (handleFuncArgs (parseFuncArgs args) env)))
  (ret.add ["function (" (first fargs) ") {\n"
            (second fargs) (transpileDo body env true) "}"])
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fmtRegoSpecOps
  "" [alias fname]
  (str (rdr/jsid :SPEC-OPS) "[\"" alias "\"] = " fname))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fmtSpecOps "" [fname attrs]
  (var ks (or (get attrs "opcode") [])
       out (->> (map #(fmtRegoSpecOps
                        (str %) fname) ks)
                (join ";\n")))
  (if (not-empty ks) (str out ";\n") out))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-func "" [ast env public?]
  (var ret (nodeTag (tnode) ast)
       fname (transpile* (nth ast 1) env)
       mtd? (== (first ast) "method")
       dot? (contains? fname ".")
       hints {}
       fargs nil
       e2 (nth ast 2)
       doc nil args 2 body 3)
  (if (string? e2)
    (set! doc 2 args 3))
  (set! body (+1 args))
  (if doc (set! doc (nth ast doc)))
  (set! args (nth ast args)
        body (ast.slice body))
  (when (and (= 3 (alen args))
             (== "with-meta" (car args))
             (array? (nth args 1)))
    (set! hints (resolveMeta (nth args 2) env)
          args (nth args 1)))
  (set! fargs (handleFuncArgs (parseFuncArgs args) env))
  (cond
    mtd?
    (do (if (.-static hints) (ret.add "static "))
        (ret.add [fname " ("])
        (if (== fname "constructor")
          (body.push (symbol "this"))))
    dot?
    (ret.add [fname " = function ("])
    :else
    (ret.add (str "function " fname "(")))
  (ret.add [(first fargs)
            ") {\n"
            (second fargs) (transpileDo body env true) "}\n"])
  (if (not-empty hints)
    (ret.add (fmtSpecOps fname hints)))
  (if doc
    (ret.prepend (writeDoc doc)))
  (if (and public?
           (not dot?)
           (= 1 (.countNSPCache (rt/globalEnv))))
    (set-in! EXTERNS fname fname))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-func-private
  "" ^{:opcode ["defn-"]} [ast env] (sf-func ast env false))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-func-public
  "" ^{:opcode ["defn"]} [ast env] (sf-func ast env true))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-try
  "" ^{:opcode ["try"]} [ast env]
  (var ret (nodeTag (tnode) ast)
       stmtQ (stmt? ast)
       sz (alen ast))
  (var~ t f c)
  ;;look for finally
  (set! f (last ast))
  (if (and (array? f)
           (== "finally" (first f)))
    (set! f (ast.pop) sz (alen ast))
    (set! f nil))
  ;;look for catch
  (set! c nil)
  (if (> sz 1) (set! c (nth ast (-1 sz))))
  (if (and (array? c)
           (== "catch" (first c)))
    (do (if (or (< (alen c) 2)
                (not (symbol? (second c)))) (syntax! :e0 ast))
        (set! c (ast.pop)))
    (set! c nil))
  ;;try needs either a catch or finally or both
  (if (and (nil? f) (nil? c)) (syntax! :e0 ast))
  (ret.add ["try {\n"
            (transpileDo (exprHint (rest ast)
                                   (not stmtQ)) env) "\n}"])
  (when c
    (set! t (second c))
    (ret.add [(str "catch (" t ") {\n")
              (transpileDo (exprHint (c.slice 2)
                                     (not stmtQ)) env) ";\n}\n"]))
  (when f
    (ret.add ["finally {\n",
              (transpileDo (exprHint (rest f)
                                     false) env false) ";\n}\n"]))
  (when-not stmtQ
    (ret.prepend "(function(){\n")
    (ret.add "}).call(this)"))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-if
  "" ^{:opcode ["if"]} [ast env]
  (var ret (nodeTag (tnode) ast)
       stmtQ (stmt? ast)
       a1 (exprHint (nth ast 1) (not stmtQ))
       a2 (exprHint (nth ast 2) (not stmtQ))
       a3 (if (> (alen ast) 3) (nth ast 3))
       elze (if a3 (exprHint a3 (not stmtQ))))
  (set! a1 (transpile* a1 env)
        a2 (transpile* a2 env)
        elze (transpile* elze env))
  (if stmtQ
    (do (ret.add ["if (" a1 ") {\n" a2 ";\n}"])
        (if a3 (ret.add [" else { \n" elze ";\n}"])))
    (ret.add ["(" a1 " ?\n" a2 " :\n" (or elze "null") ")"]))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-nth "" ^{:opcode ["nth"]} [ast env]
  (var ret (nodeTag (tnode) ast))
  (transpileAtoms ast env)
  (ret.add [(nth ast 1) "[" (nth ast 2) "]"])
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-get
  "" ^{:opcode ["aget" "get"]} [ast env]
  (var ret (nodeTag (tnode) ast))
  (transpileAtoms ast env)
  (ret.add [(nth ast 1) "[" (nth ast 2) "]"])
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-array
  "" ^{:opcode ["vec"]} [ast env]
  (var ret (nodeTag (tnode) ast) epilog "\n]")
  (if (empty? ast)
    (ret.add "[]")
    (do (if-not (vector? ast)
          (ast.splice 0 1))
        (transpileAtoms ast env)
        (ret.add "[\n")
        (for [i 0 :while (< i (alen ast)) :recur (+1 i)]
          (if (> i 0) (ret.add ",\n"))
          (ret.add (nth ast i)))
        (ret.add epilog)))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-object
  "" ^{:opcode ["hashmap"]} [ast env]
  (var ret (nodeTag (tnode) ast) epilog "\n}")
  (if (empty? ast)
    (ret.add "{}")
    (do (if-not (map? ast)
          (ast.splice 0 1))
        (transpileAtoms ast env)
        (ret.add "{\n")
        (for [i 0 :while (< i (alen ast)) :recur (+2 i)]
          (if (> i 0) (ret.add ",\n"))
          (ret.add [(nth ast i) ": " (nexth ast i)]))
        (ret.add epilog)))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- icache [])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- includeFile [fname]
  (if (contains? icache fname)
    (tnode)
    (let [src (fs/readFileSync fname "utf-8")]
      (conj! icache fname)
      (transpileTree (psr/parser src fname)
                     (rt/globalEnv )))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-include "" [ast env]
  (var ret [] fname nil
       dir (path/dirname ast.source))
  (for [i 1 e nil
        :while (< i (alen ast)) :recur (+1 i)]
    (set! e (nth ast i))
    (if (or (not (array? e))
            (not= 1 (alen e))) (syntax! :e0 ast))
    (set! fname (first e))
    (if fname
      (set! fname (fname.replace /[\"]/g "")))
    (try
      (set! fname (fs/realpathSync (str dir "/" fname)))
      (catch e
        (syntax! :e11 ast)))
    (try
      (conj! ret (includeFile fname))
      (finally
        (.popNSP (rt/globalEnv)))))
  (if (empty? ret) (tnode) ret))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-require "" [ast env]
  (var~  as path v e refers renames)
  (var ret (nodeTag (tnode) ast))
  (for [i 1
        :while (< i (alen ast)) :recur (+1 i)]
    (set! e (nth ast i)
          as (gensym)
          refers nil renames nil)
    (if (or (not (array? e))
            (< (alen e) 3)) (syntax! :e0 ast))
    (set! path (first e))
    (for [j 1 :while (< j (alen e)) :recur (+1 j)]
      (set! v (nth e j))
      (cond
        (== v "as")
        (do (set! as (str (nexth e j)))
            (++ j))
        (== v "refer")
        (do (set! refers (nexth e j))
            (++ j))
        (== v "rename")
        (do (set! renames (nexth e j))
            (++ j))))
    (ret.add ["const " (rdr/jsid as)
              "= require("
              (transpileSingle path) ");\n"])
    (for [i 0
          :while (and refers
                      (< i (alen refers))) :recur (+1 i)]
      (set! v (transpileSingle (nth refers i)))
      (ret.add ["const " v "=" as "[\"" v "\"];\n"]))
    (for [i 0
          :while (and renames
                      (< i (alen renames))) :recur (+2 i)]
      (set! e (transpileSingle (nth renames i))
            v (transpileSingle (nexth renames i)))
      (ret.add ["const " v "=" as "[\"" e "\"];\n"])))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- resolveMeta "" [ast env]
  (cond
    (array? ast)
    (JSON/parse (str "" (transpile* ast env)))
    (keyword? ast)
    (->> (transpile* [ast true] env)
         (str "" )
         (JSON/parse ))
    (symbol? ast)
    (->> (transpile* [(symbol "tag") ast] env)
         (str "")
         (JSON/parse ))
    :else
    (raise! "Bad meta value" (prn ast))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-ns
  "" ^{:opcode ["ns"]} [ast env]
  (var ret []
       hints {} nsp (nth ast 1))
  (when (and (array? nsp)
             (= 3 (alen nsp))
             (== "with-meta" (car nsp))
             (symbol? (nth nsp 1)))
    (set! hints (resolveMeta (nth nsp 2) env)
          nsp (nth nsp 1)))
  (.pushNSP (rt/globalEnv) (str nsp))
  (set! ast (ast.slice 2))
  (for [i 0 e nil
        :while (< i (alen ast)) :recur (+1 i)]
    (set! e (nth ast i))
    (cond
      (and (pair? e)
           (== "include" (car e)))
      (conj! ret (sf-include e))
      (and (pair? e)
           (== "require" (car e)))
      (conj! ret (sf-require e))))
  ;;force a internal reference to stdlib for user files
  (set! nsp (.peekNSP (rt/globalEnv)))
  (cond
    (or (= nsp "czlab.kirby.bl.macros")
        (= nsp "czlab.kirby.bl.stdlib"))
    nil
    (nsp.startsWith "czlab.kirby.")
    (conj! ret (tnodeEx "const kirbystdlibref=std;\n"))
    :else
    (->> '(require ["kirby" :as kirbystdlibref])
         (sf-require )
         (conj! ret )))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- maybeStripStdlib "" [cmd]
  (var nsp (.peekNSP (rt/globalEnv))
       lib "kirbystdlibref.")
  (set! cmd (str cmd))
  (if (and (cmd.startsWith lib)
           (= nsp "czlab.kirby.bl.stdlib"))
    (cmd.slice (alen lib))
    cmd))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-comment
  "" ^{:opcode ["comment"]} [ast env] (nodeTag (tnode) ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-for
  "" ^{:opcode ["for"]} [ast env]
  (var ret (nodeTag (tnode) ast)
       stmtQ (stmt? ast)
       body (exprHint (ast.slice 2) false))
  (if (empty? body)
    (tnode)
    (sf-floop ret (nth ast 1) body env))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-floop "" [ret args body env]
  (var vars [] recurs [])
  (var~ tst nb e)
  (for [i 0 :while (< i (alen args)) :recur (+1 i)]
    (set! e (nth args i))
    (cond (== e "while")
          (do (set! tst (nexth args i)) (++ i))
          (== e "recur")
          (do (set! recurs (args.slice (+1 i)))
              (break-out-of-loop!))
          (symbol? e)
          (do (conj! vars e (nexth args i))
              (++ i))))
  (ret.add "for (")
  (for [i 0 :while (< i (alen vars)) :recur (+2 i)]
    (if (= i 0) (ret.add "let "))
    (if (not= i 0) (ret.add ","))
    (ret.add [(transpileSingle (nth vars i))
              "=" (transpile* (nexth vars i) env)]))
  (if (empty? vars)
    (ret.add "let ____break=false;")
    (ret.add ",____break=false;"))
  (set! nb '(not ____break))
  (if tst
    (set! tst [(symbol "and") nb tst])
    (set! tst nb))
  (ret.add (transpile* tst env))
  (ret.add "; ")
  (for [i 0 k 0
        :while (< i (alen recurs)) :recur (+1 i)(+2 k)]
    (if (not= i 0) (ret.add ","))
    (ret.add [(transpileSingle (nth vars k))
              "=" (transpile* (nth recurs i) env)]))
  (ret.add "){\n")
  (ret.add (transpileDo body env false))
  (ret.add "}\n")
  (when-not stmtQ
    (ret.prepend "(function() {\n")
    (ret.add "}).call(this)"))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-jscode
  "" ^{:opcode ["js#"]} [ast env]
  (nodeTag (tnodeEx (-> (str (second ast))
                        (.replace rdr/REGEX.dquoteHat "")
                        (.replace rdr/REGEX.dquoteEnd ""))) ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-macro
  "" ^{:opcode ["defmacro"]} [ast env]
  (var pms []
       args (nth ast 2)
       body (ast.slice 3))
  (when (string? args)
    (set! doc args
          args (nth ast 3)
          body (ast.slice 4)))
  (for [i 0 e nil ev nil
        :while (< i (alen args)) :recur (+1 i)]
    (set! e (nth args i) ev (str e))
    (cond
      (= ev "&")
      (if (array? (nexth args i))
        (do (set! e (nexth args i))
            (++ i)
            (for [j 0 x nil
                  :while (< j (alen e)) :recur (+1 j)]
              (set! x (nth e j))
              (if-not (symbol? x)
                (raise! "Bad optional arg for macro"))
              (conj! pms x)))
        (do (conj! pms e (nexth args i))
            (++ i)))
      (not (symbol? e))
      (raise! "Bad optional arg for macro")
      :else
      (conj! pms e)))
  (set! ast
        [(first ast)
         (second ast)
         (concat [(symbol "fn*") pms] body)])
  (var a2 (nth ast 2)
       a1 (str (nth ast 1))
       func (rt/compute a2 env))
  (set-in! func :____macro true)
  (if doc
    (set-in! func :____doc doc))
  (rt/setMacro a1 func)
  (nodeTag (tnode) ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-unary
  "" ^{:opcode ["not" "~" "!"]} [ast env]
  (var ret (nodeTag (tnode) ast)
       [a0 a1] ast)
  (if (== a0 "not") (set! a0 (symbol "!")))
  (ret.add ["(" (transpile* a0 env) (transpile* a1 env) ")"])
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- spitExterns "" []
  (var s "" ks (keys EXTERNS))
  (when (not-empty ks)
    (set! s (join ",\n"
                  (map #(str % ": " %) ks))
          s (str "\n\nmodule.exports = {\n" s "\n};\n\n")))
  s)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- banner "" []
  (str "/*"
       "Auto generated by Kirby - v"
       MODULE-VERSION " "
       (.firstNSP (rt/globalEnv)) " - " (new Date) "*/\n\n"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- cleanCode "" [code]
  (var arr [])
  (each (fn [s]
          (set! s (s.trim))
          (if (not= s ";") (conj! arr s))) (code.split "\n"))
  (join "\n" arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileCode "" [codeStr fname options]
  (.resetNSPCache (rt/globalEnv))
  (set! EXTERNS {})
  (var outNode (transpileTree (psr/parser codeStr fname)
                              (rt/globalEnv))
       {:keys [source-map format]} options
       cstr ""
       fopts {}
       extra (spitExterns))
  (outNode.prepend (banner))
  (set! cstr
        (if source-map
          (let [outFile (str (path/basename fname ".ky") ".js")
                srcMap (str outFile ".map")
                output (outNode.toStringWithSourceMap {:file outFile})]
            (fs/writeFileSync srcMap output.map)
            (str output.code
                 extra
                 "\n//# sourceMappingURL="
                 (path/relative (path/dirname fname) srcMap)))
          (str outNode extra)))
  (if format
    (set! cstr (esfmt/format cstr fopts)))
  (set! cstr (cleanCode cstr))
  (if format
    (set! cstr (esfmt/format cstr fopts)))
  cstr)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileXXX "" [code file options]
  (try
    (transpileCode code file options)
    (catch e
      (when e
        (println (.-stack e)) (throw e)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn transpileWithSrcMap
  "" [code file options]
  (transpileXXX code file options))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn transpile
  "" [code file options]
  (transpileXXX code file options))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn parseWithSourceMap "" [codeStr fname]
  (var outNode (transpileTree (psr/parser codeStr fname)))
  (outNode.prepend (banner))
  (outNode.toStringWithSourceMap ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(def version MODULE-VERSION)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

