;; Copyright (c) 2013-2017, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author "Kenneth Leung"}

  czlab.kirby.cg.transpiler

  (require ["../bl/stdlib"
            :as std
            :refer [lambda-arg? hashmap pair? contains? last typeid
                    prn primitive pair? map? vector? opt??
                    primitive? not-empty conj! list?
                    extendAttr gensym
                    symbol keyword symbol? keyword?]]
           ["../bl/lexer"
            :as rdr
            :refer
            [tnode tnodeEx]]
           ["../bl/parser" :as psr]
           ["../rt/runtime" :as rt])
  (require ["fs" :as fs]
           ["path" :as path]
           ["esformatter" :as esfmt]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- ERRORS-MAP {
  :e0 "Syntax Error"
  :e1 "Empty statement"
  :e2 "Invalid characters in function name"
  :e3 "End of File encountered, unterminated string"
  :e4 "Closing square bracket, without an opening square bracket"
  :e5 "End of File encountered, unterminated array"
  :e6 "Closing curly brace, without an opening curly brace"
  :e7 "End of File encountered, unterminated javascript object '}'"
  :e8 "End of File encountered, unterminated parenthesis"
  :e9 "Invalid character in var name"
  :e10 "Extra chars at end of file. Maybe an extra ')'."
  :e11 "Cannot Open include File"
  :e12 "Invalid no of arguments to "
  :e13 "Invalid Argument type to "
  :e14 "End of File encountered, unterminated regular expression"
  :e15 "Invalid vararg position, must be last argument."
  :e16 "Invalid arity (args > expected) to "
  :e17 "Invalid arity (args < expected) to "})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- MODULE-VERSION "1.0.0")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- EXTERNS nil
      SPEC-OPS {}
      MATH-OP-REGEX /^[-+][0-9]+$/)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- simpleton? "" [ast]
  (or (undef? ast)
      (string? ast)
      (number? ast)
      (boolean? ast) (nil? ast)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- exprHint "" [ast flag]
  (var x ast)
  (if (simpleton? ast)
    (set! x (primitive ast)))
  (set-in! x :____expr flag)
  x)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- stmt? "" [ast]
  (if (simpleton? ast)
    (raise! "Cant test expr? on primitive"))
  (false? ast.____expr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- error! "" [e &[line file msg]]
  (raise! (get ERRORS-MAP e)
          (if msg (str " : " msg))
          (if line (str "\nLine no " line))
          (if file (str "\nFile " file))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- syntax! "" [ecode &[ast cmd]]
  (error! ecode
          (if ast ast.line 0)
          (if ast ast.source 0) cmd))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- pad "" [z] (.repeat " " z))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- testre? "" [re x] (if x (re.test x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- nodeTag "" [obj src]
  (when (and obj
             src
             (not (simpleton? obj)))
    (set! obj.source src.source
          obj.column src.column obj.line src.line)) obj)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destructVec "" [lhs keys]
  (var~ as e ev)
  (for [i 0 len (alen lhs)
        :while (< i len) :recur (+1 i)]
    (set! e (.@i lhs) ev (str e))
    (cond (symbol? e)
          (cond (= ev "_")
                nil
                (= ev "&")
                (do (set-in! keys
                             (str "&"
                                  (nexth lhs i)) i)
                    (++ i))
                (ev.startsWith "&")
                (set-in! keys ev i)
                :else
                (set-in! keys ev i))
          (keyword? e)
          (if (= ev "as")
            (do (++ i)
                (set! as (str (.@i lhs))))
            (raise! "bad keyword: :" ev))))
  as)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destructMap "" [lhs keys]
  (var~ as e ev)
  (for [i 0 len (alen lhs)
        :while (< i len) :recur (+1 i)]
    (set! e (.@i lhs) ev (str e))
    (if (keyword? e)
      (cond (or (= ev "keys")
                (= ev "strs"))
            (let [ks (nexth lhs i)]
              (++ i)
              (for [j 0 l2 (alen ks)
                    :while (< j l2) :recur (+1 j)]
                (set-in! keys
                         (str (.@j ks)) nil)))
            (= ev "as")
            (do (++ i)
                (set! as (str (.@i lhs)))))
      (raise! "bad destruct field: " (typeid e))))
  as)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destruct1 "" [lhs]
  (var as nil out [] keys {})
  (cond (vector? lhs)
        (set! as (destructVec lhs keys))
        (map? lhs)
        (set! as (destructMap lhs keys))
        (symbol? lhs)
        (set-in! keys (str lhs) nil)
        :else
        (raise! "cant destruct with: " (typeid lhs)))
  [as keys])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destruct0 "" [cmd lhs rhs env]
  (var [as keys] (destruct1 lhs)
       kdefs [] ka nil kvals (tnode))
  (if (empty? as) (set! as (gensym "A____")))
  (set! as (rdr/jsid as))
  (each-key
    (fn [v k]
      (var rest? false)
      (when (k.startsWith "&")
        (set! rest? true
              k (rest k)))
      (set! k (rdr/jsid k))
      (conj! kdefs k)
      (->>
        (cond (nil? v)
              (str "[\"" k "\"];\n")
              rest?
              (str ".slice(" v ");\n")
              :else
              (str "[" v "];\n"))
        (str k "=" as )
        (kvals.add ))) keys)
  (kvals.prepend (str cmd
                      " "
                      (join "," kdefs) ";\n"))
  [[(tnodeEx [cmd " "
              (rdr/jsid as) "= "
              (tx* rhs env) ";\n"]) kvals] kdefs])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txTreeOld "" [root env]
  (var ret (node' (tnode) root))
  (each #(if-some
           [tmp (tx* % env)]
           (ret.add [tmp "\n"])) root) ret)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txTree "" [root env]
  (var ret (node' (tnode) root))
  (doseq [r root
          :let [tmp (tx* r env)]
          :when (some? tmp)]
    (ret.add [tmp "\n"])) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txExpr "" [atoms env]
  (each (fn [a i arr]
          (set-in! arr i (tx* a env))) atoms))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txAtom "" [a]
  (var s (str a))
  (cond (lambda-arg? a)
        (str "____args[" s "]")
        (keyword? a)
        (str "\"" s "\"")
        (symbol? a)
        (rdr/jsid s)
        (primitive? a)
        (do (set! a a.value)
            (cond (string? a) a
                  (nil? a) "null"
                  :else (str a)))
        :else s))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- tx* "" [x env]
  (if (array? x) (txPairs x env) (txAtom x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- findCmd "" [ast]
  (cond (map? ast)
        "hashmap"
        (vector? ast)
        "vec"
        (list? ast)
        "list"
        (array? ast)
        (str (first ast))
        :else ""))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quoteSingle "" [a]
  (cond (keyword? a)
        (str "keyword(\":" a "\")")
        (symbol? a)
        (str "symbol(\"" a "\")")
        (primitive? a)
        (do (set! a a.value)
            (cond (string? a) a
                  (nil? a) "null"
                  :else (str a)))
        :else (str a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quote! "" [a env]
  (if (array? a)
    (if (map? a)
      (quoteMap a env)
      (quoteBlock a env))
    (quoteSingle a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quoteMap "" [a env]
  (var ret (tnode) comma "")
  (for [i 0 len (alen a)
        :while (< i len) :recur (+2 i)]
    (if (> i 0) (ret.add ","))
    (ret.add [(quote! (.@i a) env)
              " : " (quote! (nexth a i) env)]))
  (if-not (empty? a) (set! comma ","))
  (ret.prepend ["[" "symbol(\"hashmap\")" comma])
  (ret.add "]")
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quoteBlock "" [a env]
  (var ret (tnode))
  (for [i 0 len (alen a)
        :while (< i len) :recur (+1 i)]
    (if (> i 0) (ret.add ","))
    (ret.add (quote! (.@i a) env)))
  (ret.prepend "[")
  (ret.add "]")
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-quote "" ^{:opcode ["quote"]} [ast env]
  (var ret (node' (tnode) ast))
  (ret.add (quote! (.@1 ast) env))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txPairs "" [ast env]
  (var stmtQ (stmt? ast)
       cmd (findCmd ast)
       ret (tnode)
       specop nil
       tmp nil
       mc (rt/getMacro cmd))
  ;;handle macro calls
  (when mc
    (set! ast (rt/expandMacro ast env mc)
          ast (exprHint ast (not stmtQ))
          cmd (findCmd ast)))
  ;;handle (+1 ) or (-1 ) cases
  (when (rdr/REGEX.int.test cmd)
    (var c0 (ch@ cmd 0))
    (if (and (not= c0 "-")
             (not= c0 "+"))
      (set! cmd (str "+" cmd)))
    (set! ast [(symbol (ch@ cmd 0))
               (.@1 ast)
               (int (rest cmd))]
          cmd (str (first ast))))
  ;;maybe special form
  (set! specop (get SPEC-OPS cmd))
  ;;handle all cases
  (cond
    (== cmd "with-meta")
    (do (set! tmp (.@1 ast))
        (if-not (simpleton? tmp)
          (do (set-in! tmp
                       :____meta
                       (evalMeta (.@2 ast) env))
              (ret.add (tx* tmp env)))
          (raise! "cant with-meta simple value")))
    (cmd.startsWith ".-")
    (ret.add [(tx* (.@1 ast) env)
              "."
              (txAtom (symbol (cmd.slice 2)))])
    (cmd.startsWith ".@")
    (do (var onemore? false pos 2)
        (when (cmd.startsWith ".@+")
          (++ pos)
          (true! onemore?))
        (ret.add [(tx* (nth ast 1) env) "[" (cmd.slice pos)])
        (if onemore?
          (ret.add"+1]")
          (ret.add "]")))
    (= "." (ch@ cmd 0))
    (do (ret.add [(tx* (.@1 ast) env) cmd "("])
        (for [n 2 len (alen ast)
              :while (< n len) :recur (+1 n)]
          (if (not= n 2) (ret.add ","))
          (ret.add (tx* (.@n ast) env)))
        (ret.add ")"))
    (some? specop)
    (set! ret (specop ast env))
    :else
    (do (if (pair? ast)
          (do (txExpr ast env)
              (set! cmd (.@0 ast)))
          (set! cmd (txAtom ast)))
        (if-not cmd (syntax! :e1 ast))
        (set! cmd (maybeStripStdlib cmd))
        (if (pair? ast)
          (do (if (testre? rdr/REGEX.func cmd)
                (set! cmd (tnodeEx ["(" cmd ")"])))
              (ret.add [cmd
                        "("
                        (join "," (tnodeEx (rest ast))) ")"]))
          (ret.add cmd))))
  (node' ret ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- writeDoc
"Convert to jsdoc"
  [doc]
  (if doc
    (->> (-> (doc.replace rdr/REGEX.dquoteHat "")
             (.replace rdr/REGEX.dquoteEnd "")
             (.split "\\n"))
         (map #(str "//" % "\n"))) ""))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-deftype
"Define a JS Class"
  [ast env public?]
  (var ret (node' (tnode) ast)
       cz (tx* (.@1 ast) env)
       par (.@0 (.@2 ast))
       args (.@3 ast))
  (var~ n m doc mtds)
  (if (string? (.@4 ast))
    (do (set! doc (.@4 ast)
              mtds (ast.slice 5)))
    (set! mtds (ast.slice 4)))
  (ret.add ["class " cz])
  (if par
    (ret.add [" extends " (tx* par env)]))
  (ret.add " {\n")
  (for [i 0 ml (alen mtds)
        :while (< i ml) :recur (+1 i)]
    (set! m (.@i mtds))
    (when (and (== (.@0 m) "constructor")
               (not-empty args))
      (for [x 0 al (alen args)
            :while (< x al) :recur (+2 x)]
        (set-in! args
                 x
                 (str "\"" (.@x args) "\"")))
      (m.splice 2 0
        (concat [(symbol "set-in!")
                 (symbol "this")] args)))
    (m.unshift (symbol "method"))
    (ret.add (sf-func m env false))
    (ret.add "\n"))
  (ret.add "}\n")
  (if doc (ret.prepend (writeDoc doc)))
  (if (and public?
           (= 1 (.countNSPCache (rt/globalEnv))))
      (set-in! EXTERNS cz cz))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- prv-deftype
  ""
  ^{:opcode ["deftype-"]}
  [a e] (sf-deftype a e false))
(defn- pub-deftype
  ""
  ^{:opcode ["deftype"]}
  [a e] (sf-deftype a e true))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-compOp ""
  ^{:opcode ["not=" "!=" "=="
             "=" ">" ">=" "<" "<="]} [ast env]
  (var ret (node' (tnode) ast)
       cmd (.@0 ast))
  (if (or (== cmd "not=")
          (== cmd "!="))
    (set-in! ast 0 (symbol "!==")))
  (if (== cmd "=")
    (set-in! ast 0 (symbol "===")))
  (txExpr ast env)
  (for [i 0 op (ast.shift)
        :while (< i (last-index ast)) :recur (+1 i)]
    (ret.add (tnodeEx [(.@i ast)
                       " " op
                       " " (nexth ast i)])))
  (join " && " ret)
  (ret.prepend "(")
  (ret.add ")")
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-arithOp
  ""
  ^{:opcode ["+" "-" "*" "div" "%"  "mod"
             "||" "&&"
             "^" "&" "|" "<<" ">>" ">>>"]} [ast env]
  (var ret (node' (tnode) ast) op (tnode))
  (txExpr ast env)
  (var e1 (ast.shift) cmd (str e1))
  (if (== cmd "mod") (set! cmd "%"))
  (if (== cmd "div") (set! cmd "/"))
  (if (= 1 (alen ast))
    (if (== "-" cmd) (ret.add "-"))
    (op.add [""  cmd  ""]))
  (ret.add ast)
  (if (> (alen ast) 1) (join op ret))
  (ret.prepend "(")
  (ret.add ")")
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txDo "" [ast env & [return?]]
  (var ret (node' (tnode) ast)
       stmtQ (stmt? ast)
       e nil end (last-index ast))
  (set! return?
        (if stmtQ false (opt?? return? true)))
  (for [i 0 :while (< i end) :recur (+1 i)]
    (set! e (exprHint (.@i ast) false))
    (ret.add [(txPairs e env) ";\n"]))
  (when (>= end 0)
    (set! e (exprHint (.@end ast)
                      (not stmtQ))
          e (tx* e env))
    (if-not return?
      (ret.add [e ";\n"])
      (ret.add ["return " e ";\n"])))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-do
  "" ^{:opcode ["do"]} [ast env]
  (var ret (node' (tnode) ast)
       stmtQ (stmt? ast)
       body (exprHint (rest ast) (not stmtQ)))
  (ret.add (txDo body env (not stmt?)))
  (if stmtQ
    (ret.prepend "{\n")
    (ret.prepend "(function() {\n"))
  (if stmtQ
    (ret.add "}")
    (ret.add "}).call(this)"))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-case
  "" ^{:opcode ["case"]} [ast env]
  (var ret (node' (tnode) ast)
       stmtQ (stmt? ast)
       tst (.@1 ast) _x (gensym))
  (var~ e t c dft)
  (if (odd? (alen ast))
    (set! dft (ast.pop)))
  (for [i 2 al (alen ast)
        :while (< i al) :recur (+2 i)]
    (set! e (.@i ast)
          c (nexth ast i))
    (if (pair? e)
      (for [j 0 el (alen e)
            :while (< j el) :recur (+1 i)]
        (ret.add ["case "
                  (txAtom (.@j e)) ":\n"])
        (if (= j (last-index e))
          (ret.add [_x "="
                    (tx* c env) ";\nbreak;\n"])))
      (do (ret.add ["case " (txAtom e) ":\n"
                    _x "="
                    (tx* c env) ";\nbreak;\n"]))))
  (when dft
    (ret.add ["default:\n"
              _x "="
              (tx* dft env) ";\nbreak;\n"]))
  (ret.prepend ["switch ("
                (tx* tst env) ") {\n"])
  (ret.add "}")
  (if stmtQ
    (ret.prepend ["{ let " _x ";\n"])
    (ret.prepend ["(function() { let " _x ";\n"]))
  (if stmtQ
    (ret.add "}")
    (ret.add ["return " _x ";}).call(this)"]))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-vardefs "" [ast env cmd]
  (var ret (node' (tnode) ast)
       kks {}
       public? (== "global" cmd))
  (if-not (== "let" cmd) (set! cmd "var"))
  (for [i 1 s nil sl (alen ast)
        :while (< i sl) :recur (+1 i)]
    (set! s (txAtom (.@i ast)))
    (ret.add s)
    (set-in! kks s nil))
  (ret.join ",")
  (ret.prepend (str cmd " "))
  (ret.add ";\n")
  (if (and public?
           (= 1 (.countNSPCache (rt/globalEnv))))
    (each-key (fn [v k]
                (set-in! EXTERNS k k)) kks))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- local-vardefs
  ""
  ^{:opcode ["def~-"]}
  [ast env] (sf-vardefs ast env "local"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- global-vardefs
  ""
  ^{:opcode ["def~"]}
  [ast env] (sf-vardefs ast env "global"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- let-vardefs
  ""
  ^{:opcode ["var~"]}
  [ast env] (sf-vardefs ast env "let"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-const "" [ast env cmd]
  (var ret (node' (tnode) ast)
       kks {} keys []
       vname nil public? (== "global" cmd))
  (var~ rc lhs rhs)
  (set! ast (rest ast) cmd "const")
  (for [i 0 al (alen ast)
       :while (< i al) :recur (+2 i)]
    (set! lhs (.@i ast)
          rhs (nexth ast i))
    (if (symbol? lhs)
      (do (set! lhs (txAtom lhs))
          (set-in! kks lhs nil)
          (ret.add ["const " lhs
                    "= " (tx* rhs env) ";\n"]))
      (do (set! rc (destruct0 cmd lhs rhs env))
          (ret.add (.@0 rc))
          (each #(set-in! kks
                          (rdr/jsid %) nil)
                (.@1 rc)))))
  (when (and public?
             (= 1 (.countNSPCache (rt/globalEnv))))
    (each #(set-in! EXTERNS % %) (keys kks)))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-const-global
  "" ^{:opcode ["const"]}
  [ast env] (sf-const ast  env  "global"))
(defn- sf-const-local
  "" ^{:opcode ["const-"]}
  [ast env] (sf-const ast  env  "local"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-var "" [ast env cmd]
  (var ret (node' (tnode) ast)
       vname nil keys [] kks {}
       tmp nil public? (== "global" cmd))
  (var~ rc lhs rhs)
  (set! ast (rest ast))
  (if (or public?
          (== "local" cmd)) (set! cmd "var"))
  (comment
    (for [i 0
          :while (< i (alen ast)) :recur (+2 i)]
      (if (symbol? (.@i ast))
        (conj! keys (.@i ast))))
    (if (not-empty keys)
      (ret.add ["let "
                (join ","
                      (map (fn [s]
                             (var ss (txAtom s))
                             (set-in! kks ss nil) ss) keys)) ";\n"])))
  (for [i 0 al (alen ast)
        :while (< i al) :recur (+2 i)]
    (set! lhs (.@i ast)
          rhs (nexth ast i))
    (if (symbol? lhs)
      (do (set! lhs (txAtom lhs)
                tmp ["= "
                     (tx* rhs env) ";\n"])
          (when-not (contains? kks lhs)
            (set-in! kks lhs nil)
            (tmp.unshift cmd " "))
          (ret.add tmp))
      (do (set! rc (destruct0 cmd lhs rhs env))
          (ret.add (.@0 rc))
          (map #(set-in! kks
                         (rdr/jsid %) nil)
               (.@1 rc)))))
  (when (and public?
             (= 1 (.countNSPCache (rt/globalEnv))))
    (each-key (fn [v k]
                (set-in! EXTERNS k k)) kks))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-var-local
  ""
  ^{:opcode ["def-"]}
  [ast env] (sf-var ast env "local"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-var-global
  ""
  ^{:opcode ["def"]}
  [ast env] (sf-var ast env  "global"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-var-let
  ""
  ^{:opcode ["var"]}
  [ast env] (sf-var ast env "let"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-inst?
  "" ^{:opcode ["inst?"]} [ast env]
  (var ret (node' (tnode) ast))
  (ret.add ["("
            (tx* (.@2 ast) env)
            " instanceof "
            (tx* (.@1 ast) env) ")"])
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-delete
  "" ^{:opcode ["delete!"]} [ast env]
  (var ret (node' (tnode) ast))
  (ret.add ["delete " (tx* (.@1 ast) env)])
  (if (> (alen ast) 2)
    (ret.add ["[" (tx* (.@2 ast)) "]"]))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-new
  "" ^{:opcode ["new"]} [ast env]
  (var ret (node' (tnode) ast))
  (ret.add (txPairs (rest ast) env))
  (ret.prepend "new ")
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-throw
  "" ^{:opcode ["throw"]} [ast env]
  (var ret (node' (tnode) ast)
       stmtQ (stmt? ast))
  (ret.add ["throw " (tx* (.@1 ast) env)])
  (when-not stmtQ
    (ret.prepend "(function (){ ")
    (ret.add " }).call(this)"))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-x-opop
  "" ^{:opcode ["++" "--"]} [ast env]
  (txExpr ast env)
  (node' (tnodeEx [(.@0 ast)
                   (.@1 ast)]) ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-x-eq
  "" ^{:opcode ["+=" "-=" "*="
                "/=" "%=" "<<="
                ">>=" ">>>=" "&=" "|=" "^="]} [ast env]
  (txExpr ast env)
  (node' (tnodeEx [(.@1 ast)
                   " "
                   (.@0 ast)
                   " " (.@2 ast)])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-set-in
  "" ^{:opcode ["set-in!"]} [ast env]
  (assert (even? (alen ast))
          "set-in: bad arg count")
  (var ret (node' (tnode) ast)
       more false
       obj (tx* (.@1 ast) env))
  (for [i 2 al (alen ast)
        :while (< i al) :recur (+2 i)]
    (when (> i 2)
      (ret.add ",")
      (set! more true))
    (ret.add [obj "[" (tx* (.@i ast) env) "]"
              "=" (tx* (nexth ast i) env)]))
  (when more
    (ret.prepend "(")
    (ret.add ")"))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-set
  "" ^{:opcode ["set!"]} [ast env]
  (assert (odd? (alen ast))
          "set: bad arg count")
  (var more false
       ret (node' (tnode) ast))
  (for [i 1 al (alen ast)
        :while (< i al) :recur (+2 i)]
    (when (> i 1)
      (ret.add ",")
      (set! more true))
    (ret.add [(tx* (.@i ast) env)
              "=" (tx* (nexth ast i) env)]))
  (when more
    (ret.prepend "(")
    (ret.add ")"))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- parseFuncArgs "" [args]
  (var ret [])
  (var~ e ev)
  (for [i 0 al (alen args)
        :while (< i al) :recur (+1 i)]
    (set! e (.@i args) ev (str e))
    (cond (symbol? e)
          (cond (= ev "_")
                (conj! ret
                       (symbol (gensym "_")))
                (= ev "&")
                (do (set! e (nexth args i))
                    (if (symbol? e)
                      (conj! ret [e i e])
                      (conj! ret [(symbol (str "&" (gensym))) i e]))
                    (++ i))
                (ev.startsWith "&")
                (do (set! e (symbol (rest ev)))
                    (conj! ret [e i e]))
                :else
                (conj! ret e))
          (keyword? e)
          (raise! "bad function args destructure: " (typeid e))
          (array? e)
          (conj! ret [(symbol (gensym)) i e])
          :else
          (raise! "bad function args destructure: " (typeid e))))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- handleFuncArgs "" [fargs env]
  (var out [] misc []
       keys [] ret (tnode) knode (tnode))
  (each (fn [arg]
          (cond
            (symbol? arg)
            (conj! keys arg)
            (and (symbol? (.@0 arg))
                 (not (.startsWith (str (.@0 arg)) "&"))
                 (array? (.@2 arg)))
            (do (conj! keys (.@0 arg))
                (conj! misc arg))
            :else (conj! misc arg))) fargs)
  (each (fn [arr]
          (var a0 (.@0 arr)
               name (str a0)
               varg? (name.startsWith "&")
               pos (str (.@1 arr))
               a2 (.@2 arr))
          (if varg? (set! name (rest name)))
          (set! name (rdr/jsid name))
          (cond
            (and (symbol? a0)
                 (symbol? a2))
            (ret.add ["let " name
                      "=Array.prototype.slice.call(arguments," pos ");\n"])
            (array? a2)
            (do (if varg?
                  (ret.add ["let " name
                            "=Array.prototype.slice.call(arguments," pos ");\n"]))
                (ret.add (.@0 (destruct0 "let" a2 name env)))))) misc)
  (knode.add (join "," (map #(rdr/jsid (str %)) keys)))
  (conj! out knode ret))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-fn
  "" ^{:opcode ["fn"]} [ast env]
  (var ret (node' (tnode) ast)
       args (.@1 ast)
       fargs nil
       hints {}
       body (ast.slice 2))
  (when (and (= 3 (alen args))
             (== "with-meta" (.@0 args))
             (array? (.@1 args)))
    (set! hints (evalMeta (.@2 args) env)
          args (.@1 args)
          fargs (handleFuncArgs
                  (parseFuncArgs args) env)))
  (ret.add ["function (" (.@0 fargs) ") {\n"
            (.@1 fargs) (txDo body env true) "}"])
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fmtRegoSpecOps
  "" [alias fname]
  (str (rdr/jsid :SPEC-OPS)
       "[\"" alias "\"] = " fname))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fmtSpecOps "" [fname attrs]
  (var ks (or (get attrs "opcode") [])
       out (->> (map #(fmtRegoSpecOps
                        (str %) fname) ks)
                (join ";\n")))
  (if (not-empty ks) (str out ";\n") out))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-func "" [ast env public?]
  (var mtd? (== (.@0 ast) "method")
       fname (tx* (.@1 ast) env)
       dot? (contains? fname ".")
       ret (node' (tnode) ast)
       hints {}
       fargs nil
       e2 (.@2 ast)
       doc nil args 2 body 3)
  (if (string? e2)
    (set! doc 2 args 3))
  (set! body (+1 args))
  (if doc (set! doc (nth ast doc)))
  (set! args (nth ast args)
        body (ast.slice body))
  (when (and (= 3 (alen args))
             (== "with-meta" (.@0 args))
             (array? (.@1 args)))
    (set! hints (evalMeta (.@2 args) env)
          args (.@1 args)))
  (set! fargs
        (handleFuncArgs
          (parseFuncArgs args) env))
  (cond mtd?
        (do (if (.-static hints)
              (ret.add "static "))
            (ret.add [fname " ("])
            (if (== fname "constructor")
              (body.push (symbol "this"))))
        dot?
        (ret.add [fname " = function ("])
        :else
        (ret.add (str "function " fname "(")))
  (ret.add [(.@0 fargs)
            ") {\n"
            (.@1 fargs)
            (txDo body env true) "}\n"])
  (if (not-empty hints)
    (ret.add (fmtSpecOps fname hints)))
  (if doc
    (ret.prepend (writeDoc doc)))
  (if (and public?
           (not dot?)
           (= 1 (.countNSPCache (rt/globalEnv))))
    (set-in! EXTERNS fname fname))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-func-private
  ""
  ^{:opcode ["defn-"]}
  [ast env] (sf-func ast env false))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-func-public
  ""
  ^{:opcode ["defn"]}
  [ast env] (sf-func ast env true))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-try
  "" ^{:opcode ["try"]} [ast env]
  (var ret (node' (tnode) ast)
       stmtQ (stmt? ast)
       sz (alen ast))
  (var~ t f c)
  ;;look for finally
  (set! f (last ast))
  (if (and (array? f)
           (== "finally" (.@0 f)))
    (set! f (ast.pop)
          sz (alen ast))
    (set! f nil))
  ;;look for catch
  (set! c nil)
  (if (> sz 1)
    (set! c (nth ast (-1 sz))))
  (if (and (array? c)
           (== "catch" (.@0 c)))
    (do (if (or (< (alen c) 2)
                (not (symbol? (.@1 c)))) (syntax! :e0 ast))
        (set! c (ast.pop)))
    (set! c nil))
  ;;try needs either a catch or finally or both
  (if (and (nil? f) (nil? c)) (syntax! :e0 ast))
  (ret.add ["try {\n"
            (txDo (exprHint (rest ast)
                            (not stmtQ)) env) "\n}"])
  (when c
    (set! t (.@1 c))
    (ret.add [(str "catch (" t ") {\n")
              (txDo (exprHint (c.slice 2)
                              (not stmtQ)) env) ";\n}\n"]))
  (when f
    (ret.add ["finally {\n",
              (txDo (exprHint (rest f)
                              false) env false) ";\n}\n"]))
  (when-not stmtQ
    (ret.prepend "(function(){\n")
    (ret.add "}).call(this)"))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-if
  "" ^{:opcode ["if"]} [ast env]
  (var ret (node' (tnode) ast)
       stmtQ (stmt? ast)
       a1 (exprHint (.@1 ast) (not stmtQ))
       a2 (exprHint (.@2 ast) (not stmtQ))
       a3 (if (> (alen ast) 3) (.@3 ast))
       elze (if a3 (exprHint a3 (not stmtQ))))
  (set! a1 (tx* a1 env)
        a2 (tx* a2 env)
        elze (tx* elze env))
  (if stmtQ
    (do (ret.add ["if (" a1 ") {\n" a2 ";\n}"])
        (if a3 (ret.add [" else { \n" elze ";\n}"])))
    (ret.add ["(" a1 " ?\n" a2 " :\n" (or elze "null") ")"]))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-nth "" ^{:opcode ["nth"]} [ast env]
  (var ret (node' (tnode) ast))
  (txExpr ast env)
  (ret.add [(.@1 ast) "[" (.@2 ast) "]"])
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-get
  "" ^{:opcode ["aget" "get"]} [ast env]
  (var ret (node' (tnode) ast))
  (txExpr ast env)
  (ret.add [(.@1 ast) "[" (.@2 ast) "]"])
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-array
  "" ^{:opcode ["vec"]} [ast env]
  (var ret (node' (tnode) ast) epilog "\n]")
  (if (empty? ast)
    (ret.add "[]")
    (do (if-not (vector? ast)
          (ast.splice 0 1))
        (txExpr ast env)
        (ret.add "[\n")
        (for [i 0 al (alen ast)
              :while (< i al) :recur (+1 i)]
          (if (> i 0) (ret.add ",\n"))
          (ret.add (.@i ast)))
        (ret.add epilog)))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-object
  "" ^{:opcode ["hashmap"]} [ast env]
  (var ret (node' (tnode) ast) epilog "\n}")
  (if (empty? ast)
    (ret.add "{}")
    (do (if-not (map? ast)
          (ast.splice 0 1))
        (txExpr ast env)
        (ret.add "{\n")
        (for [i 0 al (alen ast)
              :while (< i al) :recur (+2 i)]
          (if (> i 0) (ret.add ",\n"))
          (ret.add [(.@i ast) ": " (nexth ast i)]))
        (ret.add epilog)))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- icache [])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- includeFile [fname]
  (if (contains? icache fname)
    (tnode)
    (let [src (fs/readFileSync fname "utf-8")]
      (conj! icache fname)
      (txTree (psr/parser src fname)
              (rt/globalEnv )))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-include "" [ast env]
  (var ret []
       dir (path/dirname ast.source))
  (var~ fname e)
  (for [i 1 al (alen ast)
        :while (< i al) :recur (+1 i)]
    (set! e (.@i ast))
    (if (or (not (array? e))
            (not= 1 (alen e))) (syntax! :e0 ast))
    (set! fname (.@0 e))
    (if fname
      (set! fname (fname.replace /[\"]/g "")))
    (try
      (set! fname (fs/realpathSync
                    (str dir "/" fname)))
      (catch e
        (syntax! :e11 ast)))
    (try
      (conj! ret (includeFile fname))
      (finally
        (.popNSP (rt/globalEnv)))))
  (if (empty? ret) (tnode) ret))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-require "" [ast env]
  (var~  as path v e refers renames)
  (var ret (node' (tnode) ast))
  (for [i 1 al (alen ast)
        :while (< i al) :recur (+1 i)]
    (set! e (.@i ast)
          as (gensym)
          refers nil renames nil)
    (if (or (not (array? e))
            (< (alen e) 3)) (syntax! :e0 ast))
    (set! path (.@0 e))
    (for [j 1 al (alen e)
          :while (< j al) :recur (+1 j)]
      (set! v (.@j e))
      (cond (== v "as")
            (do (set! as (str (nexth e j)))
                (++ j))
            (== v "refer")
            (do (set! refers (nexth e j))
                (++ j))
            (== v "rename")
            (do (set! renames (nexth e j))
                (++ j))))
    (ret.add ["const " (rdr/jsid as)
              "= require("
              (txAtom path) ");\n"])
    (for [i 0 rl (alen refers)
          :while (and refers
                      (< i rl)) :recur (+1 i)]
      (set! v (txAtom (.@i refers)))
      (ret.add ["const " v "=" as "[\"" v "\"];\n"]))
    (for [i 0 rl (alen renames)
          :while (and renames
                      (< i rl)) :recur (+2 i)]
      (set! e (txAtom (.@i renames))
            v (txAtom (nexth renames i)))
      (ret.add ["const " v
                "=" as "[\"" e "\"];\n"])))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- evalMeta "" [ast env]
  (cond
    (array? ast)
    (JSON/parse (str "" (tx* ast env)))
    (keyword? ast)
    (->> (tx* [ast true] env)
         (str "" )
         (JSON/parse ))
    (symbol? ast)
    (->> (tx* [(symbol "tag") ast] env)
         (str "")
         (JSON/parse ))
    :else
    (raise! "Bad meta value" (prn ast))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-ns
  "" ^{:opcode ["ns"]} [ast env]
  (var ret [] e nil
       hints {} nsp (.@1 ast))
  (when (and (array? nsp)
             (= 3 (alen nsp))
             (== "with-meta" (car nsp))
             (symbol? (.@1 nsp)))
    (set! hints (evalMeta (.@2 nsp) env)
          nsp (.@1 nsp)))
  (.pushNSP (rt/globalEnv) (str nsp))
  (set! ast (ast.slice 2))
  (for [i 0 al (alen ast)
        :while (< i al) :recur (+1 i)]
    (set! e (.@i ast))
    (cond (and (pair? e)
               (== "include" (.@0 e)))
          (conj! ret (sf-include e))
          (and (pair? e)
               (== "require" (.@0 e)))
          (conj! ret (sf-require e))))
  ;;force a internal reference to stdlib for user files
  (set! nsp (.peekNSP (rt/globalEnv)))
  (cond
    (or (= nsp "czlab.kirby.bl.macros")
        (= nsp "czlab.kirby.bl.stdlib"))
    nil
    (nsp.startsWith "czlab.kirby.")
    (conj! ret (tnodeEx "const kirbystdlibref=std;\n"))
    :else
    (->> '(require ["kirby" :as kirbystdlibref])
         (sf-require )
         (conj! ret )))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- maybeStripStdlib "" [cmd]
  (var lib "kirbystdlibref."
       nsp (.peekNSP (rt/globalEnv)))
  (set! cmd (str cmd))
  (if (and (cmd.startsWith lib)
           (= nsp "czlab.kirby.bl.stdlib"))
    (cmd.slice (alen lib))
    cmd))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-comment
  "" ^{:opcode ["comment"]}
  [ast env] (node' (tnode) ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-for
  "" ^{:opcode ["for"]} [ast env]
  (var ret (node' (tnode) ast)
       stmtQ (stmt? ast)
       body (exprHint (ast.slice 2) false))
  (if (empty? body)
    (tnode)
    (sf-floop ret (.@1 ast) body env))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-floop "" [ret args body env]
  (var vars [] recurs [])
  (var~ tst nb e)
  (for [i 0 al (alen args)
        :while (< i al) :recur (+1 i)]
    (set! e (.@i args))
    (cond (== e "while")
          (do (set! tst (nexth args i)) (++ i))
          (== e "recur")
          (do (set! recurs (args.slice (+1 i)))
              (break-out-of-loop!))
          (symbol? e)
          (do (conj! vars e (nexth args i))
              (++ i))))
  (ret.add "for (")
  (for [i 0 al (alen vars)
        :while (< i al) :recur (+2 i)]
    (if (= i 0) (ret.add "let "))
    (if (not= i 0) (ret.add ","))
    (ret.add [(txAtom (.@i vars))
              "=" (tx* (nexth vars i) env)]))
  (if (empty? vars)
    (ret.add "let ____break=false;")
    (ret.add ",____break=false;"))
  (set! nb '(not ____break))
  (if tst
    (set! tst [(symbol "and") nb tst])
    (set! tst nb))
  (ret.add (tx* tst env))
  (ret.add "; ")
  (for [i 0 k 0 rl (alen recurs)
        :while (< i rl) :recur (+1 i)(+2 k)]
    (if (not= i 0) (ret.add ","))
    (ret.add [(txAtom (.@k vars))
              "=" (tx* (.@i recurs) env)]))
  (ret.add "){\n")
  (ret.add (txDo body env false))
  (ret.add "}\n")
  (when-not stmtQ
    (ret.prepend "(function() {\n")
    (ret.add "}).call(this)"))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-jscode
  "" ^{:opcode ["js#"]} [ast env]
  (node' (tnodeEx (-> (str (.@1 ast))
                      (.replace rdr/REGEX.dquoteHat "")
                      (.replace rdr/REGEX.dquoteEnd ""))) ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-macro
  "" ^{:opcode ["defmacro"]} [ast env]
  (var pms [] e nil ev nil
       args (.@2 ast)
       body (ast.slice 3))
  (when (string? args)
    (set! doc args
          args (.@3 ast)
          body (ast.slice 4)))
  (for [i 0 al (alen args)
        :while (< i al) :recur (+1 i)]
    (set! e (.@i args) ev (str e))
    (cond (= ev "&")
          (if (array? (nexth args i))
            (do (set! e (nexth args i))
                (++ i)
                (for [j 0 x nil al (alen e)
                      :while (< j al) :recur (+1 j)]
                  (set! x (.@j e))
                  (if-not (symbol? x)
                    (raise! "Bad optional arg for macro"))
                  (conj! pms x)))
            (do (conj! pms e (nexth args i))
                (++ i)))
          (not (symbol? e))
          (raise! "Bad optional arg for macro")
          :else
          (conj! pms e)))
  (set! ast
        [(.@0 ast)
         (.@1 ast)
         (concat [(symbol "fn*") pms] body)])
  (var a2 (.@2 ast)
       a1 (str (.@1 ast))
       func (rt/compute a2 env))
  (set-in! func :____macro true)
  (if doc
    (set-in! func :____doc doc))
  (rt/setMacro a1 func)
  (node' (tnode) ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-unary
  "" ^{:opcode ["not" "~" "!"]} [ast env]
  (var ret (node' (tnode) ast)
       [a0 a1] ast)
  (if (== a0 "not") (set! a0 (symbol "!")))
  (ret.add ["(" (tx* a0 env) (tx* a1 env) ")"])
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- spitExterns "" []
  (var s "" ks (keys EXTERNS))
  (when (not-empty ks)
    (set! s (join ",\n"
                  (map #(str % ": " %) ks))
          s (str "\n\nmodule.exports = {\n" s "\n};\n\n")))
  s)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- banner "" []
  (str "/*"
       "Auto generated by Kirby - v"
       MODULE-VERSION " "
       (.firstNSP (rt/globalEnv)) " - " (new Date) "*/\n\n"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- cleanCode "" [code]
  (var arr [])
  (doseq [s (code.split "\n")]
    (set! s (s.trim))
    (if (not= s ";") (conj! arr s)))
  (join "\n" arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileCode "" [codeStr fname options]
  (.resetNSPCache (rt/globalEnv))
  (set! EXTERNS {})
  (var outNode (txTree (psr/parser codeStr fname)
                       (rt/globalEnv))
       {:keys [source-map format]} options
       cstr ""
       fopts {}
       extra (spitExterns))
  (outNode.prepend (banner))
  (set! cstr
        (if source-map
          (let [outFile (str (path/basename fname ".ky") ".js")
                srcMap (str outFile ".map")
                output (outNode.toStringWithSourceMap {:file outFile})]
            (fs/writeFileSync srcMap output.map)
            (str output.code
                 extra
                 "\n//# sourceMappingURL="
                 (path/relative (path/dirname fname) srcMap)))
          (str outNode extra)))
  (if format
    (set! cstr (esfmt/format cstr fopts)))
  (set! cstr (cleanCode cstr))
  (if format
    (set! cstr (esfmt/format cstr fopts)))
  cstr)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileXXX "" [code file options]
  (try
    (transpileCode code file options)
    (catch e
      (when e
        (println (.-stack e)) (throw e)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn transpileWithSrcMap
  "" [code file options]
  (transpileXXX code file options))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn transpile
  "" [code file options]
  (transpileXXX code file options))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn parseWithSourceMap "" [codeStr fname]
  (var outNode (txTree (psr/parser codeStr fname)))
  (outNode.prepend (banner))
  (outNode.toStringWithSourceMap ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(def version MODULE-VERSION)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

