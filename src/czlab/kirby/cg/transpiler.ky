;; Copyright (c) 2013-2017, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author "Kenneth Leung"}

  czlab.kirby.cg.transpiler

  (require ["../bl/stdlib" :as std]
           ["../bl/lexer" :as rdr :refer [tnode tnodeEx]]
           ["../bl/parser" :as psr]
           ["../rt/runtime" :as rt])
  (require ["fs" :as fs]
           ["path" :as path]
           ["esformatter" :as esfmt]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- gensym-counter 1)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- ERRORS-MAP {
  :e0 "Syntax Error"
  :e1 "Empty statement"
  :e2 "Invalid characters in function name"
  :e3 "End of File encountered, unterminated string"
  :e4 "Closing square bracket, without an opening square bracket"
  :e5 "End of File encountered, unterminated array"
  :e6 "Closing curly brace, without an opening curly brace"
  :e7 "End of File encountered, unterminated javascript object '}'"
  :e8 "End of File encountered, unterminated parenthesis"
  :e9 "Invalid character in var name"
  :e10 "Extra chars at end of file. Maybe an extra ')'."
  :e11 "Cannot Open include File"
  :e12 "Invalid no of arguments to "
  :e13 "Invalid Argument type to "
  :e14 "End of File encountered, unterminated regular expression"
  :e15 "Invalid vararg position, must be last argument."
  :e16 "Invalid arity (args > expected) to "
  :e17 "Invalid arity (args < expected) to "})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- MODULE-VERSION "1.0.0"
      EXTERNS nil
      SPEC-OPS {})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- gensym "" [& [pfx]]
  (var x gensym-counter)
  (++ gensym-counter)
  (str (std/opt pfx "G____") x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- error! "" [e &[line file msg]]
  (raise! (get ERRORS-MAP e)
          (if msg (str " : " msg))
          (if line (str "\nLine no " line))
          (if file (str "\nFile " file))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- syntax! "" [ecode &[ast cmd]]
  (error! ecode
          (if ast ast.line 0)
          (if ast ast.source 0) cmd))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- pad "" [z] (.repeat " " z))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- testre? "" [re x] (if x (re.test x) false))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- nodeTag "" [obj src]
  (when (and obj
             src
             (not (boolean? obj))
             (not (number? obj)))
    (set! obj.source src.source)
    (set! obj.column src.column)
    (set! obj.line src.line))
  obj)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destructVec "" [lhs keys]
  (do-with [as nil]
    (for [i 0 e nil ev nil
          :while (< i (alen lhs)) :recur (+1 i)]
      (set! e (nth lhs i) ev (str e))
      (cond
        (std/symbol? e)
        (cond
          (= ev "_") nil
          (= ev "&") (do (set-in! keys (str "&" (nexth lhs i)) i)
                         (++ i))
          (ev.startsWith "&")
          (set-in! keys ev i)
          :else
          (set-in! keys ev i))
        (std/keyword? e)
        (if (= ev "as")
          (do (++ i)
              (set! as (str (nth lhs i))))
          (raise! "bad keyword: :" ev))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destructMap "" [lhs keys]
  (do-with [as nil]
    (for [i 0 e nil ev nil
          :while (< i (alen lhs)) :recur (+1 i)]
      (set! e (nth lhs i) ev (str e))
      (if (std/keyword? e)
        (cond
          (or (= ev "keys")
              (= ev "strs"))
          (let [ks (nexth lhs i)]
            (++ i)
            (for [j 0
                  :while (< j (alen ks)) :recur (+1 j)]
              (set-in! keys (str (nth ks j)) nil)))
          (= ev "as")
          (do (++ i)
              (set! as (str (nth lhs i)))))
        (raise! "bad destruct field: " (std/typeid e))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destruct1 "" [lhs]
  (var as nil out [] keys {})
  (cond
    (std/vector? lhs) (set! as (destructVec lhs keys))
    (std/map? lhs) (set! as (destructMap lhs keys))
    (std/symbol? lhs) (set-in! keys (str lhs) nil)
    :else
    (raise! "cant destruct with: " (std/typeid lhs)))
  [ as keys])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destruct0 "" [cmd lhs rhs env]
  (var [as keys] (destruct1 lhs)
       kdefs [] ka nil kvals (tnode))
  (if (empty? as) (set! as (gensym)))
  (set! as (rdr/jsid as))
  (each-key (fn [v k]
              (var rest? false)
              (when (k.startsWith "&")
                (set! rest? true k (rest k)))
              (set! k (rdr/jsid k))
              (std/conj! kdefs k)
              (-> (cond
                    (nil? v)
                    (str "[\"" k "\"];\n")
                    rest?
                    (str ".slice(" v ");\n")
                    :else
                    (str "[" v "];\n"))
                  (str k "=" as )
                  (kvals.add ))) keys)
  (kvals.prepend (str cmd " " (join "," kdefs) ";\n"))
  [[(tnodeEx [cmd " "
              (rdr/jsid as) "= "
              (transpile* rhs env) ";\n"]) kvals] kdefs])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileTree "" [root env]
  (do-with [ret (nodeTag (tnode) root)]
    (var treeSize (alen root)
         endx (last-index root))
    (each (fn [ast]
            (var tmp ast)
            (if (array? ast)
              (set! tmp (transpileList ast env)))
            (when tmp
              (ret.add [tmp "\n"]))) root)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileAtoms "" [atoms env]
  (each (fn [a i arr] (set-in! arr i (transpile* a env))) atoms))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileSingle "" [a]
  (cond
    (std/lambda-arg? a) (str "____args[" (str a) "]")
    (std/keyword? a) (str "\"" (str a) "\"")
    (std/symbol? a) (rdr/jsid (str a))
    (string? a) a
    (nil? a) "null"
    :else (str "" a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpile* "" [x env]
  (if (array? x) (transpileList x env) (transpileSingle x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- findCmd "" [ast]
  (do-with [cmd ""]
    (cond
      (std/vector? ast) (set! cmd "vec")
      (std/map? ast) (set! cmd "hashmap")
      (std/list? ast) (set! cmd (str (first ast))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quoteSingle "" [a]
  (cond
    (std/keyword? a) (str "\"" a "\"")
    (std/symbol? a) (rdr/jsid (str a))
    (string? a) a
    (nil? a) "null"
    :else (str a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quote! [a env]
  (if (array? a)
    (if (std/map? a) (quoteMap a env) (quoteBlock a env))
    (quoteSingle a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quoteMap "" [a env]
  (do-with [ret (tnode)]
    (for [i 0 :while (< i (alen a)) :recur (+2 i)]
      (if (> i 0) (ret.add ","))
      (ret.add [(quote! (nth a i) env)
                " : " (quote! (nexth a i) env)]))
    (ret.prepend "{")
    (ret.add "}")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quoteBlock "" [a env]
  (do-with [ret (tnode)]
    (for [i 0 :while (< i (alen a)) :recur (+1 i)]
      (if (> i 0) (ret.add ","))
      (ret.add (quote! (nth a i) env)))
    (ret.prepend "[")
    (ret.add "]")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-quote "" ^{:opcode ["quote"]} [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (ret.add (quote! (nth ast 1) env))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileList "" [ast env]
  (var cmd (findCmd ast)
       mc (rt/getMacro cmd) tmp nil)
  (do-with [ret (tnode)]
    (when mc
      (set! ast (rt/expandMacro ast env mc))
      (set! cmd (findCmd ast)))
    (cond
      (cmd.startsWith ".-")
      (ret.add [(transpile* (second ast) env)
                "."
                (transpileSingle (std/symbol (cmd.slice 2)))])
      (= "." (cmd.charAt 0))
      (do (ret.add (transpile* (second ast) env))
          (ret.add [cmd "("])
          (for [n 2
                :while (< n (alen ast)) :recur (+1 n)]
            (if (not= n 2) (ret.add ","))
            (ret.add (transpile* (nth ast n) env)))
          (ret.add ")"))
      (std/contains? SPEC-OPS cmd)
      (set! ret ((get SPEC_OPS cmd) ast env))
      (rdr/REGEX.int.test cmd)
      (let [c0 (cmd.charAt 0)]
        (if (and (not= c0 "-")
                 (not= c0 "+"))
          (set! cmd (str "+" cmd)))
        (set! ast [(std/symbol (cmd.charAt 0))
                   (nth ast 1)
                   (parseInt (rest cmd))])
        (set! cmd (str (first ast)))
        (set! ret ((get SPEC-OPS cmd) ast env)))
      :else
      (do (if (std/list? ast)
            (do (transpileAtoms ast env)
                (set! cmd (first ast)))
            (set! cmd (transpileSingle ast)))
          (if-not cmd (syntax! :e1 ast))
          (set! cmd (maybeStripStdlib cmd))
          (if (std/list? ast)
            (do (if (testre? rdr/REGEX.func cmd)
                  (set! cmd (tnodeEx ["(" cmd ")"])))
                (ret.add [cmd
                          "("
                          (join ","
                                (tnodeEx (rest ast))) ")"]))
            (ret.add cmd))))
    (set! ret (nodeTag ret ast))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-deftype "" [ast env public?]
  (do-with [ret (nodeTag (tnode) ast)]
    (var cz (transpile* (nth ast 1) env)
         par (first (nth ast 2))
         args (nth ast 3)
         mtds (ast.slice 4))
    (ret.add ["class " cz])
    (if par
      (ret.add [" extends " (transpile* par env)]))
    (ret.add " {\n")
    (for [i 0 n nil m nil
          :while (< i (alen mtds)) :recur (+1 i)]
      (set! m (nth mtds i))
      (m.unshift (std/symbol "method"))
      (ret.add (sf-func m env false))
      (ret.add "\n"))
    (ret.add "}\n")
    (if (and public? (= 1 (.countNSPCache (rt/globalEnv))))
      (set-in! EXTERNS cz cz))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- prv-deftype
  "" ^{:opcode ["deftype-"]} [a e] (sf-deftype a e false))
(defn- pub-deftype
  "" ^{:opcode ["deftype"]} [a e] (sf-deftype a e true))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- _lambdaFuncCount 0)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-lambda "" ^{:opcode ["lambda"]} [ast env]
  (if (not= 0 _lambdaFuncCount)
    (raise! "Can't nest lambdas")
    (++ _lambdaFuncCount))
  (var x [(std/symbol "fn") []
          [(std/symbol "var")
           (std/symbol "____args")
           [(std/symbol "slice") (std/symbol "arguments")]]]
       body (nth ast 1))
  (if (zlen? body) (set! body [nil]))
  (if-not (and (= 1 (alen body))
               (std/value? (car body)))
    (set! body (rest ast)))
  (set! x (x.concat body))
  (try
    (sf-fn x env)
    (finally (-- _lambdaFuncCount))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-apply "" ^{:opcode ["apply"]} [ast env]
  (var args (ast.slice 2)
       f (second ast)
       ret (nodeTag (tnode) ast))
  (for [i 0 :while (< i (alen args)) :recur (+1 i)]
    (ret.add (transpile* (nth args i) env)))
  (if (> (alen args) 1) (join "," ret))
  (doto ret
    (.prepend "[")
    (.add "]")
    (.prepend [(transpile* f env) ".apply(this,"])
    (.add ")")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-compOp ""
  ^{:opcode ["not=" "!=" "=="
             "=" ">" ">=" "<" "<="]} [ast env]
  (var cmd (first ast))
  (if (or (== cmd "not=")
          (== cmd "!=")) (set-in! ast 0 (std/symbol "!==")))
  (if (== cmd "=") (set-in! ast 0 (std/symbol "===")))
  (do-with [ret (nodeTag (tnode) ast)]
    (transpileAtoms ast env)
    (for [i 0
          op (ast.shift)
          :while (< i (last-index ast)) :recur (+1 i)]
      (ret.add (tnodeEx [(nth ast i)
                         " " op " " (nexth ast i)])))
    (join " && " ret)
    (ret.prepend "(")
    (ret.add ")")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-arithOp
  ""
  ^{:opcode ["+" "-" "*" "div" "%"  "mod"
             "||" "&&"
             "^" "&" "|" "<<" ">>" ">>>"]}
  [ast env]

  (do-with [ret (nodeTag (tnode) ast)]
    (transpileAtoms ast env)
    (var op (tnode)
         e1 (ast.shift) cmd (str e1))
    (if (== cmd "mod") (set! cmd "%"))
    (if (== cmd "div") (set! cmd "/"))
    (if (= 1 (alen ast))
      (if (== "-" cmd) (ret.add "-"))
      (op.add [""  cmd  ""]))
    (ret.add ast)
    (if (> (alen ast) 1) (join op ret))
    (ret.prepend "(")
    (ret.add ")")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-repeat
  "" ^{:opcode ["repeat-n"]} [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (transpileAtoms ast env)
    (for [i 0
          end (parseInt (second ast))
          :while (< i end) :recur (+1 i)]
      (if (not= i 0) (ret.add ","))
      (ret.add (nth ast 2)))
    (ret.prepend "[")
    (ret.add "]")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileDo "" [ast env & [return?]]
  (do-with [ret (nodeTag (tnode) ast)]
    (set! return? (std/opt return? true))
    (var e nil end (last-index ast))
    (for [i 0 :while (< i end) :recur (+1 i)]
      (set! e (nth ast i))
      (ret.add [(transpileList e env) ";\n"]))
    (ret.add ";")
    (when (>= end 0)
      (set! e (transpile* (nth ast end) env))
      (if-not return?
        (ret.add [e ";\n"])
        (ret.add ["return " e ";\n"])))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-do
  "" ^{:opcode ["do"]} [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (ret.add (str "(function() {\n"))
    (ret.add (transpileDo (rest ast) env))
    (ret.add (str "}).call(this)"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-case
  "" ^{:opcode ["case"]} [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (var tst (second ast)
         _x (gensym)
         e nil t nil c nil dft nil)
    (if (odd? (alen ast))
      (set! dft (ast.pop)))
    (for [i 2
          :while (< i (alen ast)) :recur (+2 i)]
      (set! c (nexth ast i) e (nth ast i))
      (if (std/list? e)
        (for [j 0
              :while (< j (alen e)) :recur (+1 i)]
          (ret.add ["case "
                    (transpileSingle (nth e j)) ":\n"])
          (if (= j (last-index e))
            (ret.add [_x "="
                      (transpile* c env) ";\nbreak;\n"])))
        (do (ret.add ["case " (transpileSingle e) ":\n"])
            (ret.add [_x "="
                      (transpile* c env) ";\nbreak;\n"]))))
    (when dft
      (ret.add "default:\n")
      (ret.add [_x "=" (transpile* dft env) ";\nbreak;\n"]))

    (ret.prepend ["switch (" (transpile* tst env) ") {\n"])
    (ret.add "}\n")
    (ret.prepend ["(function() { let " _x ";\n"])
    (ret.add ["return " _x ";}).call(this)"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-range
  "" ^{:opcode ["range"]} [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (var len 0 start 0 step 1 end 0)
    (transpileAtoms ast env)
    (set! len (alen ast))
    (set! end (parseInt (second ast)))
    (when (> len 2)
      (set! start (parseInt (second ast)))
      (set! end (parseInt (nth ast 2))))
    (if (> len 3)
      (set! step (parseInt (nth ast 3))))
    (for [i start :while (< i end) :recur (+ i step)]
      (if (not= i start) (ret.add ","))
      (ret.add (str i)))
    (ret.prepend "[")
    (ret.add "]")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-vardefs "" [ast env cmd]
  (do-with [ret (nodeTag (tnode) ast)]
    (var kks {}
         public? (== "global" cmd))
    (if-not (== "let" cmd) (set! cmd "var"))
    (for [i 1 s nil
          :while (< i (alen ast)) :recur (+ 1 i)]
      (set! s (transpileSingle (nth ast i)))
      (ret.add (str s "=undefined"))
      (set-in! kks s nil))
    (ret.add ";")
    (doto ret
      (.join ",")
      (.prepend (str cmd " "))
      (.add ";\n"))
    (if (and public?
             (= 1 (.countNSPCache (rt/globalEnv))))
      (each-key (fn [v k] (set-in! EXTERNS k k)) kks))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- local-vardefs
  "" ^{:opcode ["def~-"]} [ast env] (sf-vardefs ast env "local"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- global-vardefs
  "" ^{:opcode ["def~"]} [ast env] (sf-vardefs ast env "global"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- let-vardefs
  "" ^{:opcode ["var~"]} [ast env] (sf-vardefs ast env "let"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-var "" [ast env cmd]
  (do-with [ret (nodeTag (tnode) ast)]
    (var vname nil keys [] kks {}
         public? (== "global" cmd))
    (set! ast (rest ast))
    (if (or public?
            (== "local" cmd)) (set! cmd "var"))
    (for [i 0
          :while (< i (alen ast)) :recur (+2 i)]
      (if (std/symbol? (nth ast i))
        (std/conj! keys (nth ast i))))
    (ret.add ";\n")
    (if (std/not-empty keys)
      (ret.add ["let "
                (join ","
                      (map (fn [s]
                             (var ss (transpileSingle s))
                             (set-in! kks ss nil) ss) keys)) ";\n"]))
    (for [i 0 rc nil
          lhs nil rhs nil
          :while (< i (alen ast)) :recur (+2 i)]
      (set! lhs (nth ast i)
            rhs (nexth ast i))
      (if (std/symbol? lhs)
        (ret.add [(transpileSingle lhs) "= "
                  (transpile* rhs env) ";\n"])
        (do (set! rc (destruct0 cmd lhs rhs env))
            (ret.add (nth rc 0))
            (map (fn [s]
                   (set-in! kks (rdr/jsid s) nil)) (nth rc 1)))))
    (ret.add ";")
    (when (and public?
               (= 1 (.countNSPCache (rt/globalEnv))))
      (each-key (fn [v k]
                  (set-in! EXTERNS k k)) kks))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-var-local
  "" ^{:opcode ["def-"]} [ast env] (sf-var ast env "local"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-var-global
  "" ^{:opcode ["def"]} [ast env] (sf-var ast env  "global"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-var-let
  "" ^{:opcode ["var"]} [ast env] (sf-var ast env "let"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-inst?
  "" ^{:opcode ["inst?"]} [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (ret.add ["("
              (transpile* (nth ast 2) env)
              " instanceof "
              (transpile* (nth ast 1) env) ")"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-delete
  "" ^{:opcode ["delete!"]} [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (ret.add ["delete " (transpile* (nth ast 1) env)])
    (if (> (alen ast) 2)
      (ret.add ["[" (transpile* (nth ast 2)) "]"]))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-new
  "" ^{:opcode ["new"]} [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (ret.add (transpileList (rest ast) env))
    (ret.prepend "new ")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-throw
  "" ^{:opcode ["throw"]} [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (ret.add ["throw " (transpile* (nth ast 1) env) ";"])
    (ret.prepend "(function (){ ")
    (ret.add " })(this)")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-x-opop
  "" ^{:opcode ["++" "--"]} [ast env]
  (transpileAtoms ast env)
  (nodeTag (tnodeEx [(first ast)
                     (second ast)]) ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-x-eq
  "" ^{:opcode ["+=" "-=" "*="
                "/=" "%=" "<<="
                ">>=" ">>>=" "&=" "|=" "^="]} [ast env]
  (transpileAtoms ast env)
  (nodeTag (tn/tnodeEx [(second ast)
                        " " (first ast) " " (nth ast 2)])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-set-in
  "" ^{:opcode ["set-in!"]} [ast env]
  (assert (even? (alen ast)) "set-in: bad arg count")
  (do-with [ret (nodeTag (tnode) ast)]
    (var obj (transpile* (nth ast 1) env))
    (for [i 2 :while (< i (alen ast)) :recur (+2 i)]
      (if (> i 2) (ret.add ","))
      (ret.add [obj "[" (transpile* (nth ast i) env) "]"
                "=" (transpile* (nexth ast i) env)]))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-set
  "" ^{:opcode ["set!"]} [ast env]
  (assert (odd? (alen ast)) "set: bad arg count")
  (do-with [ret (nodeTag (tnode) ast)]
    (var more false)
    (for [i 1 :while (< i (alen ast)) :recur (+2 i)]
      (when (> i 1) (ret.add ",") (set! more true))
      (ret.add [(transpile* (nth ast i) env)
                "="
                (transpile* (nexth ast i) env)]))
    (ret.add ";")
    (when more
      (.prepend ret "(")
      (.add ret ")"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- parseFuncArgs "" [args]
  (do-with [ret []]
    (for [i 0 e nil ev nil
          :while (< i (alen args)) :recur (+1 i)]
      (set! e (nth args i) ev (str e))
      (cond
        (std/symbol? e)
        (cond
          (= ev "_")
          (std/conj! ret (std/symbol (gensym "_")))
          (= ev "&")
          (do (set! e (nexth args i))
              (if (std/symbol? e)
                (std/conj! ret [e i e])
                (std/conj! ret [(std/symbol (str "&" (gensym))) i e]))
              (++ i))
          (ev.startsWith "&")
          (do (set! e (std/symbol (rest ev)))
              (std/conj! ret [e i e]))
          :else
          (std/conj! ret e))
        (std/keyword? e)
        (raise! "bad function args destructure: " (std/typeid e))
        (array? e)
        (std/conj! ret [(std/symbol (gensym)) i e])
        :else
        (raise! "bad function args destructure: " (std/typeid e))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- handleFuncArgs "" [fargs env]
  (do-with [out []]
    (var misc []
         keys []
         ret (tnode) knode (tnode))
    (each (fn [arg]
            (cond
              (std/symbol? arg) (std/conj! keys arg)
              (and (std/symbol? (first arg))
                   (not (.startsWith (str (first arg)) "&"))
                   (array? (nth arg 2)))
              (do (std/conj! keys (first arg))
                  (std/conj! misc arg))
              :else (std/conj! misc arg))) fargs)
    (each (fn [arr]
            (var a0 (first arr)
                 name (str a0)
                 varg? (name.startsWith "&")
                 pos (str (nth arr 1))
                 a2 (nth arr 2))
            (if varg? (set! name (rest name)))
            (set! name (rdr/jsid name))
            (cond
              (and (std/symbol? a0)
                   (std/symbol? a2))
              (ret.add ["let " name
                        "=Array.prototype.slice.call(arguments," pos ");\n"])
              (array? a2)
              (do
                (if varg?
                  (ret.add ["let " name
                            "=Array.prototype.slice.call(arguments," pos ");\n"]))
                (ret.add
                  (first (destruct0 "let" a2 name env)))))) misc)
    (knode.add (join ","
                     (map #(rdr/jsid (str %)) keys)))
    (std/conj! out knode)
    (std/conj! out ret)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-fn
  "" ^{:opcode ["fn"]} [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (var args (nth ast 1)
         fargs nil
         hints {}
         body (ast.slice 2))
    (when (and (= 3 (alen args))
               (== "with-meta" (car args))
               (array? (nth args 1)))
      (set! hints (resolveMeta (nth args 2) env))
      (set! args (nth args 1)))
    (set! fargs (handleFuncArgs (parseFuncArgs args) env))
    (ret.add "function (")
    (ret.add (first fargs))
    (ret.add [") {\n"
              (second fargs)
              (transpileDo body env) "}"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fmtRegoSpecOps
  "" [alias fname] (str "SPEC_OPS[\"" alias "\"] = " fname))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fmtSpecOps "" [fname attrs]
  (var ks (or (get attrs "opcode") [])
       out (->> (map #(fmtRegoSpecOps
                        (str %1) fname) ks)
                (join ";\n")))
  (if (std/not-empty ks) (str out ";\n") out))

(def- CUR-FUNC-NAME nil)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-func "" [ast env public?]
  (do-with [ret (nodeTag (tnode) ast)]
    (var fname (transpile* (nth ast 1) env)
         mtd? (== (first ast) "method")
         dot? (fname.includes ".")
         hints {}
         fargs nil
         e3 (nth ast 3)
         e2 (nth ast 2)
         doc nil attrs nil args 2 body 3)
    (set! CUR-FUNC-NAME fname)
    (cond
      (string? e2)
      (do (set! doc 2 args 3)
          (when (std/map? e3)
            (set! attrs 3 args 4)))
      (std/map? e2)
      (do (set! attrs 2 args 3)))
    (set! body (+1 args))
    (if doc (set! doc (nth ast doc)))
    (if attrs (set! attrs (nth ast attrs)))
    (set! args (nth ast args)
          body (ast.slice body))
    (when (and (= 3 (alen args))
               (== "with-meta" (car args))
               (array? (nth args 1)))
      (set! hints (resolveMeta (nth args 2) env)
            args (nth args 1)))
    (set! fargs (handleFuncArgs (parseFuncArgs args) env))
    (cond
      mtd?
      (do (if (.-static hints) (ret.add "static "))
          (ret.add [fname " ("]))
      dot?
      (ret.add [fname " = function ("])
      :else
      (ret.add (str "function " fname "(")))
    (ret.add (first fargs))
    (ret.add [") {\n"
              (second fargs)
              (transpileDo body env) "}\n"])
    (if (not-empty hints)
      (ret.add (fmtSpecOps fname hints)))
    (when doc
      (set! doc (-> (doc.replace rdr.REGEX.dquoteHat "")
                    (.replace rdr.REGEX.dquoteEnd "")))
      (ret.prepend (map #(str "//" % "\n") (doc.split "\\n"))))
    (if (and public?
             (not dot?)
             (= 1 (.countNSPCache (rt/globalEnv))))
      (set-in! EXTERNS fname fname))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-func-private
  "" ^{:opcode ["defn-"]} [ast env] (sf-func ast env false))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-func-public
  "" ^{:opcode ["defn"]} [ast env] (sf-func ast env true))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-try
  "" ^{:opcode ["try"]} [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (var sz (alen ast)
         t nil f nil c nil)
    ;;look for finally
    (set! f (std/last ast))
    (if (and (array? f)
             (== "finally" (first f)))
      (set! f (ast.pop) sz (alen ast))
      (set! f nil))
    ;;look for catch
    (set! c nil)
    (if (> sz 1) (set! c (nth ast (-1 sz))))
    (if (and (array? c)
             (== "catch" (first c)))
      (do (if (or (< (alen c) 2)
                  (not (std/symbol? (second c)))) (syntax! :e0 ast))
          (set! c (ast.pop)))
      (set! c nil))
    ;;try needs either a catch or finally or both
    (if (and (nil? f) (nil? c)) (syntax! :e0 ast))
    (ret.add ["(function() {\ntry {\n"
              (transpileDo (rest ast) env) "\n}"])
    (when c
      (set! t (second c))
      (ret.add [(str "catch (" t ") {\n")
                (transpileDo (c.slice 2) env) ";\n}\n"]))
    (when f
      (ret.add ["finally {\n",
                (transpileDo (rest f) env false) ";\n}\n"]))
    (ret.add "}).call(this)")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-if
  "" ^{:opcode ["if"]} [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (var a1 (nth ast 1)
         a2 (nth ast 2)
         a3 (if (> (alen ast) 3) (nth ast 3)))
    (ret.add ["(" (transpile* a1 env)
              " ?\n" (transpile* a2 env) " :\n"
              (or (transpile* a3 env) "null") ")"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-nth "" ^{:opcode ["nth"]} [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (transpileAtoms ast env)
    (ret.add [(nth ast 1) "[" (nth ast 2) "]"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-get
  "" ^{:opcode ["aget" "get"]} [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (transpileAtoms ast env)
    (ret.add [(nth ast 1) "[" (nth ast 2) "]"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-str
  "" ^{:opcode ["str"]} [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (var args (rest ast))
    (transpileAtoms args env)
    (if (> (alen args) 1)
      (doto ret
        (.add args)
        (.join ",")
        (.prepend "[")
        (.add "].join(\"\")"))
      (if (std/not-empty args)
        (ret.add ["" (first args) ".toString()"])))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-array
  "" ^{:opcode ["vec"]} [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (var epilog "\n]")
    (if (empty? ast)
      (ret.add "[]")
      (do (if-not (std/vector? ast)
            (ast.splice 0 1))
          (transpileAtoms ast env)
          (ret.add "[\n")
          (for [i 0 :while (< i (alen ast)) :recur (+1 i)]
            (if (> i 0) (ret.add ",\n"))
            (ret.add (nth ast i)))
          (ret.add epilog)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-object
  "" ^{:opcode ["hashmap"]} [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (var epilog "\n}")
    (if (empty? ast)
      (ret.add "{}")
      (do (if-not (std/map? ast)
            (ast.splice 0 1))
          (transpileAtoms ast env)
          (ret.add "{\n")
          (for [i 0 :while (< i (alen ast)) :recur (+2 i)]
            (if (> i 0) (ret.add ",\n"))
            (ret.add [(nth ast i) ": " (nexth ast i)]))
          (ret.add epilog)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- includeFile
  ((fn []
     (var icache [])
     (fn [fname]
       (if (std/contains? icache fname)
         (tnode)
         (let [src (fs/readFileSync fname "utf-8")]
           (std/conj! icache fname)
           (transpileTree (psr/parser src fname)
                          (rt/globalEnv ))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-include "" [ast env]
  (var ret [] fname nil
       dir (path/dirname ast.source))
  (for [i 1 e nil
        :while (< i (alen ast)) :recur (+1 i)]
    (set! e (nth ast i))
    (if (or (not (array? e))
            (not= 1 (alen e))) (syntax! :e0 ast))
    (set! fname (first e))
    (if fname
      (set! fname (fname.replace /[\"]/g "")))
    (try
      (set! fname (fs/realpathSync (str dir "/" fname)))
      (catch e
        (syntax! :e11 ast)))
    (try
      (std/conj! ret (includeFile fname))
      (finally
        (.popNSP (rt/globalEnv)))))
  (if (empty? ret) (tnode) ret))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-require "" [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (var~  path v e refers renames)
    (var as nil)
    (for [i 1
          :while (< i (alen ast)) :recur (+1 i)]
      (set! e (nth ast i) as (gensym))
      (set! refers nil renames nil)
      (if (or (not (array? e))
              (< (alen e) 3)) (syntax! :e0 ast))
      (set! path (first e))
      (for [j 1
            :while (< j (alen e)) :recur (+1 j)]
        (set! v (nth e j))
        (cond
          (== v "as")
          (do (set! as (str (nexth e j)))
              (++ j))
          (== v "refer")
          (do (set! refers (nexth e j))
              (++ j))
          (== v "rename")
          (do (set! renames (nexth e j))
              (++ j))))
      (ret.add ";")
      (ret.add ["var "
                (rdr/jsid as)
                "= require("
                (transpileSingle path) ");\n"])
      (for [i 0
            :while (and refers
                        (< i (alen refers)))
            :recur (+1 i)]
        (set! v (transpileSingle (nth refers i)))
        (ret.add ["var " v "=" as "[\"" v "\"];\n"]))
      (ret.add ";")
      (for [i 0
            :while (and renames
                        (< i (alen renames)))
            :recur (+2 i)]
        (set! e (transpileSingle (nth renames i)))
        (set! v (transpileSingle (nexth renames i)))
        (ret.add ["var " v "=" as "[\"" e "\"];\n"]))
      (ret.add ";"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- resolveMeta "" [ast env]
  (cond
    (array? ast)
    (JSON/parse (str "" (transpile* ast env)))
    (std/keyword? ast)
    (->> (transpile* (std/hashmap ast true) env)
         (str "" )
         (JSON/parse ))
    (std/symbol? ast)
    (->> (transpile* (std/hashmap (std/symbol "tag") ast) env)
         (str "")
         (JSON/parse ))
    :else
    (raise! "Bad meta value" (std/prn ast))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-ns
  "" ^{:opcode ["ns"]} [ast env]
  (do-with [ret []]
    (var hints {} nsp (nth ast 1))
    (when (and (array? nsp)
               (= 3 (alen nsp))
               (== "with-meta" (car nsp))
               (std/symbol? (nth nsp 1)))
      (set! hints (resolveMeta (nth nsp 2) env))
      (set! nsp (nth nsp 1)))
    (.pushNSP (rt/globalEnv) (str nsp))
    (set! ast (ast.slice 2))
    (for [i  0 e nil
          :while (< i (alen ast))
          :recur (+1 i)]
      (set! e (nth ast i))
      (cond
        (and (std/list? e)
             (== "include" (car e)))
        (std/conj! ret (sf-include e))
        (and (std/list? e)
             (== "require" (car e)))
        (std/conj! ret (sf-require e))))
    ;;force a internal reference to stdlib for user files
    (set! nsp (.peekNSP (rt/globalEnv)))
    (cond
      (or (= nsp "czlab.kirby.bl.defmacros")
          (= nsp "czlab.kirby.bl.stdlib"))
      nil
      (nsp.startsWith "czlab.kirby.")
      (std/conj! ret (tnodeEx "const kirbystdlibref=std;\n"))
      :else
      (->> [(std/symbol "require")
            ["\"kirby\""
             (std/keyword ":as") (std/symbol "kirbystdlibref")]]
           (sf-require )
           (std/conj! ret )))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- maybeStripStdlib "" [cmd]
  (var nsp (.peekNSP (rt/globalEnv))
       lib "kirbystdlibref.")
  (set! cmd (str cmd))
  (if (and (cmd.startsWith lib)
           (= nsp "czlab.kirby.bl.stdlib"))
    (cmd.slice (alen lib))
    cmd))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-comment
  "" ^{:opcode ["comment"]} [ast env] (nodeTag (tnode) ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-for
  "" ^{:opcode ["for" "floop"]} [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (var body (ast.slice 2)
         internal? (== "floop" (car ast)))
    (if (empty? body)
      (tnode)
      (sf-floop ret (nth ast 1) body env internal?))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-floop "" [ret args body env internal?]
  (var vars [] recurs [])
  (var~ tst nb)
  (floop [i 0 e nil
          :while (< i (alen args)) :recur (+1 i)]
    (set! e (nth args i))
    (cond
      (== e "while")
      (do (set! tst (nexth args i))
          (++ i))
      (== e "recur")
      (do (set! recurs (args.slice (+1 i)))
          (set! i (alen args)))
      (std/symbol? e)
      (do (std/conj! vars e (nexth args i))
          (++ i))))
  (ret.add "for (")
  (floop [i 0 :while (< i (alen vars)) :recur (+2 i)]
    (if (= i 0) (ret.add "let "))
    (if (not= i 0) (ret.add ","))
    (ret.add [(transpileSingle (nth vars i))
              "="
              (transpile* (nexth vars i) env)]))
  (if (std/not-empty vars)
    (ret.add ",____break=false")
    (ret.add "let ____break=false"))
  (ret.add "; ")
  (set! nb [(std/symbol "not") (std/symbol "____break")])
  (if tst
    (set! tst [(std/symbol "and") nb tst])
    (set! tst nb))
  (ret.add (transpile* tst env))
  (ret.add "; ")
  (floop [i 0 k 0 :while (< i (alen recurs))
                :recur (+1 i) (+2 k)]
    (if (not= i 0) (ret.add ","))
    (ret.add [(transpileSingle (nth vars k))
              "="
              (transpile* (nth recurs i) env)]))
  (doto ret
    (.add "){\n")
    (.add (transpileDo body env false))
    (.add "}\n")
    (.prepend "(function() {\n"))
  (if internal?
    (.add ret "})(this);\n")
    (.add ret "})(this)")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-jscode
  "" ^{:opcode ["js#"]} [ast env]
  (nodeTag (tnodeEx (-> (str (second ast))
                        (.replace rdr/REGEX.dquoteHat "")
                        (.replace rdr/REGEX.dquoteEnd ""))) ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-macro
  "" ^{:opcode ["defmacro"]} [ast env]
  (var pms []
       args (nth ast 2)
       body (ast.slice 3))
  (when (string? args)
    (set! doc args
          args (nth ast 3)
          body (ast.slice 4)))
  (for [i 0 e nil ev nil
        :while (< i (alen args)) :recur (+1 i)]
    (set! e (nth args i) ev (str e))
    (cond
      (= ev "&")
      (if (array? (nexth args i))
        (do (set! e (nexth args i))
            (++ i)
            (for [j 0 x nil
                  :while (< j (alen e)) :recur (+1 j)]
              (set! x (nth e j))
              (if-not (std/symbol? x)
                (raise! "Bad optional arg for macro"))
              (std/conj! pms x)))
        (do (std/conj! pms e (nexth args i))
            (++ i)))
      (not (std/symbol? e))
      (raise! "Bad optional arg for macro")
      :else
      (std/conj! pms e)))
  (set! ast
        [(first ast)
         (second ast)
         (.concat [(std/symbol "fn*") pms] body)])
  (var a2 (nth ast 2)
       a1 (str (nth ast 1))
       func (rt/compute a2 env))
  (set-in! func :____macro true)
  (if doc
    (set-in! func :____doc doc))
  (rt/setMacro a1 func)
  (nodeTag (tnode) ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-unary
  "" ^{:opcode ["not" "~" "!"]} [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (var [a0 a1] ast)
    (if (== a0 "not") (set! a0 (std/symbol "!")))
    (ret.add ["("
              (transpile* a0 env)
              (transpile* a1 env) ")"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-doseq
  "" ^{:opcode ["doseq"]} [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (var args (nth ast 1)
         body (ast.slice 2)
         [loopvar loopexpr] args
         escvar (gensym) idxvar (gensym) exprvar (gensym))
    (ret.add ["let " (transpileSingle loopvar)
              "= " exprvar "[" idxvar "];\n"])
    (for [i 2 v nil ev nil
          :while (< i (alen args)) :recur (+1 i)]
      (set! v (nth args i) ev (str v))
      (cond
        (= ev "while")
        (ret.add ["if (! "
                  (transpile* (nexth args i) env)
                  ") {" escvar "=true;}\n"])
        (= ev "when")
        (doto ret
          (.add ["if (!" escvar ") {\n"])
          (.add ["if (! "
                     (transpile* (nexth args i) env)
                     ") {continue;}\n"])
          (.add "}\n"))
        (= ev "let")
        (ret.add (sf-var-let
                   (.concat [(std/symbol "var")] (nexth args i)) env))))
    (doto ret
      (.add ["if (!" escvar ") {\n"])
      (.add (transpileDo body env false))
      (.add "}\n")
      (.add "}\n")
      (.prepend ["for(let " escvar "=false," idxvar "=0; "
                    "(!" escvar " && " idxvar
                    " < " exprvar ".length); ++" idxvar ") {\n"])
      (.prepend ["let " exprvar "= " (transpile* loopexpr env) ";\n"])
      (.prepend "(function() {\n")
      (.add "})(this);\n"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- spitExterns "" []
  (do-with [s ""]
    (var ks (keys EXTERNS))
    (when (std/not-empty ks)
      (set! s (join ",\n"
                    (map #(str % ": " %) ks)))
      (set! s (str "\n\nmodule.exports = {\n" s "\n};\n\n")))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- banner "" []
  (str "/*"
       "Auto generated by Kirby - v"
       MODULE_VERSION " "
       (.firstNSP (rt/globalEnv)) " - " (new Date) "*/\n\n"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- cleanCode "" [code]
  (var arr [])
  (each (fn [s]
          (set! s (s.trim))
          (if (not= s ";") (std/conj! arr s))) (code.split "\n"))
  (join "\n" arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileCode "" [codeStr fname srcMap?]
  (.resetNSPCache (rt/globalEnv))
  (set! EXTERNS {})
  (var outNode (transpileTree (psr/parser codeStr fname)
                              (rt/globalEnv))
       options {}
       cstr ""
       extra (spitExterns))
  (outNode.prepend (banner))
  (set! cstr
        (if srcMap?
          (let [outFile (str (path/basename fname ".ky") ".js")
                srcMap (str outFile ".map")
                output (outNode.toStringWithSourceMap {:file outFile})]
            (fs/writeFileSync srcMap output.map)
            (str output.code
                 extra
                 "\n//# sourceMappingURL="
                 (path/relative (path/dirname fname) srcMap)))
          (str outNode extra)))
  (set! cstr (cleanCode cstr))
  ;(println cstr)
  (if false (esfmt/format cstr options) cstr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileXXX "" [code file smap?]
  (try
    (transpileCode code file smap?)
    (catch e
      (when e
        (println (.-stack e)) (throw e)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn transpileWithSrcMap "" [code file] (transpileXXX code file true))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn transpile "" [code file] (transpileXXX code file false))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn parseWithSourceMap "" [codeStr fname]
  (var outNode (transpileTree (psr/parser codeStr fname)))
  (outNode.prepend (banner))
  (outNode.toStringWithSourceMap ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(def version MODULE_VERSION)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

