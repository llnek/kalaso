;; Copyright (c) 2013-2017, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author "Kenneth Leung"}

  czlab.kirby.cg.transpiler

  (require ["../bl/stdlib" :as std]
           ["../bl/lexer" :as rdr :refer [tnode tnodeEx]]
           ["../bl/parser" :as psr]
           ["../rt/runtime" :as rt])
  (require ["fs" :as fs]
           ["path" :as path]
           ["esformatter" :as esfmt]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- gensym-counter 1)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- ERRORS-MAP {
  :e0 "Syntax Error"
  :e1 "Empty statement"
  :e2 "Invalid characters in function name"
  :e3 "End of File encountered, unterminated string"
  :e4 "Closing square bracket, without an opening square bracket"
  :e5 "End of File encountered, unterminated array"
  :e6 "Closing curly brace, without an opening curly brace"
  :e7 "End of File encountered, unterminated javascript object '}'"
  :e8 "End of File encountered, unterminated parenthesis"
  :e9 "Invalid character in var name"
  :e10 "Extra chars at end of file. Maybe an extra ')'."
  :e11 "Cannot Open include File"
  :e12 "Invalid no of arguments to "
  :e13 "Invalid Argument type to "
  :e14 "End of File encountered, unterminated regular expression"
  :e15 "Invalid vararg position, must be last argument."
  :e16 "Invalid arity (args > expected) to "
  :e17 "Invalid arity (args < expected) to "})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- RESERVED {
  :compare ["not=" "!=" "==" "=" ">" ">=" "<" "<="]
  :arith ["+" "-" "*" "div" "%"  "mod"]
  :logic ["||" "&&"]
  :bitwise ["^" "&" "|" "<<" ">>" ">>>"]
  :incdec ["++" "--"]
  :unary ["not"  "~" "!"]
  :assign ["+=" "-=" "*="
         "/=" "%=" "<<="
         ">>=" ">>>=" "&=" "|=" "^="]
  :builtin
  ["quote" "syntax-quote" "quasi-quote"
  "backtick"  "unquote" "unquote-splice"
  "repeat-n"  "do"  "doto"  "case" "apply"
  "range"  "def-"  "def"  "var"  "for"
  "new"  "throw"  "while"  "lambda"
  "inst?"  "delete!"
  "aset"  "set!"  "fn"  "set-in!"
  "defn-"  "defn"
  "try"  "if"  "get"  "aget"  "str"
  "list"  "["  "vec"  "{"  "hash-map"
  "ns"  "comment"  "for"  "cons"
  "js#"  "macro"  "defmacro"]})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- MODULE-VERSION "1.0.0"
      EXTERNS nil
      SPEC-OPS {})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- gensym "" [& [pfx]]
  (var x gensym-counter)
  (++ gensym-counter)
  (str (std/opt pfx "G____") x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- regoBuiltins "" [f group]
  (each #(set! SPEC-OPS % f) (get RESERVED group)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- error! "" [e &[line file msg]]
  (raise! (get ERRORS-MAP e)
          (if msg (str " : " msg))
          (if line (str "\nLine no " line))
          (if file (str "\nFile " file))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- syntax! "" [ecode &[ast cmd]]
  (error! ecode
          (if ast ast.line 0)
          (if ast ast.source 0) cmd))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- pad "" [z] (.repeat " " z))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- testre? "" [re x] (if x (re.test x) false))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- nodeTag "" [obj src]
  (when (and obj
             src
             (not (boolean? obj))
             (not (number? obj)))
    (set! obj.source src.source)
    (set! obj.column src.column)
    (set! obj.line src.line))
  obj)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destructVec "" [lhs keys]
  (do-with [as nil]
    (for [i 0 e nil ev nil
          :while (< i (alen lhs)) (+1 i)]
      (set! e (nth lhs i) ev (str e))
      (cond
        (std/symbol? e)
        (cond
          (= ev "_") nil
          (= ev "&") (do (set! keys
                               (str "&" (nth lhs (+1 i))) i)
                         (++ i))
          (ev.startsWith "&")
          (set-in! keys ev i)
          :else
          (set-in! keys ev i))
        (std/keyword? e)
        (if (= ev "as")
          (do (++ i)
              (set! as (str (nth lhs i))))
          (raise! "bad keyword: :" ev))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destructMap "" [lhs keys]
  (do-with [as nil]
    (for [i 0 e nil ev nil
          :while (< i (alen lhs)) :recur (+1 i)]
      (set! e (nth lhs i) ev (str e))
      (if (std/keyword? e)
        (cond
          (or (= ev "keys")
              (= ev "strs"))
          (let [ks (nexth lhs i)]
            (++ i)
            (for [j 0
                  :while (< j (alen ks)) :recur (+1 j)]
              (set-in! keys (str (nth ks j)) nil)))
          (= ev "as")
          (do (++ i)
              (set! as (str (nth lhs i)))))
        (raise! "bad destruct field: " (std/typeid e))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destruct1 "" [lhs]
  (var as nil out [] keys {})
  (cond
    (std/vector? lhs) (set! as (destructVec lhs keys))
    (std/map? lhs) (set! as (destructMap lhs keys))
    (std/symbol? lhs) (set! keys (str lhs) nil)
    :else
    (raise! "cant destruct with: " (std/typeid lhs)))
  (std/vector as keys))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destruct0 "" [cmd lhs rhs env]
  (var [as keys] (destruct1 lhs)
       kdefs [] ka nil kvals (tnode))
  (if (empty? as) (set! as (gensym)))
  (set! as (rdr/jsid as))
  (each-key (fn [v k]
              (var rest? false)
              (if (k.startsWith "&")
                (set! rest? true k (rest k)))
              (set! k (rdr/jsid k))
              (conj! kdefs k)
              (-> (cond
                    (nil? v)
                    (str "[\"" k "\"];\n")
                    rest?
                    (str ".slice(" v ");\n")
                    :else
                    (str "[" v "];\n"))
                  (str n "=" as )
                  (kvals.add ))) keys)
  (kvals.prepend (str cmd " " (join "," kdefs) ";\n"))
  [[(tnodeEx [cmd " "
              (rdr/jsid as) "= "
              (transpile* rhs env) ";\n"]) kvals] kdefs])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileTree "" [root env]
  (do-with [ret (nodeTag (tnode) root)]
    (var treeSize (alen root)
         endx (last-index root))
    (each (fn [ast]
            (var tmp ast)
            (if (array? ast)
              (set! tmp (transpileList ast env)))
            (when tmp
              (ret.add [tmp "\n"]))) root)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileAtoms "" [atoms env]
  (each (fn [a i arr] (set-in! arr i (transpile* a env))) atoms))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileSingle "" [a]
  (cond
    (std/lambda-arg? a) (str "____args[" (str a) "]")
    (std/keyword? a) (str "\"" (str a) "\"")
    (std/symbol? a) (rdr/jsid (str a))
    (string? a) a
    (nil? a) "null"
    :else (str "" a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpile* "" [x env]
  (if (array? x) (transpileList x env) (transpileSingle x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- findCmd "" [ast]
  (do-with [cmd ""]
    (cond
      (std/vector? ast) (set! cmd "vec")
      (std/map? ast) (set! cmd "hashmap")
      (std/list? ast) (set! cmd (str (first ast))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quoteSingle "" [a]
  (cond
    (std/keyword? a) (str "\"" a "\"")
    (std/symbol? a) (rdr/jsid (str a))
    (string? a) a
    (nil? a) "null"
    :else (str a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quote! [a env]
  (if (array? a)
    (if (std/map? a) (quoteMap a env) (quoteBlock a env))
    (quoteSingle a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quoteMap "" [a env]
  (do-with [ret (tnode)]
    (for [i 0 :while (< i (alen a)) :recur (+2 i)]
      (if (> i 0) (ret.add ","))
      (ret.add [(quote! (nth a i) env)
                " : " (quote! (nexth a i) env)]))
    (ret.prepend "{")
    (ret.add "}")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quoteBlock "" [a env]
  (do-with [ret (tnode)]
    (for [i 0 :while (< i (alen a)) :recur (+1 i)]
      (if (> i 0) (ret.add ","))
      (ret.add (quote! (nth a i) env)))
    (ret.prepend "[")
    (ret.add "]")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-quote "" ^{:opcode ["quote"]} [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (ret.add (quote! (nth ast 1) env))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileList "" [ast env]
  (var cmd (findCmd ast)
       mc (rt/getMacro cmd) tmp nil)
  (do-with [ret (tnode)]
    (when mc
      (set! ast (rt/expandMacro ast env mc))
      (set! cmd (findCmd ast)))
    (cond
      (cmd.startsWith ".-")
      (ret.add [(transpile* (second ast) env)
                "."
                (transpileSingle (std/symbol (cmd.slice 2)))])
      (= "." (cmd.charAt 0))
      (do (ret.add (transpile* (second ast) env))
          (ret.add [cmd "("])
          (for [n 2
                :while (< n (alen ast)) :recur (+1 n)]
            (if (not= n 2) (ret.add ","))
            (ret.add (transpile* (nth ast n) env)))
          (ret.add ")"))
      (std/contains? SPEC-OPS cmd)
      (set! ret ((get SPEC_OPS cmd) ast env))
      (rdr/REGEX.int.test cmd)
      (let [c0 (cmd.charAt 0)]
        (if (and (not= c0 "-")
                 (not= c0 "+"))
          (set! cmd (str "+" cmd)))
        (set! ast [(std/symbol (cmd.charAt 0))
                   (nth ast 1)
                   (parseInt (rest cmd))])
        (set! cmd (str (first ast)))
        (set! ret ((get SPEC-OPS cmd) ast env)))
      :else
      (do (if (std/list? ast)
            (do (transpileAtoms ast env)
                (set! cmd (first ast)))
            (set! cmd (transpileSingle ast)))
          (if-not cmd (syntax! :e1 ast))
          (set! cmd (maybeStripStdlib cmd))
          (if (std/list? ast)
            (do (if (testre? rdr/REGEX.func cmd)
                  (set! cmd (tnodeEx ["(" cmd ")"])))
                (ret.add [cmd
                          "("
                          (join ","
                                (tnodeEx (rest ast))) ")"]))
            (ret.add cmd))))
    (set! ret (nodeTag ret ast))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-deftype "" [ast env public?]
  (do-with [ret (nodeTag (tnode) ast)]
    (var cz (transpile* (nth ast 1) env)
         par (first (nth ast 2))
         args (nth ast 3)
         mtds (ast.slice 4))
    (ret.add ["class " cz])
    (if par
      (ret.add [" extends " (transpile* par env)]))
    (ret.add " {\n")
    (for [i 0 n nil m nil
          :while (< i (alen mtds)) :recur (+1 i)]
      (set! m (nth mtds i))
      (m.unshift (std/symbol "method"))
      (ret.add (sf-func m env false))
      (ret.add "\n"))
    (ret.add "}\n")
    (if (and public? (= 1 (.countNSPCache (rt/globalEnv))))
      (set-in! EXTERNS cz cz))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- prv-deftype
  "" ^{:opcode ["deftype-"]} [a e] (sf-deftype a e false))
(defn- pub-deftype
  "" ^{:opcode ["deftype"]} [a e] (sf-deftype a e true))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- _lambdaFuncCount 0)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-lambda "" [ast env]
  (if (not= 0 _lambdaFuncCount)
    (raise! "Cant nest lambdas")
    (++ _lambdaFuncCount))
  (var x [(types/symbol "fn")
          (types/vector)
          [(types/symbol "var")
           (types/symbol "____args")
           [(types/symbol "Array.prototype.slice.call")
            (types/symbol "arguments")]]]
       body (nth ast 1))
  (if (= (alen body) 0) (set! body [nil]))
  (if (and (= 1 (alen body))
           (types/value? (nth body 0)))
    nil
    (set! body (ast.slice 1)))
  (set! x (x.concat body))
  (try
    (sf-fn x env)
    (finally (-- _lambdaFuncCount))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS "lambda" sf-lambda)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-apply "" [ast env]
  (var args (ast.slice 2)
       f (second ast)
       ret (nodeTag (tn/tnode) ast))
  (forlet ((i 0) (< i (alen args)) (i (inc i)))
    (ret.add (transpile* (nth args i) env)))
  (if (> (alen args) 1) (join "," ret))
  (doto ret
    (.prepend "[")
    (.add "]")
    (.prepend [(transpile* f env) ".apply(this,"])
    (.add ret ")")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :apply sf-apply)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-compOp "" [ast env]
  (var cmd (first ast))
  (if (or (== cmd "not=")
          (== cmd "!=")) (set! ast 0 (types/symbol "!==")))
  (if (== cmd "=") (set! ast 0 (types/symbol "===")))
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (transpileAtoms ast env)
    (forlet ((i 0
              op (ast.shift))
             (< i (last-index ast)) (i (inc i)))
      (ret.add (tn/tnodeEx [(nth ast i)
                            " " op " " (nth ast (inc i))])))
    (join " && " ret)
    (ret.prepend "(")
    (ret.add ")")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(regoBuiltins sf-compOp "compare")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-arithOp "" [ast env]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (transpileAtoms ast env)
    (var op (tn/tnode)
         e1 (ast.shift)
         cmd (types/symbol-s e1))
    (if (== cmd "mod") (set! cmd "%"))
    (if (== cmd "div") (set! cmd "/"))
    (if (= 1 (alen ast))
      (if (== "-" cmd) (ret.add "-"))
      (op.add [""  cmd  ""]))
    (ret.add ast)
    (if (> (alen ast) 1) (join op ret))
    (ret.prepend "(")
    (ret.add ")")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(regoBuiltins sf-arithOp "bitwise")
(regoBuiltins sf-arithOp "logic")
(regoBuiltins sf-arithOp "arith")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-repeat "" [ast env]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (transpileAtoms ast env)
    (forlet ((i 0
              end (parseInt (second ast)))
             (< i end) (i (inc i)))
      (if (not= i 0) (ret.add ","))
      (ret.add (nth ast 2)))
    (ret.prepend "[")
    (ret.add "]")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :repeat-n sf-repeat)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileDo "" [ast env & [return?]]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (set! return? (std.maybe return? true))
    (var p (pad indent)
         e nil
         end (last-index ast))
    (forlet ((i 0) (< i end) (i (inc i)))
      (set! e (nth ast i))
      (ret.add [p (transpileList e env) ";\n"]))
    (when  (>= end 0)
      (set! e (transpile* (nth ast end) env))
      (if-not return?
        (ret.add [p e ";\n"])
        (ret.add [p "return " e ";\n"])))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-do "" [ast env]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (var p (pad indent))
    (ret.add (str p "(function() {\n"))
    (ret.add (transpileDo (ast.slice 1) env))
    (ret.add (str p "}).call(this)"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :do sf-do)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-case "" [ast env]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (var tst (second ast)
         e nil t nil c nil dft nil)
    (if (odd? (alen ast))
      (set! dft (ast.pop)))
    (forlet ((i 2)
             (< i (alen ast)) (i (+ i 2)))
      (set! c (nth ast (+ i 1)))
      (set! e (nth ast i))
      (if (types/list? e)
        (forlet ((j 0)
                 (< j (alen e)) (i (inc)))
          (ret.add ["case "
                    (transpileSingle (nth e j)) ":\n"])
          (if (= j (last-index e))
            (ret.add ["____x= "
                      (transpile* c env) ";\nbreak;\n"])))
        (do (ret.add ["case " (transpileSingle e) ":\n"])
            (ret.add ["____x= "
                      (transpile* c env) ";\nbreak;\n"]))))
    (when dft
      (ret.add "default:\n")
      (ret.add ["____x= "
                (transpile* dft env) ";\nbreak;\n"]))

    (ret.prepend ["switch (",
                  (transpile* tst env) ") {\n"])
    (ret.add "}\n")
    (ret.prepend "(function() { let ____x;\n")
    (ret.add "return ____x;}).call(this)")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :case sf-case)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-range "" [ast env]
  ;;if (ast.length < 2 || ast.length > 4) syntax_E("e0",ast);
  (do-with [ret (nodeTag (tn/tnode) ast)]
  (var len 0 start 0 step 1 end 0)
  (transpileAtoms ast env)
  (set! len (alen ast))
  (set! end (parseInt (second ast)))
  (when (> len 2)
    (set! start (parseInt (second ast)))
    (set! end (parseInt (nth ast 2))))
  (if (> len 3)
    (set! step (parseInt (nth ast 3))))

  (forlet ((i start) (< i end) (i (+ i step)))
    (if (not= i start) (ret.add ","))
    (ret.add (str i)))
  (ret.prepend "[")
  (ret.add "]")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :range sf-range)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-vardefs "" [ast env cmd]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (var kks {}
         public? (== "global" cmd))
    (if-not (== "let" cmd) (set! cmd "var"))
    (forlet ((i 1 s nil) (< i (alen ast)) (i (inc i)))
      (set! s (transpileSingle (nth ast i)))
      (ret.add (str s "=undefined"))
      (set! kks s nil))
    (doto ret
      (.join ",")
      (.prepend (str cmd " "))
      (.add ";\n"))
    (if (and public?
             (= 1 (.countNSPCache (rt/globalEnv))))
      (each-key (fn [v k] (set! EXTERNS k k)) kks))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS "def~-"
      (fn [ast env]  (sf-vardefs ast env "local")))
(set! SPEC-OPS "def~"
      (fn [ast env] (sf-vardefs ast env "global")))
(set! SPEC-OPS "var~"
      (fn [ast env] (sf-vardefs ast env "let")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-var "" [ast env cmd]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (var vname nil
         keys [] kks {}
         public? (== "global" cmd))
    (set! ast (rest ast))
    (if (or public?
            (== "local" cmd)) (set! cmd "var"))

    (forlet ((i 0)
             (< i (alen ast)) (i (+ i 2)))
      (if (types/symbol? (nth ast i))
        (keys.push (nth ast i))))
    (if (std/not-empty keys)
      (ret.add ["let "
                (join ","
                      (map (fn [s]
                             (var ss (transpileSingle s))
                             (set! kks ss nil)
                             ss)
                           keys)) ";\n"]))
    (forlet ((rc nil i 0
              lhs nil rhs nil)
             (< i (alen ast)) (i (+ i 2)))
      (set! rhs (nth ast (+ i 1)))
      (set! lhs (nth ast i))
      (if (types/symbol? lhs)
        (ret.add [(transpileSingle lhs) "= "
                  (transpile* rhs env) ";\n"])
        (do (set! rc (destruct0 cmd lhs rhs env))
            (ret.add (nth rc 0))
            (map (fn [s]
                   (set! kks (rdr/jsid s) nil))
                 (nth rc 1)))))
    (when (and public?
               (= 1 (.countNSPCache (rt/glbalEnv))))
      (each-key (fn [v k]
                  (set! EXTERNS k k)) kks))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-var-local "" [ast env] (sf-var ast env "local"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :def- sf-var-local)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-var-global "" [ast env] (sf-var ast env  "global"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :def sf-var-global)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-var-let "" [ast env] (sf-var ast env "let"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :var sf-var-let)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-inst? "" [ast env]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (ret.add ["("
              (transpile* (nth ast 2) env)
              " instanceof "
              (transpile* (nth ast 1) env) ")"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :inst? sf-inst?)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-delete "" [ast env]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (ret.add ["delete " (transpile* (nth ast 1) env)])
    (if (> (alen ast) 2)
      (ret.add ["[" (transpile* (nth ast 2)) "]"]))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :delete! sf-delete)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-new "" [ast env]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (ret.add (transpileList (rest ast) env))
    (ret.prepend "new ")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :new sf-new)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-throw "" [ast env]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (ret.add ["throw " (transpile* (nth ast 1) env) ";"])
    (ret.prepend "(function (){ ")
    (ret.add " }).call(this)")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :throw sf-throw)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-x-opop "" [ast env]
  (transpileAtoms ast env)
  (nodeTag (tn/tnodeEx [(first ast)
                        (second ast)]) ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(regoBuiltins sf-x-opop "incdec")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-x-eq "" [ast env]
  (transpileAtoms ast env)
  (nodeTag (tn/tnodeEx [(second ast)
                        " " (first ast) " " (nth ast 2)])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(regoBuiltins sf-x-eq "assign")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-set-in "" [ast env]
  (assert (std/even? (alen ast)) "set-in: bad arg count")
  (do-with [ret (nodeTag (tnode) ast)]
    (var obj (transpile* (nth ast 1) env))
    (for [i 2 :while (< i (alen ast)) :recur (+2 i)]
      (if (> i 2) (ret.add ","))
      (ret.add [obj "[" (transpile* (nth ast i) env) "]"
                "=" (transpile* (nth ast (+1 i)) env)]))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set-in! SPEC-OPS "set-in!" sf-set-in)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-set "" [ast env]
  (assert (std/odd? (alen ast)) "set: bad arg count")
  (do-with [ret (nodeTag (tnode) ast)]
    (for [i 1 :while (< i (alen ast)) :recur (+2 i)]
      (if (> i 1) (ret.add ","))
      (ret.add [(transpile* (nth ast i) env)
                "="
                (transpile* (nth ast (+1 i)) env)]))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set-in! SPEC-OPS "set!" sf-set)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- parseFuncArgs "" [args]
  (do-with [ret []]
    (forlet ((i 0 e nil ev nil)
             (< i (alen args)) (i (inc i)))
      (set! e (nth args i))
      (set! ev (.-value e))
      (cond
        (types/symbol? e)
        (cond
          (= ev "_")
          (ret.push (types/symbol (gensym "_")))
          (= ev "&")
          (do (set! e (nth args (+ i 1)))
              (if (types/symbol? e)
                (ret.push [e i e])
                (ret.push [(types/symbol
                             (str "&" (gensym))) i e]))
              (++ i))
          (ev.startsWith "&")
          (do (set! e (types/symbol (rest ev)))
              (ret.push [e, i, e]))
          :else
          (ret.push e))
        (types/keyword? e)
        (raise! "bad function args destructure: "
                (types/obj-type e))
        (array? e)
        (ret.push [(types/symbol (gensym)) i e])
        :else
        (raise! "bad function args destructure: "
                (types/obj-type e))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- handleFuncArgs "" [fargs env]
  (do-with [out []]
    (var misc [] keys []
         ret (tn/tnode) knode (tn/tnode))
    (each (fn [arg]
            (cond
              (types/symbol? arg) (keys.push arg)
              (and (types/symbol? (first arg))
                   (not (.startsWith (str (first arg)) "&"))
                   (array? (nth arg 2)))
              (do (keys.push (first arg))
                  (misc.push arg))
              :else (misc.push arg))) fargs)
    (each (fn [arr]
            (var a0 (first arr)
                 name (str a0)
                 varg? (name.startsWith "&")
                 pos (str (nth arr 1))
                 a2 (nth arr 2))
            (if varg? (set! name (rest name)))
            (set! name (rdr/jsid name))
            (cond
              (and (types/symbol? a0)
                   (types/symbol? a2))
              (ret.add ["let " name
                        "=Array.prototype.slice.call(arguments," pos ");\n"])
              (array? a2)
              (do
                (if varg?
                  (ret.add ["let " name
                            "=Array.prototype.slice.call(arguments," pos ");\n"]))
                (ret.add
                  (first (destruct0 "let" a2 name env)))))) misc)

    (knode.add (join ","
                     (map #(rdr/jsid (str %)) keys)))
    (out.push knode)
    (out.push ret)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-fn "" [ast env]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (var args (nth ast 1)
         fargs nil
         hints {}
         body (ast.slice 2))
    (when (and (= 3 (alen args))
               (== "with-meta" (car args))
               (array? (nth args 1)))
      (set! hints (resolveMeta (nth args 2) env))
      (set! args (nth args 1)))
    (set! fargs (handleFuncArgs
                 (parseFuncArgs args) env))
    (ret.add "function (")
    (ret.add (first fargs))
    (ret.add [") {\n"
              (second fargs)
              (transpileDo body env)
              (pad indent) "}"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set-in! SPEC-OPS "fn" sf-fn)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fmtRegoSpecOps "" [alias fname]
  (str "SPEC_OPS[\"" alias "\"] = " fname))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fmtSpecOps "" [fname attrs]
  (var ks (or (get attrs "opcode") [])
       out (->> (map #(fmtRegoSpecOps
                        (str %1) fname) ks)
                (join ";\n")))
  (if (> (alen ks) 0) (str out ";\n") out))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-func "" [ast env public?]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (var fname (transpile* (nth ast 1) env)
         mtd? (== (first ast) "method")
         dot? (fname.includes ".")
         hints {}
         fargs nil
         e3 (nth ast 3)
         e2 (nth ast 2)
         doc nil attrs nil args 2 body 3)
    (cond
      (string? e2)
      (do (set! doc 2)
          (set! args 3)
          (when (types/map? e3)
            (set! attrs 3)
            (set! args 4)))
      (types/map? e2)
      (do (set! attrs 2)
          (set! args 3)))
    (set! body (+ args 1))
    (if doc (set! doc (nth ast doc)))
    (if attrs (set! attrs (nth ast attrs)))
    (set! args (nth ast args))
    (set! body (ast.slice body))
    (when (and (= 3 (alen args))
               (== "with-meta" (car args))
               (array? (nth args 1)))
      (set! hints (resolveMeta (nth args 2) env))
      (set! args (nth args 1)))
    (set! fargs (handleFuncArgs
                  (parseFuncArgs args) env))
    (cond
      mtd?
      (do (if (.-static hints) (ret.add "static "))
          (ret.add [fname " ("]))
      dot?
      (ret.add [fname " = function ("])
      :else
      (ret.add (str "function " fname "(")))
    (ret.add (first fargs))
    (ret.add [") {\n"
              (second fargs)
              (transpileDo body env)
              (pad indent) "}\n"])

    (if-not (std/empty? hints)
      (ret.add (fmtSpecOps fname attrs)))

    (when doc
      (set! doc (doc.replace rdr.REGEX.dquoteHat ""))
      (set! doc (doc.replace rdr.REGEX.dquoteEnd ""))
      (ret.prepend
                (map #(str "//" % "\n")
                     (doc.split "\\n"))))
    (if (and public?
             (not dot?)
             (= 1 (.countNSPCache (rt/globalEnv))))
      (set! EXTERNS fname fname))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-func-private "" [ast env] (sf-func ast env false))
(set! SPEC-OPS :defn- sf-func-private)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-func-public "" [ast env] (sf-func ast env true))
(set! SPEC-OPS :defn sf-func-public)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-try "" [ast env]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (var sz (alen ast)
         t nil
         f nil
         c nil
         ind (pad indent))
    ;;look for finally
    (set! f (std/last ast))
    (if (and (array? f)
             (== "finally" (first f)))
      (do (set! f (ast.pop))
          (set! sz (alen ast)))
      (set! f nil))
    ;;look for catch
    (set! c nil)
    (if (> sz 1) (set! c (nth ast (- sz 1))))
    (if (and (array? c)
             (== "catch" (first c)))
      (do (if (or (< (alen c) 2)
                  (not (types/symbol? (second c)))) (syntax! :e0 ast))
          (set! c (.pop ast)))
      (set! c nil))
    ;;try needs either a catch or finally or both
    (if (and (nil? f) (nil? c)) (syntax! :e0 ast))
    (ret.add [(str "(function() {\n" ind "try {\n")
              (transpileDo (rest ast) env)
              (str "\n" ind "} ")])
    (when c
      (set! t (second c))
      (ret.add [(str "catch (" t ") {\n")
                (transpileDo (c.slice 2) env)
                (str ";\n" ind "}\n")]))
    (when f
      (ret.add ["finally {\n",
                (transpileDo (rest f) env false)
                (str ";\n" ind "}\n")]))
    (ret.add (str ind "}).call(this)"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :try sf-try)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-if "" [ast env]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (var a1 (nth ast 1)
         a2 (nth ast 2)
         a3 (if (> (alen ast) 3) (nth ast 3)))
    (+= indent tabspace)
    (ret.add ["("
              (transpile* a1 env)
              (str " ?\n" (pad indent))
              (transpile* a2 env)
              (str " :\n" (pad indent))
              (or (transpile* a3 env) "null") ")"])
    (-= indent tabspace)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :if sf-if)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-nth "" [ast env]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (transpileAtoms ast env)
    (ret.add [(nth ast 1) "[" (nth ast 2) "]"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :nth sf-nth)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-get "" [ast env]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (transpileAtoms ast env)
    (ret.add [(nth ast 1) "[" (nth ast 2) "]"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :aget sf-get)
(set! SPEC-OPS :get sf-get)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-str "" [ast env]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (var args (rest ast))
    (transpileAtoms args env)
    (if (> (alen args) 1)
      (doto ret
        (.add args)
        (.join ",")
        (.prepend "[")
        (.add "].join(\"\")"))
      (if (> (alen args) 0)
        (ret.add ["" (first args) ".toString()"])))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :str sf-str)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-array "" [ast env]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (var p (pad indent)
         epilog (str "\n" p "]"))
    (if (std/empty? ast)
      (ret.add "[]")
      (do (if-not (types/vector? ast)
            (ast.splice 0 1))
          (+= indent tabspace)
          (transpileAtoms ast env)
          (set! p (pad indent))
          (ret.add (str "[\n" p))
          (forlet ((i 0) (< i (alen ast)) (i (inc i)))
            (if (> i 0) (ret.add (str ",\n" p)))
            (ret.add (nth ast i)))
          (ret.add epilog)
          (-= indent tabspace)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :vec sf-array)
;(set! SPEC-OPS "[" sf-array)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-object "" [ast env]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (var p (pad indent)
         epilog (str "\n" p "}"))
    (if (std/empty? ast)
      (ret.add "{}")
      (do (if-not (types/map? ast)
            (ast.splice 0 1))
          (+= indent tabspace)
          (transpileAtoms ast env)
          (set! p (pad indent))
          (ret.add (str "{\n" p))
          (forlet ((i 0) (< i (alen ast)) (i (+ i 2)))
            (if (> i 0) (ret.add (str ",\n" p)))
            (ret.add [(nth ast i)
                      ": "
                      (nth ast (+ i 1))]))
          (ret.add epilog)
          (-= indent tabspace)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :hash-map sf-object)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- includeFile
  ((fn []
     (var icache [])
     (fn [fname]
       (if (std/contains? icache fname)
         (tn/tnode)
         (let [src (fs.readFileSync fname "utf-8")]
           (icache.push fname)
           (transpileTree (psr/parser src fname)
                          (rt/globalEnv ))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-include "" [ast env]
  (var ret [] fname nil dir (path/dirname ast.source))
  (forlet ((i 1 e nil)
           (< i (alen ast)) (i (inc i)))
    (set! e (nth ast i))
    (if (or (not (array? e))
            (not= 1 (alen e))) (syntax! :e0 ast))
    (set! fname (first e))
    (if fname
      (set! fname (fname.replace /[\"]/g "")))
    (try
      (set! fname (fs/realpathSync (str dir "/" fname)))
      (catch e
        (syntax! :e11 ast)))
    (try
      (-= indent tabspace)
      (ret.push (includeFile fname))
      (finally
        (.popNSP (rt/globalEnv))
        (+= indent tabspace))))
  (if (std/empty? ret) (tn/tnode) ret))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-require "" [ast env]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (var~  path v e refers renames)
    (var as nil)
    (forlet ((i 1)
             (< i (alen ast)) (i (inc i)))
      (set! e (nth ast i))
      (set! as (gensym))
      (if (or (not (array? e))
              (< (alen e) 3)) (syntax! :e0 ast))
      (set! path (first e))
      (forlet ((j 1)
               (< j (alen e)) (j (inc j)))
        (set! v (nth e j))
        (cond
          (== v "as")
          (do (set! as (str (nth e (+ j 1))))
              (++ j))
          (== v "refer")
          (do (set! refers (nth e (+ j 1)))
              (++ j))
          (== v "rename")
          (do (set! renames (nth e (+ j 1)))
              (++ j))))
      (ret.add ["var "
                (rdr/jsid as)
                "= require("
                (transpileSingle path) ");\n"])
      (forlet ((i 0)
               (and refers
                    (< i (alen refers))) (i (inc i)))
        (set! v (transpileSingle (nth refers i)))
        (ret.add ["var " v "=" as "[\"" v "\"];\n"]))
      (forlet ((i 0)
               (and renames
                    (< i (alen renames))) (i (+ i 2)))
        (set! e (transpileSingle (nth renames i)))
        (set! v (transpileSingle (nth renames (+ i 1))))
        (ret.add ["var " v "=" as "[\"" e "\"];\n"])))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- resolveMeta "" [ast env]
  (cond
    (Array/isArray ast)
    (JSON/parse (str "" (transpile* ast env)))
    (std/keyword? ast)
    (->> (transpile* (std/hashmap ast true) env)
         (str "" )
         (JSON/parse ))
    (std/symbol? ast)
    (->> (transpile* (std/hashmap (std/symbol "tag") ast) env)
         (str "")
         (JSON/parse ))
    :else
    (raise! "Bad meta value" (std/prn ast))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-ns "" [ast env]
  (do-with [ret []]
    (var hints {} nsp (nth ast 1))
    (when (and (Array/isArray nsp)
               (= 3 (alen nsp))
               (== "with-meta" (car nsp))
               (std/symbol? (nth nsp 1)))
      (set! hints (resolveMeta (nth nsp 2) env))
      (set! nsp (nth nsp 1)))
    (.pushNSP (rt/globalEnv) (std/symbol-s nsp))
    (set! ast (ast.slice 2))
    (for [i  0 e nil
          :recur (+1 i)
          :while (< i (alen ast))]
      (set! e (nth ast i))
      (cond
        (and (std/list? e)
             (== "include" (car e)))
        (ret.push (sf-include e))
        (and (std/list? e)
             (== "require" (car e)))
        (ret.push (sf-require e))))
    ;;force a internal reference to stdlib for
    ;;user files
    (set! nsp (.peekNSP (rt/globalEnv)))
    (cond
      (or (= nsp "czlab.kirby.bl.defmacros")
          (= nsp "czlab.kirby.bl.stdlib"))
      nil
      (nsp.startsWith "czlab.kirby.")
      (ret.add "var kirbystdlibref=std;\n")
      :else
      (-> [(std/symbol "require")
           ["\"kirby\""
            (std/keyword ":as") (std/symbol "kirbystdlibref")]]
          (sf-require )
          (ret.push )))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :ns sf-ns)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- maybeStripStdlib "" [cmd]
  (var nsp (.peekNSP (rt/globalEnv))
       lib "kirbystdlibref.")
  (set! cmd (str cmd))
  (if (and (cmd.startsWith lib)
           (= nsp "czlab.kirby.bl.stdlib"))
    (cmd.slice (alen lib))
    cmd))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-comment "" [ast env] (nodeTag (tn/tnode) ast))
(set! SPEC-OPS :comment sf-comment)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-for "" [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (var body (ast.slice 2))
    (if (not-empty body)
      (sf-floop ret (nth ast 1) body env))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-floop "" [ret args body env]
  (var vars [] recurs [])
  (var~ tst nb)
  (for [i 0 e nil
        :while (< i (alen args)) :recur (+1 i)]
    (set! e (nth args i))
    (cond
      (== e "while")
      (do (set! tst (nth args (+1 i)))
          (++ i))
      (== e "recur")
      (do (set! recurs (args.slice (+1 i)))
          (set! i (alen a1)))
      (types/symbol? e)
      (do (vars.push e (nth args (+1 i)))
          (++ i))))
  (ret.add "for (")
  (for [i 0 :while (< i (alen vars)) :recur (+2 i)]
    (if (= i 0) (ret.add "let "))
    (if (not= i 0) (ret.add ","))
    (ret.add [(transpileSingle (nth vars i))
              "="
              (transpile* (nth vars (+1 i)) env)]))
  (if (not-empty vars)
    (ret.add ",____break=false")
    (ret.add "let ____break=false"))
  (ret.add "; ")
  (set! nb [(types/symbol "not")
            (types/symbol "____break")])
  (if tst
    (set! tst [(types/symbol "and") nb tst])
    (set! tst nb))
  (ret.add (transpile* tst env))
  (ret.add "; ")
  (for [i 0 k 0 :while (< i (alen recurs))
                :recur (+1 i) (+2 k)]
    (if (not= i 0) (ret.add ","))
    (ret.add [(transpileSingle (nth vars k))
              "="
              (transpile* (nth recurs i) env)]))
  (doto ret
    (.add "){\n")
    (.add (transpileDo body env false))
    (.add "}\n")
    (.prepend "(function() {\n")
    (.add "})(this);\n")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS "for" sf-for)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-jscode "" [ast env]
  (nodeTag (tn/tnodeEx (-> (.toString (second ast))
                           (.replace rdr/REGEX.dquoteHat "")
                           (.replace rdr/REGEX.dquoteEnd ""))) ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS "js#" sf-jscode)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-macro "" [ast env]
  (var pms (types/vector)
       args (nth ast 2)
       body (ast.slice 3))
  (when (string? args)
    (set! doc args)
    (set! args (nth ast 3))
    (set! body (ast.slice 4)))
  (forlet ((i 0 e nil ev nil)
           (< i (alen args)) (i (inc i)))
    (set! e (nth args i))
    (set! ev (.-value e))
    (cond
      (= ev "&")
      (if (array? (nth args (+ i 1)))
        (do (set! e (nth args (+ i 1)))
            (++ i)
            (forlet ((j 0 x nil)
                     (< j (alen e)) (j (inc j)))
              (set! x (nth e j))
              (if-not (types/symbol? x)
                (raise! "Bad optional arg for macro"))
              (pms.push x)))
        (do (pms.push e (nth args (+ i 1)))
            (++ i)))
      (not (types/symbol? e))
      (raise! "Bad optional arg for macro")
      :else
      (pms.push e)))
  (set! ast
        [(first ast)
         (second ast)
         (.concat [(types/symbol "fn*") pms] body)])
  (var a2 (nth ast 2)
       a1 (str (nth ast 1))
       func (rt/compute a2 env))
  (set! func :____macro true)
  (if doc
    (set! func :____doc doc))
  (rt/setMacro a1 func)
  (nodeTag (tn/tnode) ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS "defmacro" sf-macro)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-unary "" [ast env]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (var [a0 a1] ast)
    (if (== a0 "not") (set! a0 (types/symbol "!")))
    (ret.add ["("
              (transpile* a0 env)
              (transpile* a1 env) ")"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(regoBuiltins sf-unary "unary")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-doseq "" [ast env]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (var args (nth ast 1)
         body (ast.slice 2)
         loopvar (nth args 0)
         loopexpr (nth args 1)
         escvar (gensym)
         idxvar (gensym)
         exprvar (gensym))
    (ret.add ["let " (transpileSingle loopvar)
              "= " exprvar "[" idxvar "];\n"])
    (forlet ((i 2 v nil ev nil)
             (< i (alen args)) (i (inc i)))
      (set! v (nth args i))
      (set! ev (.-value v))
      (cond
        (= ev "while")
        (ret.add ["if (! "
                  (transpile* (nth args (+ i 1)) env)
                  ") {" escvar "=true;}\n"])
        (= ev "when")
        (doto ret
          (.add ["if (!" escvar ") {\n"])
          (.add ["if (! "
                     (transpile* (nth args (+ i 1)) env)
                     ") {continue;}\n"])
          (.add "}\n"))
        (= ev "let")
        (ret.add (sf-var-let
                   (concat [(types/symbol "var")]
                           (nth args (+ i 1))) env))))
    (ret.add ["if (!" escvar ") {\n"])
    (ret.add (transpileDo body env false))
    (ret.add "}\n")
    (ret.add "}\n")
    (ret.prepend ["for(var " escvar "=false," idxvar "=0; "
                  "(!" escvar " && " idxvar
                  " < " exprvar ".length); ++" idxvar ") {\n"])
    (ret.prepend ["let " exprvar "= " (transpile* loopexpr env) ";\n"])
    (ret.prepend "(function() {\n")
    (ret.add "})(this);\n")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS "doseq" sf-doseq)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- spitExterns "" []
  (do-with [s ""]
    (var ks (keys EXTERNS)
         p (pad tabspace))
    (when (> (alen ks) 0)
      (set! s (join ",\n"
                    (map #(str p  %  ": " %) ks)))
      (set! s (str "\n\nmodule.exports = {\n" s "\n};\n\n")))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- banner "" []
  (str "/*"
       "Auto generated by Kirby - v"
       MODULE_VERSION " "
       (.firstNSP (rt/globalEnv)) " - " (new Date) "*/\n\n"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- cleanCode "" [code]
  (var arr [])
  (each (fn [s]
          (set! s (s.trim))
          (if (not= s ";") (arr.push s))) (code.split "\n"))
  (join "\n" arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileCode "" [codeStr fname srcMap?]
  (set! indent (- tabspace))
  (set! EXTERNS {})
  (.resetNSPCache (rt/globalEnv))
  (var outNode (transpileTree (psr/parser codeStr
                                          fname)
                              (rt/globalEnv))
       options {}
       cstr ""
       extra (spitExterns))
  (outNode.prepend (banner))
  (set! cstr
        (if srcMap?
          (let [outFile (str (path/basename fname ".ky") ".js")
                srcMap (str outFile ".map")
                output (outNode.toStringWithSourceMap {:file outFile})]
            (fs/writeFileSync srcMap output.map)
            (str output.code
                 extra
                 "\n//# sourceMappingURL="
                 (path/relative (path/dirname fname) srcMap)))
          (str outNode extra)))
  (set! cstr (cleanCode cstr))
  ;(println cstr)
  (if true (esfmt/format cstr options) cstr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileXXX "" [code file smap?]
  (try
    (transpileCode code file smap?)
    (catch e
      (when e
        (println (.-stack e)) (throw e)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn transpileWithSrcMap "" [code file] (transpileXXX code file true))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn transpile "" [code file] (transpileXXX code file false))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn parseWithSourceMap "" [codeStr fname]
  (var outNode (transpileTree (psr/parser codeStr fname)))
  (outNode.prepend (banner))
  (outNode.toStringWithSourceMap ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(def version MODULE_VERSION)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

