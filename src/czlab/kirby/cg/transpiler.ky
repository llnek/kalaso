;; Copyright (c) 2013-2017, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author "Kenneth Leung"}

  czlab.kirby.cg.transpiler

  (require ["../bl/macros" :as macros]
           ["../bl/types" :as types]
           ["../bl/stdlib" :as std]
           ["../bl/tnode" :as tn]
           ["../bl/lexer" :as rdr]
           ["../bl/parser" :as psr]
           ["../rt/runtime" :as rt])
  (require ["fs" :as fs]
           ["path" :as path]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- gensym-counter 1)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- ERRORS-MAP {
  :e0 "Syntax Error"
  :e1 "Empty statement"
  :e2 "Invalid characters in function name"
  :e3 "End of File encountered, unterminated string"
  :e4 "Closing square bracket, without an opening square bracket"
  :e5 "End of File encountered, unterminated array"
  :e6 "Closing curly brace, without an opening curly brace"
  :e7 "End of File encountered, unterminated javascript object '}'"
  :e8 "End of File encountered, unterminated parenthesis"
  :e9 "Invalid character in var name"
  :e10 "Extra chars at end of file. Maybe an extra ')'."
  :e11 "Cannot Open include File"
  :e12 "Invalid no of arguments to "
  :e13 "Invalid Argument type to "
  :e14 "End of File encountered, unterminated regular expression"
  :e15 "Invalid vararg position, must be last argument."
  :e16 "Invalid arity (args > expected) to "
  :e17 "Invalid arity (args < expected) to "})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- RESERVED {
  :compare ["not=" "!=" "==" "=" ">" ">=" "<" "<="]
  :arith ["+" "-" "*" "div" "%"  "mod"]
  :logic ["||" "&&"]
  :bitwise ["^" "&" "|" "<<" ">>" ">>>"]
  :incdec ["++" "--"]
  :unary ["not"  "~" "!"]
  :assign ["+=" "-=" "*="
         "/=" "%=" "<<="
         ">>=" ">>>=" "&=" "|=" "^="]
  :builtin
  ["quote" "syntax-quote" "quasi-quote"
  "backtick"  "unquote" "unquote-splice"
  "repeat-n"  "do"  "doto"  "case" "apply"
  "range"  "def-"  "def"  "var"  "forlet"
  "new"  "throw"  "while"  "lambda"
  "inst?"  "delete!"
  "aset"  "set!"  "fn"  "def!"
  "defn-"  "defn"
  "try"  "if"  "get"  "aget"  "str"
  "list"  "["  "vec"  "{"  "hash-map"
  "ns"  "comment"  "for"  "cons"
  "js#"  "macro"  "defmacro"]})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- MODULE-VERSION "1.0.0"
      nosemi? false
      tabspace 2
      indent (- tabspace)
      EXTERNS nil
      NSPACES nil
      SPEC-OPS {})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- gensym "" [& [pfx]]
  (var x gensym-counter)
  (++ gensym-counter)
  (str (std/maybe pfx "G____") x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- regoBuiltins "" [f group]
  (each #(set! SPEC-OPS % f) (get RESERVED group)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- error! "" [e line file msg]
  (raise! (get ERRORS-MAP e)
          (if msg (str " : " msg) "")
          (if line (str "\nLine no " line) "")
          (if file (str "\nFile " file) "")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- syntax! "" [ecode ast cmd]
  (error! ecode
          (if ast ast.line 0)
          (if ast ast.source 0) cmd))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- pad "" [z] (.repeat " " z))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- testre? "" [re x] (if x (re.test x) false))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- nodeTag "" [obj src]
  (when (and obj
             src
             (not (boolean? obj))
             (not (number? obj)))
    (set! obj.source src.source)
    (set! obj.column src.column)
    (set! obj.line src.line))
  obj)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destruct1 "" [lhs]
  (var as "" out [] keys {})
  (cond
    (types/vector? lhs)
    (forlet ((i 0 e nil ev nil)
             (< i (alen lhs)) (i (inc i)))
      (set! e (nth lhs i))
      (set! ev (.-value e))
      (cond
        (types/symbol? e)
        (cond
          (= ev "_") nil
          (= ev "&") (do (set! keys
                               (str "&" (nth lhs (inc i))) i)
                         (++ i))
          (ev.startsWith "&")
          (set! keys ev i)
          :else
          (set! keys ev i))
        (types/keyword? e)
        (if (= ev "as")
          (do (++ i)
              (set! as (str (nth lhs i))))
          (raise! "bad keyword: :" ev))))
    (types/map? lhs)
    (forlet ((i 0 e nil ev nil)
             (< i (alen lhs)) (i (inc i)))
      (set! e (nth lhs i))
      (set! ev (.-value e))
      (if (types/keyword? e)
        (cond
          (or (= ev "keys")
              (= ev "strs"))
          (let [ks (nth lhs (inc i))]
            (++ i)
            (forlet ((j 0)
                     (< j (alen ks)) (j (inc j)))
              (set! keys (str (nth ks j)) nil)))
          (= ev "as")
          (do (++ i)
              (set! as (str (nth lhs i)))))
        (raise! "bad destruct field: "
                (types/obj-type e))))
    (types/symbol? lhs)
    (set! keys (str lhs) nil)
    :else
    (raise! "cant destruct with: " (types/obj-type lhs)))
  ;;return
  [as keys])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destruct0 "" [cmd lhs rhs env]
  (var d (destruct1 lhs)
       as (nth d 0)
       kdefs []
       ka nil
       kvals (tn/tnode)
       keys (nth d 1))
  (if (std/empty? as) (set! as (gensym)))
  (set! as (rdr/jsid as))
  (each (fn [x]
          (var name (nth x 0)
               n nil
               pos nil
               rest? false)
          (when (name.startsWith "&")
            (set! rest? true)
            (set! name (name.slice 1)))
          (set! n (rdr/jsid name))
          (kdefs.push n)
          (set! pos (nth x 1))
          (cond
            (nil? pos)
            (set! ka (str n "=" as "[\"" name "\"];\n"))
            rest?
            (set! ka (str n "=" as ".slice(" pos ");\n"))
            :else
            (set! ka (str n "=" as "[" pos "];\n")))
          (kvals.add ka))
        (Object.entries keys))
  (kvals.prepend (str cmd " " (join "," kdefs) ";\n"))
  [[(tn/tnodeEx [cmd " "
                (rdr/jsid as) "= "
                (transpile* rhs env) ";\n"]) kvals] kdefs])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileTree "" [root env]
  (do-with [ret (nodeTag (tn/tnode) root)]
    (var pstr ""
         treeSize (alen root)
         endx (last-index root))
    (+= indent tabspace)
    (set! pstr (pad indent))
    (each (fn [ast]
            (var tmp ast)
            (if (array? ast)
              (set! tmp (transpileList ast env)))
            (when tmp
              (ret.add [pstr tmp (if nosemi? ""  ";") "\n"])
              (set! nosemi? false))) root)
    (-= indent tabspace)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileAtoms "" [atoms env]
  (each (fn [a i arr]
          (set! arr
                i
                (if (array? a)
                  (transpileList a env)
                  (transpileSingle a)))) atoms))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileSingle "" [a]
  (cond
    (types/symbol? a)
    (rdr/jsid (types/symbol-s a))
    (types/keyword? a)
    (str "\"" (types/keyword-s a) "\"")
    (types/lambda-arg? a)
    (str "____args[" (types/lambda-arg-s a) "]")
    (string? a)
    a
    (nil? a)
    "null"
    :else
    (str "" a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpile* "" [x env]
  (if (array? x)
    (transpileList x env) (transpileSingle x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- findCmd "" [ast]
  (do-with [cmd ""]
    (cond
      (types/vector? ast) (set! cmd "[")
      (types/map? ast) (set! cmd "{")
      (types/list? ast) (set! cmd (types/symbol-s (first ast))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileList "" [ast env]
  (var cmd (findCmd ast)
       mc (macros/get cmd) tmp nil)
  (do-with [ret (tn/tnode)]
    (when mc
      (set! ast (rt/expandMacro ast env mc))
      (set! cmd (findCmd ast)))
    (cond
      (cmd.startsWith ".-")
      (ret.add [(transpile* (second ast) env)
                "."
                (transpileSingle (types/symbol (cmd.slice 2)))])
      (= "." (cmd.charAt 0))
      (do (ret.add (transpile* (second ast) env))
          (ret.add [cmd "("])
          (forlet ((n 2)
                   (< n (alen ast)) (n (inc n)))
            (if (not= n 2) (ret.add ","))
            (ret.add (transpile* (nth ast n) env)))
          (ret.add ")"))
      (SPEC-OPS.hasOwnProperty cmd)
      (set! ret ((get SPEC_OPS cmd) ast env))
      :else
      (do (if (types/list? ast)
            (do (transpileAtoms ast env)
                (set! cmd (first ast)))
            (set! cmd (transpileSingle ast)))
          (if-not cmd (syntax! :e1 ast))
          (if (types/list? ast)
            (do (if (testre? rdr/REGEX.func cmd)
                  (set! cmd (tn/tnodeEx ["(" cmd ")"])))
                (ret.add [cmd
                          "("
                          (join ","
                                (tn/tnodeEx (ast.slice 1))) ")"]))
            (ret.add cmd))))
    (set! ret (nodeTag ret ast))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- _lambdaFuncCount 0)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-lambda "" [ast env]
  (if (not= 0 _lambdaFuncCount)
    (raise! "Cant nest lambdas")
    (++ _lambdaFuncCount))
  (var x [(types/symbol "fn")
          (types/vector)
          (map (fn [s] (types/symbol s))
               ["let", "____args",
                "Array.prototype.slice.call(arguments)"])]
       body (nth ast 1))
  (if (= (alen body) 0) (set! body [nil]))
  (if (and (= 1 (alen body))
           (types/value? (nth body 0)))
    nil
    (set! body (ast.slice 1)))
  (set! x (x.concat body))
  (try
    (sf-fn x env)
    (finally (-- _lambdaFuncCount))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS "lambda" sf-lambda)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-apply "" [ast env]
  (var args (ast.slice 2)
       f (second ast)
       ret (nodeTag (tn/tnode) ast))
  (forlet ((i 0) (< i (alen args)) (i (inc i)))
    (ret.add (transpile* (nth args i) env)))
  (if (> (alen args) 1) (join "," ret))
  (doto ret
    (.prepend "[")
    (.add "]")
    (.prepend [(transpile* f env) ".apply(this,"])
    (.add ret ")")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :apply sf-apply)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-compOp "" [ast env]
  (var cmd (first ast))
  (if (or (= cmd "not=")
          (= cmd "!=")) (set! ast 0 (types/symbol "!==")))
  (if (= cmd "=") (set! ast 0 (types/symbol "===")))
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (transpileAtoms ast env)
    (forlet ((i 0
              op (ast.shift))
             (< i (last-index ast)) (i (inc i)))
      (ret.add (tn/tnodeEx [(nth ast i)
                            " " op " " (nth ast (inc i))])))
    (join " && " ret)
    (ret.prepend "(")
    (ret.add ")")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(regoBuiltins sf-compOp "compare")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-arithOp "" [ast env]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (transpileAtoms ast env)
    (var op (tn/tnode)
         e1 (ast.shift)
         cmd (types/symbol-s e1))
    (if (= cmd "mod") (set! cmd "%"))
    (if (= cmd "div") (set! cmd "/"))
    (if (= 1 (alen ast))
      (if (= "-" cmd) (ret.add "-"))
      (op.add [""  cmd  ""]))
    (ret.add ast)
    (if (> (alen ast) 1) (join op ret))
    (ret.prepend "(")
    (ret.add ")")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(regoBuiltins sf-arithOp "bitwise")
(regoBuiltins sf-arithOp "logic")
(regoBuiltins sf-arithOp "arith")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-repeat "" [ast env]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (transpileAtoms ast env)
    (forlet ((i 0
              end (parseInt (second ast)))
             (< i end) (i (inc i)))
      (if (not= i 0) (ret.add ","))
      (ret.add (nth ast 2)))
    (ret.prepend "[")
    (ret.add "]")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :repeat-n sf-repeat)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileDo "" [ast env & [return?]]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (set! return? (std.maybe return? true))
    (var p (pad indent)
         e nil
         end (last-index ast))
    (forlet ((i 0) (< i end) (i (inc i)))
      (set! e (nth ast i))
      (ret.add [p (transpileList e env) ";\n"]))
    (when  (>= end 0)
      (set! e (transpile* (nth ast end) env))
      (if-not return?
        (ret.add [p e ";\n"])
        (ret.add [p "return " e ";\n"])))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-do "" [ast env]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (var p (pad indent))
    (ret.add (str p "(function() {\n"))
    (ret.add (transpileDo (ast.slice 1) env))
    (ret.add (str p "}).call(this)"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :do sf-do)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-case "" [ast env]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (var tst (second ast)
         e nil t nil c nil dft nil)
    (if (odd? (alen ast))
      (set! dft (ast.pop)))
    (forlet ((i 2)
             (< i (alen ast)) (i (+ i 2)))
      (set! c (nth ast (+ i 1)))
      (set! e (nth ast i))
      (if (types/list? e)
        (forlet ((j 0)
                 (< j (alen e)) (i (inc)))
          (ret.add ["case "
                    (transpileSingle (nth e j)) ":\n"])
          (if (= j (last-index e))
            (ret.add ["____x= "
                      (transpile* c env) ";\nbreak;\n"])))
        (do (ret.add ["case " (transpileSingle e) ":\n"])
            (ret.add ["____x= "
                      (transpile* c env) ";\nbreak;\n"]))))
    (when dft
      (ret.add "default:\n")
      (ret.add ["____x= "
                (transpile* dft env) ";\nbreak;\n"]))

    (ret.prepend ["switch (",
                  (transpile* tst env) ") {\n"])
    (ret.add "}\n")
    (ret.prepend "(function() { let ____x;\n")
    (ret.add "return ____x;}).call(this)")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :case sf-case)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-range "" [ast env]
  ;;if (ast.length < 2 || ast.length > 4) syntax_E("e0",ast);
  (do-with [ret (nodeTag (tn/tnode) ast)]
  (var len 0 start 0 step 1 end 0)
  (transpileAtoms ast env)
  (set! len (alen ast))
  (set! end (parseInt (second ast)))
  (when (> len 2)
    (set! start (parseInt (second ast)))
    (set! end (parseInt (nth ast 2))))
  (if (> len 3)
    (set! step (parseInt (nth ast 3))))

  (forlet ((i start) (< i end) (i (+ i step)))
    (if (not= i start) (ret.add ","))
    (ret.add (str i)))
  (ret.prepend "[")
  (ret.add "]")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :range sf-range)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-var "" [ast env cmd]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (var vname nil
         keys [] kks {}
         public? (== "global" cmd))
    (set! ast (rest ast))
    (if (or public?
            (== "local" cmd)) (set! cmd "var"))

    (forlet ((i 0)
             (< i (alen ast)) (i (+ i 2)))
      (if (types/symbol? (nth ast i))
        (keys.push (nth ast i))))
    (if (std/not-empty keys)
      (ret.add ["let "
                (join ","
                      (map (fn [s]
                             (var ss (transpileSingle s))
                             (set! kks ss nil)
                             ss)
                           keys)) ";\n"]))
    (forlet ((rc nil i 0
              lhs nil rhs nil)
             (< i (alen ast)) (i (+ i 2)))
      (set! rhs (nth ast (+ i 1)))
      (set! lhs (nth ast i))
      (if (types/symbol? lhs)
        (ret.add [(transpileSingle lhs) "= "
                  (transpile* rhs env) ";\n"])
        (do (set! rc (destruct0 cmd lhs rhs env))
            (ret.add (nth rc 0))
            (map (fn [s]
                   (set! kks (rdr/jsid s) nil))
                 (nth rc 1)))))
    (when (and public?
               (= 1 (alen NSPACES)))
      (each-key (fn [v k]
                  (set! EXTERNS k k)) kks))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-var-local "" [ast env] (sf-var ast env "local"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :def- sf-var-local)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-var-global "" [ast env] (sf-var ast env  "global"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :def sf-var-global)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-var-let "" [ast env] (sf-var ast env "let"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :var sf-var-let)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-inst? "" [ast env]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (ret.add ["("
              (transpile* (nth ast 2) env)
              " instanceof "
              (transpile* (nth ast 1) env) ")"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :inst? sf-inst?)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-delete "" [ast env]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (ret.add ["delete " (transpile* (nth ast 1) env)])
    (if (> (alen ast) 2)
      (ret.add ["[" (transpile* (nth ast 2)) "]"]))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :delete! sf-delete)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-new "" [ast env]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (ret.add (transpileList (rest ast) env))
    (ret.prepend "new ")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :new sf-new)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-throw "" [ast env]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (ret.add ["throw " (transpile* (nth ast 1) env) ";"])
    (ret.prepend "(function (){ ")
    (ret.add " }).call(this)")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :throw sf-throw)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-x-opop "" [ast env]
  (transpileAtoms ast env)
  (nodeTag (tn/tnodeEx [(first ast)
                        (second ast)]) ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(regoBuiltins sf-x-opop "incdec")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-x-eq "" [ast env]
  (transpileAtoms ast env)
  (nodeTag (tn/tnodeEx [(second ast)
                        " " (first ast) " " (nth ast 2)])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(regoBuiltins sf-x-eq "assign")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-set "" [ast env]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (var e1 (transpile* (nth ast 1) env))
    (if (= 4 (alen ast))
      (doto ret
        (.add e1)
        (.add "[")
        (.add (transpile* (nth ast 2) env))
        (.add "]"))
      (ret.add e1))
    (ret.add [" = "
              (transpile* (nth ast
                               (last-index ast)) env)])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :aset sf-set)
(set! SPEC-OPS :set! sf-set)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- parseFuncArgs "" [args]
  (do-with [ret []]
    (forlet ((i 0 e nil ev nil)
             (< i (alen args)) (i (inc i)))
      (set! e (nth args i))
      (set! ev (.-value e))
      (cond
        (types/symbol? e)
        (cond
          (= ev "_")
          (ret.push (types/symbol (gensym "_")))
          (= ev "&")
          (do (set! e (nth args (+ i 1)))
              (if (types/symbol? e)
                (ret.push [e i e])
                (ret.push [(types/symbol
                             (str "&" (gensym))) i e]))
              (++ i))
          (ev.startsWith "&")
          (do (set! e (types/symbol (rest ev)))
              (ret.push [e, i, e]))
          :else
          (ret.push e))
        (types/keyword? e)
        (raise! "bad function args destructure: "
                (types/obj-type e))
        (array? e)
        (ret.push [(types/symbol (gensym)) i e])
        :else
        (raise! "bad function args destructure: "
                (types/obj-type e))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- handleFuncArgs "" [fargs env]
  (do-with [out []]
    (var misc [] keys []
         ret (tn/tnode) knode (tn/tnode))
    (each (fn [arg]
            (cond
              (types/symbol? arg) (keys.push arg)
              (and (types/symbol? (first arg))
                   (not (.startsWith (str (first arg)) "&"))
                   (array? (nth arg 2)))
              (do (keys.push (first arg))
                  (misc.push arg))
              :else (misc.push arg))) fargs)
    (each (fn [arr]
            (var a0 (first arr)
                 name (str a0)
                 varg? (name.startsWith "&")
                 pos (str (nth arr 1))
                 a2 (nth arr 2))
            (if varg? (set! name (rest name)))
            (set! name (rdr/jsid name))
            (cond
              (and (types/symbol? a0)
                   (types/symbol? a2))
              (ret.add ["let " name
                        "=Array.prototype.slice.call(arguments," pos ");\n"])
              (array? a2)
              (do
                (if varg?
                  (ret.add ["let " name
                            "=Array.prototype.slice.call(arguments," pos ");\n"]))
                (ret.add
                  (first (destruct0 "let" a2 name env)))))) misc)

    (knode.add (join ","
                     (map #(rdr/jsid (str %)) keys)))
    (out.push knode)
    (out.push ret)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-fn "" [ast env]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (var args (nth ast 1)
         body (.slice ast 2)
         fargs (handleFuncArgs
                 (parseFuncArgs args) env))
    (ret.add "function (")
    (ret.add (first fargs))
    (ret.add [") {\n"
              (second fargs)
              (transpileDo body env)
              (pad indent) "}"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS "fn" sf-fn)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-func "" [ast env public?]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (var fname (transpileSingle (nth ast 1))
         dot? (fname.includes ".")
         fargs nil
         e3 (nth ast 3)
         e2 (nth ast 2)
         doc nil attrs nil args 2 body 3)
    (cond
      (string? e2)
      (do (set! doc 2)
          (set! args 3)
          (when (types/map? e3)
            (set! attrs 3)
            (set! args 4)))
      (types/map? e2)
      (do (set! attrs 2)
          (set! args 3)))
    (set! body (+ args 1))
    (if doc (set! doc (nth ast doc)))
    (if attrs (set! attrs (nth ast attrs)))
    (set! args (nth ast args))
    (set! fargs (handleFuncArgs
                  (parseFuncArgs args) env))
    (set! body (ast.slice body))
    (if dot?
      (ret.add [fname " = function ("])
      (ret.add (str "function " fname "(")))
    (ret.add (first fargs))
    (ret.add [") {\n"
              (second fargs)
              (transpileDo body env)
              (pad indent) "}\n"])
    (when (and false attrs)
      ;;//ret.add(fmtSpecOps(fname, attrs));
      ;;//ret.add(";");
      nil)
    (when doc
      (set! doc (doc.replace rdr.REGEX.dquoteHat ""))
      (set! doc (doc.replace rdr.REGEX.dquoteEnd ""))
      (ret.prepend
                (map #(str "//" % "\n")
                     (doc.split "\\n"))))
    (if (and public?
             (not dot?)
             (= 1 (alen NSPACES)))
      (set! EXTERNS fname fname))
    (set! nosemi? true)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-func-private "" [ast env] (sf-func ast env false))
(set! SPEC-OPS :defn- sf-func-private)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-func-public "" [ast env] (sf-func ast env true))
(set! SPEC-OPS :defn sf-func-public)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-try "" [ast env]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (var sz (alen ast)
         t nil
         f nil
         c nil
         ind (pad indent))
    ;;look for finally
    (set! f (std/last ast))
    (if (and (array? f)
             (== "finally" (first f)))
      (do (set! f (ast.pop))
          (set! sz (alen ast)))
      (set! f nil))
    ;;look for catch
    (set! c nil)
    (if (> sz 1) (set! c (nth ast (- sz 1))))
    (if (and (array? c)
             (== "catch" (first c)))
      (do (if (or (< (alen c) 2)
                  (not (types/symbol? (second c)))) (syntax! :e0 ast))
          (set! c (.pop ast)))
      (set! c nil))
    ;;try needs either a catch or finally or both
    (if (and (nil? f) (nil? c)) (syntax! :e0 ast))
    (ret.add [(str "(function() {\n" ind "try {\n")
              (transpileDo (rest ast) env)
              (str "\n" ind "} ")])
    (when c
      (set! t (second c))
      (ret.add [(str "catch (" t ") {\n")
                (transpileDo (c.slice 2) env)
                (str ";\n" ind "}\n")]))
    (when f
      (ret.add ["finally {\n",
                (transpileDo (rest f) env)
                (str ";\n" ind "}\n")]))
    (ret.add (str ind "}).call(this)"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :try sf-try)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-if "" [ast env]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (var a1 (nth ast 1)
         a2 (nth ast 2)
         a3 (if (> (alen ast) 3) (nth ast 3)))
    (+= indent tabspace)
    (ret.add ["("
              (transpile* a1 env)
              (str " ?\n" (pad indent))
              (transpile* a2 env)
              (str " :\n" (pad indent))
              (or (transpile* a3 env) "null") ")"])
    (-= indent tabspace)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :if sf-if)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-nth "" [ast env]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (transpileAtoms ast env)
    (ret.add [(nth ast 1) "[" (nth ast 2) "]"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :nth sf-nth)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-get "" [ast env]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (transpileAtoms ast env)
    (ret.add [(nth ast 1) "[" (nth ast 2) "]"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :aget sf-get)
(set! SPEC-OPS :get sf-get)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-str "" [ast env]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (var args (rest ast))
    (transpileAtoms args env)
    (if (> (alen args) 1)
      (doto ret
        (.add args)
        (.join ",")
        (.prepend "[")
        (.add "].join(\"\")"))
      (if (> (alen args) 0)
        (ret.add ["" (first args) ".toString()"])))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :str sf-str)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-array "" [ast env]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (var p (pad indent)
         epilog (str "\n" p "]"))
    (if (std/empty? ast)
      (ret.add "[]")
      (do (if-not (types/vector? ast)
            (ast.splice 0 1))
          (+= indent tabspace)
          (transpileAtoms ast env)
          (set! p (pad indent))
          (ret.add (str "[\n" p))
          (forlet ((i 0) (< i (alen ast)) (i (inc i)))
            (if (> i 0) (ret.add (str ",\n" p)))
            (ret.add (nth ast i)))
          (ret.add epilog)
          (-= indent tabspace)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :vec sf-array)
;(set! SPEC-OPS "[" sf-array)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-object "" [ast env]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (var p (pad indent)
         epilog (str "\n" p "}"))
    (if (std/empty? ast)
      (ret.add "{}")
      (do (if-not (types/map? ast)
            (ast.splice 0 1))
          (+= indent tabspace)
          (transpileAtoms ast env)
          (set! p (pad indent))
          (ret.add (str "{\n" p))
          (forlet ((i 0) (< i (alen ast)) (i (+ i 2)))
            (if (> i 0) (ret.add (str ",\n" p)))
            (ret.add [(nth ast i)
                      ": "
                      (nth ast (+ i 1))]))
          (ret.add epilog)
          (-= indent tabspace)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :hash-map sf-object)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- includeFile
  ((fn []
     (var icache [])
     (fn [fname]
       (if (std/contains? icache fname)
         (tn/tnode)
         (let [src (fs.readFileSync fname "utf-8")]
           (icache.push fname)
           (transpileTree (psr/parser src fname)
                          (rt/globalEnv ))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-include "" [ast env]
  (var ret [] fname nil dir (path/dirname ast.source))
  (forlet ((i 1 e nil)
           (< i (alen ast)) (i (inc i)))
    (set! e (nth ast i))
    (if (or (not (array? e))
            (not= 1 (alen e))) (syntax! :e0 ast))
    (set! fname (first e))
    (if fname
      (set! fname (fname.replace /[\"]/g "")))
    (try
      (set! fname (fs/realpathSync (str dir "/" fname)))
      (catch e
        (syntax! :e11 ast)))
    (try
      (-= indent tabspace)
      (ret.push (includeFile fname))
      (finally
        (NSPACES.pop)
        (+= indent tabspace))))
  (if (std/empty? ret) (tn/tnode) ret))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-require "" [ast env]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (var path nil v nil e nil)
    (forlet ((i 1)
             (< i (alen ast)) (i (inc i)))
      (set! e (nth ast i))
      (if (or (not (array? e))
              (not= 3 (alen e))) (syntax! :e0 ast))
      (set! path (first e))
      (set! v (nth e 2))
      (ret.add ["var "
                (transpileSingle v env)
                "= require("
                (transpileSingle path env) ");\n"]))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-ns "" [ast env]
  (do-with [ret []]
    (forlet ((i 1 e nil nsp nil)
             (< i (alen ast)) (i (inc i)))
      (set! e (nth ast i))
      (cond
        (types/symbol? e)
        (if nsp
          (syntax! :e0 ast)
          (NSPACES.push (e.toString)))
        (and (types/list? e)
             (== "with-meta" (nth e 0))
             (types/symbol? (nth e 1)))
        (if nsp
          (syntax! :e0 ast)
          (NSPACES.push (str (second e))))
        (and (types/list? e)
             (== "include" (first e)))
        (ret.push (sf_include e))
        (and (types/list? e)
             (== "require" (first e)))
        (ret.push (sf_require e))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :ns sf-ns)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-comment "" [ast env] (nodeTag (tn/tnode) ast))
(set! SPEC-OPS :comment sf-comment)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-floop "" [ast env hint]
  (do-with [ret (nodeTag (tn/tnodeEx "for (") ast)]
    (var c1 nil c2 nil c3 nil
         c (nth ast 1) ind (pad indent))
    (if (or (not (array? c))
            (not= 3 (alen c))) (syntax! :e0 ast))
    (set! c1 (first c))
    (set! c2 (second c))
    (set! c3 (nth c 2))
    (+= indent tabspace)
    (if (array? c1)
      (forlet ((i 0) (< i (alen c1)) (i (+ i 2)))
        (if (= i 0) (ret.add (str hint " ")))
        (if (> i 0) (ret.add ","))
        (ret.add [(transpileSingle (nth c1 i) env)
                  " = "
                  (transpile* (nth c1 (inc i)) env)])))
    (ret.add "; ")

    (if (array? c2)
      (ret.add ["(!____break && " (transpileList c2 env) ")"])
      (ret.add " !___break "))

    (ret.add "; ")
    (if (array? c3)
      (forlet ((i 0) (< i (alen c3)) (i (+ i 2)))
        (if (> i 0) (ret.add ","))
        (ret.add [(transpileSingle (nth c3 i) env)
                  " = "
                  (transpile* (nth c3 (inc i)) env)])))
    (ret.add ") {\n")
    (if (> (alen ast) 2)
      (ret.add [ind (pad tabspace)
                (transpileDo (ast.slice 2) env false) ";"]))
    (ret.add (str "\n" ind "}\n"))
    (ret.prepend "(function () {let ____break=false;\n")
    (ret.add "}).call(this)")
    (-= indent tabspace)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :forlet (fn [ast env] (sf-floop ast env "let")))
(set! SPEC-OPS :for (fn [ast env] (sf-floop ast env "")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-wloop "" [ast env]
  (do-with [ret (nodeTag (tn/tnodeEx "for (;") ast)]
    (var cond (second ast)
         ind (pad indent))
    (ret.add [" (!____break && " (transpile* cond env) ") "])
    (ret.add ";) {\n")
    (+= indent tabspace)
    (if (> (alen ast) 2)
      (ret.add [ind
                (pad tabspace)
                (transpileDo (ast.slice 2) env false) ";"]))
    (ret.add (str "\n" ind "}\n"))
    (ret.prepend "(function () {let ____break=false;\n")
    (ret.add "}).call(this)")
    (-= indent tabspace)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :while sf-wloop)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-jscode "" [ast env]
  (set! nosemi? true)
  (nodeTag (tn/tnodeEx (-> (.toString (second ast))
                           (.replace rdr/REGEX.dquoteHat "")
                           (.replace rdr/REGEX.dquoteEnd ""))) ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS "js#" sf-jscode)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-macro "" [ast env]
  (var pms (types/vector)
       args (nth ast 2)
       body (ast.slice 3))
  (when (string? args)
    (set! doc args)
    (set! args (nth ast 3))
    (set! body (ast.slice 4)))
  (forlet ((i 0 e nil ev nil)
           (< i (alen args)) (i (inc i)))
    (set! e (nth args i))
    (set! ev (.-value e))
    (cond
      (= ev "&")
      (if (array? (nth args (+ i 1)))
        (do (set! e (nth args (+ i 1)))
            (++ i)
            (forlet ((j 0 x nil)
                     (< j (alen e)) (j (inc j)))
              (set! x (nth e j))
              (if-not (types/symbol? x)
                (raise! "Bad optional arg for macro"))
              (pms.push x)))
        (do (pms.push e (nth args (+ i 1)))
            (++ i)))
      (not (types/symbol? e))
      (raise! "Bad optional arg for macro")
      :else
      (pms.push e)))
  (set! ast
        [(first ast)
         (second ast)
         (.concat [(types/symbol "fn*") pms] body)])
  (var a2 (nth ast 2)
       a1 (str (nth ast 1))
       func (rt/compute a2 env))
  (set! func :____macro true)
  (if doc
    (set! func :____doc doc))
  (macros/set a1 func)
  (nodeTag (tn/tnode) ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS "defmacro" sf-macro)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-unary "" [ast env]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (var [a0 a1] ast)
    (if (== a0 "not") (set! a0 (types/symbol "!")))
    (ret.add ["("
              (transpile* a0 env)
              (transpile* a1 env) ")"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(regoBuiltins sf-unary "unary")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-doseq "" [ast env]
  (do-with [ret (nodeTag (tn/tnode) ast)]
    (var args (nth ast 1)
         body (ast.slice 2)
         loopvar (nth args 0)
         loopexpr (nth args 1)
         escvar (gensym)
         idxvar (gensym)
         exprvar (gensym))
    (ret.add ["let " (transpileSingle loopvar)
              "= " exprvar "[" idxvar "];\n"])
    (forlet ((i 2 v nil ev nil)
             (< i (alen args)) (i (inc i)))
      (set! v (nth args i))
      (set! ev (.-value v))
      (cond
        (= ev "while")
        (ret.add ["if (! "
                  (transpile* (nth args (+ i 1)) env)
                  ") {" escvar "=true;}\n"])
        (= ev "when")
        (doto ret
          (.add ["if (!" escvar ") {\n"])
          (.add ["if (! "
                     (transpile* (nth args (+ i 1)) env)
                     ") {continue;}\n"])
          (.add "}\n"))
        (= ev "let")
        (ret.add (sf-var-let
                   (concat [(types/symbol "var")]
                           (nth args (+ i 1))) env))))
    (ret.add ["if (!" escvar ") {\n"])
    (ret.add (transpileDo body env false))
    (ret.add "}\n")
    (ret.add "}\n")
    (ret.prepend ["for(var " escvar "=false," idxvar "=0; "
                  "(!" escvar " && " idxvar
                  " < " exprvar ".length); ++" idxvar ") {\n"])
    (ret.prepend ["let " exprvar "= " (transpile* loopexpr env) ";\n"])
    (ret.prepend "(function() {\n")
    (ret.add "})(this);\n")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS "doseq" sf-doseq)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- spitExterns "" []
  (do-with [s ""]
    (var ks (keys EXTERNS)
         p (pad tabspace))
    (when (> (alen ks) 0)
      (set! s (join ",\n"
                    (map #(str p  %  ": " %) ks)))
      (set! s (str "\n\nmodule.exports = {\n" s "\n};\n\n")))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- banner "" []
  (str "/*"
       "Auto generated by Kirby - v"
       MODULE_VERSION " "
       (first NSPACES) " - " (new Date) "*/\n\n"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileCode "" [codeStr fname srcMap?]
  (set! indent (- tabspace))
  (set! EXTERNS {})
  (set! NSPACES [])
  (var outNode (transpileTree (psr/parser codeStr
                                          fname)
                              (rt/globalEnv))
       extra (spitExterns))
  (outNode.prepend (banner))
  (if srcMap?
    (let [outFile (str (path/basename fname ".ky") ".js")
          srcMap (str outFile ".map")
          output (outNode.toStringWithSourceMap {:file outFile})]
      (fs/writeFileSync srcMap output.map)
      (str output.code
           extra
           "\n//# sourceMappingURL="
           (path/relative (path/dirname fname) srcMap)))
    (str outNode extra)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileXXX "" [code file smap?]
  (try
    (transpileCode code file smap?)
    (catch e
      (when e
        (println (.-stack e)) (throw e)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn transpileWithSrcMap "" [code file] (transpileXXX code file true))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn transpile "" [code file] (transpileXXX code file false))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn parseWithSourceMap "" [codeStr fname]
  (var outNode (transpileTree (psr/parser codeStr fname)))
  (outNode.prepend (banner))
  (outNode.toStringWithSourceMap ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(def version MODULE_VERSION)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

