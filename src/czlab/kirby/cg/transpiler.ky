;; Copyright (c) 2013-2017, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author "Kenneth Leung"}

  czlab.kirby.cg.transpiler

  (require ["../bl/stdlib"
            :as std
            :refer [lambda-arg? hashmap pairs? contains? last typeid
                    prn primitive map? vector? opt?? some?
                    primitive? not-empty conj! list?
                    extendAttr gensym count
                    symbol keyword symbol? keyword?]]
           ["../bl/lexer"
            :as rdr
            :refer
            [tnode tnodeEx]]
           ["../bl/parser" :as psr]
           ["../rt/runtime" :as rt])
  (require ["fs" :as fs]
           ["path" :as path]
           ["esformatter" :as esfmt]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- ERRORS-MAP {
  :e0 "Syntax Error"
  :e1 "Empty statement"
  :e2 "Invalid characters in function name"
  :e3 "End of File encountered, unterminated string"
  :e4 "Closing square bracket, without an opening square bracket"
  :e5 "End of File encountered, unterminated array"
  :e6 "Closing curly brace, without an opening curly brace"
  :e7 "End of File encountered, unterminated javascript object '}'"
  :e8 "End of File encountered, unterminated parenthesis"
  :e9 "Invalid character in var name"
  :e10 "Extra chars at end of file. Maybe an extra ')'."
  :e11 "Cannot Open include File"
  :e12 "Invalid no of arguments to "
  :e13 "Invalid Argument type to "
  :e14 "End of File encountered, unterminated regular expression"
  :e15 "Invalid vararg position, must be last argument."
  :e16 "Invalid arity (args > expected) to "
  :e17 "Invalid arity (args < expected) to "})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- MODULE-VERSION "1.0.0")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- EXTERNS nil
      SPEC-OPS {}
      MATH-OP-REGEX /^[-+][0-9]+$/)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- simpleton? "" [ast]
  (or (undef? ast)
      (string? ast)
      (number? ast)
      (boolean? ast) (nil? ast)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- exprHint "" [ast flag]
  (var x ast)
  (if (simpleton? ast)
    (set! x (primitive ast)))
  (set-in! x :____expr flag)
  x)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- stmt? "" [ast]
  (if (simpleton? ast)
    (raise! "Cant test expr? on primitive"))
  (false? ast.____expr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- error! "" [e &[line file msg]]
  (raise! (get ERRORS-MAP e)
          (if msg (str " : " msg))
          (if line (str "\nLine no " line))
          (if file (str "\nFile " file))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- syntax! "" [ecode &[ast cmd]]
  (error! ecode
          (if ast ast.line 0)
          (if ast ast.source 0) cmd))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- pad "" [z] (.repeat " " z))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- testre? "" [re x] (if x (re.test x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- node' "" [obj src]
  (when (and obj
             src
             (not (simpleton? obj)))
    (set! obj.source src.source
          obj.column src.column obj.line src.line)) obj)

(defn- xxx "" [args]
  (var pms []
       fargs (tnode) out (tnode))
  (var~ rhs e ev rval)
  (for [i 0 sz (count args)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i args))
    (cond
      (symbol? e)
      (do
        (set! ev $(e))
        (when (or (= "&" ev)
                  (ev.startsWith "&"))
          (set! rval (tnodeEx ["kirbystdlibref.slice("
                               "arguments," i ")"]))
          (break-out-of-loop!))
        (cond
          (= ev "&")
          (do (set! e (.@+i args))
              (cond
                (symbol? e)
                (set! rhs e)
                (array? e)
                (do (set! out (tnode))
                    (set! rhs (destruct* e out))
                    (ret.add (xxx rhs rval out)))))
          (ev.startsWith "&")
          (set! rhs (symbol (rest ev)))
          :else
          (conj! pms e)))
      (array? e)
      (do (set! rval (tnodeEx ["arguments[" i "]"]))
          (set! out (tnode))
          (set! rhs (destruct* e out))
          (conj! pms rhs)
          (ret.add (xxx rhs rval out)))
      :else ""))
  (for [i 0 sz (count pms)
        :while (< i sz) :recur (+1 i)]
    (fargs.add $(.@i pms)))
  (fargs.join ",")
  [fargs ret])

(defn- xxx "" [rhs rval parts]
  (var ret (tnode))
  (ret.add [cmd " " $(rhs) "=" rval ";\n"])
  (doseq [p parts]
    (if (array? p)
      (ret.add ["let " $(1st p) "=" $(rhs) "[" (2nd p) "];\n"])
      (ret.add p)))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destruct* "" [coll out]
  (var rhs (gensym))
  (for [i 0 e nil sz (count coll)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i coll))
    (when (and (keyword? e)
               (== e "as"))
      (set! rhs (.@+i coll))
      (break-out-of-loop!)))
  (cond
    (map? coll) (crackMap rhs coll out)
    (vector? coll) (crackVec rhs coll out)
    :else "")
  rhs)

;;[a b c & d]
;;[a b c & [d e]]
(defn- crackVec "" [target coll out]
  (var~ out rval rhs e ev)
  (var pms [] ret (tnode))
  (for [i 0 sz (count coll)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i coll))
    (cond
      (symbol? e)
      (do
        (set! ev $(e))
        (when (or (= "&" ev)
                  (ev.startsWith "&"))
          (set! rval (tnodeEx ["kirbystdlibref.slice("
                               target "," i ")"]))
          (break-out-of-loop!))
        (cond
          (= ev "&")
          (do (set! e (.@+i coll))
              (cond
                (symbol? e)
                (set! rhs e)
                (array? e)
                (do (set! out (tnode))
                    (set! rhs (destruct* e out))
                    (ret.add (xxx rhs rval out)))))
          (ev.startsWith "&")
          (set! rhs (symbol (rest ev)))
          :else
          (ret.add ["let " $(e) "=" rhs "[" i "];\n"])))
      (array? e)
      (do (set! rval (tnodeEx [target "[" i "]"]))
          (set! out (tnode))
          (set! rhs (destruct* e out))
          (conj! pms [rhs i])
          (ret.add (xxx rhs rval out)))
      :else ""))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destructVec "" [lhs keys]
  (var~ as e ev)
  (for [i 0 sz (n# lhs)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i lhs) ev $(e))
    (cond (symbol? e)
          (cond (= ev "_")
                nil
                (= ev "&")
                (do (set-in! keys
                             (str "&"
                                  (.@+i lhs)) i)
                    (++ i))
                (ev.startsWith "&")
                (set-in! keys ev i)
                :else
                (set-in! keys ev i))
          (keyword? e)
          (if (= ev "as")
            (do (++ i)
                (set! as $(.@i lhs)))
            (raise! "bad keyword: :" ev))))
  as)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destructMap "" [lhs keys]
  (var~ as e ev)
  (for [i 0 sz (n# lhs)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i lhs) ev $(e))
    (if (keyword? e)
      (cond (or (= ev "keys")
                (= ev "strs"))
            (let [ks (.@+i lhs)]
              (++ i)
              (for [j 0 sz (n# ks)
                    :while (< j sz) :recur (+1 j)]
                (set-in! keys
                         $(.@j ks) nil)))
            (= ev "as")
            (do (++ i)
                (set! as $(.@i lhs))))
      (raise! "bad destruct field: " (typeid e))))
  as)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destruct1 "" [lhs]
  (var as nil out [] keys {})
  (cond (vector? lhs)
        (set! as (destructVec lhs keys))
        (map? lhs)
        (set! as (destructMap lhs keys))
        (symbol? lhs)
        (set-in! keys $(lhs) nil)
        :else
        (raise! "cant destruct with: " (typeid lhs)))
  [as keys])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destruct0 "" [cmd lhs rhs env]
  (var [as keys] (destruct1 lhs)
       kdefs [] ka nil kvals (tnode))
  (if (empty? as) (set! as (gensym "A____")))
  (set! as (rdr/jsid as))
  (each-key
    (fn [v k]
      (var rest? false)
      (when (k.startsWith "&")
        (set! rest? true
              k (rest k)))
      (set! k (rdr/jsid k))
      (conj! kdefs k)
      (->>
        (cond (nil? v)
              (str "[\"" k "\"];\n")
              rest?
              (str ".slice(" v ");\n")
              :else
              (str "[" v "];\n"))
        (str k "=" as )
        (kvals.add ))) keys)
  (kvals.prepend (str cmd
                      " "
                      (join "," kdefs) ";\n"))
  [[(tnodeEx [cmd " "
              (rdr/jsid as) "= "
              (tx* rhs env) ";\n"]) kvals] kdefs])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txTree "" [root env]
  (var ret (node' (tnode) root))
  (doseq [r root
          :let [tmp (tx* r env)]
          :when (some? tmp)]
    (ret.add [tmp "\n"])) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txExpr "" [atoms env]
  (each (fn [a i arr]
          (set-in! arr i (tx* a env))) atoms))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txAtom "" [a]
  (var s $(a))
  (cond (lambda-arg? a)
        (str "____args[" s "]")
        (keyword? a)
        (str "\"" s "\"")
        (symbol? a)
        (rdr/jsid s)
        (nil? a)
        "null"
        (primitive? a)
        (do (set! a a.value)
            (cond (string? a) a
                  (nil? a) "null"
                  :else $(a)))
        :else s))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- tx* "" [x env]
  (if (array? x) (txPairs x env) (txAtom x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- findCmd "" [ast]
  (cond (vector? ast)
        "vec"
        (map? ast)
        "hashmap"
        (list? ast)
        "list"
        (array? ast)
        $(1st ast)
        :else ""))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quoteSingle "" [a]
  (cond (keyword? a)
        (str "keyword(\":" a "\")")
        (symbol? a)
        (str "symbol(\"" a "\")")
        (primitive? a)
        (do (set! a a.value)
            (cond (string? a) a
                  (nil? a) "null"
                  :else $(a)))
        :else $(a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quote! "" [a env]
  (if (array? a)
    (if (map? a)
      (quoteMap a env)
      (quoteBlock a env))
    (quoteSingle a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quoteMap "" [a env]
  (var ret (tnode) comma "")
  (for [i 0 sz (n# a)
        :while (< i sz) :recur (+2 i)]
    (if (> i 0) (ret.add ","))
    (ret.add [(quote! (.@i a) env)
              " : " (quote! (.@+i a) env)]))
  (if-not (empty? a) (set! comma ","))
  (ret.prepend ["[" "symbol(\"hashmap\")" comma])
  (ret.add "]")
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quoteBlock "" [a env]
  (var ret (tnode))
  (for [i 0 sz (n# a)
        :while (< i sz) :recur (+1 i)]
    (if (> i 0) (ret.add ","))
    (ret.add (quote! (.@i a) env)))
  (ret.prepend "[")
  (ret.add "]")
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-quote "" ^{:opcode ["quote"]} [ast env]
  (var ret (node' (tnode) ast))
  (ret.add (quote! (2nd ast) env))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txPairs "" [ast env]
  (var stmtQ (stmt? ast)
       cmd (findCmd ast)
       ret (tnode)
       specop nil
       tmp nil
       mc (rt/getMacro cmd))
  ;;handle macro calls
  (when mc
    (set! ast (rt/expandMacro ast env mc)
          ast (exprHint ast (not stmtQ))
          cmd (findCmd ast)))
  ;;handle (+1 ) or (-1 ) cases
  (when (rdr/REGEX.int.test cmd)
    (var c0 (ch@ cmd 0))
    (if (and (not= c0 "-")
             (not= c0 "+"))
      (set! cmd (str "+" cmd)))
    (set! ast [(symbol (ch@ cmd 0))
               (2nd ast)
               (int (rest cmd))]
          cmd $(1st ast)))
  ;;maybe special form
  (set! specop (get SPEC-OPS cmd))
  ;;handle all cases
  (cond
    (== cmd "with-meta")
    (do (set! tmp (2nd ast))
        (if-not (simpleton? tmp)
          (do (set-in! tmp
                       :____meta
                       (evalMeta (.@2 ast) env))
              (ret.add (tx* tmp env)))
          (raise! "cant with-meta simple value")))
    (cmd.startsWith ".-")
    (ret.add [(tx* (2nd ast) env)
              "."
              (txAtom (symbol (cmd.slice 2)))])
    (cmd.startsWith ".@")
    (do (var onemore? #f pos 2)
        (when (cmd.startsWith ".@+")
          (++ pos)
          (true! onemore?))
        (ret.add [(tx* (2nd ast) env) "[" (cmd.slice pos)])
        (if onemore?
          (ret.add "+1]")
          (ret.add "]")))
    (= "." (ch@ cmd 0))
    (do (ret.add [(tx* (2nd ast) env) cmd "("])
        (for [n 2 sz (n# ast)
              :while (< n sz) :recur (+1 n)]
          (if (not= n 2) (ret.add ","))
          (ret.add (tx* (.@n ast) env)))
        (ret.add ")"))
    (some? specop)
    (set! ret (specop ast env))
    :else
    (do (if (pairs? ast)
          (do (txExpr ast env)
              (set! cmd (1st ast)))
          (set! cmd (txAtom ast)))
        (if-not cmd (syntax! :e1 ast))
        (set! cmd (maybeStripStdlib cmd))
        (if (pairs? ast)
          (do (if (testre? rdr/REGEX.func cmd)
                (set! cmd (tnodeEx ["(" cmd ")"])))
              (ret.add [cmd
                        "("
                        (join "," (tnodeEx (rest ast))) ")"]))
          (ret.add cmd))))
  (node' ret ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- writeDoc "Convert to jsdoc"
  [doc]
  (if doc
    (->> (-> (doc.replace rdr/REGEX.dquoteHat "")
             (.replace rdr/REGEX.dquoteEnd "")
             (.split "\\n"))
         (map #(str "//" (.trim (str %)) "\n"))) ""))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-deftype
  "Define a JS Class"
  ^{:opcode ["deftype" "deftype-"]}
  [ast env]
  (var private? (.endsWith $(1st ast) "-")
       ret (node' (tnode) ast)
       cz (tx* (2nd ast) env)
       par (1st (.@2 ast))
       args (.@3 ast))
  (var~ n m doc mtds)
  (if (string? (.@4 ast))
    (do (set! doc (.@4 ast)
              mtds (ast.slice 5)))
    (set! mtds (ast.slice 4)))
  (ret.add ["class " cz])
  (if par
    (ret.add [" extends " (tx* par env)]))
  (ret.add " {\n")
  (for [i 0 pos 0 sz (n# mtds)
        :while (< i sz) :recur (+1 i)]
    (set! m (.@i mtds))
    (set! pos (if (string? (2nd m)) 3 2))
    (when (and (== (1st m) "constructor")
               (not-empty args))
      (txExpr args env)
      (for [x 0 sz (n# args)
            :while (< x sz) :recur (+2 x)]
        (set-in! args
                 x
                 (str "\"" (.@x args) "\"")))
      (m.splice pos 0
        (concat [(symbol "set-in!")
                 (symbol "this")] args)))
    (m.unshift (symbol "method"))
    (ret.add (sf-func m env #f))
    (ret.add "\n"))
  (ret.add "}\n")
  (if doc (ret.prepend (writeDoc doc)))
  (if (and (not private?)
           (= 1 (.countNSPCache (rt/globalEnv))))
      (set-in! EXTERNS cz cz))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-compOp ""
  ^{:opcode ["not=" "!=" "=="
             "=" ">" ">=" "<" "<="]}
  [ast env]
  (var ret (node' (tnode) ast)
       cmd (1st ast))
  (if (or (== cmd "not=")
          (== cmd "!="))
    (set-in! ast 0 (symbol "!==")))
  (if (== cmd "=")
    (set-in! ast 0 (symbol "===")))
  (txExpr ast env)
  (for [i 0 op (ast.shift)
        :while (< i (last-index ast)) :recur (+1 i)]
    (ret.add (tnodeEx [(.@i ast)
                       " " op
                       " " (.@+i ast)])))
  (join " && " ret)
  (ret.prepend "(")
  (ret.add ")")
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-arithOp
  ""
  ^{:opcode ["+" "-" "*" "div" "%"  "mod"
             "||" "&&"
             "^" "&" "|" "<<" ">>" ">>>"]}
  [ast env]
  (var op (tnode)
       ret (node' (tnode) ast))
  (txExpr ast env)
  (var e1 (ast.shift) cmd $(e1))
  (if (== cmd "mod") (set! cmd "%"))
  (if (== cmd "div") (set! cmd "/"))
  (if (= 1 (n# ast))
    (if (== "-" cmd) (ret.add "-"))
    (op.add [""  cmd  ""]))
  (ret.add ast)
  (if (> (n# ast) 1) (join op ret))
  (ret.prepend "(")
  (ret.add ")")
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txDo "" [ast env & [return?]]
  (var ret (node' (tnode) ast)
       stmtQ (stmt? ast)
       e nil end (last-index ast))
  (set! return?
        (if stmtQ false (opt?? return? true)))
  (for [i 0 :while (< i end) :recur (+1 i)]
    (set! e (exprHint (.@i ast) #f))
    (ret.add [(txPairs e env) ";\n"]))
  (when (>= end 0)
    (set! e (exprHint (.@end ast)
                      (not stmtQ))
          e (tx* e env))
    (if-not return?
      (ret.add [e ";\n"])
      (ret.add ["return " e ";\n"])))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-do
  "" ^{:opcode ["do"]} [ast env]
  (var ret (node' (tnode) ast)
       stmtQ (stmt? ast)
       body (exprHint (rest ast) (not stmtQ)))
  (ret.add (txDo body env (not stmtQ)))
  (if stmtQ
    (ret.prepend "{\n")
    (ret.prepend "(function() {\n"))
  (if stmtQ
    (ret.add "}")
    (ret.add "}).call(this)"))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-case
  "" ^{:opcode ["case"]} [ast env]
  (var ret (node' (tnode) ast)
       stmtQ (stmt? ast)
       brk ";\nbreak;\n"
       tst (2nd ast) _x $(gensym "C____"))
  (var~ e t c dft)
  (if (odd? (n# ast))
    (set! dft (ast.pop)))
  (for [i 2 sz (n# ast)
        :while (< i sz) :recur (+2 i)]
    (set! e (.@i ast)
          c (.@+i ast))
    (if (pairs? e)
      (for [j 0 sz (n# e)
            :while (< j sz) :recur (+1 i)]
        (ret.add ["case "
                  (txAtom (.@j e)) ":\n"])
        (if (= j (last-index e))
          (ret.add [_x "="
                    (tx* c env) brk])))
      (do (ret.add ["case " (txAtom e) ":\n"
                    _x "="
                    (tx* c env) brk]))))
  (when dft
    (ret.add ["default:\n"
              _x "="
              (tx* dft env) brk]))
  (ret.prepend ["switch ("
                (tx* tst env) ") {\n"])
  (ret.add "}")
  (if stmtQ
    (ret.prepend ["{ let " _x ";\n"])
    (ret.prepend ["(function() { let " _x ";\n"]))
  (if stmtQ
    (ret.add "}")
    (ret.add ["return " _x ";}).call(this)"]))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-vardefs
  ""
  ^{:opcode ["def~-" "def~" "var~"]}
  [ast env]

  (var ret (node' (tnode) ast)
       cmd $(1st ast)
       kks {}
       private? (.endsWith cmd "-"))
  (if-not (== "let" cmd) (set! cmd "var"))
  (for [i 1 s nil sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (set! s (txAtom (.@i ast)))
    (ret.add s)
    (set-in! kks s nil))
  (ret.join ",")
  (ret.prepend (str cmd " "))
  (ret.add ";\n")
  (if (and (not private?)
           (= 1 (.countNSPCache (rt/globalEnv))))
    (each-key (fn [v k]
                (set-in! EXTERNS k k)) kks))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-const
  ""
  ^{:opcode ["const" "const-"]}
  [ast env]

  (var ret (node' (tnode) ast)
       cmd $(1st ast)
       kks {} keys []
       vname nil
       private? (.endsWith cmd "-"))
  (var~ rc lhs rhs)
  (set! ast (rest ast) cmd "const")
  (for [i 0 sz (n# ast)
       :while (< i sz) :recur (+2 i)]
    (set! lhs (.@i ast)
          rhs (.@+i ast))
    (if (symbol? lhs)
      (do (set! lhs (txAtom lhs))
          (set-in! kks lhs nil)
          (ret.add [cmd " " lhs
                    "= " (tx* rhs env) ";\n"]))
      (do (set! rc (destruct0 cmd lhs rhs env))
          (ret.add (1st rc))
          (each #(set-in! kks
                          (rdr/jsid %) nil)
                (2nd rc)))))
  (when (and (not private?)
             (= 1 (.countNSPCache (rt/globalEnv))))
    (each #(set-in! EXTERNS % %) (keys kks)))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-var
  ""
  ^{:opcode ["def" "def-" "var"]}
  [ast env]

  (var ret (node' (tnode) ast)
       tmp nil vname nil
       cmd $(1st ast)
       keys [] kks {}
       private? (not= cmd "def"))
  (var~ rc lhs rhs)
  (set! ast (rest ast)
        cmd (if (== cmd "var") "let" "var"))
  (comment
    (for [i 0
          :while (< i (n# ast)) :recur (+2 i)]
      (if (symbol? (.@i ast))
        (conj! keys (.@i ast))))
    (if (not-empty keys)
      (ret.add ["let "
                (join ","
                      (map (fn [s]
                             (var ss (txAtom s))
                             (set-in! kks ss nil) ss) keys)) ";\n"])))
  (for [i 0 sz (n# ast)
        :while (< i sz) :recur (+2 i)]
    (set! lhs (.@i ast)
          rhs (.@+i ast))
    (if (symbol? lhs)
      (do (set! lhs (txAtom lhs)
                tmp [lhs "= "
                     (tx* rhs env) ";\n"])
          (when-not (contains? kks lhs)
            (set-in! kks lhs nil)
            (tmp.unshift cmd " "))
          (ret.add tmp))
      (do (set! rc (destruct0 cmd lhs rhs env))
          (ret.add (1st rc))
          (map #(set-in! kks
                         (rdr/jsid %) nil)
               (2nd rc)))))
  (when (and (not private?)
             (= 1 (.countNSPCache (rt/globalEnv))))
    (each-key (fn [v k]
                (set-in! EXTERNS k k)) kks))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-inst?
  "" ^{:opcode ["inst?"]} [ast env]
  (var ret (node' (tnode) ast))
  (ret.add ["("
            (tx* (.@2 ast) env)
            " instanceof "
            (tx* (2nd ast) env) ")"])
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-delete
  "" ^{:opcode ["delete!"]} [ast env]
  (var ret (node' (tnode) ast))
  (ret.add ["delete " (tx* (2nd ast) env)])
  (if (> (n# ast) 2)
    (ret.add ["[" (tx* (.@2 ast)) "]"]))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-new
  "" ^{:opcode ["new"]} [ast env]
  (var ret (node' (tnode) ast))
  (ret.add (txPairs (rest ast) env))
  (ret.prepend "new ")
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-throw
  "" ^{:opcode ["throw"]} [ast env]
  (var ret (node' (tnode) ast)
       stmtQ (stmt? ast))
  (ret.add ["throw " (tx* (2nd ast) env)])
  (when-not stmtQ
    (ret.prepend "(function (){ ")
    (ret.add " }).call(this)"))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-x-opop
  "" ^{:opcode ["++" "--"]} [ast env]
  (txExpr ast env)
  (node' (tnodeEx [(1st ast)
                   (2nd ast)]) ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-x-eq
  "" ^{:opcode ["+=" "-=" "*="
                "/=" "%=" "<<="
                ">>=" ">>>=" "&=" "|=" "^="]} [ast env]
  (txExpr ast env)
  (node' (tnodeEx [(2nd ast)
                   " "
                   (1st ast)
                   " " (.@2 ast)])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-set-in
  "" ^{:opcode ["set-in!"]} [ast env]
  (assert (even? (n# ast))
          "set-in: bad arg count")
  (var ret (node' (tnode) ast)
       more #f
       obj (tx* (2nd ast) env))
  (for [i 2 sz (n# ast)
        :while (< i sz) :recur (+2 i)]
    (when (> i 2)
      (ret.add ",")
      (true! more))
    (ret.add [obj "[" (tx* (.@i ast) env) "]"
              "=" (tx* (.@+i ast) env)]))
  (when more
    (ret.prepend "(")
    (ret.add ")"))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-set
  "" ^{:opcode ["set!"]} [ast env]
  (assert (odd? (n# ast))
          "set: bad arg count")
  (var more #f
       ret (node' (tnode) ast))
  (for [i 1 sz (n# ast)
        :while (< i sz) :recur (+2 i)]
    (when (> i 1)
      (ret.add ",")
      (true! more))
    (ret.add [(tx* (.@i ast) env)
              "=" (tx* (.@+i ast) env)]))
  (when more
    (ret.prepend "(")
    (ret.add ")"))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- parseFuncArgs "" [args]
  (var pms [] ret [])
  (var~ e ev)
  (for [pos 0 sz (n# args)
        :while (< pos sz) :recur (+1 pos)]
    (set! e (.@pos args) ev $(e))
    (cond
      (symbol? e)
      (cond
        (= ev "&")
        (do (set! e (.@+pos args))
            (cond
              (symbol? e)
              (ret.add ["let "
                        (txAtom e)
                        "=slice(arguments," pos ");\n"])
              (map? e)
              (destructMap)
              (array? e)
              (destructVec)))
        (ev.startsWith "&")
        (ret.add ["let "
                  (rdr/jsid (rest ev))
                  "=slice(arguments," pos ");\n"])
        (== ev "_")
        nil
        :else (conj! pms e))
      (map? e)
      (destructMap)
      (array? e)
      (destructVec)
      :else
      (raise! "bad function arg: " (typeid e))))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- XXparseFuncArgs "" [args]
  (var ret [])
  (var~ e ev)
  (for [i 0 sz (n# args)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i args) ev $(e))
    (cond (symbol? e)
          (cond (= ev "_")
                (conj! ret
                       (gensym "_"))
                (= ev "&")
                (do (set! e (.@+i args))
                    (if (symbol? e)
                      (conj! ret [e i e])
                      (conj! ret [(symbol (str "&" $(gensym "A____"))) i e]))
                    (++ i))
                (ev.startsWith "&")
                (do (set! e (symbol (rest ev)))
                    (conj! ret [e i e]))
                :else
                (conj! ret e))
          (keyword? e)
          (raise! "bad function args destructure: " (typeid e))
          (array? e)
          (conj! ret [(gensym) i e])
          :else
          (raise! "bad function args destructure: " (typeid e))))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- handleFuncArgs "" [fargs env]
  (var out [] misc []
       keys [] ret (tnode) knode (tnode))
  (each (fn [arg]
          (cond
            (symbol? arg)
            (conj! keys arg)
            (and (symbol? (1st arg))
                 (not (.startsWith $(1st arg) "&"))
                 (array? (.@2 arg)))
            (do (conj! keys (1st arg))
                (conj! misc arg))
            :else (conj! misc arg))) fargs)
  (each (fn [arr]
          (var a0 (1st arr)
               name $(a0)
               varg? (name.startsWith "&")
               pos $(2nd arr)
               a2 (.@2 arr))
          (if varg? (set! name (rest name)))
          (set! name (rdr/jsid name))
          (cond
            (and (symbol? a0)
                 (symbol? a2))
            (ret.add ["let " name
                      "=Array.prototype.slice.call(arguments," pos ");\n"])
            (array? a2)
            (do (if varg?
                  (ret.add ["let " name
                            "=Array.prototype.slice.call(arguments," pos ");\n"]))
                (ret.add (1st (destruct0 "let" a2 name env)))))) misc)
  (knode.add (join "," (map #(rdr/jsid (str %)) keys)))
  (conj! out knode ret))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-fn
  "" ^{:opcode ["fn"]} [ast env]
  (var ret (node' (tnode) ast)
       args (2nd ast)
       fargs nil
       hints {}
       body (ast.slice 2))
  (when (and (= 3 (n# args))
             (== "with-meta" (1st args))
             (array? (2nd args)))
    (set! hints (evalMeta (.@2 args) env)
          args (2nd args)))
  (set! fargs (handleFuncArgs
                  (parseFuncArgs args) env))
  (ret.add ["function (" (1st fargs) ") {\n"
            (2nd fargs) (txDo body env #t) "}"])
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fmtRegoSpecOps
  "" [alias fname]
  (str (rdr/jsid :SPEC-OPS)
       "[\"" alias "\"] = " fname))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fmtSpecOps "" [fname attrs]
  (var ks (or (get attrs "opcode") [])
       out (->> (map #(fmtRegoSpecOps
                        (str %) fname) ks)
                (join ";\n")))
  (if (not-empty ks) (str out ";\n") out))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-func
  ""
  ^{:opcode ["defn" "defn-"]}
  [ast env]

  (var mtd? (== (1st ast) "method")
       fname (tx* (2nd ast) env)
       dot? (contains? fname ".")
       ret (node' (tnode) ast)
       hints {}
       fargs nil
       e2 (.@2 ast)
       doc nil args 2 body 3
       private? (.endsWith $(1st ast) "-"))
  (if (string? e2)
    (set! doc 2 args 3))
  (set! body (+1 args))
  (if doc (set! doc (nth ast doc)))
  (set! args (nth ast args)
        body (ast.slice body))
  (when (and (= 3 (n# args))
             (== "with-meta" (1st args))
             (array? (2nd args)))
    (set! hints (evalMeta (.@2 args) env)
          args (2nd args)))
  (set! fargs
        (handleFuncArgs
          (parseFuncArgs args) env))
  (cond mtd?
        (do (if (.-static hints)
              (ret.add "static "))
            (ret.add [fname " ("])
            (if (== fname "constructor")
              (body.push (symbol "this"))))
        dot?
        (ret.add [fname " = function ("])
        :else
        (ret.add ["const " fname " = function ("]))
  (ret.add [(1st fargs)
            ") {\n"
            (2nd fargs)
            (txDo body env #t) "};\n"])
  (if (not-empty hints)
    (ret.add (fmtSpecOps fname hints)))
  (if doc
    (ret.prepend (writeDoc doc)))
  (if (and (not private?)
           (not dot?)
           (not mtd?)
           (= 1 (.countNSPCache (rt/globalEnv))))
    (set-in! EXTERNS fname fname))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-try
  "" ^{:opcode ["try"]} [ast env]
  (var stmtQ (stmt? ast)
       sz (n# ast)
       ret (node' (tnode) ast))
  (var~ t f c)
  ;;look for finally
  (set! f (last ast))
  (if (and (array? f)
           (== "finally" (1st f)))
    (set! f (ast.pop)
          sz (n# ast))
    (nil! f))
  ;;look for catch
  (nil! c)
  (if (> sz 1)
    (set! c (nth ast (-1 sz))))
  (if (and (array? c)
           (== "catch" (1st c)))
    (do (if (or (< (n# c) 2)
                (not (symbol? (2nd c)))) (syntax! :e0 ast))
        (set! c (ast.pop)))
    (nil! c))
  ;;try needs either a catch or finally or both
  (if (and (nil? f) (nil? c)) (syntax! :e0 ast))
  (ret.add ["try {\n"
            (txDo (exprHint (rest ast)
                            (not stmtQ)) env) "\n}"])
  (when c
    (set! t (2nd c))
    (ret.add [(str "catch (" t ") {\n")
              (txDo (exprHint (c.slice 2)
                              (not stmtQ)) env) ";\n}\n"]))
  (when f
    (ret.add ["finally {\n",
              (txDo (exprHint (rest f) #f) env #f) ";\n}\n"]))
  (when-not stmtQ
    (ret.prepend "(function(){\n")
    (ret.add "}).call(this)"))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-if
  "" ^{:opcode ["if"]} [ast env]

  (var ret (node' (tnode) ast)
       stmtQ (stmt? ast)
       a1 (exprHint (2nd ast) (not stmtQ))
       a2 (exprHint (.@2 ast) (not stmtQ))
       a3 (if (> (n# ast) 3) (.@3 ast))
       elze (if a3 (exprHint a3 (not stmtQ))))
  (set! a1 (tx* a1 env)
        a2 (tx* a2 env)
        elze (tx* elze env))
  (if stmtQ
    (do (ret.add ["if (" a1 ") {\n" a2 ";\n}"])
        (if a3 (ret.add [" else { \n" elze ";\n}"])))
    (ret.add ["(" a1 " ?\n" a2 " :\n" (or elze "null") ")"]))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-nth ""
  ^{:opcode ["nth"]} [ast env]

  (var ret (node' (tnode) ast))
  (txExpr ast env)
  (ret.add [(2nd ast) "[" (.@2 ast) "]"])
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-get
  "" ^{:opcode ["aget" "get"]} [ast env]

  (var ret (node' (tnode) ast))
  (txExpr ast env)
  (ret.add [(2nd ast) "[" (.@2 ast) "]"])
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-array
  "" ^{:opcode ["vec"]} [ast env]

  (var ret (node' (tnode) ast))
  (if (empty? ast)
    (ret.add "[]")
    (do (if-not (vector? ast)
          (ast.splice 0 1))
        (txExpr ast env)
        (ret.add "[\n")
        (for [i 0 sz (n# ast)
              :while (< i sz) :recur (+1 i)]
          (if (> i 0) (ret.add ",\n"))
          (ret.add (.@i ast)))
        (ret.add "\n]")))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-object
  "" ^{:opcode ["hashmap"]} [ast env]

  (var ret (node' (tnode) ast))
  (if (empty? ast)
    (ret.add "{}")
    (do (if-not (map? ast)
          (ast.splice 0 1))
        (txExpr ast env)
        (ret.add "{\n")
        (for [i 0 sz (n# ast)
              :while (< i sz) :recur (+2 i)]
          (if (> i 0) (ret.add ",\n"))
          (ret.add [(.@i ast) ": " (.@+i ast)]))
        (ret.add "\n}")))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- icache [])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- includeFile [fname]
  (if (contains? icache fname)
    (tnode)
    (let [src (fs/readFileSync fname "utf-8")]
      (conj! icache fname)
      (txTree (psr/parser src fname)
              (rt/globalEnv )))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-include "" [ast env]
  (var ret []
       dir (path/dirname ast.source))
  (var~ fname e)
  (for [i 1 sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i ast))
    (if (or (not (array? e))
            (not= 1 (n# e))) (syntax! :e0 ast))
    (set! fname (1st e))
    (if fname
      (set! fname (fname.replace /[\"]/g "")))
    (try
      (set! fname (fs/realpathSync
                    (str dir "/" fname)))
      (catch e
        (syntax! :e11 ast)))
    (try
      (conj! ret (includeFile fname))
      (finally
        (.popNSP (rt/globalEnv)))))
  (if (empty? ret) (tnode) ret))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-require "" [ast env]
  (var~ as path v e refers renames)
  (var ret (node' (tnode) ast))
  (for [i 1 sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i ast)
          as $(gensym "R____")
          refers nil renames nil)
    (if (or (not (array? e))
            (< (n# e) 3)) (syntax! :e0 ast))
    (set! path (1st e))
    (for [j 1 sz (n# e)
          :while (< j sz) :recur (+1 j)]
      (set! v (.@j e))
      (cond (== v "as")
            (do (set! as $(.@+j e))
                (++ j))
            (== v "refer")
            (do (set! refers (.@+j e))
                (++ j))
            (== v "rename")
            (do (set! renames (.@+j e))
                (++ j))))
    (ret.add ["const " (rdr/jsid as)
              "= require("
              (txAtom path) ");\n"])
    (for [i 0 sz (n# refers)
          :while (and refers
                      (< i sz)) :recur (+1 i)]
      (set! v (txAtom (.@i refers)))
      (ret.add ["const " v "=" as "[\"" v "\"];\n"]))
    (for [i 0 sz (n# renames)
          :while (and renames
                      (< i sz)) :recur (+2 i)]
      (set! e (txAtom (.@i renames))
            v (txAtom (.@+i renames)))
      (ret.add ["const " v
                "=" as "[\"" e "\"];\n"])))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- evalMeta "" [ast env]
  (cond
    (array? ast)
    (JSON/parse $(tx* ast env))
    (keyword? ast)
    (->> (tx* [ast #t] env)
         (str )
         (JSON/parse ))
    (symbol? ast)
    (->> (tx* [(symbol "tag") ast] env)
         (str )
         (JSON/parse ))
    :else
    (raise! "Bad meta value" (prn ast))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-ns
  "" ^{:opcode ["ns"]} [ast env]
  (var ret [] e nil
       hints {} nsp (2nd ast))
  (when (and (array? nsp)
             (= 3 (n# nsp))
             (== "with-meta" (1st nsp))
             (symbol? (2nd nsp)))
    (set! hints (evalMeta (.@2 nsp) env)
          nsp (2nd nsp)))
  (.pushNSP (rt/globalEnv) $(nsp))
  (set! ast (ast.slice 2))
  (for [i 0 sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i ast))
    (cond (and (pairs? e)
               (== "include" (1st e)))
          (conj! ret (sf-include e))
          (and (pairs? e)
               (== "require" (1st e)))
          (conj! ret (sf-require e))))
  ;;force a internal reference to stdlib for user files
  (set! nsp (.peekNSP (rt/globalEnv)))
  (cond
    (or (= nsp "czlab.kirby.bl.macros")
        (= nsp "czlab.kirby.bl.stdlib"))
    nil
    (nsp.startsWith "czlab.kirby.")
    (conj! ret (tnodeEx "const kirbystdlibref=std;\n"))
    :else
    (->> '(require ["kirby" :as kirbystdlibref])
         (sf-require )
         (conj! ret )))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- maybeStripStdlib "" [cmd]
  (var lib "kirbystdlibref."
       nsp (.peekNSP (rt/globalEnv)))
  (set! cmd $(cmd))
  (if (and (cmd.startsWith lib)
           (= nsp "czlab.kirby.bl.stdlib"))
    (cmd.slice (n# lib))
    cmd))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-comment
  "" ^{:opcode ["comment"]}
  [ast env] (node' (tnode) ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-for
  "" ^{:opcode ["for"]} [ast env]
  (var ret (node' (tnode) ast)
       stmtQ (stmt? ast)
       body (exprHint (ast.slice 2) #f))
  (if (empty? body)
    (tnode)
    (sf-floop ret (2nd ast) body env stmtQ))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-floop "" [ret args body env stmtQ]
  (var vars [] recurs [])
  (var~ tst nb e)
  (for [i 0 sz (n# args)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i args))
    (cond (== e "while")
          (do (set! tst (.@+i args)) (++ i))
          (== e "recur")
          (do (set! recurs (args.slice (+1 i)))
              (break-out-of-loop!))
          (symbol? e)
          (do (conj! vars e (.@+i args))
              (++ i))))
  (ret.add "for (")
  (for [i 0 sz (n# vars)
        :while (< i sz) :recur (+2 i)]
    (if (= i 0) (ret.add "let "))
    (if (not= i 0) (ret.add ","))
    (ret.add [(txAtom (.@i vars))
              "=" (tx* (.@+i vars) env)]))
  (if (empty? vars)
    (ret.add "let ____break=false;")
    (ret.add ",____break=false;"))
  (set! nb '(not ____break))
  (if tst
    (set! tst [(symbol "and") nb tst])
    (set! tst nb))
  (ret.add (tx* tst env))
  (ret.add "; ")
  (for [i 0 k 0 sz (n# recurs)
        :while (< i sz) :recur (+1 i)(+2 k)]
    (if (not= i 0) (ret.add ","))
    (ret.add [(txAtom (.@k vars))
              "=" (tx* (.@i recurs) env)]))
  (ret.add "){\n")
  (ret.add (txDo body env #f))
  (ret.add "}\n")
  (when-not stmtQ
    (ret.prepend "(function() {\n")
    (ret.add "}).call(this)"))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-jscode
  "" ^{:opcode ["js#"]} [ast env]
  (node' (tnodeEx (-> $(2nd ast)
                      (.replace rdr/REGEX.dquoteHat "")
                      (.replace rdr/REGEX.dquoteEnd ""))) ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-macro
  "" ^{:opcode ["defmacro"]} [ast env]

  (var pms []
       args (.@2 ast)
       body (ast.slice 3))
  (var~ x e ev)
  (when (string? args)
    (set! doc args
          args (.@3 ast)
          body (ast.slice 4)))
  (for [i 0 sz (n# args)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i args) ev $(e))
    (cond (= ev "&")
          (if (array? (.@+i args))
            (do (set! e (.@+i args))
                (++ i)
                (for [j 0 sz (n# e)
                      :while (< j sz) :recur (+1 j)]
                  (set! x (.@j e))
                  (if-not (symbol? x)
                    (raise! "Bad optional arg for macro"))
                  (conj! pms x)))
            (do (conj! pms e (.@+i args))
                (++ i)))
          (not (symbol? e))
          (raise! "Bad optional arg for macro")
          :else
          (conj! pms e)))
  (set! ast
        [(1st ast)
         (2nd ast)
         (concat [(symbol "fn*") pms] body)])
  (var a1 $(2nd ast)
       a2 (.@2 ast)
       func (rt/compute a2 env))
  (set-in! func :____macro #t)
  (if doc
    (set-in! func :____doc doc))
  (rt/setMacro a1 func)
  (node' (tnode) ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-unary
  "" ^{:opcode ["not" "~" "!"]} [ast env]

  (var ret (node' (tnode) ast)
       [a0 a1] ast)
  (if (== a0 "not") (set! a0 (symbol "!")))
  (ret.add ["(" (tx* a0 env) (tx* a1 env) ")"])
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- spitExterns "" []
  (var s "" ks (keys EXTERNS))
  (when (not-empty ks)
    (set! s (join ",\n"
                  (map #(str % ": " %) ks))
          s (str "\n\nmodule.exports = {\n" s "\n};\n\n")))
  s)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- banner "" []
  (str "/*"
       "Auto generated by Kirby - v"
       MODULE-VERSION " "
       (.firstNSP (rt/globalEnv)) " - " (new Date) "*/\n\n"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- cleanCode "" [code]
  (var tmp nil arr [])
  (doseq [s (code.split "\n")]
    (set! tmp (s.trim))
    (if (and (not-empty tmp)
             (not= tmp ";")) (conj! arr s)))
  (join "\n" arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileCode "" [codeStr fname options]
  (.resetNSPCache (rt/globalEnv))
  (set! EXTERNS {})
  (var outNode (txTree (psr/parser codeStr fname)
                       (rt/globalEnv))
       {:keys [source-map format]} options
       cstr ""
       fopts {}
       extra (spitExterns))
  (true! format)
  (set! cstr
        (if source-map
          (let [outFile (str (path/basename fname ".ky") ".js")
                srcMap (str outFile ".map")
                output (outNode.toStringWithSourceMap {:file outFile})]
            (fs/writeFileSync srcMap output.map)
            (str output.code
                 extra
                 "\n//# sourceMappingURL="
                 (path/relative (path/dirname fname) srcMap)))
          (str outNode extra)))
  (if format
    (set! cstr (esfmt/format cstr fopts)))
  (set! cstr (cleanCode cstr))
  ;;(if format (set! cstr (esfmt/format cstr fopts)))
  (if (empty? cstr) "" (str (banner) cstr)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileXXX "" [code file options]
  (try
    (transpileCode code file options)
    (catch e
      (when e
        (println (.-stack e)) (throw e)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn transpileWithSrcMap
  "" [code file & [options]]
  (transpileXXX code
                file
                (opt?? options {})))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn transpile
  "" [code file & [options]]
  (transpileXXX code
                file
                (opt?? options {})))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn parseWithSourceMap "" [codeStr fname]
  (var outNode (txTree (psr/parser codeStr fname)))
  (outNode.prepend (banner))
  (outNode.toStringWithSourceMap ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(def version MODULE-VERSION)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

