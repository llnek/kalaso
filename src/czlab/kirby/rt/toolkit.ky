;; Copyright (c) 2013-2017, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author "Kenneth Leung"}

  czlab.kalaso.toolkit

  (require ["../bl/types" :as types]
           ["../bl/stdlib" :as std]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- pr-str-A "" [arr]
  (map (fn [e] (types.pr-obj e)) arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- pr-str "" [&xs] (-> (pr-str-A xs)(.join " ")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- str-A "" [arr]
  (map (fn [e] (types.pr-obj e false)) arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- str "" [&xs] (-> (str-A xs)(.join "")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- prn "" [&xs]
  (.apply std.println this (pr-str-A xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- println "" [&xs]
  (.apply std.println this (str-A xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- slurp "" [f]
  (-> (require "fs")(.readFileSync f "utf-8")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- timeMillis "" [] (-> (new Date)(.getTime )))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- assoc "" [src &xs]
  (.apply types.assoc
          this
          (std.concat [ (types.clone src) ] xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- dissoc "" [src &xs]
  (.apply types.dissoc
          this
          (std.concat [ (types.clone src) ] xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- cons "" [a b] (std.concat [a] b))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- conj "" [arr &xs]
  (cond
    (types.list? arr)
    (-> (.reverse xs)(.concat arr))
    (std.some? arr)
    (do-with [v (std.concat arr xs)]
      (set! v :__isvector__ true))
    :else arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- seq "" [obj]
  (cond
    (types.list? obj)
    (if (std.not-empty obj) obj)
    (types.vector? obj)
    (if (std.not-empty obj) (std.slice obj))
    (string? obj)
    (if (std.not-empty obj) (.split obj ""))
    (nil? obj)
    nil
    :else
    (std.raise! "seq: called on non-sequence")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- apply "" [f & xs]
  (var end (last-index xs))
  (.apply f
          this
          (std.concat (std.slice xs 0 end) (nth xs end))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- GLOBAL (if (undef? window) undefined  window))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- resolveJS "" [s]
  [(if (std.contains? s ".")
     (let [re (regex "^(.*)\\.[^\\.]*$" "g")
           mc (.exec re s)]
       (eval (nth mc 1)))
     GLOBAL)
   (eval s)])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- filterJS "" [obj]
  (var cache []
       s (if obj
           (JSON.stringify obj
                           (fn [k v]
                             (if (object? v)
                               (if-not (std.contains? cache v)
                                 (.push cache v)
                                 (set! v undefined)))
                             v))))
  (if (std.not-empty s) (JSON.parse s)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- withMeta "" [obj m]
  (do-with [ret (types.clone obj)] (set! ret :__meta__ m)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- meta "" [obj]
  (if (and (not (types.sequential? obj))
           (not (types.hashmap? obj))
           (not (types.object? obj))
           (not (fn? obj)))
    (std.raise! "attempt to get metadata from: "
                (types.obj-type obj)))
  (get obj :__meta__))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- deref "" [a] (.-value a))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- reset! "" [a v] (set! a :value v))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- swap! "" [a f &xs]
  (var args (std.concat [ (.-value a) ] xs))
  (set! a :value (.apply f this args))
  (get a :value))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- evalJS "" [s]
  (filterJS (eval (.toString s))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- invokeJS "" [method & xs]
  (var r (resolveJS method)
       obj (first r)
       f (second r)
       res (.apply f obj xs))
  (filterJS res))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- gensym-counter (types.atom 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- gensym "" []
  (types.symbol (str "G__"
                     (swap! gensym-counter
                            (fn [x] (+ x 1))))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! module.exports {

  "is-same?"  (fn [a b] (== a b))

  "obj-type*"  types.obj-type

  "gensym*"  gensym

  "is-eq?"  types.eq?

  "is-nil?"  (fn [x] (nil? x))

  "is-some?"  (fn [x] (and (isdef? x) (not= x nil)))

  "slice*"  (fn [&xs] (.apply std.slice this xs))

  "throw*"  (fn [&xs] (.apply std.raise! this xs))

  "#f?"  (fn [x] (false? x))
  "#t?"  (fn [x] (true? x))
  "is-str?"  (fn [x] (string? x))

  "symbol*"  types.symbol
  "is-symbol?"  types.symbol?
  "keyword*"  types.keyword
  "is-keyword?"  types.keyword?

  "pr-str*"  pr-str
  "str*"  str
  "prn*"  prn
  "println*"  println
  "slurp*"  slurp

  "<"   (fn [a b] (< a b))
  "<="  (fn [a b] (<= a b))
  ">"   (fn [a b] (> a b))
  ">="  (fn [a b] (>= a b))
  "+"   (fn [a b] (+ a b))
  "-"   (fn [a b] (- a b))
  "*"   (fn [a b] (* a b))
  "/"   (fn [a b] (/ a b))

  "time*"  timeMillis

  "list*"  types.list
  "is-list?"  types.list?

  "vector*"  types.vector
  "is-vector?"  types.vector?

  "hash-map*"  types.hashmap
  "is-map?"  types.hashmap?

  "assoc*"  assoc
  "dissoc*"  dissoc

  "is-contains?"  (fn [c x]
                      (cond
                        (or (array? c)
                            (string? c)) (.includes c x)
                        (object? c) (.hasOwnProperty c x)
                        :else false))

  "get*"  (fn [m k] (get m k))
  "keys*"  (fn [x] (Object.keys x))
  "values*"  (fn [x] (Object.values x))

  "dec*"  (fn [x] (- x 1))
  "inc*"  (fn [x] (+ x 1))

  "not*"  (fn [x] (if x false true))

  "is-even?"  (fn [n] (= 0 (mod n 2)))
  "is-odd?"  (fn [n]  (= 1 (mod n 2)))

  "is-sequential?"  types.sequential?
  "cons*"  cons

  "concat*"  (fn [arr]
                (set! arr (or arr []))
                (arr.concat.apply arr
                        (std.slice arguments 1)))

  "nth*"  (fn [arr i] (get arr i))
  "first*"  (fn [arr] (get arr 0))
  "rest*"  (fn [arr] (if arr (.slice arr 1) []))

  "is-empty?"  (fn [arr] (or (nil? arr) (= 0 (alen arr))))

  "not-empty*" (fn [arr] (if (or (nil? arr)
                                 (= 0 (alen arr))) nil arr))

  "count*"  (fn [s]
               (cond
                 (or (array? s)
                     (string? s)) (alen s)
                 (nil? s) 0
                 (object? s) (Object.keys s)
                 :else 0))

  "apply*"  apply
  "map*"  map

  "type*"  (fn [x] (typeof x))
  "evens*"  (fn [arr]
               (do-with [ret []]
                 (set! arr (or arr []))
                 (forlet ((i 0) (< i (alen arr)) (i (+ i 2)))
                   (.push ret (nth arr i)))))
  "odds*"  (fn [arr]
               (do-with [ret []]
                 (set! arr (or arr []))
                 (forlet ((i 1) (< i (alen arr)) (i (+ i 2)))
                   (.push ret (nth arr i)))))

  "conj*"  conj
  "seq*"  seq

  "with-meta*"  withMeta
  "meta*"  meta
  "atom*"  types.atom
  "is-atom?"  types.atom?
  "deref*"  deref
  "reset*"  reset
  "swap*"  swap

  "js-eval*"  evalJS
  "js*"  invokeJS

})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

