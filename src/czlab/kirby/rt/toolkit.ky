;; Copyright (c) 2013-2017, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author "Kenneth Leung"}

  czlab.kirby.rt.toolkit

  (require ["fs" :as fs])
  (require ["../bl/stdlib"
            :as std
            :refer [stringify
                    contains?
                    LambdaArg
                    Keyword
                    not-empty
                    object?
                    Symbol
                    Atom
                    symbol
                    swap!
                    atom
                    vector
                    vector?
                    list?
                    map?
                    some?
                    typeid
                    sequential?]]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro prstrX "" [b arr] `(map #(std/prn % ~b) ~arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro prstrT "" [arr] `(prstrX true ~arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro prstrF "" [arr] `(prstrX false ~arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn Function.prototype.clone "" []
  (var that this tmp nil)
  (set! tmp #(apply that this arguments))
  (each-key (fn [v k] (set-in! tmp k v)) that)
  tmp)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- prnStr "" [&xs] (join " " (prstrT xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- prnLn "" [&xs] (each #(println %) (prstrT xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- slurp "" [f] (fs/readFileSync f "utf-8"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- timeMillis "" [] (.getTime (new Date)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- object "" [&xs]
  (if (empty? xs)
    {}
    (apply assoc this (concat [ {} ] xs))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- assoc "" [src & xs]
  (if (odd? (alen xs))
    (raise! "Odd number of assoc arguments"))
  (var ret (clone src))
  (var~ k v)
  (for [i 0 :while (< i (alen xs)) :recur (+2 i)]
    (set! k (str "" (nth xs i))
          v (nexth xs i))
    (if-not (string? k)
      (raise! "expected string, got: " (type k)))
    (set-in! ret k v))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- dissoc "" [src & xs]
  (var ret (clone src))
  (for [i 0 :while (< i (alen xs)) :recur (+1 i)]
    (delete! ret (nth xs i)))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- clone "" [obj]
  (var ret nil)
  (case (typeid obj)
    :list
    (set! ret (slice obj))
    :vector
    (do (set! ret (slice obj))
        (set-in! ret :____vec true))
    :map
    (do (set! ret (slice obj))
        (set-in! ret :____map true))
    :object
    (set! ret
          (reduce
            (fn [acc n]
              (set-in! acc n (get obj n)) acc)
            {}
            (keys obj)))
    :function
    (set! ret (obj.clone))
    ;else
    (raise! "clone of non-collection: " (typeid obj)))
  (Object.defineProperty ret
                         :____meta
                         {:enumerable false :writable true})
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- cons "" [a b] (concat [a] b))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- conj "" [arr & xs]
  (cond
    (list? arr)
    (concat (xs.reverse) arr)
    (some? arr)
    (do-with [v (concat arr xs)]
      (set-in! v :____vec true))
    :else arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- seq "" [obj]
  (cond
    (list? obj)
    (if (not-empty obj) obj)
    (vector? obj)
    (if (not-empty obj) (slice obj))
    (string? obj)
    (if (not-empty obj) (obj.split ""))
    (nil? obj)
    nil
    :else
    (raise! "seq: called on non-sequence")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fapply "" [f & xs] (f.apply this xs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fmap "" [f arr] (map f arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- GLOBAL (if (undef? window) undefined  window))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- resolveJS "" [s]
  (vector (if (contains? s ".")
            (-> (.exec /^(.*)\.[^\.]*$/g s) (nth 1) (eval))
            GLOBAL)
          (eval s)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- filterJS "" [obj]
  (var s (stringify obj))
  (if (not-empty s) (JSON/parse s)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- withMeta "" [obj m]
  (var ret (clone obj))
  (set-in! ret :____meta m)
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- jsObject? "" [m]
  (and (object? m)
       (not (inst? LambdaArg m))
       (not (inst? Atom m))
       (not (inst? Symbol m))
       (not (inst? Keyword m))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- meta "" [obj]
  (if (and (not (sequential? obj))
           (not (map? obj))
           (not (jsObject? obj))
           (not (fn? obj)))
    (raise! "can't get metadata from: " (typeid obj)))
  (get obj :____meta))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- evalJS "" [s]
  (filterJS (eval (s.toString))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- invokeJS "" [method & xs]
  (var [obj f] (resolveJS method)
       res (apply f obj xs))
  (filterJS res))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- gensym-counter (atom 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- gensym "" [& [pfx]]
  (symbol (str (or pfx "G____")
               (swap! gensym-counter
                      (fn [x] (+1 x))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! module.exports {

  "is-same?"  (fn [a b] (== a b))

  "obj-type*"  std/typeid

  "gensym*"  gensym

  "is-eq?"  std/eq?

  "is-nil?"  (fn [x] (nil? x))

  "is-some?"  std/some?

  "slice*"  (fn [arr &xs]
              (Array.prototype.slice.apply arr xs))

  "throw*"  (fn [&xs]
              (throw (new Error (.join xs ""))))

  "#f?"  (fn [x] (false? x))
  "#t?"  (fn [x] (true? x))
  "is-str?"  (fn [x] (string? x))

  "symbol*"  std/symbol
  "is-symbol?"  std/symbol?
  "keyword*"  std/keyword
  "is-keyword?"  std/keyword?

  "println*"  prnLn
  "prn*"  prnStr

  "slurp*"  slurp

  "<"   (fn [a b] (< a b))
  "<="  (fn [a b] (<= a b))
  ">"   (fn [a b] (> a b))
  ">="  (fn [a b] (>= a b))
  "+"   (fn [a b] (+ a b))
  "-"   (fn [a b] (- a b))
  "*"   (fn [a b] (* a b))
  "/"   (fn [a b] (div a b))

  "not=" (fn [a b] (not= a b))
  "=" (fn [a b] (= a b))

  "time*"  timeMillis

  "list*"  std/list
  "is-list?"  std/list?

  "vector*"  std/vector
  "is-vector?"  std/vector?

  "hash-map*"  std/hashmap
  "is-map?"  std/map?

  "dissoc*"  dissoc
  "assoc*"  assoc

  "is-contains?" std/contains?

  "get*"  (fn [m k] (get m k))
  "keys*"  (fn [x] (Object.keys x))
  "values*"  (fn [x] (Object.values x))

  "dec*"  (fn [x] (- x 1))
  "inc*"  (fn [x] (+ x 1))

  "not*"  (fn [x] (if x false true))

  "is-even?"  (fn [n] (= 0 (mod n 2)))
  "is-odd?"  (fn [n]  (= 1 (mod n 2)))

  "is-sequential?"  std/sequential?
  "cons*"  cons

  "concat*"  std/concat*

  "nth*"  (fn [arr i] (get arr i))
  "first*"  (fn [arr] (get arr 0))
  "rest*"  (fn [arr] (if arr (arr.slice 1) []))

  "is-empty?"  std/empty?

  "not-empty*" std/not-empty

  "count*"  std/count

  "apply*"  fapply
  "map*"  fmap

  "type*"  (fn [x] (typeof x))
  "evens*" std/evens
  "odds*"  std/odds

  "conj*"  conj
  "seq*"  seq

  "with-meta*"  withMeta
  "meta*"  meta
  "atom*"  std/atom
  "is-atom?"  std/atom?
  "deref*"  std/deref
  "reset*"  std/reset!
  "swap*"  std/swap!

  "js-eval*"  evalJS
  "js*"  invokeJS

})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

