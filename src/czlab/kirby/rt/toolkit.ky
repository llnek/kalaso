;; Copyright (c) 2013-2017, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author "Kenneth Leung"}

  czlab.kirby.rt.toolkit

  (require ["fs" :as fs])
  (require ["../bl/stdlib"
            :as std
            :refer [LambdaArg Keyword Symbol Atom]]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro prstr-X "" [b arr] `(map #(std/prn % ~b) ~arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro prstr-T "" [arr] `(prstr-X true ~arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro prstr-F "" [arr] `(prstr-X false ~arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn Function.prototype.clone "" []
  (var that this)
  (do-with [tmp #(that.apply this arguments)]
    (each-key (fn [v k] (set-in! tmp k v)) that)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- prn-str "" [&xs] (join " " (prstr-T xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- prnice "" [&xs]
  (each (fn [s] (println s)) (prstr-T xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- slurp "" [f] (fs/readFileSync f "utf-8"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- timeMillis "" [] (.getTime (new Date)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- object "" [&xs]
  (if (empty? xs)
    {}
    (assoc.apply this (concat [ {} ] xs))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- assoc "" [src & xs]
  (if (odd? (alen xs))
    (raise! "Odd number of assoc arguments"))
  (do-with [ret (clone src)]
    (for [i 0 k nil v nil
          :while (< i (alen xs)) :recur (+2 i)]
      (set! k (str "" (nth xs i)))
      (set! v (nexth xs i))
      (if-not (string? k)
        (raise! "expected string, got: " (type k)))
      (set-in! ret k v))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- dissoc "" [src & xs]
  (do-with [ret (clone src)]
    (for [i 0 :while (< i (alen xs)) :recur (+1 i)]
      (delete! ret (nth xs i)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- clone "" [obj]
  (do-with [ret nil]
    (case (std/typeid obj)
      :list
      (set! ret (slice obj))
      :vector
      (doto ret
        (set! (slice obj))
        (set-in! :____vec true))
      :hash-map
      (doto ret
        (set! (slice obj))
        (set-in! :____map true))
      :object
      (set! ret
            (reduce
              (fn [acc n]
                (set-in! acc n (get obj n)) acc)
              {}
              (keys obj)))
      :function
      (set! ret (obj.clone))
      ;else
      (raise! "clone of non-collection: "
              (std/typeid obj)))
    (Object.defineProperty ret
                           :____meta
                           {:enumerable false :writable true })))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- cons "" [a b] (concat [a] b))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- conj "" [arr & xs]
  (cond
    (std/list? arr)
    (.concat (xs.reverse) arr)
    (std/some? arr)
    (do-with [v (concat arr xs)]
      (set-in! v :____vec true))
    :else arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- seq "" [obj]
  (cond
    (std/list? obj)
    (if (std/not-empty obj) obj)
    (std/vector? obj)
    (if (std/not-empty obj) (slice obj))
    (string? obj)
    (if (std/not-empty obj) (obj.split ""))
    (nil? obj)
    nil
    :else
    (raise! "seq: called on non-sequence")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fapply "" [f & xs] (f.apply this xs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fmap "" [f arr] (map f arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- GLOBAL (if (undef? window) undefined  window))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- resolveJS "" [s]
  [(if (std/contains? s ".")
     (-> (.exec /^(.*)\.[^\.]*$/g s) (nth 1) (eval))
     GLOBAL)
   (eval s)])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- filterJS "" [obj]
  (var s (std/stringify obj))
  (if (std/not-empty s) (JSON/parse s)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- withMeta "" [obj m]
  (do-with [ret (clone obj)]
           (set-in! ret :____meta m)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- jsObject? "" [m]
  (and (std/object? m)
       (not (inst? LambdaArg m))
       (not (inst? Atom m))
       (not (inst? Symbol m))
       (not (inst? Keyword m))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- meta "" [obj]
  (if (and (not (std/sequential? obj))
           (not (std/map? obj))
           (not (jsObject? obj))
           (not (fn? obj)))
    (raise! "can't get metadata from: "
            (std/typeid obj)))
  (get obj :____meta))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- evalJS "" [s]
  (filterJS (eval (s.toString))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- invokeJS "" [method & xs]
  (var [obj f] (resolveJS method)
       res (f.apply obj xs))
  (filterJS res))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- gensym-counter (std/atom 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- gensym "" [& [pfx]]
  (std/symbol (str (or pfx "G__")
                     (std/swap! gensym-counter
                            (fn [x] (+ x 1))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! module.exports {

  "is-same?"  (fn [a b] (== a b))

  "obj-type*"  std/typeid

  "gensym*"  gensym

  "is-eq?"  std/eq?

  "is-nil?"  (fn [x] (nil? x))

  "is-some?"  std/some?

  "slice*"  (fn [arr &xs]
              (Array.prototype.slice.apply arr xs))

  "throw*"  (fn [&xs]
              (throw (new Error (.join xs ""))))

  "#f?"  (fn [x] (false? x))
  "#t?"  (fn [x] (true? x))
  "is-str?"  (fn [x] (string? x))

  "symbol*"  std/symbol
  "is-symbol?"  std/symbol?
  "keyword*"  std/keyword
  "is-keyword?"  std/keyword?

  "println*"  prnice
  "prn*"  prn-str

  "slurp*"  slurp

  "<"   (fn [a b] (< a b))
  "<="  (fn [a b] (<= a b))
  ">"   (fn [a b] (> a b))
  ">="  (fn [a b] (>= a b))
  "+"   (fn [a b] (+ a b))
  "-"   (fn [a b] (- a b))
  "*"   (fn [a b] (* a b))
  "/"   (fn [a b] (div a b))

  "not=" (fn [a b] (not= a b))
  "=" (fn [a b] (= a b))

  "time*"  timeMillis

  "list*"  std/list
  "is-list?"  std/list?

  "vector*"  std/vector
  "is-vector?"  std/vector?

  "hash-map*"  std/hashmap
  "is-map?"  std/map?

  "dissoc*"  dissoc
  "assoc*"  assoc

  "is-contains?" std/contains?

  "get*"  (fn [m k] (get m k))
  "keys*"  (fn [x] (Object.keys x))
  "values*"  (fn [x] (Object.values x))

  "dec*"  (fn [x] (- x 1))
  "inc*"  (fn [x] (+ x 1))

  "not*"  (fn [x] (if x false true))

  "is-even?"  (fn [n] (= 0 (mod n 2)))
  "is-odd?"  (fn [n]  (= 1 (mod n 2)))

  "is-sequential?"  std/sequential?
  "cons*"  cons

  "concat*"  std/concat*

  "nth*"  (fn [arr i] (get arr i))
  "first*"  (fn [arr] (get arr 0))
  "rest*"  (fn [arr] (if arr (arr.slice 1) []))

  "is-empty?"  std/empty?

  "not-empty*" std/not-empty

  "count*"  std/count

  "apply*"  fapply
  "map*"  fmap

  "type*"  (fn [x] (typeof x))
  "evens*" std/evens
  "odds*"  std/odds

  "conj*"  conj
  "seq*"  seq

  "with-meta*"  withMeta
  "meta*"  meta
  "atom*"  std/atom
  "is-atom?"  std/atom?
  "deref*"  std/deref
  "reset*"  std/reset!
  "swap*"  std/swap!

  "js-eval*"  evalJS
  "js*"  invokeJS

})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

