;; Copyright (c) 2013-2017, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author "Kenneth Leung"}

  czlab.kirby.rt.toolkit

  (require ["../bl/types" :as types]
           ["../bl/stdlib" :as std]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro prstr-X [b arr] `(map #(types/pr-obj % ~b) ~arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro prstr-T [arr] `(prstr-X true ~arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro prstr-F [arr] `(prstr-X false ~arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- prn-str "" [&xs] (join " " (prstr-T xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- prnice "" [&xs]
  (each (fn [s] (println s)) (prstr-T xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- slurp "" [f]
  (-> (require "fs")(.readFileSync f "utf-8")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- timeMillis "" [] (-> (new Date)(.getTime )))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- object "" [&xs]
  (if (std/empty? xs)
    {}
    (assoc.apply this (concat [ {} ] xs))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- assoc "" [src & xs]
  (if (not= 0 (mod (alen xs) 2))
    (raise! "Odd number of assoc arguments"))
  (do-with [ret (clone src)]
    (forlet ((i 0 k nil v nil)
             (< i (alen xs)) (i (+ i 2)))
      (set! k (str "" (nth xs i)))
      (set! v (nth xs (+ i 1)))
      (if-not (string? k)
        (raise! "expected string, got: " (type k)))
      (set! ret k v))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- dissoc "" [src & xs]
  (do-with [ret (clone src)]
    (forlet ((i 0) (< i (alen xs)) (i (inc i)))
      (delete! ret (nth xs i)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- clone "" [obj]
  (do-with [ret nil]
    (case (types/obj-type obj)
      :list
      (set! ret (slice obj))
      :vector
      (doto ret
        (set! (slice obj))
        (set! :____vec true))
      :hash-map
      (doto ret
        (set! (slice obj))
        (set! :____map true))
      :object
      (set! ret
            (reduce
              (fn [acc n]
                (set! acc n (get obj n)) acc)
              {}
              (keys obj)))
      :function
      (set! ret (obj.clone))
      ;else
      (raise! "clone of non-collection: "
              (types/obj-type obj)))
    (Object.defineProperty ret
                           :____meta
                           {:enumerable false :writable true })))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- cons "" [a b] (concat [a] b))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- conj "" [arr & xs]
  (cond
    (types/list? arr)
    (-> (xs.reverse)(.concat arr))
    (std/some? arr)
    (do-with [v (concat arr xs)]
      (set! v :____vec true))
    :else arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- seq "" [obj]
  (cond
    (types/list? obj)
    (if (std/not-empty obj) obj)
    (types/vector? obj)
    (if (std/not-empty obj) (slice obj))
    (string? obj)
    (if (std/not-empty obj) (obj.split ""))
    (nil? obj)
    nil
    :else
    (raise! "seq: called on non-sequence")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fapply "" [f & xs] (f.apply this xs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fmap "" [f arr] (map f arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- GLOBAL (if (undef? window) undefined  window))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- resolveJS "" [s]
  [(if (std/contains? s ".")
     (-> (.exec /^(.*)\.[^\.]*$/g s) (nth 1) (eval))
     GLOBAL)
   (eval s)])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- filterJS "" [obj]
  (var cache []
       s (if obj
           (JSON/stringify obj
                           (fn [k v]
                             (if (object? v)
                               (if (std/contains? cache v)
                                 (undef! v)
                                 (cache.push v)))
                             v))))
  (if (std/not-empty s) (JSON/parse s)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- withMeta "" [obj m]
  (do-with [ret (types/clone obj)]
           (set! ret :____meta m)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- meta "" [obj]
  (if (and (not (types/sequential? obj))
           (not (types/hashmap? obj))
           (not (types/jsObject? obj))
           (not (fn? obj)))
    (raise! "can't get metadata from: "
            (types/obj-type obj)))
  (get obj :____meta))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- deref "" [a] (.-value a))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- reset! "" [a v] (set! a :value v))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- swap! "" [a f &xs]
  (->> (concat [(.-value a)] xs)
       (f.apply this )
       (set! a :value )) (get a :value))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- evalJS "" [s]
  (filterJS (eval (s.toString))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- invokeJS "" [method & xs]
  (var [obj f] (resolveJS method)
       res (f.apply obj xs))
  (filterJS res))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- gensym-counter (types/atom 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- gensym "" [& [pfx]]
  (types/symbol (str (or pfx "G__")
                     (swap! gensym-counter
                            (fn [x] (+ x 1))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! module.exports {

  "is-same?"  (fn [a b] (== a b))

  "obj-type*"  types/obj-type

  "gensym*"  gensym

  "is-eq?"  types/eq?

  "is-nil?"  (fn [x] (nil? x))

  "is-some?"  std/some?

  "slice*"  (fn [arr &xs]
              (Array.prototype.slice.apply arr xs))

  "throw*"  (fn [&xs]
              (throw (new Error (.join xs ""))))

  "#f?"  (fn [x] (false? x))
  "#t?"  (fn [x] (true? x))
  "is-str?"  (fn [x] (string? x))

  "symbol*"  types/symbol
  "is-symbol?"  types/symbol?
  "keyword*"  types/keyword
  "is-keyword?"  types/keyword?

  "println*"  prnice
  "prn*"  prn-str

  "slurp*"  slurp

  "<"   (fn [a b] (< a b))
  "<="  (fn [a b] (<= a b))
  ">"   (fn [a b] (> a b))
  ">="  (fn [a b] (>= a b))
  "+"   (fn [a b] (+ a b))
  "-"   (fn [a b] (- a b))
  "*"   (fn [a b] (* a b))
  "/"   (fn [a b] (div a b))

  "time*"  timeMillis

  "list*"  types/list
  "is-list?"  types/list?

  "vector*"  types/vector
  "is-vector?"  types/vector?

  "hash-map*"  types/hashmap
  "is-map?"  types/hashmap?

  "dissoc*"  dissoc
  "assoc*"  assoc

  "is-contains?" std/contains?

  "get*"  (fn [m k] (get m k))
  "keys*"  (fn [x] (Object.keys x))
  "values*"  (fn [x] (Object.values x))

  "dec*"  (fn [x] (- x 1))
  "inc*"  (fn [x] (+ x 1))

  "not*"  (fn [x] (if x false true))

  "is-even?"  (fn [n] (= 0 (mod n 2)))
  "is-odd?"  (fn [n]  (= 1 (mod n 2)))

  "is-sequential?"  types/sequential?
  "cons*"  cons

  "concat*"  std/concat*

  "nth*"  (fn [arr i] (get arr i))
  "first*"  (fn [arr] (get arr 0))
  "rest*"  (fn [arr] (if arr (arr.slice 1) []))

  "is-empty?"  std/empty?

  "not-empty*" std/not-empty

  "count*"  std/count

  "apply*"  fapply
  "map*"  fmap

  "type*"  (fn [x] (typeof x))
  "evens*" std/evens
  "odds*"  std/odds

  "conj*"  conj
  "seq*"  seq

  "with-meta*"  withMeta
  "meta*"  meta
  "atom*"  types/atom
  "is-atom?"  types/atom?
  "deref*"  deref
  "reset*"  reset!
  "swap*"  swap!

  "js-eval*"  evalJS
  "js*"  invokeJS

})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

