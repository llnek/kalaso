;; Copyright (c) 2013-2017, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author "Kenneth Leung"}

  czlab.kirby.rt.runtime

  (require ["readline" :as readline])
  (require ["../bl/parser" :as parser]
           ["../bl/stdlib"
            :as std
            :refer [contains?
                    keyword?
                    atom
                    into!
                    vector?
                    vector
                    symbol?
                    symbol
                    count
                    pairs?
                    list?
                    map?
                    tree
                    seq
                    prn
                    not-empty
                    sequential?]]
           ["../rt/toolkit" :as rt]
           ["../bl/env" :as env :refer [LEXEnv]]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- loadedMacros? false)
(def- CACHE {})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- loadMacros "" []
  (when-not loadedMacros?
    (true! loadedMacros?)
    (require "../bl/macros.ky")) nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn setMacro "Register a new macro"
  [cmd func]
  (when (and cmd func)
    (set! cmd $(cmd))
    (when-not (contains? cmd "/")
      (var c (global_env.peekNSP))
      (if-not c (raise! "missing namespace"))
      (set! cmd (str c "/" cmd)))
    ;;(println "adding macro ==== " cmd)
    (set-in! CACHE cmd func)) nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getMacro "Get macro"
  [cmd]
  (var ret nil)
  (set! cmd $(cmd))
  (if (contains? cmd "/")
    (set! ret (get CACHE cmd))
    (let [nsp (global_env.peekNSP)]
      (if nsp
        (set! ret (get CACHE
                       (str nsp "/" cmd))))
      (if-not ret
        (set! ret
              (get CACHE
                   (str "czlab.kirby.bl.macros/" cmd))))))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn wrap-str "" [s]
  (str "\"" (-> (s.replace /\\/g "\\\\")
                (.replace /"/g "\\\"")
                (.replace /\n/g "\\n")) "\""))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn unwrap-str "" [s]
  (if (and (s.startsWith "\"")
           (s.endsWith "\""))
    (-> (s.slice 1 (last-index s))
        (.replace /\\"/g "\"")
        (.replace /\\n/g "\n")
        (.replace /\\\\/g "\\")) s))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- dbg "" [obj]
  (println "DBG-RT: " (prn obj #t)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- readAST "Returns the AST"
  [s]
  (var ret (parser/parser s))
  (if (= 1 (n# ret))
    (set! ret (1st ret)))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- isList? "Returns true
               if a non-empty list"
  [x]
  (and (sequential? x) (not-empty x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quasiquote "" [ast]
  (cond
    (not (isList? ast))
    [(symbol "quote") ast]
    (and (symbol? (1st ast))
         (== (1st ast) "unquote"))
    (2nd ast)
    (and (isList? (1st ast))
         (== (1st (1st ast))
             "splice-unquote"))
    [(symbol "concat*")
     (2nd (1st ast))
     (quasiquote (rest ast))]
    :else
    (let [a0 (1st ast)
          a1 (rest ast)]
      [(symbol "cons*")
       (quasiquote a0)
       (quasiquote a1)])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- isMacroCall? "" [ast env]
  (and (pairs? ast)
       (symbol? (1st ast))
       (getMacro $(1st ast))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn expandMacro
  "" [ast env mc] (mexpand ast env))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- mexpand "" [ast env]
  (var isM? (isMacroCall? ast env)
       mac nil
       cmd (if isM? (1st ast) ""))
  (while (isMacroCall? ast env)
    (set! cmd $(1st ast)
          mac (getMacro cmd)
          ast (mac.apply mac (rest ast))))
  ast)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- evalAst "" [ast env]
  (cond
    (keyword? ast)
    (str "\"" ast "\"")
    (string? ast)
    (unwrap-str ast)
    (symbol? ast)
    (env.get ast)
    (pairs? ast)
    (map #(compute %1 env) ast)
    (list? ast)
    (into! :list (map #(compute %1 env) ast))
    (vector? ast)
    (into! :vector (map #(compute %1 env) ast))
    (and #f (map? ast))
    (reduce
      (fn [acc en]
        (set-in! acc
                 (compute (1st en) env)
                 (compute (last en) env)) acc)
      {}
      (seq ast))
    (map? ast)
    (do-with [m {}]
      (for [i 0 sz (n# ast)
            :while (< i sz) :recur (+2 i)]
        (set-in! m
                 (compute (.@i ast) env)
                 (compute (.@+i ast) env))))
    :else ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- handleAND "" [ast env]
  (var ret true)
  (for [i 1 sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (set! ret (compute (.@i ast) env))
    (if-not ret (break-out-of-loop!)))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- handleOR "" [ast env]
  (var ret nil)
  (for [i 1 sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (set! ret (compute (.@i ast) env))
    (if ret (break-out-of-loop!)))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- handleLet "" [ast env]
  (var e (new LEXEnv env)
       a1 (.@1 ast))
  (for [i 0 sz (n# a1)
        :while (< i sz) :recur (+2 i)]
    (e.set (.@i a1)
           (compute (.@+i a1) e)))
  [(.@2 ast) e])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- handleMacro "" [ast env]
  (var rc [(1st ast)
           (2nd ast)
           (concat [(symbol "fn*")
                    (.@2 ast)] (ast.slice 3))]
       a2 (.@2 rc)
       a1 (.@1 rc)
       func (compute  a2 env))
  (set-in! func :____macro #t)
  (env.set a1 func))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- handleTry "" [ast env]
  (var a1 (.@1 ast)
       a2 (.@2 ast))
  (try
    (compute a1 env)
    (catch ex
      (if (and a2 (== "catch*"
                      (1st a2)))
        (if (inst? Error ex)
          (set! ex (.-message ex)))
        (compute (.@2 a2)
                 (new LEXEnv
                      env [(.@1 a2)] [ex]))
        (throw ex)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- handleIf "" [ast env]
  (var c (compute (.@1 ast) env)
       a2 (.@2 ast)
       a3 (.@3 ast))
  (if (or (nil? c)
          (false? c))
    (if-not (undef? a3) a3) a2))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- handleForm "" [ast env]
  (var el (evalAst ast env)
       f (1st el))
  (if (.-____ast f)
    [true (.-____ast f)
          (f.____genenv (rest el))]
    [false (apply f f (rest el)) env]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fn-wrap "" [run ast env params]
  (var f #(run ast
               (new LEXEnv
                    env params ____args)))
  (set-in! f
           :____macro false
           :____meta nil
           :____ast ast
           :____genenv #(new LEXEnv
                             env params %))
  f)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- compute* "" [ast env]
  ;;(println "eval:" (prn ast))
  (var ok? #t ret nil)
  (for []
    (set! ast
          (mexpand ast env))
    (->>
      (cond
        (not (array? ast))
        (do->true
          (set! ret (evalAst ast env)))
        (empty? ast)
        (do->true
          (set! ret ast))
        (== "and*"
            (1st ast))
        (do->true
          (set! ret (handleAND ast env)))
        (== "or*"
            (1st ast))
        (do->true
          (set! ret (handleOR ast env)))
        (== "def*"
            (1st ast))
        (do->true
          (set! ret (env.set a1
                             (compute a2 env))))
        (== "let*"
            (1st ast))
        (do->false
          (var rc (handleLet ast env))
          (set! ast (1st rc)
                env (2nd rc)))
        (== "quote"
            (1st ast))
        (do->true
          (set! ret (2nd ast)))
        (== "quasiquote"
            (1st ast))
        (do->false
          (set! ast
                (quasiquote (2nd ast))))
        (== "macro*"
            (1st ast))
        (do->true
          (set! ret (handleMacro ast env)))
        (== "macroexpand"
            (1st ast))
        (do->true
          (set! ret
                (mexpand (2nd ast) env)))
        (== "try*"
            (1st ast))
        (do->true
          (set! ret (handleTry ast env)))
        (== "do*"
            (1st ast))
        (do->false
          (evalAst (ast.slice 1 -1) env)
          (set! ast (nth ast (last-index ast))))
        (== "if*"
            (1st ast))
        (do->false
          (set! ast (handleIf ast env)))
        (== "fn*"
            (1st ast))
        (do->true
          (set! ret
                (fn-wrap compute
                         (.@2 ast)
                         env
                         (.@1 ast))))
        :else
        (let [rc (handleForm ast env)
              a1 (.@1 rc)
              a2 (.@2 rc)]
          (if (1st rc)
            (do->false
              (set! ast a1 env a2))
            (do->true
              (set! ret a1)))))
      (set! ____break )))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn compute "" [ast env]
  (if-not env (set! env global_env))
  (var ret (compute* ast env))
  (if (undef? ret) nil ret))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- show "" [exp] (prn exp))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn newEnv "" []
  (var ret (new LEXEnv))
  (each-key (fn [v k]
              (ret.set (symbol k) v)) rt)
  (ret.set (symbol "eval")
           #(compute % ret))
  (ret.set (symbol "*ARGV*") [])
  (ret.set (symbol "*host-language*")  "javascript")
  (ret.set (symbol "*gensym-counter*") (atom 0))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- prefix "kirby> ")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- run_repl
  (fn []
    (var rl (readline.createInterface
              process.stdin process.stdout))
    (rl.on
      :line
      (fn [line]
        (try
          (if line (println (rep line)))
          (catch err (println err)))
        (rl.setPrompt prefix  (alen prefix))
        (rl.prompt )))
    (rl.on
      :close
      (fn []
        (println "Bye!")
        (process.exit 0)))
    (println prefix "Kirby REPL v1.0.0")
    (rl.setPrompt prefix  (alen prefix))
    (rl.prompt )))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- rep #(show (compute (readAST %))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def-  global_env (new LEXEnv))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn runRepl "" [] (init) (run_repl))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- macro_assert "
  (macro* assert* [c msg] (if* c true (throw* msg)))")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- macro_cond "
  (macro* cond* [&xs]
    (if* (> (count* xs) 0)
      (list* 'if*
            (first* xs)
            (nth* xs 1)
            (cons* 'cond* (rest* (rest* xs))))))")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn init "" []
  (set! global_env (newEnv))
  (global_env.set
    (symbol "*host-language*") "javascript")
  ;(rep macro_cond)
  ;(rep macro_assert)
  (loadMacros))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn globalEnv "" [] global_env)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

