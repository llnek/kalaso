;; Copyright (c) 2013-2017, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author "Kenneth Leung"}

  czlab.kirby.rt.runtime

  (require ["readline" :as readline])
  (require ["../bl/parser" :as parser]
           ["../bl/stdlib"
            :as std
            :refer [contains?
                    keyword?
                    atom
                    into
                    vector?
                    vector
                    symbol?
                    symbol
                    count
                    list?
                    map?
                    tree
                    seq
                    prn
                    not-empty
                    sequential?]]
           ["../rt/toolkit" :as rt]
           ["../bl/env" :as env :refer [LEXEnv]]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- loadedMacros? false)
(def- CACHE {})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- loadMacros "" []
  (when-not loadedMacros?
    (true! loadedMacros?)
    (require "../bl/macros.ky")) nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn setMacro
"Register a new macro"
  [cmd func]
  (when (and cmd func)
    (set! cmd (str cmd))
    (when-not (contains? cmd "/")
      (var c (global_env.peekNSP))
      (if-not c (raise! "missing namespace"))
      (set! cmd (str c "/" cmd)))
    ;;(println "adding macro ==== " cmd)
    (set-in! CACHE cmd func)) nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getMacro
"Get macro"
  [cmd]
  (var ret nil)
  (set! cmd (str cmd))
  (if (contains? cmd "/")
    (set! ret (get CACHE cmd))
    (let [nsp (global_env.peekNSP)]
      (if nsp
        (set! ret (get CACHE
                       (str nsp "/" cmd))))
      (if-not ret
        (set! ret
              (get CACHE
                   (str "czlab.kirby.bl.macros/" cmd))))))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn wrap-str "" [s]
  (str "\"" (-> (s.replace /\\/g "\\\\")
                (.replace /"/g "\\\"")
                (.replace /\n/g "\\n")) "\""))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn unwrap-str "" [s]
  (if (and (s.startsWith "\"")
           (s.endsWith "\""))
    (-> (s.slice 1 (last-index s))
        (.replace /\\"/g "\"")
        (.replace /\\n/g "\n")
        (.replace /\\\\/g "\\")) s))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- dbg "" [obj]
  (println "DBG-RT: " (prn obj true)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- readAST
"Returns the AST"
  [s]
  (var ret (parser/parser s))
  (if (= 1 (count ret))
    (set! ret (first ret)))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- isList?
"Returns true if a non-empty list"
  [x]
  (and (sequential? x) (not-empty x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quasiquote "" [ast]
  (cond
    (not (isList? ast))
    [(symbol "quote") ast]
    (and (symbol? (first ast))
         (== (first ast) "unquote"))
    (second ast)
    (and (isList? (first ast))
         (== (first (first ast))
             "splice-unquote"))
    [(symbol "concat*")
     (second (first ast))
     (quasiquote (rest ast))]
    :else
    (let [a0 (first ast)
          a1 (rest ast)]
      [(symbol "cons*")
       (quasiquote a0)
       (quasiquote a1)])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- isMacroCall? "" [ast env]
  (and (pairs? ast)
       (symbol? (first ast))
       (getMacro (str (first ast)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn expandMacro
  "" [ast env mc] (mexpand ast env))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- mexpand "" [ast env]
  (var isM? (isMacroCall? ast env)
       mac nil
       cmd (if isM? (first ast) ""))
  (while (isMacroCall? ast env)
    (set! cmd (str (first ast))
          mac (getMacro cmd)
          ast (mac.apply mac (rest ast))))
  ast)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- evalAst "" [ast env]
  (cond
    (keyword? ast)
    (str "\"" ast "\"")
    (string? ast)
    (unwrap-str ast)
    (symbol? ast)
    (env.get ast)
    (pairs? ast)
    (map #(compute %1 env) ast)
    (list? ast)
    (into! :list (map #(compute %1 env) ast))
    (vector? ast)
    (into! :vector (map #(compute %1 env) ast))
    (and false (map? ast))
    (reduce
      (fn [acc en]
        (set-in! acc
                 (compute (first en) env)
                 (compute (last en) env)) acc)
      {}
      (seq ast))
    (map? ast)
    (do-with [m {}]
      (for [i 0 :while (< i (alen ast)) :recur (+2 i)]
        (set-in! m
                 (compute (nth ast i) env)
                 (compute (nexth ast i) env))))
    :else ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- handleAND "" [ast env]
  (var ret true)
  (for [i 1
        :while (< i (alen ast)) :recur (+1 i)]
    (set! ret (compute (nth ast i) env))
    (if-not ret (break-out-of-loop!)))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- handleOR "" [ast env]
  (var ret nil)
  (for [i 1
        :while (< i (alen ast)) :recur (+1 i)]
    (set! ret (compute (nth ast i) env))
    (if ret (break-out-of-loop!)))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- handleLet "" [ast env]
  (var e (new LEXEnv env)
       a1 (nth ast 1))
  (for [i 0 :while (< i (alen a1)) :recur (+2 i)]
    (e.set (nth a1 i)
           (compute (nexth a1 i) e)))
  [(nth ast 2) e])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- handleMacro "" [ast env]
  (var rc [(first ast)
           (second ast)
           (concat [(symbol "fn*")
                    (nth ast 2)] (ast.slice 3))]
       a2 (nth rc 2)
       a1 (nth rc 1)
       func (compute  a2 env))
  (set-in! func :____macro true)
  (env.set a1 func))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- handleTry "" [ast env]
  (var a1 (nth ast 1)
       a2 (nth ast 2))
  (try
    (compute a1 env)
    (catch ex
      (if (and a2 (== "catch*"
                      (first a2)))
        (if (inst? Error ex)
          (set! ex (.-message ex)))
        (compute (nth a2 2)
                 (new LEXEnv
                      env [(nth a2 1)] [ex]))
        (throw ex)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- handleIf "" [ast env]
  (var c (compute (nth ast 1) env)
       a2 (nth ast 2)
       a3 (nth ast 3))
  (if (or (nil? c)
          (false? c))
    (if-not (undef? a3) a3) a2))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- handleForm "" [ast env]
  (var el (evalAst ast env)
       f (first el))
  (if (.-____ast f)
    [true (.-____ast f)
          (f.____genenv (rest el))]
    [false (f.apply this (rest el)) env]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fn-wrap "" [run ast env params]
  (var f #(run ast
               (new LEXEnv
                    env params ____args)))
  (set-in! f
           :____macro false
           :____meta nil
           :____ast ast
           :____genenv #(new LEXEnv
                             env params %))
  f)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- compute* "" [ast env]
  ;;(println "eval:" (prn ast))
  (var ok? true ret nil)
  (for []
    (set! ast
          (mexpand ast env))
    (->>
      (cond
        (not (array? ast))
        (do->true
          (set! ret (evalAst ast env)))
        (= 0 (count ast))
        (do->true
          (set! ret ast))
        (== "and*"
            (first ast))
        (do->true
          (set! ret (handleAND ast env)))
        (== "or*"
            (first ast))
        (do->true
          (set! ret (handleOR ast env)))
        (== "def*"
            (first ast))
        (do->true
          (set! ret (env.set a1
                             (compute a2 env))))
        (== "let*"
            (first ast))
        (do->false
          (var rc (handleLet ast env))
          (set! ast (first rc)
                env (second rc)))
        (== "quote"
            (first ast))
        (do->true
          (set! ret (second ast)))
        (== "quasiquote"
            (first ast))
        (do->false
          (set! ast
                (quasiquote (second ast))))
        (== "macro*"
            (first ast))
        (do->true
          (set! ret (handleMacro ast env)))
        (== "macroexpand"
            (first ast))
        (do->true
          (set! ret
                (mexpand (second ast) env)))
        (== "try*"
            (first ast))
        (do->true
          (set! ret (handleTry ast env)))
        (== "do*"
            (first ast))
        (do->false
          (evalAst (ast.slice 1 -1) env)
          (set! ast (nth ast (last-index ast))))
        (== "if*"
            (first ast))
        (do->false
          (set! ast (handleIf ast env)))
        (== "fn*"
            (first ast))
        (do->true
          (set! ret
                (fn-wrap compute
                         (nth ast 2)
                         env
                         (nth ast 1))))
        :else
        (let [rc (handleForm ast env)
              a1 (nth rc 1)
              a2 (nth rc 2)]
          (if (first rc)
            (do->false
              (set! ast a1 env a2))
            (do->true
              (set! ret a1)))))
      (set! ____break )))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn compute "" [ast env]
  (if-not env (set! env global_env))
  (var ret (compute* ast env))
  (if (undef? ret) nil ret))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- show "" [exp] (prn exp))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn newEnv "" []
  (var ret (new LEXEnv))
  (each-key (fn [v k]
              (ret.set (symbol k) v)) rt)
  (ret.set (symbol "eval")
           #(compute % ret))
  (ret.set (symbol "*ARGV*") [])
  (ret.set (symbol "*host-language*")  "javascript")
  (ret.set (symbol "*gensym-counter*") (atom 0))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- prefix "kirby> ")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- run_repl
  (fn []
    (var rl (readline.createInterface
              process.stdin process.stdout))
    (rl.on
      :line
      (fn [line]
        (try
          (if line (println (rep line)))
          (catch err (println err)))
        (rl.setPrompt prefix  (alen prefix))
        (rl.prompt )))
    (rl.on
      :close
      (fn []
        (println "Bye!")
        (process.exit 0)))
    (println prefix "Kirby REPL v1.0.0")
    (rl.setPrompt prefix  (alen prefix))
    (rl.prompt )))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- rep #(show (compute (readAST %))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def-  global_env (new LEXEnv))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn runRepl "" [] (init) (run_repl))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- macro_assert "
  (macro* assert* [c msg] (if* c true (throw* msg)))")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- macro_cond "
  (macro* cond* [&xs]
    (if* (> (count* xs) 0)
      (list* 'if*
            (first* xs)
            (nth* xs 1)
            (cons* 'cond* (rest* (rest* xs))))))")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn init "" []
  (set! global_env (newEnv))
  (global_env.set
    (symbol "*host-language*") "javascript")
  (rep macro_cond)
  (rep macro_assert)
  (loadMacros))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn globalEnv "" [] global_env)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

