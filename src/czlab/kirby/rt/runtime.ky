;; Copyright (c) 2013-2017, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author "Kenneth Leung"}

  czlab.kirby.rt.runtime

  (require ["readline" :as readline])
  (require ["../bl/parser" :as parser]
           ["../bl/stdlib" :as std]
           ["../rt/toolkit" :as rt]
           ["../bl/env" :as env :refer [LEXEnv]]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- loadedMacros? false)
(def- CACHE {})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- loadMacros []
  (when-not loadedMacros?
    (set! loadedMacros? true)
    (require "../bl/macros.ky")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn setMacro "" [cmd func]
  (when (and cmd func)
    (set! cmd (str cmd))
    (when-not (cmd.includes "/")
      (var c (global_env.peekNSP))
      (if-not c (raise! "missing namespace"))
      (set! cmd (str c "/" cmd)))
    ;;(println "adding macro ==== " cmd)
    (set-in! CACHE cmd func)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getMacro "" [cmd]
  (do-with [ret nil]
    (set! cmd (str cmd))
    (if (cmd.includes "/")
      (set! ret (get CACHE cmd))
      (let [nsp (global_env.peekNSP)]
        (if nsp (set! ret (get CACHE
                               (str nsp "/" cmd))))
        (if-not ret
          (set! ret (get CACHE
                         (str "czlab.kirby.bl.macros/" cmd))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- wrap-str "" [s]
  (str "\"" (-> (s.replace /\\/g "\\\\")
                (.replace /"/g "\\\"")
                (.replace /\n/g "\\n")) "\""))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- unwrap-str "" [s]
  (if (and (s.startsWith "\"")
           (s.endsWith "\""))
    (-> (s.slice 1 (last-index s))
        (.replace /\\"/g "\"")
        (.replace /\\n/g "\n")
        (.replace /\\\\/g "\\")) s))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- dbg "" [obj]
  (println "DBG-RT: " (std/prn obj true)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- readAST "" [s]
  (do-with [ret (parser/parser s)]
    (if (= 1 (alen ret)) (set! ret (first ret)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- isPair? "" [x]
  (and (std/sequential? x) (std/not-empty x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quasiquote "" [ast]
  (cond
    (not (isPair? ast))
    [(std/symbol "quote") ast]
    (and (std/symbol? (first ast))
         (= (.-value (first ast)) "unquote"))
    (second ast)
    (and (isPair? (first ast))
         (= (.-value (first (first ast))) "splice-unquote"))
    [(std/symbol "concat*")
     (second (first ast))
     (quasiquote (rest ast))]
    :else
    (let [a0 (first ast)
          a1 (rest ast)]
      [(std/symbol "cons*")
       (quasiquote a0)
       (quasiquote a1)])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- isMacroCall? "" [ast env]
  (and (std/list? ast)
       (std/symbol? (first ast))
       (getMacro (str (first ast)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn expandMacro "" [ast env mc]
  (do-with [ret (macroexpand ast env)]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- macroexpand "" [ast env]
  (var isM? (isMacroCall? ast env)
       mac nil
       cmd (if isM? (first ast) ""))
  (while (isMacroCall? ast env)
    (set! cmd (str (first ast)))
    (set! mac (getMacro cmd))
    (set! ast (mac.apply mac (rest ast))))
  ast)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- evalAst "" [ast env]
  (cond
    (std/keyword? ast)
    (str "\"" ast "\"")
    (string? ast)
    (unwrap-str ast)
    (std/symbol? ast)
    (env.get ast)
    (std/list? ast)
    (map #(compute %1 env) ast)
    (std/vector? ast)
    (do-with [v (map #(compute %1 env) ast)]
      (set-in! v :____vec true))
    (and false
         (std/map? ast))
    (do-with [m {}]
      (forkeys [k ast]
        (set-in! m
                 (compute k env)
                 (compute (get ast k) env))))
    (std/map? ast)
    (do-with [m {}]
      (for [i 0 :while (< i (alen ast)) :recur (+2 i)]
        (set-in! m
                 (compute (nth ast i) env)
                 (compute (nexth ast i) env))))
    :else ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- handleAND "" [ast env]
  (let [ret true
        skip? false]
    (for [i 1 :while
              (and (not skip?)
                   (< i (alen ast))) :recur (+1 i)]
      (set! ret (compute (nth ast i) env))
      (if-not ret (set! skip? true)))
    ret))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- handleOR "" [ast env]
  (let [ret nil skip? false]
    (for [i 1 :while
              (and (not skip?)
                   (< i (alen ast))) :recur (+1 i)]
      (set! ret (compute (nth ast i) env))
      (if ret (set! skip? true)))
    ret))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- handleLet "" [ast env]
  (var e (new LEXEnv env)
       a1 (nth ast 1))
  (for [i 0 :while (< i (alen a1)) :recur (+2 i)]
    (e.set (nth a1 i)
           (compute (nexth a1 i) e)))
  [true (nth ast 2) e])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- handleMacro "" [ast env]
  (var rc [(nth ast 0) (nth ast 1)
           (concat [(std/symbol "fn*") (nth ast 2)]
                   (ast.slice 3))]
       a2 (nth rc 2)
       a1 (nth rc 1)
       func (compute  a2 env))
  (set-in! func :____macro true)
  (env.set a1 func))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- handleTry "" [ast env]
  (var a1 (nth ast 1)
       a2 (nth ast 2))
  (try
    (compute a1 env)
    (catch ex
      (if (and a2 (= "catch*"
                     (str  (first a2))))
        (if (inst? Error ex)
          (set! ex (.-message ex)))
        (compute (nth a2 2)
                 (new LEXEnv env [(nth a2 1)] [ex]))
        (throw ex)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- handleIf "" [ast env]
  (var c (compute (nth ast 1) env)
       a2 (nth ast 2)
       a3 (nth ast 3))
  (if (or (= c nil)
          (false? c))
    (if-not (undef? a3) a3) a2))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- handleForm "" [ast env]
  (var el (evalAst ast env)
       f (nth el 0))
  (if (.-____ast f)
    [true (.-____ast f) (f.____genenv (rest el))]
    [false (f.apply this (rest el)) env]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fn-wrap "" [run ast env params]
  (do-with [f #(run ast (new LEXEnv env params arguments))]
    (set-in! f
             :____macro false
             :____meta nil
             :____ast ast
             :____genenv #(new LEXEnv env params %))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- computeLoop "" [ast env]
  ;;(println "EVAL:" (std/prn ast))
  (var ok? true ret nil)
  (while ok?
    (set! ast (macroexpand ast env))
    (set! ok?
          (cond
            (not (std/list? ast))
            (do->false (set! ret (evalAst ast env)))
            (= 0 (alen ast))
            (do->false (set! ret ast))
            (= "and*"
               (str (nth ast 0)))
            (do->false (set! ret (handleAND ast env)))
            (= "or*"
               (str (nth ast 0)))
            (do->false (set! ret (handleOR ast env)))
            (= "def*"
               (str (nth ast 0)))
            (do->false
              (set! ret (env.set a1 (compute a2 env))))
            (= "let*"
               (str (nth ast 0)))
            (let [rc (handleLet ast env)]
              (set! ast (nth rc 1))
              (set! env (nth rc 2))
              (nth rc 0))
            (= "quote"
               (str (nth ast 0)))
            (do->false (set! ret (nth ast 1)))
            (= "quasiquote"
               (str (nth ast 0)))
            (do->true (set! ast (quasiquote (nth ast 1))))
            (= "defmacro"
               (str (nth ast 0)))
            (do->false (set! ret (handleMacro ast env)))
            (= "macroexpand"
               (str (nth ast 0)))
            (do->false
              (set! ret (macroexpand (nth ast 1) env)))
            (= "try*"
               (str (nth ast 0)))
            (do->false (set! ret (handleTry ast env)))
            (= "do*"
               (str (nth ast 0)))
            (do->true
              (evalAst (ast.slice 1 -1) env)
              (set! ast (nth ast (last-index ast))))
            (= "if*"
               (str (nth ast 0)))
            (do->true (set! ast (handleIf ast env)))
            (= "fn*"
               (str (nth ast 0)))
            (do->false (set! ret
                             (fn-wrap compute
                                      (nth ast 2)
                                      env
                                      (nth ast 1))))
            :else
            (let [rc (handleForm ast env)]
              (if (first rc)
                (do (set! ast (nth rc 1))
                    (set! env (nth rc 2)))
                (do (set! ret (nth rc 1))))
              (nth rc 0)))))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn compute "" [ast env]
  (if-not env (set! env global_env))
  (var ret (computeLoop ast env))
  (if (undef? ret) nil ret))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- show "" [exp] (std/prn exp))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn newEnv "" []
  (do-with [ret (new LEXEnv)]
    (each-key (fn [v k]
                (ret.set (std/symbol k) v)) rt)
    (ret.set (std/symbol "eval")
             (fn [ast] (compute ast ret)))
    (ret.set (std/symbol "*ARGV*") [])
    (ret.set (std/symbol "*host-language*")  "javascript")
    (ret.set (std/symbol "*gensym-counter*") (std/atom 0))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- prefix "kirby> ")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- run_repl (fn []
  (var rl (readline.createInterface process.stdin
                                    process.stdout))
  (rl.on :line
         (fn [line]
           (try
             (if line (println (rep line)))
             (catch err (println err)))
           (rl.setPrompt prefix  (alen prefix))
           (rl.prompt )))
  (rl.on :close
         (fn []
           (println "Bye!")
           (process.exit 0)))
  (println prefix "Kirby REPL v1.0.0")
  (rl.setPrompt prefix  (alen prefix))
  (rl.prompt )))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def-  rep #(show (compute (readAST %))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def-  global_env (new LEXEnv))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn runRepl "" [] (init) (run_repl))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- macro_assert "
  (defmacro assert* [c msg] (if* c true (throw* msg)))")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- macro_cond "
  (defmacro cond* [&xs]
    (if* (> (count* xs) 0)
      (list* 'if*
            (first* xs)
            (nth* xs 1)
            (cons* 'cond* (rest* (rest* xs))))))")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn init "" []
  (set! global_env (newEnv))
  (global_env.set (std/symbol "*host-language*") "javascript")
  (rep macro_cond)
  (rep macro_assert)
  (loadMacros))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn globalEnv "" [] global_env)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

