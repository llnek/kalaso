;; Copyright (c) 2013-2017, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author "Kenneth Leung"}

  czlab.kirby.rt.runtime

  (require ["readline" :as readline])
  (require ["../bl/parser" :as parser]
           ["../bl/stdlib"
            :as std
            :refer [contains?
                    keyword?
                    atom
                    into
                    vector?
                    vector
                    symbol?
                    symbol
                    count
                    list?
                    map?
                    tree
                    seq
                    prn
                    not-empty
                    sequential?]]
           ["../rt/toolkit" :as rt]
           ["../bl/env" :as env :refer [LEXEnv]]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- loadedMacros? false)
(def- CACHE {})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- loadMacros []
  (when-not loadedMacros?
    (set! loadedMacros? true)
    (require "../bl/macros.ky")) nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn setMacro "" [cmd func]
  (when (and cmd func)
    (set! cmd (str cmd))
    (when-not (contains? cmd "/")
      (var c (global_env.peekNSP))
      (if-not c (raise! "missing namespace"))
      (set! cmd (str c "/" cmd)))
    ;;(println "adding macro ==== " cmd)
    (set-in! CACHE cmd func)) nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getMacro "" [cmd]
  (var ret nil)
  (set! cmd (str cmd))
  (if (contains? cmd "/")
    (set! ret (get CACHE cmd))
    (let [nsp (global_env.peekNSP)]
      (if nsp
        (set! ret (get CACHE
                       (str nsp "/" cmd))))
      (if-not ret
        (set! ret
              (get CACHE
                   (str "czlab.kirby.bl.macros/" cmd))))))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- wrap-str "" [s]
  (str "\"" (-> (s.replace /\\/g "\\\\")
                (.replace /"/g "\\\"")
                (.replace /\n/g "\\n")) "\""))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- unwrap-str "" [s]
  (if (and (s.startsWith "\"")
           (s.endsWith "\""))
    (-> (s.slice 1 (last-index s))
        (.replace /\\"/g "\"")
        (.replace /\\n/g "\n")
        (.replace /\\\\/g "\\")) s))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- dbg "" [obj]
  (println "DBG-RT: " (prn obj true)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- readAST "" [s]
  (var ret (parser/parser s))
  (if (= 1 (count ret))
    (set! ret (first ret)))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- isPair? "" [x]
  (and (sequential? x) (not-empty x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quasiquote "" [ast]
  (cond
    (not (isPair? ast))
    (tree (symbol "quote") ast)
    (and (symbol? (first ast))
         (= (.-value (first ast)) "unquote"))
    (second ast)
    (and (isPair? (first ast))
         (= (.-value (first (first ast))) "splice-unquote"))
    (tree (symbol "concat*")
          (second (first ast))
          (quasiquote (rest ast)))
    :else
    (let [a0 (first ast)
          a1 (rest ast)]
      (tree (symbol "cons*")
       (quasiquote a0)
       (quasiquote a1)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- isMacroCall? "" [ast env]
  (and (pairs? ast)
       (symbol? (first ast))
       (getMacro (str (first ast)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn expandMacro "" [ast env mc] (macroexpand ast env))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- macroexpand "" [ast env]
  (var isM? (isMacroCall? ast env)
       mac nil
       cmd (if isM? (first ast) ""))
  (while (isMacroCall? ast env)
    (set! cmd (str (first ast))
          mac (getMacro cmd)
          ast (mac.apply mac (rest ast))))
  ast)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- evalAst "" [ast env]
  (cond
    (keyword? ast)
    (str "\"" ast "\"")
    (string? ast)
    (unwrap-str ast)
    (symbol? ast)
    (env.get ast)
    (pairs? ast)
    (map #(compute %1 env) ast)
    (list? ast)
    (into :list (map #(compute %1 env) ast))
    (vector? ast)
    (into :vector (map #(compute %1 env) ast))
    (and false (map? ast))
    (reduce
      (fn [acc en]
        (set-in! acc
                 (compute (first en) env)
                 (compute (last en) env)) acc)
      {}
      (seq ast))
    (map? ast)
    (do-with [m {}]
      (for [i 0 :while (< i (alen ast)) :recur (+2 i)]
        (set-in! m
                 (compute (nth ast i) env)
                 (compute (nexth ast i) env))))
    :else ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- handleAND "" [ast env]
  (var ret true)
  (for [i 1
        :while (< i (alen ast)) :recur (+1 i)]
    (set! ret (compute (nth ast i) env))
    (if-not ret (break-out-of-loop!)))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- handleOR "" [ast env]
  (var ret nil)
  (for [i 1
        :while (< i (alen ast)) :recur (+1 i)]
    (set! ret (compute (nth ast i) env))
    (if ret (break-out-of-loop!)))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- handleLet "" [ast env]
  (var e (new LEXEnv env)
       a1 (nth ast 1))
  (for [i 0 :while (< i (alen a1)) :recur (+2 i)]
    (e.set (nth a1 i)
           (compute (nexth a1 i) e)))
  (vector true (nth ast 2) e))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- handleMacro "" [ast env]
  (var rc (tree (nth ast 0)
                (nth ast 1)
                (concat [(symbol "fn*") (nth ast 2)]
                        (ast.slice 3)))
       a2 (nth rc 2)
       a1 (nth rc 1)
       func (compute  a2 env))
  (set-in! func :____macro true)
  (env.set a1 func))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- handleTry "" [ast env]
  (var a1 (nth ast 1)
       a2 (nth ast 2))
  (try
    (compute a1 env)
    (catch ex
      (if (and a2 (= "catch*"
                     (str  (first a2))))
        (if (inst? Error ex)
          (set! ex (.-message ex)))
        (compute (nth a2 2)
                 (new LEXEnv env [(nth a2 1)] [ex]))
        (throw ex)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- handleIf "" [ast env]
  (var c (compute (nth ast 1) env)
       a2 (nth ast 2)
       a3 (nth ast 3))
  (if (or (nil? c)
          (false? c))
    (if-not (undef? a3) a3) a2))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- handleForm "" [ast env]
  (var el (evalAst ast env)
       f (first el))
  (if (.-____ast f)
    (vector true (.-____ast f) (f.____genenv (rest el)))
    (vector false (f.apply this (rest el)) env)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fn-wrap "" [run ast env params]
  (var f #(run ast (new LEXEnv env params ____args)))
  (set-in! f
           :____macro false
           :____meta nil
           :____ast ast
           :____genenv #(new LEXEnv env params %))
  f)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- computeLoop "" [ast env]
  ;;(println "EVAL:" (prn ast))
  (var ok? true ret nil)
  (while ok?
    (set! ast (macroexpand ast env))
    (set! ok?
          (cond
            (not (array? ast))
            (do->false (set! ret (evalAst ast env)))
            (= 0 (count ast))
            (do->false (set! ret ast))
            (= "and*"
               (str (first ast)))
            (do->false (set! ret (handleAND ast env)))
            (= "or*"
               (str (first ast)))
            (do->false (set! ret (handleOR ast env)))
            (= "def*"
               (str (first ast)))
            (do->false
              (set! ret (env.set a1 (compute a2 env))))
            (= "let*"
               (str (first ast 0)))
            (let [rc (handleLet ast env)]
              (set! ast (nth rc 1))
              (set! env (nth rc 2))
              (first rc))
            (= "quote"
               (str (first ast)))
            (do->false (set! ret (second ast)))
            (= "quasiquote"
               (str (first ast)))
            (do->true (set! ast (quasiquote (second ast))))
            (= "macro*"
               (str (first ast)))
            (do->false (set! ret (handleMacro ast env)))
            (= "macroexpand"
               (str (first ast)))
            (do->false
              (set! ret (macroexpand (second ast) env)))
            (= "try*"
               (str (first ast)))
            (do->false (set! ret (handleTry ast env)))
            (= "do*"
               (str (first ast)))
            (do->true
              (evalAst (ast.slice 1 -1) env)
              (set! ast (nth ast (last-index ast))))
            (= "if*"
               (str (first ast)))
            (do->true (set! ast (handleIf ast env)))
            (= "fn*"
               (str (first ast)))
            (do->false (set! ret
                             (fn-wrap compute
                                      (nth ast 2)
                                      env
                                      (nth ast 1))))
            :else
            (let [rc (handleForm ast env)]
              (if (first rc)
                (do (set! ast (nth rc 1))
                    (set! env (nth rc 2)))
                (do (set! ret (nth rc 1))))
              (first rc)))))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn compute "" [ast env]
  (if-not env (set! env global_env))
  (var ret (computeLoop ast env))
  (if (undef? ret) nil ret))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- show "" [exp] (prn exp))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn newEnv "" []
  (var ret (new LEXEnv))
  (each-key (fn [v k]
              (ret.set (symbol k) v)) rt)
  (ret.set (symbol "eval")
           (fn [ast] (compute ast ret)))
  (ret.set (symbol "*ARGV*") [])
  (ret.set (symbol "*host-language*")  "javascript")
  (ret.set (symbol "*gensym-counter*") (atom 0))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- prefix "kirby> ")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- run_repl (fn []
  (var rl (readline.createInterface process.stdin
                                    process.stdout))
  (rl.on :line
         (fn [line]
           (try
             (if line (println (rep line)))
             (catch err (println err)))
           (rl.setPrompt prefix  (alen prefix))
           (rl.prompt )))
  (rl.on :close
         (fn []
           (println "Bye!")
           (process.exit 0)))
  (println prefix "Kirby REPL v1.0.0")
  (rl.setPrompt prefix  (alen prefix))
  (rl.prompt )))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def-  rep #(show (compute (readAST %))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def-  global_env (new LEXEnv))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn runRepl "" [] (init) (run_repl))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- macro_assert "
  (macro* assert* [c msg] (if* c true (throw* msg)))")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- macro_cond "
  (macro* cond* [&xs]
    (if* (> (count* xs) 0)
      (list* 'if*
            (first* xs)
            (nth* xs 1)
            (cons* 'cond* (rest* (rest* xs))))))")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn init "" []
  (set! global_env (newEnv))
  (global_env.set (symbol "*host-language*") "javascript")
  (rep macro_cond)
  (rep macro_assert)
  (loadMacros))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn globalEnv "" [] global_env)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

