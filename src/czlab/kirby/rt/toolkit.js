/*Auto generated by Kirby - v1.0.0 czlab.kirby.rt.toolkit Thu Nov 09 2017 21:18:37 GMT-0800 (PST)*/

var fs = require("fs");
var std = require("../bl/stdlib");
var stringify = std["stringify"];
var contains_QUERY = std["contains_QUERY"];
var LambdaArg = std["LambdaArg"];
var Keyword = std["Keyword"];
var not_DASH_empty = std["not_DASH_empty"];
var object_QUERY = std["object_QUERY"];
var Symbol = std["Symbol"];
var Atom = std["Atom"];
var symbol = std["symbol"];
var swap_BANG = std["swap_BANG"];
var atom = std["atom"];
var vector = std["vector"];
var vector_QUERY = std["vector_QUERY"];
var list_QUERY = std["list_QUERY"];
var map_QUERY = std["map_QUERY"];
var some_QUERY = std["some_QUERY"];
var typeid = std["typeid"];
var sequential_QUERY = std["sequential_QUERY"];
var kirbystdlibref = std;




//
Function.prototype.clone = function() {
  let that,
    tmp;
  that = this;
  tmp = null;
  tmp = function() {
    let ____args;
    ____args = Array.prototype.slice.call(arguments);
    return that.apply(this, arguments);
  };
  let G__1;
  G__1 = that;
  Object.entries(G__1).forEach(function(e) {
    return (function(v, k) {
      return tmp[k] = v;
    })(e[1], e[0]);
  });
  return tmp;
}

//
function prnStr() {
  let xs = Array.prototype.slice.call(arguments, 0);
  return xs.map(function() {
    let ____args;
    ____args = Array.prototype.slice.call(arguments);
    return std.prn(____args[0], true);
  }).join(" ");
}

//
function prnLn() {
  let xs = Array.prototype.slice.call(arguments, 0);
  return xs.map(function() {
    let ____args;
    ____args = Array.prototype.slice.call(arguments);
    return std.prn(____args[0], true);
  }).forEach(function() {
    let ____args;
    ____args = Array.prototype.slice.call(arguments);
    return (console ?
      console.log([____args[0]].join("")) :
      null);
  });
}

//
function slurp(f) {
  return fs.readFileSync(f, "utf-8");
}

//
function timeMillis() {
  return new Date().getTime();
}

//
function object() {
  let xs = Array.prototype.slice.call(arguments, 0);
  return ((0 === kirbystdlibref.count(xs)) ?
    {} :
    assoc.apply(this, [{}].concat(xs)));
}

//
function assoc(src) {
  let xs = Array.prototype.slice.call(arguments, 1);
  if ( (!(0 === (xs.length % 2))) ) {
    throw new Error("Odd number of assoc arguments");
  }
  let ret;
  ret = clone(src);
  let k,
    v;
  for (let i = 0, ____break = false; ((!____break) && (i < xs.length)); i = (i + 2)) {
    (k = ["", xs[i]].join(""), v = xs[(i + 1)]);
    if ( (!(typeof (k) === "string")) ) {
      throw new Error(["expected string, got: ", typeof (k)].join(""));
    }
    ret[k] = v;
  }
  return ret;
}

//
function dissoc(src) {
  let xs = Array.prototype.slice.call(arguments, 1);
  let ret;
  ret = clone(src);
  for (let i = 0, ____break = false; ((!____break) && (i < xs.length)); i = (i + 1)) {
    delete ret[xs[i]];
  }
  return ret;
}

//
function clone(obj) {
  let ret;
  ret = null;
  {
    let S____3;
    switch (typeid(obj)) {
      case "list":
        S____3 = ret = Array.prototype.slice.call(obj);
        break;
      case "vector":
        S____3 = (function() {
          ret = Array.prototype.slice.call(obj);
          return ret["____vec"] = true;
        }).call(this);
        break;
      case "map":
        S____3 = (function() {
          ret = Array.prototype.slice.call(obj);
          return ret["____map"] = true;
        }).call(this);
        break;
      case "object":
        S____3 = ret = Object.keys(obj).reduce(function(acc, n) {
          acc[n] = obj[n];
          return acc;
        }, {});
        break;
      case "function":
        S____3 = ret = obj.clone();
        break;
      default:
        S____3 = (function() {
          throw new Error(["clone of non-collection: ", typeid(obj)].join("")) ;
        }).call(this);
        break;
    }
  }
  Object.defineProperty(ret, "____meta", {
    "enumerable": false,
    "writable": true
  });
  return ret;
}

//
function cons(a, b) {
  return [a].concat(b);
}

//
function conj(arr) {
  let xs = Array.prototype.slice.call(arguments, 1);
  return (list_QUERY(arr) ?
    xs.reverse().concat(arr) :
    (some_QUERY(arr) ?
      (function() {
        let v;
        v = arr.concat(xs);
        v["____vec"] = true;
        return v;
      }).call(this) :
      (true ?
        arr :
        null)));
}

//
function seq(obj) {
  return (list_QUERY(obj) ?
    ((!(0 === kirbystdlibref.count(obj))) ?
      obj :
      null) :
    (vector_QUERY(obj) ?
      ((!(0 === kirbystdlibref.count(obj))) ?
        Array.prototype.slice.call(obj) :
        null) :
      ((typeof (obj) === "string") ?
        ((!(0 === kirbystdlibref.count(obj))) ?
          obj.split("") :
          null) :
        ((obj === null) ?
          null :
          (true ?
            (function() {
              throw new Error("seq: called on non-sequence") ;
            }).call(this) :
            null)))));
}

//
function fapply(f) {
  let xs = Array.prototype.slice.call(arguments, 1);
  return f.apply(this, xs);
}

//
function fmap(f, arr) {
  return arr.map(f);
}

let GLOBAL;
GLOBAL = ((typeof (window) === "undefined") ?
  undefined :
  window);

//
function resolveJS(s) {
  return vector((contains_QUERY(s, ".") ?
    eval(/^(.*)\.[^\.]*$/g.exec(s)[1]) :
    GLOBAL), eval(s));
}

//
function filterJS(obj) {
  let s;
  s = stringify(obj);
  return ((!(0 === kirbystdlibref.count(s))) ?
    JSON.parse(s) :
    null);
}

//
function withMeta(obj, m) {
  let ret;
  ret = clone(obj);
  ret["____meta"] = m;
  return ret;
}

//
function jsObject_QUERY(m) {
  return (object_QUERY(m) && (!(m instanceof LambdaArg)) && (!(m instanceof Atom)) && (!(m instanceof Symbol)) && (!(m instanceof Keyword)));
}

//
function meta(obj) {
  if ( ((!sequential_QUERY(obj)) && (!map_QUERY(obj)) && (!jsObject_QUERY(obj)) && (!(typeof (obj) === "function"))) ) {
    throw new Error(["can't get metadata from: ", typeid(obj)].join(""));
  }
  return obj["____meta"];
}

//
function evalJS(s) {
  return filterJS(eval(s.toString()));
}

//
function invokeJS(method) {
  let xs = Array.prototype.slice.call(arguments, 1);
  let res;
  let G____4 = resolveJS(method);
  let obj,
    f;
  obj = G____4[0];
  f = G____4[1];
  res = f.apply(obj, xs);
  return filterJS(res);
}

let gensym_DASH_counter;
gensym_DASH_counter = atom(0);

//
function gensym() {
  let G____5 = Array.prototype.slice.call(arguments, 0);
  let G____6 = G____5;
  let pfx;
  pfx = G____6[0];
  return symbol([(pfx || "G____"), swap_BANG(gensym_DASH_counter, function(x) {
    return (x + 1);
  })].join(""));
}

module.exports = {
  "is-same?": function(a, b) {
    return (a == b);
  },
  "obj-type*": std.typeid,
  "gensym*": gensym,
  "is-eq?": std.eq_QUERY,
  "is-nil?": function(x) {
    return (x === null);
  },
  "is-some?": std.some_QUERY,
  "slice*": function(arr) {
    let xs = Array.prototype.slice.call(arguments, 1);
    return Array.prototype.slice.apply(arr, xs);
  },
  "throw*": function() {
    let xs = Array.prototype.slice.call(arguments, 0);
    return (function() {
      throw new Error(xs.join("")) ;
    }).call(this);
  },
  "#f?": function(x) {
    return (false === x);
  },
  "#t?": function(x) {
    return (true === x);
  },
  "is-str?": function(x) {
    return (typeof (x) === "string");
  },
  "symbol*": std.symbol,
  "is-symbol?": std.symbol_QUERY,
  "keyword*": std.keyword,
  "is-keyword?": std.keyword_QUERY,
  "println*": prnLn,
  "prn*": prnStr,
  "slurp*": slurp,
  "<": function(a, b) {
    return (a < b);
  },
  "<=": function(a, b) {
    return (a <= b);
  },
  ">": function(a, b) {
    return (a > b);
  },
  ">=": function(a, b) {
    return (a >= b);
  },
  "+": function(a, b) {
    return (a + b);
  },
  "-": function(a, b) {
    return (a - b);
  },
  "*": function(a, b) {
    return (a * b);
  },
  "/": function(a, b) {
    return (a / b);
  },
  "not=": function(a, b) {
    return (a !== b);
  },
  "=": function(a, b) {
    return (a === b);
  },
  "time*": timeMillis,
  "list*": std.list,
  "is-list?": std.list_QUERY,
  "vector*": std.vector,
  "is-vector?": std.vector_QUERY,
  "hash-map*": std.hashmap,
  "is-map?": std.map_QUERY,
  "dissoc*": dissoc,
  "assoc*": assoc,
  "is-contains?": std.contains_QUERY,
  "get*": function(m, k) {
    return m[k];
  },
  "keys*": function(x) {
    return Object.keys(x);
  },
  "values*": function(x) {
    return Object.values(x);
  },
  "dec*": function(x) {
    return (x - 1);
  },
  "inc*": function(x) {
    return (x + 1);
  },
  "not*": function(x) {
    return (x ?
      false :
      true);
  },
  "is-even?": function(n) {
    return (0 === (n % 2));
  },
  "is-odd?": function(n) {
    return (1 === (n % 2));
  },
  "is-sequential?": std.sequential_QUERY,
  "cons*": cons,
  "concat*": std.concat_STAR,
  "nth*": function(arr, i) {
    return arr[i];
  },
  "first*": function(arr) {
    return arr[0];
  },
  "rest*": function(arr) {
    return (arr ?
      arr.slice(1) :
      []);
  },
  "is-empty?": std.empty_QUERY,
  "not-empty*": std.not_DASH_empty,
  "count*": std.count,
  "apply*": fapply,
  "map*": fmap,
  "type*": function(x) {
    return typeof (x);
  },
  "evens*": std.evens,
  "odds*": std.odds,
  "conj*": conj,
  "seq*": seq,
  "with-meta*": withMeta,
  "meta*": meta,
  "atom*": std.atom,
  "is-atom?": std.atom_QUERY,
  "deref*": std.deref,
  "reset*": std.reset_BANG,
  "swap*": std.swap_BANG,
  "js-eval*": evalJS,
  "js*": invokeJS
}
