/*Auto generated by Kirby - v1.0.0 czlab.kirby.rt.toolkit Mon Oct 30 2017 16:19:40 GMT-0700 (PDT)*/

var types= require("../bl/types");
var std= require("../bl/stdlib");




//
function prn_str() {
let xs=Array.prototype.slice.call(arguments,0);
return xs.map(function () {
let ____args;
____args= Array.prototype.slice.call(arguments);

return types.pr_obj(____args[0],true);
}).join(" ");
}

//
function prnice() {
let xs=Array.prototype.slice.call(arguments,0);
return xs.map(function () {
let ____args;
____args= Array.prototype.slice.call(arguments);

return types.pr_obj(____args[0],true);
}).forEach(function (s) {
return (console ?
console.log([ s ].join("")) :
null);
});
}

//
function slurp(f) {
return require("fs").readFileSync(f,"utf-8");
}

//
function timeMillis() {
return new Date().getTime();
}

//
function object() {
let xs=Array.prototype.slice.call(arguments,0);
return (std.empty_QUERY(xs) ?
{} :
assoc.apply(this,[ {} ].concat(xs)));
}

//
function assoc(src) {
let xs=Array.prototype.slice.call(arguments,1);
((0 !== (xs.length%2)) ?
(function (){ throw new Error([ "Odd number of assoc arguments" ].join("")); }).call(this) :
null);
return (function() {
let ret;
ret= clone(src);

(function () {let ____break=false;
for (let i = 0,k = null,v = null; (!____break && (i < xs.length)); i = (i+2)) {
k = ["",xs[i]].join("");
v = xs[(i+1)];
((!(typeof(k) === "string")) ?
(function (){ throw new Error([ "expected string, got: ",typeof(k) ].join("")); }).call(this) :
null);
ret[k] = v;

}
}).call(this);
return ret;
}).call(this);
}

//
function dissoc(src) {
let xs=Array.prototype.slice.call(arguments,1);
return (function() {
let ret;
ret= clone(src);

(function () {let ____break=false;
for (let i = 0; (!____break && (i < xs.length)); i = (i+1)) {
delete ret[xs[i]];

}
}).call(this);
return ret;
}).call(this);
}

//
function clone(obj) {
return (function() {
let ret;
ret= null;

(function() { let ____x;
switch (types.obj_type(obj)) {
case "list":
____x= ret = Array.prototype.slice.call(obj);
break;
case "vector":
____x= (function() {
let G__1;
G__1= ret;

G__1 = Array.prototype.slice.call(obj);
G__1["____vec"] = true;
return G__1;
}).call(this);
break;
case "hash-map":
____x= (function() {
let G__2;
G__2= ret;

G__2 = Array.prototype.slice.call(obj);
G__2["____map"] = true;
return G__2;
}).call(this);
break;
case "object":
____x= ret = Object.keys(obj).reduce(function (acc,n) {
acc[n] = obj[n];
return acc;
},{});
break;
case "function":
____x= ret = obj.clone();
break;
default:
____x= (function (){ throw new Error([ "clone of non-collection: ",types.obj_type(obj) ].join("")); }).call(this);
break;
}
return ____x;}).call(this);
Object.defineProperty(ret,"____meta",{ "enumerable": false,"writable": true });
return ret;
}).call(this);
}

//
function cons(a,b) {
return [ a ].concat(b);
}

//
function conj(arr) {
let xs=Array.prototype.slice.call(arguments,1);
return (types.list_QUERY(arr) ?
xs.reverse().concat(arr) :
(std.some_QUERY(arr) ?
(function() {
let v;
v= arr.concat(xs);

v["____vec"] = true;
return v;
}).call(this) :
(true ?
arr :
null)));
}

//
function seq(obj) {
return (types.list_QUERY(obj) ?
(std.not_empty(obj) ?
obj :
null) :
(types.vector_QUERY(obj) ?
(std.not_empty(obj) ?
Array.prototype.slice.call(obj) :
null) :
((typeof(obj) === "string") ?
(std.not_empty(obj) ?
obj.split("") :
null) :
((obj === null) ?
null :
(true ?
(function (){ throw new Error([ "seq: called on non-sequence" ].join("")); }).call(this) :
null)))));
}

//
function fapply(f) {
let xs=Array.prototype.slice.call(arguments,1);
return f.apply(this,xs);
}

//
function fmap(f,arr) {
return arr.map(f);
}

let GLOBAL;
GLOBAL= ((typeof(window) === "undefined") ?
undefined :
window);

//
function resolveJS(s) {
return [ (std.contains_QUERY(s,".") ?
eval(/^(.*)\.[^\.]*$/g.exec(s)[1]) :
GLOBAL),eval(s) ];
}

//
function filterJS(obj) {
let cache,s;
cache= [];
s= (obj ?
JSON.stringify(obj,function (k,v) {
(object_QUERY(v) ?
(std.contains_QUERY(cache,v) ?
v = undefined :
cache.push(v)) :
null);
return v;
}) :
null);

return (std.not_empty(s) ?
JSON.parse(s) :
null);
}

//
function withMeta(obj,m) {
return (function() {
let ret;
ret= types.clone(obj);

ret["____meta"] = m;
return ret;
}).call(this);
}

//
function meta(obj) {
(((!types.sequential_QUERY(obj))&&(!types.hashmap_QUERY(obj))&&(!types.jsObject_QUERY(obj))&&(!(typeof(obj) === "function"))) ?
(function (){ throw new Error([ "can't get metadata from: ",types.obj_type(obj) ].join("")); }).call(this) :
null);
return obj["____meta"];
}

//
function deref(a) {
return a.value;
}

//
function reset_BANG(a,v) {
return a["value"] = v;
}

//
function swap_BANG(a,f) {
let xs=Array.prototype.slice.call(arguments,2);
a["value"] = f.apply(this,[ a.value ].concat(xs));
return a["value"];
}

//
function evalJS(s) {
return filterJS(eval(s.toString()));
}

//
function invokeJS(method) {
let xs=Array.prototype.slice.call(arguments,1);
let res;
let G____1= resolveJS(method);
let obj,f;
obj=G____1[0];
f=G____1[1];
res= f.apply(obj,xs);

return filterJS(res);
}

let gensym_counter;
gensym_counter= types.atom(0);

//
function gensym() {
let G____2=Array.prototype.slice.call(arguments,0);
let G____3= G____2;
let pfx;
pfx=G____3[0];
return types.symbol([(pfx||"G__"),swap_BANG(gensym_counter,function (x) {
return (x+1);
})].join(""));
}

module.exports = { "is-same?": function (a,b) {
return (a == b);
},"obj-type*": types.obj_type,"gensym*": gensym,"is-eq?": types.eq_QUERY,"is-nil?": function (x) {
return (x === null);
},"is-some?": std.some_QUERY,"slice*": function (arr) {
let xs=Array.prototype.slice.call(arguments,1);
return Array.prototype.slice.apply(arr,xs);
},"throw*": function () {
let xs=Array.prototype.slice.call(arguments,0);
return (function (){ throw new Error(xs.join("")); }).call(this);
},"#f?": function (x) {
return (false === x);
},"#t?": function (x) {
return (true === x);
},"is-str?": function (x) {
return (typeof(x) === "string");
},"symbol*": types.symbol,"is-symbol?": types.symbol_QUERY,"keyword*": types.keyword,"is-keyword?": types.keyword_QUERY,"println*": prnice,"prn*": prn_str,"slurp*": slurp,"<": function (a,b) {
return (a < b);
},"<=": function (a,b) {
return (a <= b);
},">": function (a,b) {
return (a > b);
},">=": function (a,b) {
return (a >= b);
},"+": function (a,b) {
return (a+b);
},"-": function (a,b) {
return (a-b);
},"*": function (a,b) {
return (a*b);
},"/": function (a,b) {
return (a/b);
},"time*": timeMillis,"list*": types.list,"is-list?": types.list_QUERY,"vector*": types.vector,"is-vector?": types.vector_QUERY,"hash-map*": types.hashmap,"is-map?": types.hashmap_QUERY,"dissoc*": dissoc,"assoc*": assoc,"is-contains?": std.contains_QUERY,"get*": function (m,k) {
return m[k];
},"keys*": function (x) {
return Object.keys(x);
},"values*": function (x) {
return Object.values(x);
},"dec*": function (x) {
return (x-1);
},"inc*": function (x) {
return (x+1);
},"not*": function (x) {
return (x ?
false :
true);
},"is-even?": function (n) {
return (0 === (n%2));
},"is-odd?": function (n) {
return (1 === (n%2));
},"is-sequential?": types.sequential_QUERY,"cons*": cons,"concat*": std.concat_STAR,"nth*": function (arr,i) {
return arr[i];
},"first*": function (arr) {
return arr[0];
},"rest*": function (arr) {
return (arr ?
arr.slice(1) :
[]);
},"is-empty?": std.empty_QUERY,"not-empty*": std.not_empty,"count*": std.count,"apply*": fapply,"map*": fmap,"type*": function (x) {
return typeof(x);
},"evens*": std.evens,"odds*": std.odds,"conj*": conj,"seq*": seq,"with-meta*": withMeta,"meta*": meta,"atom*": types.atom,"is-atom?": types.atom_QUERY,"deref*": deref,"reset*": reset_BANG,"swap*": swap_BANG,"js-eval*": evalJS,"js*": invokeJS }
