;; Copyright (c) 2013-2017, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http:;;opensource.org;licenses;eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author "Kenneth Leung" }

  czlab.kirby.reader)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(include "./core.kirby")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(def- TreeNode (.-SourceNode (require "source-map")))
(def- *fs* nil *path* nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(def- REGEX
  { macroGet (regex "^#slice@(\\d+)")
    noret (regex "^def\\b|^var\\b|^set!\\b|^throw\\b")
    id (regex "^[a-zA-Z_$][?\\-*!0-9a-zA-Z_$]*$")
    id2 (regex "^[*\\-][?\\-*!0-9a-zA-Z_$]+$")
    func (regex "^function\\b")
    query (regexs "\\?" "g")
    bang (regexs "!" "g")
    dash (regexs "-" "g")
    star (regexs "\\*" "g")
    wspace (regex "\\s") })
(def- KIRBY "____kirby")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(when (undef? window)
  (set! *path* (require "path"))
  (set! *fs* (require "fs")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- testid? [name]
  (or (REGEX.id.test name) (REGEX.id2.test name)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- normalizeId [name]
  (var pfx "")
  (when (and (string? name)
           (= "-" (.charAt name 0)))
    (set! pfx "-")
    (set! name (.slice name 1)))
  (if (testid? name)
    (-> (str pfx name)
        (.replace REGEX.query "_QUERY")
        (.replace REGEX.bang "_BANG")
        (.replace REGEX.dash "_")
        (.replace REGEX.star "_STAR"))
    (if (= pfx "") name (str pfx name))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;use this function to generate code, we need to escape out funny
;;chars in names
(defn- tnodeString []
  (var me this)
  (do-with [s ""]
    (.walk me
           (fn [chunk hint]
             (if (and (= hint.name chunk)
                      (string? chunk))
               (set! chunk (normalizeId chunk)))
             (+= s chunk)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- tnode [ln col src chunk name]
  (var args? (js-args?))
  (do-with [n nil]
    (if args?
      (set! n
            (if name
              (new TreeNode ln col src chunk name)
              (new TreeNode ln col src chunk)))
      (set! n (new TreeNode)))
    (set! n KIRBY { eTYPE nil })
    (set! n :toString tnodeString)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- tnodeChunk [chunk name] (tnode nil nil nil chunk name))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- addToken [tree token context]
  (do-with [ret ""]
    (when token
      (if (= ":else" token) (set! token "true"))
      (if (= "nil" token) (set! token "null"))
      (if (and (or (.startsWith token ":")
                   (.startsWith token "'"))
               (testid? (.substring token 1)))
        (set! token (str "\"" (.substring token 1) "\"")))
      (conj!! tree (tnode context.lineno
                          (- context.tknCol 1)
                          context.filename token token)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- lexer [prevToken context]
  (var ____BREAK! nil
       formType nil
       state nil
       token ""
       ch nil
       escStr? false
       inStr? false
       comment? false)

  (do-with [tree []]
    (set! state
          (reduce (fn [acc k]
                    (set! acc k (get context k)) acc)
                  {}
                  [:filename :lineno]))
    (set! tree KIRBY state)
    (cond
      (= "[" prevToken)
      (set! state :eTYPE :array)
      (= "{" prevToken)
      (set! state :eTYPE :object))

    (set! ____BREAK! false)
    (while (and (not ____BREAK!)
                (< context.pos (alen context.codeStr)))
      (set! ch (.charAt context.codeStr context.pos))
      (inc!! context.colno)
      (inc!! context.pos)
      (when (= ch "\n")
        (inc!! context.lineno)
        (set! context.colno 1)
        (if comment? (toggle! comment?)))
      (cond
        comment?
        nil
        escStr?
        (do
          (toggle! escStr?)
          (inc! token ch))
        (= ch "\"")
        (do
          (toggle! inStr?)
          (inc! token ch))
        inStr?
        (do
          (if (= ch "\n") (set! ch "\\n"))
          (if (= ch "\\") (set! escStr? true))
          (inc! token ch))
        (= ch "'")
        ;;more work
        (inc! token ch)
        (or (= ch "[")
            (= ch "]"))
        (do
          (set! token (addToken tree token context))
          (set! context.tknCol context.colno)
          (if (= ch "[")
            (do
              (set! formType  :array)
              (conj!! tree (lexer ch context)))
            (do
              (set! formType nil)
              (set! ____BREAK! true))))
        (or (= ch "{")
            (= ch "}"))
        (do
          (set! token (addToken tree token context))
          (set! context.tknCol context.colno)
          (if (= ch "{")
            (do
              (set! formType  :object)
              (conj!! tree (lexer ch context)))
            (do
              (set! formType nil)
              (set! ____BREAK! true))))
        (= ch ";")
        (set! comment? true)
        (or (= ch "(")
            (= ch ")"))
        (do
          (set! token (addToken tree token context))
          (set! context.tknCol context.colno)
          (if (= ch "(")
            (do (set! formType :list)
                (conj!! tree (lexer nil context)))
            (do (set! formType nil)
                (set! ____BREAK! true))))
        (REGEX.wspace.test ch)
        (do
          (if (= ch "\n") (-- context.lineno))
          (set! token (addToken tree token context))
          (if (= ch "\n") (++ context.lineno))
          (set! context.tknCol context.colno))
        :else
        (+= token ch)))
    ;;final check!
    (if inStr? (syntax! 'e3 tree))
    (cond
      (= formType :array)
      (syntax! 'e5 tree)
      (= formType :object)
      (syntax! 'e7 tree)
      (= formType :list)
      (syntax! 'e8 tree))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF


