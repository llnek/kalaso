;; Copyright (c) 2013-2017, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http:;;opensource.org;licenses;eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author "Kenneth Leung"}

  czlab.kirby.reader

  (include "./core.kirby")

  (require ["source-map" :as *smap*]
           ["path" :as *path*]
           ["fs" :as *fs*]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(def- TreeNode (.-SourceNode  *smap*))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(def- REGEX
  { :noret (regex "^def\\b|^var\\b|^set!\\b|^throw\\b")
    :id (regex "^[a-zA-Z_$][?\\-*!0-9a-zA-Z_$]*$")
    :id2 (regex "^[*\\-][?\\-*!0-9a-zA-Z_$]+$")
    :float (regex "^[-+]?[0-9]+\\.[0-9]+$")
    :int (regex "^[-+]?[0-9]+$")
    :hex (regex "^[-+]?0x")
    :macroGet (regex "^#slice@(\\d+)")
    :dquoteHat (regex "^\"")
    :dquoteEnd (regex "\"$")
    :func (regex "^function\\b")
    :query (regexs "\\?" "g")
    :bang (regexs "!" "g")
    :dash (regexs "-" "g")
    :star (regexs "\\*" "g")
    :wspace (regex "\\s") })

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(def- tkn-string "STRING")
(def- tkn-number "NUMBER")
(def- tkn-symbol "SYMBOL")
(def- tkn-ident "IDENT")
(def- tkn-atom "ATOM")
(def- tkn-hat "HAT")
(def- tkn-ns "NS")
(def- tkn-quote "QUOTE")
(def- tkn-back-tick "BACKTICK")
(def- tkn-list "LIST")
(def- tkn-tree "TREE")
(def- tkn-array "ARRAY")
(def- tkn-object "OBJECT")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defmacro name?? [obj] (get?? ~obj :name ""))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- nodeTag [obj src line col type]
  (when obj
    (set! obj :source src)
    (set! obj :column col)
    (set! obj :line line)
    (set! obj :eTYPE type)) obj)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- testid? [name]
  (or (REGEX.id.test name) (REGEX.id2.test name)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- normalizeId [name]
  (var pfx "")
  (when (and (string? name)
             (= "-" (.charAt name 0)))
    (set! pfx "-")
    (set! name (.slice name 1)))
  (if (testid? name)
    (-> (str pfx name)
        (.replace REGEX.query "_QUERY")
        (.replace REGEX.bang "_BANG")
        (.replace REGEX.dash "_")
        (.replace REGEX.star "_STAR"))
    (if (= pfx "") name (str pfx name))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;use this function to generate code, we need to escape out funny
;;chars in names
(defn- tnodeString []
  (var me this)
  (do-with [s ""]
    (.walk me
           (fn [chunk hint]
             (if (and (= hint.name chunk)
                      (string? chunk))
               (set! chunk (normalizeId chunk)))
             (+= s chunk)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- tnode [source line col chunk name type]
  (var args? (js-args?))
  (do-with [n nil]
    (if args?
      (set! n
            (if name
              (new TreeNode line col source chunk name)
              (new TreeNode line col source chunk)))
      (set! n (new TreeNode)))
    (set! n :eTYPE type)
    (set! n :toString tnodeString)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- tnodeEx [chunk name type]
  (tnode nil nil nil chunk name type))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- addToken [tree token ctx]
  (var n nil t tkn-symbol)
  (do-with [ret ""]
    (when token
      (if (= ":else" token) (set! token "true"))
      (if (= "nil" token) (set! token "null"))
      (cond
        (and (.startsWith token "\"")
             (.endsWith token "\""))
        (set! t tkn-string)
        (or (REGEX.float.test token)
            (REGEX.int.test token)
            (REGEX.hex.test token))
        (set! t tkn-number)
        (= "^" token)
        (set! t tkn-hat)
        (= "`" token)
        (set! t tkn-back-tick)
        (.startsWith token ":")
        (set! token (str "\"" (.slice token 1) "\""))
        (.startsWith token "'")
        (set! token (str "\"" (.slice token 1) "\""))
        :else
        (set! t tkn-ident))
      (set! n (tnode ctx.file
                     ctx.line
                     (dec ctx.tcol) token token t))
      (conj!! tree n))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- lexer [prevToken ctx]
  (var ____BREAK! nil
       formType nil
       token ""
       ch nil
       escStr? false
       inStr? false
       comment? false)

  (do-with [tree []]
    (nodeTag tree
             (get ctx :source)
             (get ctx :line)
             0
             (cond
               (= "{" prevToken) tkn-object
               (= "[" prevToken) tkn-array
               :else tkn-list))
    (set! ____BREAK! false)
    (while (and (not ____BREAK!)
                (< ctx.pos (alen ctx.codeStr)))
      (set! ch (.charAt ctx.codeStr ctx.pos))
      (++ ctx.colno)
      (++ ctx.pos)
      (when (= ch "\n")
        (++ ctx.lineno)
        (set! ctx.colno 1)
        (if comment? (toggle! comment?)))
      (cond
        comment?
        nil
        escStr?
        (do (toggle! escStr?)
            (+= token ch))
        (= ch "\"")
        (do (toggle! inStr?)
            (inc! token ch))
        inStr?
        (do (if (= ch "\n") (set! ch "\\n"))
            (if (= ch "\\") (set! escStr? true))
            (+= token ch))
        (= ch "'")
        (+= token ch)
        (or (= ch "[")
            (= ch "]"))
        (do (set! token (addToken tree token ctx))
            (set! ctx.tcol ctx.colno)
            (if (= ch "[")
              (do (set! formType tkn-array)
                  (conj!! tree (lexer ch ctx)))
              (do (set! formType nil)
                  (set! ____BREAK! true))))
        (or (= ch "{")
            (= ch "}"))
        (do (set! token (addToken tree token ctx))
            (set! ctx.tcol ctx.colno)
            (if (= ch "{")
              (do (set! formType tkn-object)
                  (conj!! tree (lexer ch ctx)))
              (do (set! formType nil)
                  (set! ____BREAK! true))))
        (= ch ";")
        (set! comment? true)
        (or (= ch "(")
            (= ch ")"))
        (do (set! token (addToken tree token ctx))
            (set! ctx.tcol ctx.colno)
            (if (= ch "(")
              (do (set! formType tkn-list)
                  (conj!! tree (lexer nil ctx)))
              (do (set! formType nil)
                  (set! ____BREAK! true))))
        (REGEX.wspace.test ch)
        (do (if (= ch "\n") (-- ctx.lineno))
            (set! token (addToken tree token ctx))
            (if (= ch "\n") (++ ctx.lineno))
            (set! ctx.tcol ctx.colno))
        :else
        (+= token ch)))
    ;;final check!
    (if inStr? (syntax! 'e3 tree))
    (case formType
      tkn-array (syntax! 'e5 tree)
      tkn-object (syntax! 'e7 tree)
      tkn-list (syntax! 'e8 tree))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF


