/*Auto generated by Kirby v1.0.0 - Sun Jan 21 2018 16:59:18 GMT-0800 (PST)
  czlab.kirby.stdlib
({"doc":"Kirby's standard core library.","author":"Kenneth Leung"})
*/

////////////////////////////////////////////////////////////////////////////////
//fn: [println] in file: stdlib.ky, line: 17
const println = function() {
  let msgs = Array.prototype.slice.call(arguments, 0);
  return (console ?
    console.log(msgs.join("")) :
    null);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [not-empty] in file: stdlib.ky, line: 21
//If coll is empty, returns nil, else coll
const not_DASH_empty = function(coll) {
  return ((0 === count(coll)) ?
    null :
    coll);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [noCRef] in file: stdlib.ky, line: 29
//Use a cache to store already referenced objects
//to prevent circular references
const noCRef = function() {
  let cache = [];
  return function(k, v) {
    if (( (typeof (v) === "function") )) {
      v = "native-fn";
    } else {
      if (object_QUERY(v)) {
        if (contains_QUERY(cache, v)) {
          v = undefined;
        } else {
          conj_BANG(cache, v);
        }
      } else {
        null;
      }
    }
    return v;
  };
};
////////////////////////////////////////////////////////////////////////////////
//fn: [stringify] in file: stdlib.ky, line: 42
//JSON stringify (no cyclical obj-ref)
const stringify = function(obj) {
  return (obj ?
    JSON.stringify(obj, noCRef()) :
    null);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [opt??] in file: stdlib.ky, line: 50
//If cur is not defined, returns other else cur
const opt_QUERY__QUERY = function(cur, other) {
  return (((typeof (cur) !== "undefined")) ?
    cur :
    other);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [conj!] in file: stdlib.ky, line: 58
//conj[oin]. Returns coll with the xs
//'added'. (conj! nil item) returns [item].
//If coll is a list, prepends else appends to coll.
const conj_BANG = function(coll) {
  let xs = Array.prototype.slice.call(arguments, 1);
  let c = (coll || []);
  if (list_QUERY(c)) {
    c.unshift.apply(c, xs.reverse());
  } else {
    c.push.apply(c, xs);
  }
  return c;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [conj] in file: stdlib.ky, line: 71
//Like conj! but
//returns a new collection
const conj = function(coll) {
  let xs = Array.prototype.slice.call(arguments, 1);
  let c = (vector_QUERY(coll) ?
    into("vector", coll) :
    (list_QUERY(coll) ?
      into("list", coll) :
      (map_QUERY(coll) ?
        into("map", coll) :
        (nichts_QUERY(coll) ?
          [] :
          (true ?
            Array.prototype.slice.call(coll) :
            null)))));
  return conj_BANG.apply(this, [c].concat(xs));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [pop!] in file: stdlib.ky, line: 87
//Removes the first element if list,
//else removes the last element,
//returning the element
//and the altered collection
const pop_BANG = function(coll) {
  let r = (list_QUERY(coll) ?
    coll.shift() :
    coll.pop());
  return [r, coll];
};
////////////////////////////////////////////////////////////////////////////////
//fn: [pop] in file: stdlib.ky, line: 99
//Like pop! but returns a new collection
const pop = function(coll) {
  let r = (list_QUERY(coll) ?
    getProp(coll, 0) :
    last(coll));
  return [r, (list_QUERY(coll) ?
    coll.slice(1) :
    coll.slice(0, -1))];
};
////////////////////////////////////////////////////////////////////////////////
//fn: [wrap-str] in file: stdlib.ky, line: 107
//Prepend and append
//strings to the object.
const wrap_DASH_str = function(obj, start, end) {
  return [start, obj, end].join("");
};
////////////////////////////////////////////////////////////////////////////////
//fn: [getProp] in file: stdlib.ky, line: 112
//If prop is a string, returns the value of
//this object property, obeying the own? flag.
//Otherwise, return the value at the index of
//the array
const getProp = function(obj, prop) {
  let GS__2 = Array.prototype.slice.call(arguments, 2);
  let own_QUERY = GS__2[0];
  own_QUERY = opt_QUERY__QUERY(own_QUERY, true);
  return ((((typeof (prop) === "string")) || ((typeof (prop) === "number"))) ?
    ((own_QUERY && ((typeof (prop) === "string")) && (!obj.hasOwnProperty(prop))) ?
      undefined :
      obj[prop]) :
    undefined);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [prn] in file: stdlib.ky, line: 132
//Print data as string - use to dump an AST node
const prn = function(obj) {
  let GS__3 = Array.prototype.slice.call(arguments, 1);
  let r_QUERY = GS__3[0];
  let f = noCRef();
  if (complex_QUERY(obj)) {
    obj = f(null, obj);
  }
  return (obj ?
    prn_STAR(obj, r_QUERY, f) :
    "");
};
////////////////////////////////////////////////////////////////////////////////
//fn: [prnArr*] in file: stdlib.ky, line: 143
//Print an array
const prnArr_STAR = function(obj, r_QUERY, f) {
  return obj.map(function(v, i) {
    let x = f(i, v);
    return prn_STAR(opt_QUERY__QUERY(x, null), r_QUERY, f);
  }).join(" ");
};
////////////////////////////////////////////////////////////////////////////////
//fn: [prn*] in file: stdlib.ky, line: 151
const prn_STAR = function(obj, r_QUERY, func) {
  let pfx = function() {
    let ____args = Array.prototype.slice.call(arguments);
    return prn_STAR(____args[0], r_QUERY, func);
  };
  let parr = ((Array.isArray(obj)) ?
    function() {
      let ____args = Array.prototype.slice.call(arguments);
      return wrap_DASH_str(prnArr_STAR(obj, r_QUERY, func), ____args[0], ____args[1]);
    } :
    null);
  return (function() {
    let C__4;
    switch (typeid(obj)) {
      case "atom":
        C__4 = wrap_DASH_str(func(null, obj.value), "(atom", ")");
        break;
      case "lambda-arg":
        C__4 = ["%", (parseInt(obj.value) + 1)].join("");
        break;
      case "keyword":
        C__4 = [(obj.pfx ?
          "::" :
          ":"), obj.value].join("");
        break;
      case "symbol":
        C__4 = obj.value;
        break;
      case "object":
        C__4 = wrap_DASH_str(seq(obj).reduce(function(acc, GS__5) {
          let k = GS__5[0];
          let v = GS__5[1];
          let x = func(k, v);
          if ( (!((typeof (x) === "undefined"))) ) {
            conj_BANG(acc, [pfx(k), ":", pfx(x)].join(""));
          } else {
            null;
          }
          return acc;
        }, []).join(","), "{", "}");
        break;
      case "vector":
        C__4 = parr("[", "]");
        break;
      case "map":
        C__4 = parr("{", "}");
        break;
      case "list":
        C__4 = parr("'(", ")");
        break;
      case "string":
        C__4 = (r_QUERY ?
          quote_DASH_str(obj) :
          obj);
        break;
      case "null":
      case "nil":
        C__4 = "null";
        break;
      default:
        C__4 = ((Array.isArray(obj)) ?
          parr("(", ")") :
          obj.toString());
        break;
    }
    return C__4;
  }).call(this);
};
//Defining a clojure-like Atom
class Atom {
  ////////////////////////////////////////////////////////////////////////////////
  //fn: [constructor] in file: stdlib.ky, line: 195
  constructor(val) {
    this["value"] = null;
    this.value = val;
    return this;
  }
}
////////////////////////////////////////////////////////////////////////////////
//fn: [atom?] in file: stdlib.ky, line: 198
//Returns true if an Atom
const atom_QUERY = function(atm) {
  return (atm instanceof Atom);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [atom] in file: stdlib.ky, line: 202
//Create a new Atom
const atom = function(val) {
  return new Atom(val);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [reset!] in file: stdlib.ky, line: 206
//Set a new value to the Atom
const reset_BANG = function(a, v) {
  return (function() {
    let GS__6 = null;
    a.value = v;
    return GS__6;
  }).call(this);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [resetVec!] in file: stdlib.ky, line: 210
const resetVec_BANG = function(v) {
  return (function() {
    let GS__7 = null;
    if ( (Array.isArray(v)) ) {
      v.splice(0);
    }
    return GS__7;
  }).call(this);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [resetObject!] in file: stdlib.ky, line: 214
const resetObject_BANG = function(obj) {
  return (function() {
    let GS__8 = null;
    if (object_QUERY(obj)) {
      Object.keys(obj).forEach(function() {
        let ____args = Array.prototype.slice.call(arguments);
        return delete obj[____args[0]];
      });
    }
    return GS__8;
  }).call(this);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [sort!] in file: stdlib.ky, line: 220
//Returns a sorted sequence of the items in coll.
//If no comparator is supplied, uses compare
const sort_BANG = function(comp, coll) {
  return (((typeof (comp) === "function")) ?
    coll.sort(comp) :
    comp.sort());
};
////////////////////////////////////////////////////////////////////////////////
//fn: [find] in file: stdlib.ky, line: 227
//Returns the value of the first element
//in the collection that satisfies the
//provided predicate function
const find = function(coll, pred) {
  let ret = null;
  let c = null;
  for (let i = 0, sz = count(coll), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
    c = coll[i];
    if (pred(c)) {
      ret = c;
      ____break = true;
    }
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [deref] in file: stdlib.ky, line: 245
//Get value inside the Atom
const deref = function(a) {
  return a.value;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [swap!] in file: stdlib.ky, line: 249
//Change value inside the Atom,
//returning the new value
const swap_BANG = function(a, f) {
  let xs = Array.prototype.slice.call(arguments, 2);
  a.value = f.apply(this, [a.value].concat(xs));
  return getProp(a, "value");
};
////////////////////////////////////////////////////////////////////////////////
//fn: [typeid] in file: stdlib.ky, line: 257
//Returns the type-id
//of this object
const typeid = function(obj) {
  return (lambda_DASH_arg_QUERY(obj) ?
    "lambda-arg" :
    (keyword_QUERY(obj) ?
      "keyword" :
      (symbol_QUERY(obj) ?
        "symbol" :
        (vector_QUERY(obj) ?
          "vector" :
          (atom_QUERY(obj) ?
            "atom" :
            (list_QUERY(obj) ?
              "list" :
              (map_QUERY(obj) ?
                "map" :
                (((obj === null)) ?
                  "null" :
                  (((obj === true)) ?
                    "true" :
                    (((obj === false)) ?
                      "false" :
                      (((typeof (obj) === "function")) ?
                        "function" :
                        (((typeof (obj) === "string")) ?
                          "string" :
                          (((typeof (obj) === "number")) ?
                            "number" :
                            ((Array.isArray(obj)) ?
                              "array" :
                              (object_QUERY(obj) ?
                                "object" :
                                (true ?
                                  (function() {
                                    throw new Error(["Unknown type [", typeof (obj), "]"].join(""));
                                  }).call(this) :
                                  null))))))))))))))));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [complex?] in file: stdlib.ky, line: 280
//True if x is an array
//or js object.
const complex_QUERY = function(x) {
  return ((Array.isArray(x)) || object_QUERY(x));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [simple?] in file: stdlib.ky, line: 285
//True if x is a
//primitive value type
const simple_QUERY = function(obj) {
  return (((typeof (obj) === "undefined")) || ((obj === null)) || ((obj === false)) || ((obj === true)) || ((typeof (obj) === "string")) || ((typeof (obj) === "number")));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [value?] in file: stdlib.ky, line: 291
//Returns true
//if a simple LISP value
const value_QUERY = function(obj) {
  return (((obj === null)) || vector_QUERY(obj) || list_QUERY(obj) || map_QUERY(obj) || ((obj === false)) || ((obj === true)) || ((typeof (obj) === "string")) || ((typeof (obj) === "number")));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [sequential?] in file: stdlib.ky, line: 304
//True if coll
//implements Sequential
const sequential_QUERY = function(arr) {
  return ((Array.isArray(arr)) && (!map_QUERY(arr)));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [map2Obj] in file: stdlib.ky, line: 310
const map2Obj = function(m) {
  let ret = {};
  let k,
    v;
  for (let i = 0, sz = count(m), ____break = false; ((!____break) && (i < sz)); i = (i + 2)) {
    (k = m[i], v = m[i + 1]);
    ret[[k].join("")] = v;
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [eq?] in file: stdlib.ky, line: 320
//True if both are equal
const eq_QUERY = function(a, b) {
  let k = null;
  let ok_QUERY = true;
  return ((map_QUERY(a) && map_QUERY(b) && (a.length === b.length)) ?
    eq_QUERY(map2Obj(a), map2Obj(b)) :
    (((Array.isArray(a)) && (Array.isArray(b)) && (a.length === b.length)) ?
      (function() {
        for (let i = 0, sz = a.length, ____break = false; ((!____break) && (ok_QUERY && (i < sz))); i = (i + 1)) {
          if ( (!eq_QUERY(a[i], b[i])) ) {
            ok_QUERY = false;
          }
        }
        return ok_QUERY;
      }).call(this) :
      (((a instanceof LambdaArg) && (b instanceof LambdaArg)) ?
        (a.value === b.value) :
        (((a instanceof Symbol) && (b instanceof Symbol)) ?
          (a.value === b.value) :
          (((a instanceof Keyword) && (b instanceof Keyword)) ?
            ((a.pfx === b.pfx) && (a.value === b.value)) :
            ((object_QUERY(a) && object_QUERY(b) && (count(a) === count(b))) ?
              (function() {
                for (let i = 0, ks = Object.keys(a), sz = count(ks), ____break = false; ((!____break) && (ok_QUERY && (i < sz))); i = (i + 1)) {
                  k = ks[i];
                  if ( (!eq_QUERY(getProp(a, k), getProp(b, k))) ) {
                    ok_QUERY = false;
                  }
                }
                return ok_QUERY;
              }).call(this) :
              (true ?
                (a === b) :
                null)))))));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [object?] in file: stdlib.ky, line: 354
//Returns true
//if a js object
const object_QUERY = function(obj) {
  return ((!(((obj === null)) || (Array.isArray(obj)))) ?
    (typeof (obj) === "object") :
    null);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [last] in file: stdlib.ky, line: 360
//Returns the last element
const last = function(coll) {
  return (((Array.isArray(coll)) && (coll.length > 0)) ?
    getProp(coll, (coll.length - 1)) :
    null);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [into!] in file: stdlib.ky, line: 366
//Assign a type to this collection
const into_BANG = function(type, coll) {
  let C__9;
  switch (type) {
    case "vector":
      C__9 = coll["____vec"] = true;
      break;
    case "list":
      C__9 = coll["____list"] = true;
      break;
    case "map":
      C__9 = coll["____map"] = true;
      break;
  }
  return coll;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [into] in file: stdlib.ky, line: 377
//Like into! but
//returning a new collection
const into = function(type, coll) {
  return into_BANG(type, coll.slice(0));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [pairs?] in file: stdlib.ky, line: 383
//Returns true if
//a LISP list, not data
const pairs_QUERY = function(obj) {
  return ((Array.isArray(obj)) && (!vector_QUERY(obj)) && (!map_QUERY(obj)) && (!list_QUERY(obj)));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [list?] in file: stdlib.ky, line: 389
//Returns true if a List
const list_QUERY = function(obj) {
  return ((Array.isArray(obj)) && obj.____list);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [list] in file: stdlib.ky, line: 393
//Create a List
const list = function() {
  let xs = Array.prototype.slice.call(arguments, 0);
  xs["____list"] = true;
  return xs;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [vector?] in file: stdlib.ky, line: 397
//Returns true if a Vector
const vector_QUERY = function(obj) {
  return ((Array.isArray(obj)) && obj.____vec);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [vector] in file: stdlib.ky, line: 401
//Create a Vector
const vector = function() {
  let xs = Array.prototype.slice.call(arguments, 0);
  xs["____vec"] = true;
  return xs;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [map?] in file: stdlib.ky, line: 405
//Returns true if a Hashmap
const map_QUERY = function(obj) {
  return ((Array.isArray(obj)) && obj.____map);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [arraymap] in file: stdlib.ky, line: 409
//Create a new array map
const arraymap = function() {
  let xs = Array.prototype.slice.call(arguments, 0);
  if (( (!((0 === modulo(xs.length, 2)))) )) {
    throw new Error("Invalid arity for arraymap");
  }
  xs["____map"] = true;
  return xs;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [object] in file: stdlib.ky, line: 416
//Create a new js object
const object = function() {
  let xs = Array.prototype.slice.call(arguments, 0);
  if (( (!((0 === modulo(xs.length, 2)))) )) {
    throw new Error("Invalid arity for object");
  }
  return zipmap(evens(xs), odds(xs));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [seq] in file: stdlib.ky, line: 423
//Returns a sequence
const seq = function(obj) {
  return (((typeof (obj) === "string")) ?
    obj.split("") :
    ((Array.isArray(obj)) ?
      obj.slice(0) :
      (object_QUERY(obj) ?
        Object.entries(obj) :
        null)));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [contains?] in file: stdlib.ky, line: 431
//True if item is inside
const contains_QUERY = function(coll, x) {
  return (((Array.isArray(coll)) || ((typeof (coll) === "string"))) ?
    coll.includes(x) :
    (object_QUERY(coll) ?
      coll.hasOwnProperty(x) :
      (true ?
        false :
        null)));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [nichts?] in file: stdlib.ky, line: 438
//True if object is
//either null of undefined
const nichts_QUERY = function(obj) {
  return (((typeof (obj) === "undefined")) || ((obj === null)));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [some?] in file: stdlib.ky, line: 442
//True if object is
//defined and not null
const some_QUERY = function(obj) {
  return (!nichts_QUERY(obj));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [count] in file: stdlib.ky, line: 446
//Count the number of elements inside
const count = function(coll) {
  return (coll ?
    ((((typeof (coll) === "string")) || (Array.isArray(coll))) ?
      coll :
      Object.keys(coll)).length :
    0);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [concat*] in file: stdlib.ky, line: 453
//Add many to this collection
const concat_STAR = function(coll) {
  let xs = Array.prototype.slice.call(arguments, 1);
  return (coll ?
    coll.concat.apply(coll, xs) :
    null);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [every] in file: stdlib.ky, line: 458
const every = function(coll, start, step) {
  let ret = [];
  for (let i = start, sz = count(coll), ____break = false; ((!____break) && (i < sz)); i = (i + step)) {
    conj_BANG(ret, coll[i]);
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [copyVector] in file: stdlib.ky, line: 464
const copyVector = function(from, to) {
  return (((Array.isArray(from)) && (Array.isArray(to))) ?
    (function() {
      let fc = count(from);
      let tc = count(to);
      return ((!(fc < tc)) ?
        to.forEach(function(v, i) {
          return to[i] = getProp(from, i);
        }) :
        null);
    }).call(this) :
    null);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [evens] in file: stdlib.ky, line: 473
//Collect every
//2nd item starting at 0
const evens = function(coll) {
  return every(coll, 0, 2);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [odds] in file: stdlib.ky, line: 477
//Collect every
//2nd item starting at 1
const odds = function(coll) {
  return every(coll, 1, 2);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [modulo] in file: stdlib.ky, line: 481
//Modulo
const modulo = function(x, N) {
  return ((x < 0) ?
    (x - (-1 * (N + (Math.floor(((-1 * x) / N)) * N)))) :
    (x % N));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [partition] in file: stdlib.ky, line: 489
//Returns a sequence of lists of n items each.
const partition = function(n, coll) {
  return (function() {
    let _x_ = null;
    let recur = null;
    let _f_ = function(ret, GS__10) {
      let x = GS__10[0];
      let y = GS__10[1];
      if (not_DASH_empty(x)) {
        conj_BANG(ret, x);
      }
      return ((0 === count(y)) ?
        ret :
        recur(ret, split_DASH_seq(y, n)));
    };
    let _r_ = _f_;
    recur = function() {
      _x_ = arguments;
      if (_r_) {
        for (_r_ = undefined; _r_ === undefined;) {
          _r_ = _f_.apply(this, _x_);
        }
        return _r_;
      }
      return undefined;
    };
    return recur([], split_DASH_seq(coll, n));
  })(this);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [split-str] in file: stdlib.ky, line: 502
//Returns a sequence of strings of n characters each.
const split_DASH_str = function(n, string) {
  let ret = [];
  for (let i = 0, sz = count(string), ____break = false; ((!____break) && (i < sz));) {
    conj_BANG(ret, string.substr(i, n));
    i = (i + n);
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [interleave] in file: stdlib.ky, line: 513
//Returns a seq of the first item
//in each coll, then the second, etc
const interleave = function(c1, c2) {
  let cz = ((c2.length < c1.length) ?
    c2.length :
    c1.length);
  let ret = [];
  for (let i = 0, ____break = false; ((!____break) && (i < cz)); i = (i + 1)) {
    conj_BANG(ret, c1[i], c2[i]);
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [zipmap] in file: stdlib.ky, line: 524
//Returns an object with the
//keys mapped to the corresponding vals
const zipmap = function(keys, vals) {
  let cz = ((keys.length < vals.length) ?
    keys.length :
    vals.length);
  let ret = {};
  for (let i = 0, ____break = false; ((!____break) && (i < cz)); i = (i + 1)) {
    ret[[keys[i]].join("")] = vals[i];
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [extendAttr] in file: stdlib.ky, line: 536
const extendAttr = function(obj, attr) {
  let GS__11 = Array.prototype.slice.call(arguments, 2);
  let flags = GS__11[0];
  flags = opt_QUERY__QUERY(flags, {
    "enumerable": false,
    "writable": true
  });
  Object.defineProperty(obj, attr, flags);
  return obj;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [cons] in file: stdlib.ky, line: 542
//Returns a new seq where x is the first element and seq is
//the rest.
const cons = function(x, coll) {
  return [x].concat(coll);
};
const gensym_DASH_counter = atom(0);
////////////////////////////////////////////////////////////////////////////////
//fn: [gensym] in file: stdlib.ky, line: 550
//Generates next random symbol
const gensym = function() {
  let GS__12 = Array.prototype.slice.call(arguments, 0);
  let pfx = GS__12[0];
  return symbol([opt_QUERY__QUERY(pfx, "GS__"), swap_BANG(gensym_DASH_counter, function(x) {
    return (x + 1);
  })].join(""));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [carve] in file: stdlib.ky, line: 557
const carve = function(coll) {
  let GS__13 = Array.prototype.slice.call(arguments, 1);
  let start = GS__13[0];
  let end = GS__13[1];
  return (((typeof (end) !== "undefined")) ?
    Array.prototype.slice.call(coll, start, end) :
    (((typeof (start) !== "undefined")) ?
      Array.prototype.slice.call(coll, start) :
      Array.prototype.slice.call(coll)));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [assoc!] in file: stdlib.ky, line: 565
const assoc_BANG = function(mmap) {
  let xs = Array.prototype.slice.call(arguments, 1);
  if (mmap) {
    for (let i = 0, sz = count(xs), ____break = false; ((!____break) && (i < sz)); i = (i + 2)) {
      mmap[xs[i]] = xs[i + 1];
    }
  }
  return mmap;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [dissoc!] in file: stdlib.ky, line: 574
const dissoc_BANG = function(mmap) {
  let xs = Array.prototype.slice.call(arguments, 1);
  if (mmap) {
    let GS__14 = xs;
    for (let GS__16 = 0, GS__15 = false, ____break = false; ((!____break) && ((!GS__15) && (GS__16 < GS__14.length))); GS__16 = (GS__16 + 1)) {
      let n = getProp(GS__14, GS__16);
      null;
      if ( (!true) ) {
        GS__15 = true;
      } else {
        null;
      }
      if ( ((!GS__15) && true) ) {
        delete mmap[n];
      }
    }
    null;
  }
  return mmap;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [truthy?] in file: stdlib.ky, line: 580
//LISP truthy
const truthy_QUERY = function(a) {
  return (!falsy_QUERY(a));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [falsy?] in file: stdlib.ky, line: 583
//LISP falsy
const falsy_QUERY = function(a) {
  return (((a === null)) || ((a === false)));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [flatten] in file: stdlib.ky, line: 586
//Flatten an array
const flatten = function(xs) {
  return xs.reduce(function(acc, v) {
    return acc.concat(v);
  }, []);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [identity] in file: stdlib.ky, line: 591
//Returns its argument.
const identity = function(x) {
  return x;
};
var _STAR_ns_STAR = atom(null);
////////////////////////////////////////////////////////////////////////////////
//fn: [setnsp!] in file: stdlib.ky, line: 597
const setnsp_BANG = function(p) {
  return reset_BANG(_STAR_ns_STAR, p);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [getnsp] in file: stdlib.ky, line: 599
const getnsp = function() {
  let p = _STAR_ns_STAR.value;
  return ((0 === count(p)) ?
    "user" :
    p);
};
const m_DASH_identity = (function() {
  let bind,
    unit,
    zero,
    plus;
  return (function() {
    let bind = function(mv, mf) {
      return mf(mv);
    };
    let unit = function() {
      let ____args = Array.prototype.slice.call(arguments);
      return ____args[0];
    };
    return {
      "bind": bind,
      "unit": unit,
      "zero": zero,
      "plus": plus
    };
  }).call(this);
}).call(this);
const m_DASH_maybe = (function() {
  let bind,
    unit,
    zero,
    plus;
  return (function() {
    let bind = function(mv, mf) {
      return ((!((mv === null))) ?
        mf(mv) :
        null);
    };
    let unit = function() {
      let ____args = Array.prototype.slice.call(arguments);
      return ____args[0];
    };
    let zero = null;
    return {
      "bind": bind,
      "unit": unit,
      "zero": zero,
      "plus": plus
    };
  }).call(this);
}).call(this);
const m_DASH_list = (function() {
  let bind,
    unit,
    zero,
    plus;
  return (function() {
    let bind = function(mv, mf) {
      return flatten(mv.map(mf));
    };
    let unit = function() {
      let ____args = Array.prototype.slice.call(arguments);
      return [].concat(____args[0]);
    };
    let zero = [];
    let plus = function() {
      let ____args = Array.prototype.slice.call(arguments);
      return flatten(____args);
    };
    return {
      "bind": bind,
      "unit": unit,
      "zero": zero,
      "plus": plus
    };
  }).call(this);
}).call(this);
const m_DASH_state = (function() {
  let bind,
    unit,
    zero,
    plus;
  return (function() {
    let bind = function(mv, mf) {
      return function(state) {
        return (function() {
          let GS__17 = mv(state);
          let value = GS__17[0];
          let newState = GS__17[1];
          return mf(value)(newState);
        }).call(this);
      };
    };
    let unit = function(v) {
      return function() {
        let ____args = Array.prototype.slice.call(arguments);
        return [v, ____args[0]];
      };
    };
    return {
      "bind": bind,
      "unit": unit,
      "zero": zero,
      "plus": plus
    };
  }).call(this);
}).call(this);
const m_DASH_continuation = (function() {
  let bind,
    unit,
    zero,
    plus;
  return (function() {
    let bind = function(mv, mf) {
      return function(cont) {
        return mv(function(value) {
          return mf(value)(cont);
        });
      };
    };
    let unit = function(value) {
      return function(cont) {
        return cont(value);
      };
    };
    return {
      "bind": bind,
      "unit": unit,
      "zero": zero,
      "plus": plus
    };
  }).call(this);
}).call(this);
////////////////////////////////////////////////////////////////////////////////
//fn: [run-cont] in file: stdlib.ky, line: 665
//Execute the computation cont
//in the cont monad and return its result.
const run_DASH_cont = function(cont) {
  return cont(identity);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [quote-str] in file: stdlib.ky, line: 672
//Add quotes around a string
const quote_DASH_str = function(s) {
  let out = "\"";
  for (let i = 0, ch = "", sz = count(s), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
    ch = s.charAt(i);
    if ( (ch === "\"") ) {
      out += "\\\"";
    } else {
      if ( (ch === "\n") ) {
        out += "\\n";
      } else {
        if ( (ch === "\t") ) {
          out += "\\t";
        } else {
          if ( (ch === "\f") ) {
            out += "\\f";
          } else {
            if ( (ch === "\r") ) {
              out += "\\r";
            } else {
              if ( (ch === "\v") ) {
                out += "\\v";
              } else {
                if ( (ch === "\\") ) {
                  out += (("u" === s.charAt((i + 1))) ?
                    ch :
                    "\\\\");
                } else {
                  if (true) {
                    out += ch;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return out += "\"";
};
////////////////////////////////////////////////////////////////////////////////
//fn: [unquote-str] in file: stdlib.ky, line: 689
//Removes quotes around a string
const unquote_DASH_str = function(s) {
  return ((s.startsWith("\"") && s.endsWith("\"")) ?
    (function() {
      let out = "";
      s = s.slice(1, -1);
      for (let i = 0, nx = "", ch = "", sz = count(s), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
        ch = s.charAt(i);
        if ( (ch === "\\") ) {
          ++i;
          nx = s.charAt(i);
          if ( (nx === "\"") ) {
            out += "\"";
          } else {
            if ( (nx === "\\") ) {
              out += "\\";
            } else {
              if ( (nx === "n") ) {
                out += "\n";
              } else {
                if ( (nx === "t") ) {
                  out += "\t";
                } else {
                  if ( (nx === "f") ) {
                    out += "\f";
                  } else {
                    if ( (nx === "v") ) {
                      out += "\v";
                    } else {
                      if ( (nx === "r") ) {
                        out += "\r";
                      } else {
                        if (true) {
                          out += ch;
                          --i;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          out += ch;
        }
      }
      return out;
    }).call(this) :
    s);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [escXml] in file: stdlib.ky, line: 713
//Escape XML special chars
const escXml = function(s) {
  let out = "";
  for (let i = 0, c = null, sz = count(s), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
    c = s[i];
    if ( (c === "&") ) {
      c = "&amp;";
    } else {
      if ( (c === ">") ) {
        c = "&gt;";
      } else {
        if ( (c === "<") ) {
          c = "&lt;";
        } else {
          if ( (c === "\"") ) {
            c = "&quot;";
          } else {
            if ( (c === "'") ) {
              c = "&apos;";
            } else {
              null;
            }
          }
        }
      }
    }
    out += c;
  }
  return out;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [split-seq] in file: stdlib.ky, line: 728
//Split a collection into 2 parts
const split_DASH_seq = function(coll, cnt) {
  return ((cnt < count(coll)) ?
    [Array.prototype.slice.call(coll, 0, cnt), Array.prototype.slice.call(coll, cnt)] :
    [Array.prototype.slice.call(coll, 0), []]);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [select-keys] in file: stdlib.ky, line: 734
//Get a subset of keys
const select_DASH_keys = function(coll, keys) {
  return seq(keys).reduce(function(acc, n) {
    acc[[n].join("")] = getProp(coll, [n].join(""));
    return acc;
  }, {});
};
////////////////////////////////////////////////////////////////////////////////
//fn: [doUpdateIn!] in file: stdlib.ky, line: 742
const doUpdateIn_BANG = function(coll, n, func, args, err) {
  let cur = (((typeof (n) === "number")) ?
    (((Array.isArray(coll)) && (n < coll.length)) ?
      getProp(coll, n) :
      err(n)) :
    (true ?
      getProp(coll, n) :
      null));
  let v = func.apply(this, cons(cur, args));
  return coll[n] = v;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [update-in!] in file: stdlib.ky, line: 752
//'Updates' a value in a nested associative structure, where ks is a
//sequence of keys and f is a function that will take the old value
//and any supplied args and return the new value, and returns a new
//nested structure.  If any levels do not exist, hash-maps will be
//created.
const update_DASH_in_BANG = function(coll, keys, func) {
  let xs = Array.prototype.slice.call(arguments, 3);
  let err = function() {
    let ____args = Array.prototype.slice.call(arguments);
    return (function() {
      throw new Error(["update-in! failed, bad nested keys: ", ____args[0]].join(""));
    }).call(this);
  };
  let root = coll;
  let end = (keys.length - 1);
  let m,
    n;
  for (let i = 0, ____break = false; ((!____break) && (i <= end)); i = (i + 1)) {
    n = keys[i];
    if ( (i === end) ) {
      doUpdateIn_BANG(root, n, func, xs, err);
    } else {
      if (( (typeof (n) === "number") )) {
        if ( (!((Array.isArray(root)) && (n < root.length))) ) {
          err(n);
        } else {
          root = getProp(root, n);
        }
      } else {
        if (true) {
          m = getProp(root, n);
          if (( (typeof (m) === "undefined") )) {
            m = {};
            root[n] = m;
          }
          if ( (!object_QUERY(m)) ) {
            err(n);
          } else {
            null;
          }
          root = m;
        }
      }
    }
  }
  return coll;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [get-in] in file: stdlib.ky, line: 784
//Returns the value in a nested associative structure,
//where ks is a sequence of keys. Returns nil if the key
//is not present, or the not-found value if supplied.
const get_DASH_in = function(coll, keys) {
  let root = coll;
  let ret = null;
  let end = (keys.length - 1);
  let m,
    n;
  for (let i = 0, ____break = false; ((!____break) && (i <= end)); i = (i + 1)) {
    n = keys[i];
    if (( (typeof (n) === "number") )) {
      if ( (!((Array.isArray(root)) && (n < root.length))) ) {
        ret = null;
        console.log("sdfdsgfdsgdsgd");
        ____break = true;
      } else {
        (root = getProp(root, n), ret = root);
      }
    } else {
      if (true) {
        (root = getProp(root, n), ret = root);
      }
    }
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [merge!] in file: stdlib.ky, line: 810
const merge_BANG = function(base, m) {
  let ret = (base || {});
  let src = (m || {});
  let GS__18 = src;
  Object.entries(GS__18).forEach(function(e) {
    return (function(v, k) {
      return ret[k] = v;
    })(getProp(e, 1), getProp(e, 0));
  });
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [merge] in file: stdlib.ky, line: 817
//Returns a map that consists of the rest of the maps conj-ed onto
//the first.  If a key occurs in more than one map, the mapping from
//the latter (left-to-right) will be the mapping in the result.
const merge = function() {
  let maps = Array.prototype.slice.call(arguments, 0);
  return maps.reduce(function(acc, n) {
    return merge_BANG(acc, n);
  }, {});
};
////////////////////////////////////////////////////////////////////////////////
//fn: [difference] in file: stdlib.ky, line: 826
//Return a set that is the first set
//without elements of the other set.
const difference = function(a, b) {
  let ret = [];
  let z = null;
  for (let i = 0, sz = count(a), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
    z = a[i];
    if ( (!contains_QUERY(b, z)) ) {
      conj_BANG(ret, z);
    } else {
      null;
    }
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [percent] in file: stdlib.ky, line: 839
const percent = function(numerator, denominator) {
  return (100 * (numerator / denominator));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [toFixed] in file: stdlib.ky, line: 843
const toFixed = function(num, digits) {
  digits = opt_QUERY__QUERY(digits, 2);
  return Number(num).toFixed(digits);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [ensureTest] in file: stdlib.ky, line: 850
const ensureTest = function(cnd, msg) {
  msg = (msg || "test");
  return (function() {
    try {
      return [(cnd ?
        "passed:" :
        "FAILED:"), " ", msg].join("");
    } catch (e) {
      return ["FAILED: ", msg].join("");
    }
  }).call(this);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [ensureTestThrown] in file: stdlib.ky, line: 856
const ensureTestThrown = function(expected, error, msg) {
  return (((error === null)) ?
    ["FAILED: ", msg].join("") :
    (((expected === typeof (error)) || (expected === "any")) ?
      ["passed: ", msg].join("") :
      ["FAILED: ", msg].join("")));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [runtest] in file: stdlib.ky, line: 865
const runtest = function(test) {
  let GS__19 = Array.prototype.slice.call(arguments, 1);
  let title = GS__19[0];
  title = opt_QUERY__QUERY(title, "test");
  let now = new Date();
  let results = test();
  let sum = count(results);
  let ok = count(results.filter(function() {
    let ____args = Array.prototype.slice.call(arguments);
    return ____args[0].startsWith("p");
  }));
  let ps = toFixed(percent(ok, sum));
  return ["+".repeat(78), title, now, "+".repeat(78), results.join("\n"), "=".repeat(78), ["Passed: ", ok, "/", sum, " [", ps, "%]"].join(""), ["Failed: ", (sum - ok)].join(""), ["CPU Time: ", (new Date() - now), "ms"].join("")].join("\n");
};
module.exports = {
  da57bc0172fb42438a11e6e8778f36fb: {
    ns: "czlab.kirby.stdlib",
    macros: {}
  },
  println: println,
  not_DASH_empty: not_DASH_empty,
  stringify: stringify,
  opt_QUERY__QUERY: opt_QUERY__QUERY,
  conj_BANG: conj_BANG,
  conj: conj,
  pop_BANG: pop_BANG,
  pop: pop,
  wrap_DASH_str: wrap_DASH_str,
  getProp: getProp,
  prn: prn,
  Atom: Atom,
  atom_QUERY: atom_QUERY,
  atom: atom,
  reset_BANG: reset_BANG,
  resetVec_BANG: resetVec_BANG,
  resetObject_BANG: resetObject_BANG,
  sort_BANG: sort_BANG,
  find: find,
  deref: deref,
  swap_BANG: swap_BANG,
  typeid: typeid,
  complex_QUERY: complex_QUERY,
  simple_QUERY: simple_QUERY,
  value_QUERY: value_QUERY,
  sequential_QUERY: sequential_QUERY,
  eq_QUERY: eq_QUERY,
  object_QUERY: object_QUERY,
  last: last,
  into_BANG: into_BANG,
  into: into,
  pairs_QUERY: pairs_QUERY,
  list_QUERY: list_QUERY,
  list: list,
  vector_QUERY: vector_QUERY,
  vector: vector,
  map_QUERY: map_QUERY,
  arraymap: arraymap,
  object: object,
  seq: seq,
  contains_QUERY: contains_QUERY,
  nichts_QUERY: nichts_QUERY,
  some_QUERY: some_QUERY,
  count: count,
  concat_STAR: concat_STAR,
  copyVector: copyVector,
  evens: evens,
  odds: odds,
  modulo: modulo,
  partition: partition,
  split_DASH_str: split_DASH_str,
  interleave: interleave,
  zipmap: zipmap,
  extendAttr: extendAttr,
  cons: cons,
  gensym: gensym,
  carve: carve,
  assoc_BANG: assoc_BANG,
  dissoc_BANG: dissoc_BANG,
  truthy_QUERY: truthy_QUERY,
  falsy_QUERY: falsy_QUERY,
  flatten: flatten,
  identity: identity,
  setnsp_BANG: setnsp_BANG,
  getnsp: getnsp,
  m_DASH_identity: m_DASH_identity,
  m_DASH_maybe: m_DASH_maybe,
  m_DASH_list: m_DASH_list,
  m_DASH_state: m_DASH_state,
  m_DASH_continuation: m_DASH_continuation,
  run_DASH_cont: run_DASH_cont,
  quote_DASH_str: quote_DASH_str,
  unquote_DASH_str: unquote_DASH_str,
  escXml: escXml,
  split_DASH_seq: split_DASH_seq,
  select_DASH_keys: select_DASH_keys,
  update_DASH_in_BANG: update_DASH_in_BANG,
  get_DASH_in: get_DASH_in,
  merge: merge,
  difference: difference,
  percent: percent,
  toFixed: toFixed,
  ensureTest: ensureTest,
  ensureTestThrown: ensureTestThrown,
  runtest: runtest
};