/*Auto generated by Kirby - v1.0.0 czlab.kirby.compiler Sat Dec 02 2017 02:17:35 GMT-0800 (PST)*/

const std = require("./stdlib");
const lambda_DASH_arg_QUERY = std["lambda_DASH_arg_QUERY"];
const hashmap = std["hashmap"];
const pairs_QUERY = std["pairs_QUERY"];
const contains_QUERY = std["contains_QUERY"];
const last = std["last"];
const typeid = std["typeid"];
const prn = std["prn"];
const primitive = std["primitive"];
const map_QUERY = std["map_QUERY"];
const vector_QUERY = std["vector_QUERY"];
const opt_QUERY__QUERY = std["opt_QUERY__QUERY"];
const some_QUERY = std["some_QUERY"];
const primitive_QUERY = std["primitive_QUERY"];
const not_DASH_empty = std["not_DASH_empty"];
const conj_BANG = std["conj_BANG"];
const list_QUERY = std["list_QUERY"];
const gensym = std["gensym"];
const count = std["count"];
const pop_BANG = std["pop_BANG"];
const slice = std["slice"];
const symbol = std["symbol"];
const keyword = std["keyword"];
const symbol_QUERY = std["symbol_QUERY"];
const keyword_QUERY = std["keyword_QUERY"];
const eng = require("./engine");
const parser = require("./parser");
const tnode = parser["tnode"];
const tnodeEx = parser["tnodeEx"];
const fs = require("fs");
const path = require("path");
const esfmt = require("esformatter");
const kirbystdlibref = std;
const ERRORS_DASH_MAP = {
  "invalid-fargs": "",
  "invalid-catch": "",
  "invalid-try": "",
  "invalid-include": "",
  "invalid-require": "",
  "invalid-namespace": "",
  "destruct-args": "",
  "file-access": "",
  "file-read": "",
  "file-open": "",
  "unknown-keyword": "",
  "invalid-arity": "",
  "invalid-meta": "",
  "syntax-error": "",
  "empty-form": ""
};
const XERRORS_DASH_MAP = {
  "e0": "Syntax Error",
  "e1": "Empty statement",
  "e2": "Invalid characters in function name",
  "e3": "End of File encountered, unterminated string",
  "e4": "Closing square bracket, without an opening square bracket",
  "e5": "End of File encountered, unterminated array",
  "e6": "Closing curly brace, without an opening curly brace",
  "e7": "End of File encountered, unterminated javascript object '}'",
  "e8": "End of File encountered, unterminated parenthesis",
  "e9": "Invalid character in var name",
  "e10": "Extra chars at end of file. Maybe an extra ')'.",
  "e11": "Cannot Open include File",
  "e12": "Invalid no of arguments to ",
  "e13": "Invalid Argument type to ",
  "e14": "End of File encountered, unterminated regular expression",
  "e15": "Invalid vararg position, must be last argument.",
  "e16": "Invalid arity (args > expected) to ",
  "e17": "Invalid arity (args < expected) to "
};
const MODULE_DASH_VERSION = "1.0.0";
var EXTERNS = null;
var SPEC_DASH_OPS = {};
var MATH_DASH_OP_DASH_REGEX = /^[-+][0-9]+$/;
////////////////////////////////////////////////////////////////////////////////
//name: [doFuncArgs] in file: compiler.ky near line: 74
const doFuncArgs = function(ast, args, env) {
  let ret = [tnode(), tnode()];
  let fargs = ret[0];
  let fdefs = ret[1];
  let pms = [];
  let e,
    ev,
    rval,
    out;
  for (let i = 0, sz = kirbystdlibref.count(args), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
    e = args[i];
    if (symbol_QUERY(e)) {
      if ( (e == "&") ) {
        (rval = tnode(), e = args[i + 1]);
        rval.add(["slice(arguments,", [i].join(""), ")"]);
        if (symbol_QUERY(e)) {
          fdefs.add(["let ", tx_STAR(e, env), "=", rval, ";\n"]);
        } else {
          (out = tnode(), e = destruct_STAR(e, out, env, ast));
          fdefs.add(["let ", tx_STAR(e, env), "=", rval, ";\n", out]);
        }
        ____break = true;
      } else {
        conj_BANG(pms, e);
      }
    } else {
      if (Array.isArray(e)) {
        (rval = tnode(), out = tnode(), e = destruct_STAR(e, out, env, ast));
        rval.add(["arguments[", [i].join(""), "]"]);
        conj_BANG(pms, e);
        fdefs.add(["let ", tx_STAR(e, env), "=", rval, ";\n", out]);
      } else {
        if (true) {
          error_BANG("destruct-args", ast);
        }
      }
    }
  }
  pms.forEach(function() {
    let ____args = Array.prototype.slice.call(arguments);
    return fargs.add(tx_STAR(____args[0], env));
  });
  fargs.join(",");
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//name: [destruct*] in file: compiler.ky near line: 112
const destruct_STAR = function(coll, out, env, ast) {
  let rhs = gensym();
  let e = null;
  for (let i = 0, sz = kirbystdlibref.count(coll), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
    e = coll[i];
    if ( (keyword_QUERY(e) && (e == "as")) ) {
      rhs = coll[i + 1];
    } else {
      ____break = true;
    }
  }
  if (map_QUERY(coll)) {
    out.add(destruct_DASH_Map(rhs, coll, env, ast));
  } else {
    if (vector_QUERY(coll)) {
      out.add(destruct_DASH_Vec(rhs, coll, env, ast));
    } else {
      null;
    }
  }
  return rhs;
};
////////////////////////////////////////////////////////////////////////////////
//name: [destruct-Vec] in file: compiler.ky near line: 129
const destruct_DASH_Vec = function(src, coll, env, ast) {
  src = tx_STAR(src, env);
  let e,
    rval,
    out;
  let ret = tnode();
  for (let i = 0, sz = kirbystdlibref.count(coll), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
    e = coll[i];
    if (symbol_QUERY(e)) {
      if ( (e == "_") ) {
        null;
      } else {
        if ( (e == "&") ) {
          (rval = tnode(), out = tnode(), e = coll[i + 1]);
          rval.add(["slice(", src, ",", [i].join(""), ")"]);
          if ( (!symbol_QUERY(e)) ) {
            e = destruct_STAR(e, out, env, ast);
          }
          ret.add(["let ", tx_STAR(e, env), "=", rval, ";\n", out]);
          ____break = true;
        } else {
          if (true) {
            out = tnode();
            out.add(["let ", tx_STAR(e, env), "=", src, "[", [i].join(""), "];\n", out]);
          }
        }
      }
    } else {
      if (Array.isArray(e)) {
        (rval = tnode(), out = tnode(), e = destruct_STAR(e, out, env, ast));
        rval.add([src, "[", [i].join(""), "]"]);
        ret.add(["let ", tx_STAR(e, env), "=", rval, ";\n", out]);
      } else {
        if (keyword_QUERY(e)) {
          if ( (e == "as") ) {
            ++i;
          } else {
            error_BANG("unknown-keyword", ast);
          }
        } else {
          if (true) {
            error_BANG("syntax-error", ast);
          }
        }
      }
    }
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//name: [destruct-Map] in file: compiler.ky near line: 171
const destruct_DASH_Map = function(src, coll, env, ast) {
  src = tx_STAR(src, env);
  let ret = tnode();
  let e,
    arr;
  for (let i = 0, sz = kirbystdlibref.count(coll), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
    e = coll[i];
    if (keyword_QUERY(e)) {
      if ( ((e == "keys") || (e == "strs")) ) {
        arr = coll[i + 1];
        ++i;
        for (let j = 0, sz = kirbystdlibref.count(arr), ____break = false; ((!____break) && (j < sz)); j = (j + 1)) {
          e = arr[j];
          ret.add(["let ", tx_STAR(e, env), "=", src, "[\"", [e].join(""), "\"];\n"]);
        }
      } else {
        if (true) {
          error_BANG("unknown-keyword", ast);
        }
      }
    } else {
      if (true) {
        error_BANG("syntax-error", ast);
      }
    }
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//name: [simple?] in file: compiler.ky near line: 197
const simple_QUERY = function(ast) {
  return ((typeof (ast) === "undefined") || (ast === null) || (typeof (ast) === "string") || (typeof (ast) === "number") || (typeof (ast) === "boolean"));
};
////////////////////////////////////////////////////////////////////////////////
//name: [wrap] in file: compiler.ky near line: 201
const wrap = function(ret, head, tail) {
  if (head) {
    ret.prepend(head);
  }
  ret.add(tail);
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//name: [exprHint] in file: compiler.ky near line: 207
const exprHint = function(ast, flag) {
  if (simple_QUERY(ast)) {
    ast = primitive(ast);
  }
  ast["____expr"] = flag;
  return ast;
};
////////////////////////////////////////////////////////////////////////////////
//name: [stmt?] in file: compiler.ky near line: 211
const stmt_QUERY = function(ast) {
  if (simple_QUERY(ast)) {
    error_BANG("syntax-error", ast);
  }
  return (false === ast.____expr);
};
////////////////////////////////////////////////////////////////////////////////
//name: [error!] in file: compiler.ky near line: 215
const error_BANG = function(e, ast) {
  let G____8 = Array.prototype.slice.call(arguments, 2);
  let msg = G____8[0];
  return (function() {
    throw new Error([ERRORS_DASH_MAP[e],(msg ?
      [" : ", msg].join("") :
      null),(ast.line ?
      ["\nline: ", ast.line].join("") :
      null),(ast.source ?
      ["\nfile: ", ast.source].join("") :
      null)].join("")) ;
  }).call(this);
};
////////////////////////////////////////////////////////////////////////////////
//name: [testre?] in file: compiler.ky near line: 222
const testre_QUERY = function(re, x) {
  return (x ?
    re.test(x) :
    null);
};
////////////////////////////////////////////////////////////////////////////////
//name: [pad] in file: compiler.ky near line: 225
const pad = function(n) {
  return " ".repeat(n);
};
////////////////////////////////////////////////////////////////////////////////
//name: [node'] in file: compiler.ky near line: 228
const node_QTE = function(ast) {
  let G____9 = Array.prototype.slice.call(arguments, 1);
  let obj = G____9[0];
  obj = opt_QUERY__QUERY(obj, tnode());
  (obj["source"] = ast.source, obj["line"] = ast.line, obj["column"] = ast.column);
  return obj;
};
////////////////////////////////////////////////////////////////////////////////
//name: [txTree] in file: compiler.ky near line: 235
const txTree = function(root, env) {
  let ret = node_QTE(root);
  let G__1 = root;
  for (let G__3 = 0, G__2 = false, ____break = false; ((!____break) && ((!G__2) && (G__3 < G__1.length))); G__3 = (G__3 + 1)) {
    let r = G__1[G__3];
    let t = tx_STAR(r, env);
    if ( (!true) ) {
      G__2 = true;
    }
    if ( ((!G__2) && some_QUERY(t)) ) {
      ret.add([t, "\n"]);
    }
  }
  null;
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//name: [txForm] in file: compiler.ky near line: 243
const txForm = function(expr, env) {
  return expr.forEach(function(a, i, arr) {
    return arr[i] = tx_STAR(a, env);
  });
};
////////////////////////////////////////////////////////////////////////////////
//name: [txAtom] in file: compiler.ky near line: 248
const txAtom = function(a) {
  let s = [a].join("");
  return (lambda_DASH_arg_QUERY(a) ?
    ["____args[", s, "]"].join("") :
    (keyword_QUERY(a) ?
      ["\"", s, "\""].join("") :
      (symbol_QUERY(a) ?
        parser.jsid(s) :
        ((a === null) ?
          "null" :
          (primitive_QUERY(a) ?
            (function() {
              a = a.value;
              return ((typeof (a) === "string") ?
                a :
                ((a === null) ?
                  "null" :
                  (true ?
                    [a].join("") :
                    null)));
            }).call(this) :
            (true ?
              s :
              null))))));
};
////////////////////////////////////////////////////////////////////////////////
//name: [tx*] in file: compiler.ky near line: 266
const tx_STAR = function(x) {
  let G____10 = Array.prototype.slice.call(arguments, 1);
  let env = G____10[0];
  return (Array.isArray(x) ?
    txPairs(x, env) :
    txAtom(x));
};
////////////////////////////////////////////////////////////////////////////////
//name: [gcmd] in file: compiler.ky near line: 271
const gcmd = function(ast) {
  return (map_QUERY(ast) ?
    "hashmap" :
    (vector_QUERY(ast) ?
      "vec" :
      (list_QUERY(ast) ?
        "list" :
        ((Array.isArray(ast) && symbol_QUERY(ast[0])) ?
          [ast[0]].join("") :
          (true ?
            "" :
            null)))));
};
////////////////////////////////////////////////////////////////////////////////
//name: [quoteSingle] in file: compiler.ky near line: 279
const quoteSingle = function(a) {
  return (keyword_QUERY(a) ?
    ["keyword(\":", a, "\")"].join("") :
    (symbol_QUERY(a) ?
      ["symbol(\"", a, "\")"].join("") :
      (primitive_QUERY(a) ?
        (function() {
          a = a.value;
          return ((typeof (a) === "string") ?
            a :
            ((a === null) ?
              "null" :
              (true ?
                [a].join("") :
                null)));
        }).call(this) :
        (true ?
          [a].join("") :
          null))));
};
////////////////////////////////////////////////////////////////////////////////
//name: [quote!] in file: compiler.ky near line: 292
const quote_BANG = function(ast, env) {
  return (Array.isArray(ast) ?
    (map_QUERY(ast) ?
      quoteMap(ast, env) :
      quoteBlock(ast, env)) :
    quoteSingle(ast));
};
////////////////////////////////////////////////////////////////////////////////
//name: [quoteMap] in file: compiler.ky near line: 300
const quoteMap = function(ast, env) {
  let comma = "";
  let ret = node_QTE(ast);
  for (let i = 0, sz = kirbystdlibref.count(ast), ____break = false; ((!____break) && (i < sz)); i = (i + 2)) {
    if ( (i > 0) ) {
      ret.add(",");
    }
    ret.add([quote_BANG(ast[i], env), " : ", quote_BANG(ast[i + 1], env)]);
  }
  if ( (!(0 === kirbystdlibref.count(ast))) ) {
    comma = ",";
  }
  return wrap(ret, ["[", "symbol(\"hashmap\")", comma], "]");
};
////////////////////////////////////////////////////////////////////////////////
//name: [quoteBlock] in file: compiler.ky near line: 312
const quoteBlock = function(ast, env) {
  let ret = node_QTE(ast);
  for (let i = 0, sz = kirbystdlibref.count(ast), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
    if ( (i > 0) ) {
      ret.add(",");
    }
    ret.add(quote_BANG(ast[i], env));
  }
  return wrap(ret, "[", "]");
};
////////////////////////////////////////////////////////////////////////////////
//name: [txPairs] in file: compiler.ky near line: 321
const txPairs = function(ast, env) {
  let stmtQ = stmt_QUERY(ast);
  let ret = node_QTE(ast);
  let cmd = gcmd(ast);
  let op = null;
  let tmp = null;
  let mc = eng.getMacro(cmd);
  if (mc) {
    (ast = eng.expandMacro(ast, env, mc), ast = exprHint(ast, (!stmtQ)), cmd = gcmd(ast));
  }
  if (parser.REGEX.int.test(cmd)) {
    let c0 = cmd.charAt(0);
    if ( ((c0 !== "-") && (c0 !== "+")) ) {
      cmd = ["+", cmd].join("");
    }
    (ast = [symbol(cmd.charAt(0)), ast[1], parseInt(cmd.slice(1))], cmd = [ast[0]].join(""));
  }
  op = SPEC_DASH_OPS[cmd];
  if ( (cmd == "with-meta") ) {
    tmp = ast[1];
    if ( (!simple_QUERY(tmp)) ) {
      tmp["____meta"] = evalMeta(ast[2], env);
      ret.add(tx_STAR(tmp, env));
    } else {
      error_BANG("invalid-meta", ast);
    }
  } else {
    if (cmd.startsWith(".-")) {
      ret.add([tx_STAR(ast[1], env), ".", tx_STAR(symbol(cmd.slice(2)), env)]);
    } else {
      if (cmd.startsWith(".@")) {
        let onemore_QUERY = false;
        let pos = 2;
        if (cmd.startsWith(".@+")) {
          ++pos;
          onemore_QUERY = true;
        }
        ret.add([tx_STAR(ast[1], env), "[", cmd.slice(pos),(onemore_QUERY ?
          "+1]" :
          "]")]);
      } else {
        if (cmd.startsWith(".")) {
          ret.add([tx_STAR(ast[1], env), cmd, "("]);
          for (let n = 2, sz = kirbystdlibref.count(ast), ____break = false; ((!____break) && (n < sz)); n = (n + 1)) {
            if ( (n !== 2) ) {
              ret.add(",");
            }
            ret.add(tx_STAR(ast[n], env));
          }
          ret.add(")");
        } else {
          if (some_QUERY(op)) {
            ret = op(ast, env);
          } else {
            if (true) {
              if (pairs_QUERY(ast)) {
                txForm(ast, env);
                cmd = [ast[0]].join("");
              } else {
                cmd = tx_STAR(ast, env);
              }
              if ( (!cmd) ) {
                error_BANG("empty-form", ast);
              }
              cmd = maybeStripStdlib(cmd);
              if (pairs_QUERY(ast)) {
                ret.add([(testre_QUERY(parser.REGEX.func, cmd) ?
                  tnodeEx(["(", cmd, ")"]) :
                  cmd), "(", tnodeEx(ast.slice(1)).join(","), ")"]);
              } else {
                ret.add(cmd);
              }
            }
          }
        }
      }
    }
  }
  return node_QTE(ast, ret);
};
////////////////////////////////////////////////////////////////////////////////
//name: [writeDoc] in file: compiler.ky near line: 391
//Convert to jsdoc
const writeDoc = function(doc) {
  let out = [];
  if (doc) {
    doc.replace(parser.REGEX.dquoteHat, "").replace(parser.REGEX.dquoteEnd, "").split("\\n").forEach(function() {
      let ____args = Array.prototype.slice.call(arguments);
      return (function() {
        let s = [____args[0]].join("").trim();
        return ((!(0 === kirbystdlibref.count(s))) ?
          conj_BANG(out, ["//", s, "\n"].join("")) :
          null);
      }).call(this);
    });
  }
  return out;
};
////////////////////////////////////////////////////////////////////////////////
//name: [txDo] in file: compiler.ky near line: 403
const txDo = function(ast, env) {
  let G____11 = Array.prototype.slice.call(arguments, 2);
  let return_QUERY = G____11[0];
  let stmtQ = stmt_QUERY(ast);
  let ret = node_QTE(ast);
  let e = null;
  let end = (ast.length - 1);
  return_QUERY = (stmtQ ?
    false :
    opt_QUERY__QUERY(return_QUERY, true));
  for (let i = 0, ____break = false; ((!____break) && (i < end)); i = (i + 1)) {
    e = exprHint(ast[i], false);
    ret.add([tx_STAR(e, env), ";\n"]);
  }
  if ( (end >= 0) ) {
    (e = exprHint(ast[end], (!stmtQ)), e = tx_STAR(e, env));
    ret.add(((!return_QUERY) ?
      [e, ";\n"] :
      ["return ", e, ";\n"]));
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//name: [sf-quote] in file: compiler.ky near line: 421
const sf_DASH_quote = function(ast, env) {
  if ( (!(kirbystdlibref.count(ast) === 2)) ) {
    error_BANG("invalid-arity", ast);
  }
  let ret = node_QTE(ast);
  return wrap(ret, null, quote_BANG(ast[1], env));
};
SPEC_DASH_OPS["quote"] = sf_DASH_quote;
////////////////////////////////////////////////////////////////////////////////
//name: [sf-deftype] in file: compiler.ky near line: 427
//Define a JS Class
const sf_DASH_deftype = function(ast, env) {
  if ( (!(kirbystdlibref.count(ast) >= 4)) ) {
    error_BANG("invalid-arity", ast);
  }
  let private_QUERY = [ast[0]].join("").endsWith("-");
  let czname = tx_STAR(ast[1], env);
  let par = ast[2][0];
  let czargs = ast[3];
  let ret = node_QTE(ast);
  let n,
    m,
    doc,
    mtds;
  if ( (typeof (ast[4]) === "string") ) {
    (doc = ast[4], mtds = Array.prototype.slice.call(ast, 5));
  } else {
    mtds = Array.prototype.slice.call(ast, 4);
  }
  ret.add(["class ", czname]);
  if (par) {
    ret.add([" extends ", tx_STAR(par, env)]);
  }
  ret.add(" {\n");
  for (let i = 0, pos = 0, sz = kirbystdlibref.count(mtds), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
    (m = mtds[i], pos = ((typeof (m[1]) === "string") ?
      3 :
      2));
    if ( (([m[0]].join("") == "constructor") && (!(0 === kirbystdlibref.count(czargs)))) ) {
      for (let x = 0, sz = kirbystdlibref.count(czargs), ____break = false; ((!____break) && (x < sz)); x = (x + 2)) {
        czargs[x] = ["\"", args[x], "\""].join("");
      }
      m.splice(pos, 0, [symbol("set-in!"), symbol("this")].concat(czargs));
    }
    m.unshift(symbol("method"));
    ret.add([sf_DASH_func(m, env, false), "\n"]);
  }
  ret.add("}\n");
  if (doc) {
    ret.prepend(writeDoc(doc));
  }
  if ( ((!private_QUERY) && (1 === eng.globalEnv().countNSPCache())) ) {
    EXTERNS[czname] = czname;
  }
  return ret;
};
SPEC_DASH_OPS["deftype"] = sf_DASH_deftype;
SPEC_DASH_OPS["deftype-"] = sf_DASH_deftype;
////////////////////////////////////////////////////////////////////////////////
//name: [sf-compOp] in file: compiler.ky near line: 471
const sf_DASH_compOp = function(ast, env) {
  if ( (!((kirbystdlibref.count(ast) >= 3) && (!(0 === mod(kirbystdlibref.count(ast), 2))))) ) {
    error_BANG("invalid-arity", ast);
  }
  let ret = node_QTE(ast);
  let cmd = [ast[0]].join("");
  if ( (cmd == "not=") ) {
    ast[0] = symbol("!==");
  } else {
    if ( (cmd == "=") ) {
      ast[0] = symbol("===");
    } else {
      null;
    }
  }
  for (let i = 0, op = tx_STAR(ast.shift(), env), ____break = false; ((!____break) && (i < (ast.length - 1))); i = (i + 1)) {
    ret.add(tnodeEx([tx_STAR(ast[i], env), " ", op, " ", tx_STAR(ast[i + 1], env)]));
  }
  ret.join(" && ");
  return wrap(ret, "(", ")");
};
SPEC_DASH_OPS["not="] = sf_DASH_compOp;
SPEC_DASH_OPS["!="] = sf_DASH_compOp;
SPEC_DASH_OPS["=="] = sf_DASH_compOp;
SPEC_DASH_OPS["="] = sf_DASH_compOp;
SPEC_DASH_OPS[">"] = sf_DASH_compOp;
SPEC_DASH_OPS[">="] = sf_DASH_compOp;
SPEC_DASH_OPS["<"] = sf_DASH_compOp;
SPEC_DASH_OPS["<="] = sf_DASH_compOp;
////////////////////////////////////////////////////////////////////////////////
//name: [sf-arithOp] in file: compiler.ky near line: 491
const sf_DASH_arithOp = function(ast, env) {
  let e1 = tx_STAR(ast.shift(), env);
  let op = "";
  let cmd = [e1].join("");
  let ret = node_QTE(ast);
  if ( (cmd == "bitwise-zrshift") ) {
    cmd = ">>>";
  } else {
    if ( (cmd == "bitwise-rshift") ) {
      cmd = ">>";
    } else {
      if ( (cmd == "bitwise-lshift") ) {
        cmd = "<<";
      } else {
        if ( (cmd == "bitwise-and") ) {
          cmd = "&";
        } else {
          if ( (cmd == "bitwise-or") ) {
            cmd = "|";
          } else {
            if ( (cmd == "bitwise-not") ) {
              cmd = "~";
            } else {
              if ( (cmd == "bitwise-xor") ) {
                cmd = "^";
              } else {
                if ( (cmd == "rem") ) {
                  cmd = "%";
                } else {
                  if ( (cmd == "div") ) {
                    cmd = "/";
                  } else {
                    if ( (cmd == "and") ) {
                      cmd = "&&";
                    } else {
                      if ( (cmd == "or") ) {
                        cmd = "||";
                      } else {
                        if ( (cmd == "exp") ) {
                          cmd = "**";
                        } else {
                          null;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if ( (1 === kirbystdlibref.count(ast)) ) {
    if ( ("-" == cmd) ) {
      ret.add("-");
    }
  } else {
    op = cmd;
  }
  ret.add(ast);
  if ( (kirbystdlibref.count(ast) > 1) ) {
    ret.join(op);
  }
  return wrap(ret, "(", ")");
};
SPEC_DASH_OPS["bitwise-lshift"] = sf_DASH_arithOp;
SPEC_DASH_OPS["bitwise-rshift"] = sf_DASH_arithOp;
SPEC_DASH_OPS["bitwise-zrshift"] = sf_DASH_arithOp;
SPEC_DASH_OPS["+"] = sf_DASH_arithOp;
SPEC_DASH_OPS["-"] = sf_DASH_arithOp;
SPEC_DASH_OPS["*"] = sf_DASH_arithOp;
SPEC_DASH_OPS["div"] = sf_DASH_arithOp;
SPEC_DASH_OPS["mod"] = sf_DASH_arithOp;
SPEC_DASH_OPS["or"] = sf_DASH_arithOp;
SPEC_DASH_OPS["and"] = sf_DASH_arithOp;
SPEC_DASH_OPS["exp"] = sf_DASH_arithOp;
SPEC_DASH_OPS["rem"] = sf_DASH_arithOp;
SPEC_DASH_OPS["bitwise-and"] = sf_DASH_arithOp;
SPEC_DASH_OPS["bitwise-or"] = sf_DASH_arithOp;
SPEC_DASH_OPS["bitwise-not"] = sf_DASH_arithOp;
SPEC_DASH_OPS["bitwise-xor"] = sf_DASH_arithOp;
////////////////////////////////////////////////////////////////////////////////
//name: [sf-do] in file: compiler.ky near line: 520
const sf_DASH_do = function(ast, env) {
  let ret = node_QTE(ast);
  let stmtQ = stmt_QUERY(ast);
  ret.add(txDo(exprHint(ast.slice(1), (!stmtQ)), env, (!stmtQ)));
  return (stmtQ ?
    wrap(ret, null, "") :
    wrap(ret, "(function() {\n", "}).call(this)"));
};
SPEC_DASH_OPS["do"] = sf_DASH_do;
////////////////////////////////////////////////////////////////////////////////
//name: [sf-case] in file: compiler.ky near line: 532
const sf_DASH_case = function(ast, env) {
  let stmtQ = stmt_QUERY(ast);
  let brk = ";\nbreak;\n";
  let ret = node_QTE(ast);
  let tst = ast[1];
  let _x = [gensym("C__")].join("");
  let e,
    t,
    c,
    dft;
  if ( (!(0 === mod(kirbystdlibref.count(ast), 2))) ) {
    dft = pop_BANG(ast)[0];
  }
  for (let i = 2, sz = kirbystdlibref.count(ast), ____break = false; ((!____break) && (i < sz)); i = (i + 2)) {
    (e = ast[i], c = ast[i + 1]);
    if (pairs_QUERY(e)) {
      for (let j = 0, sz = kirbystdlibref.count(e), ____break = false; ((!____break) && (j < sz)); j = (j + 1)) {
        ret.add(["case ", tx_STAR(e[j], env), ":\n"]);
        if ( (j === (e.length - 1)) ) {
          ret.add([_x, "=", tx_STAR(c, env), brk]);
        }
      }
    } else {
      ret.add(["case ", tx_STAR(e, env), ":\n", _x, "=", tx_STAR(c, env), brk]);
    }
  }
  if (dft) {
    ret.add(["default:\n", _x, "=", tx_STAR(dft, env), brk]);
  }
  wrap(ret, ["switch (", tx_STAR(tst, env), ") {\n"], "}");
  return (stmtQ ?
    wrap(ret, ["let ", _x, ";\n"], "") :
    wrap(ret, ["(function() { let ", _x, ";\n"], ["return ", _x, ";}).call(this)"]));
};
SPEC_DASH_OPS["case"] = sf_DASH_case;
////////////////////////////////////////////////////////////////////////////////
//name: [sf-vardefs] in file: compiler.ky near line: 568
const sf_DASH_vardefs = function(ast, env) {
  let ret = node_QTE(ast);
  let cmd = [ast[0]].join("");
  let kks = {};
  let private_QUERY = cmd.endsWith("-");
  if (cmd.startsWith("def")) {
    cmd = "var";
  } else {
    cmd = "let";
  }
  for (let i = 1, s = null, sz = kirbystdlibref.count(ast), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
    s = tx_STAR(ast[i], env);
    kks[s] = null;
    ret.add(s);
  }
  ret.join(",");
  wrap(ret, [cmd, " "].join(""), ";\n");
  if ( ((!private_QUERY) && (1 === eng.globalEnv().countNSPCache())) ) {
    let G__4 = kks;
    Object.entries(G__4).forEach(function(e) {
      return (function(v, k) {
        return EXTERNS[k] = k;
      })(e[1], e[0]);
    });
  }
  return ret;
};
SPEC_DASH_OPS["def~-"] = sf_DASH_vardefs;
SPEC_DASH_OPS["def~"] = sf_DASH_vardefs;
SPEC_DASH_OPS["var~"] = sf_DASH_vardefs;
////////////////////////////////////////////////////////////////////////////////
//name: [sf-var] in file: compiler.ky near line: 588
const sf_DASH_var = function(ast, env) {
  if ( (!(!(0 === mod(kirbystdlibref.count(ast), 2)))) ) {
    error_BANG("invalid-arity", ast);
  }
  let ret = node_QTE(ast);
  let cmd = [ast[0]].join("");
  let keys = [];
  let tmp = null;
  let vname = null;
  let private_QUERY = ((cmd !== "const") && (cmd !== "def"));
  let rval,
    rc,
    lhs,
    rhs;
  (ast = ast.slice(1), cmd = (cmd.startsWith("const") ?
    "const" :
    ((cmd == "var") ?
      "let" :
      "var")));
  for (let i = 0, sz = kirbystdlibref.count(ast), ____break = false; ((!____break) && (i < sz)); i = (i + 2)) {
    (lhs = ast[i], rhs = ast[i + 1], rval = tx_STAR(rhs, env));
    if (symbol_QUERY(lhs)) {
      (lhs = tx_STAR(lhs, env), tmp = [cmd, " ", lhs, "=", rval, ";\n"]);
      conj_BANG(keys, lhs);
      ret.add(tmp);
    } else {
      (out = tnode(), rhs = destruct_STAR(lhs, out, env, ast));
      ret.add(["let ", tx_STAR(rhs, env), "=", rval, ";\n", out]);
    }
  }
  if ( ((!private_QUERY) && (1 === eng.globalEnv().countNSPCache())) ) {
    keys.forEach(function(k) {
      return EXTERNS[k] = k;
    });
  }
  return ret;
};
SPEC_DASH_OPS["const-"] = sf_DASH_var;
SPEC_DASH_OPS["const"] = sf_DASH_var;
SPEC_DASH_OPS["def-"] = sf_DASH_var;
SPEC_DASH_OPS["def"] = sf_DASH_var;
SPEC_DASH_OPS["var"] = sf_DASH_var;
////////////////////////////////////////////////////////////////////////////////
//name: [sf-inst?] in file: compiler.ky near line: 626
const sf_DASH_inst_QUERY = function(ast, env) {
  if ( (!(kirbystdlibref.count(ast) === 3)) ) {
    error_BANG("invalid-arity", ast);
  }
  let ret = node_QTE(ast);
  return wrap(ret, null, ["(", tx_STAR(ast[2], env), " instanceof ", tx_STAR(ast[1], env), ")"]);
};
SPEC_DASH_OPS["inst?"] = sf_DASH_inst_QUERY;
////////////////////////////////////////////////////////////////////////////////
//name: [sf-delete] in file: compiler.ky near line: 634
const sf_DASH_delete = function(ast, env) {
  if ( (!((kirbystdlibref.count(ast) >= 2) && (kirbystdlibref.count(ast) < 4))) ) {
    error_BANG("invalid-arity", ast);
  }
  let ret = node_QTE(ast);
  ret.add(["delete ", tx_STAR(ast[1], env)]);
  if ( (kirbystdlibref.count(ast) > 2) ) {
    ret.add(["[", tx_STAR(ast[2], env), "]"]);
  }
  return ret;
};
SPEC_DASH_OPS["delete!"] = sf_DASH_delete;
////////////////////////////////////////////////////////////////////////////////
//name: [sf-new] in file: compiler.ky near line: 645
const sf_DASH_new = function(ast, env) {
  let ret = node_QTE(ast);
  return wrap(ret, "new ", tx_STAR(ast.slice(1), env));
};
SPEC_DASH_OPS["new"] = sf_DASH_new;
////////////////////////////////////////////////////////////////////////////////
//name: [sf-throw] in file: compiler.ky near line: 651
const sf_DASH_throw = function(ast, env) {
  let ret = node_QTE(ast);
  let stmtQ = stmt_QUERY(ast);
  ret.add(["throw ", tx_STAR(ast[1], env)]);
  if ( (!stmtQ) ) {
    wrap(ret, "(function (){ ", ";}).call(this)");
  }
  return ret;
};
SPEC_DASH_OPS["throw"] = sf_DASH_throw;
////////////////////////////////////////////////////////////////////////////////
//name: [sf-x-opop] in file: compiler.ky near line: 662
const sf_DASH_x_DASH_opop = function(ast, env) {
  if ( (!(kirbystdlibref.count(ast) === 2)) ) {
    error_BANG("invalid-arity", ast);
  }
  let ret = node_QTE(ast);
  let cmd = [ast[0]].join("");
  let a2 = tx_STAR(ast[1], env);
  if (cmd.endsWith("$")) {
    ret.add([a2, cmd.slice(0, -1)]);
  } else {
    ret.add([cmd, a2]);
  }
  return ret;
};
SPEC_DASH_OPS["++"] = sf_DASH_x_DASH_opop;
SPEC_DASH_OPS["--"] = sf_DASH_x_DASH_opop;
SPEC_DASH_OPS["++$"] = sf_DASH_x_DASH_opop;
SPEC_DASH_OPS["--$"] = sf_DASH_x_DASH_opop;
////////////////////////////////////////////////////////////////////////////////
//name: [sf-x-eq] in file: compiler.ky near line: 673
const sf_DASH_x_DASH_eq = function(ast, env) {
  if ( (!(kirbystdlibref.count(ast) === 3)) ) {
    error_BANG("invalid-arity", ast);
  }
  let cmd = [ast[0]].join("");
  let ret = node_QTE(ast);
  if ( (cmd == "bitwise-zrshift=") ) {
    cmd = ">>>=";
  } else {
    if ( (cmd == "bitwise-rshift=") ) {
      cmd = ">>=";
    } else {
      if ( (cmd == "bitwise-lshift=") ) {
        cmd = "<<=";
      } else {
        if ( (cmd == "bitwise-xor=") ) {
          cmd = "^=";
        } else {
          if ( (cmd == "bitwise-or=") ) {
            cmd = "|=";
          } else {
            if ( (cmd == "bitwise-and=") ) {
              cmd = "&=";
            } else {
              if ( (cmd == "div=") ) {
                cmd = "/=";
              } else {
                if ( (cmd == "rem=") ) {
                  cmd = "%=";
                } else {
                  if ( (cmd == "exp=") ) {
                    cmd = "**=";
                  } else {
                    null;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return wrap(ret, null, [tx_STAR(ast[1], env), " ", cmd, " ", tx_STAR(ast[2], env)]);
};
SPEC_DASH_OPS["+="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS["-="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS["*="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS["div="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS["rem="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS["exp="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS["bitwise-and="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS["bitwise-or="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS["bitwise-xor="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS["bitwise-lshift="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS["bitwise-rshift="] = sf_DASH_x_DASH_eq;
SPEC_DASH_OPS["bitwise-zrshift="] = sf_DASH_x_DASH_eq;
////////////////////////////////////////////////////////////////////////////////
//name: [sf-set-in] in file: compiler.ky near line: 703
const sf_DASH_set_DASH_in = function(ast, env) {
  if ( (!(0 === mod(kirbystdlibref.count(ast), 2))) ) {
    error_BANG("invalid-arity", ast);
  }
  let ret = node_QTE(ast);
  let more = false;
  let obj = tx_STAR(ast[1], env);
  for (let i = 2, sz = kirbystdlibref.count(ast), ____break = false; ((!____break) && (i < sz)); i = (i + 2)) {
    if ( (i > 2) ) {
      ret.add(",");
      more = true;
    }
    ret.add([obj, "[", tx_STAR(ast[i], env), "]", "=", tx_STAR(ast[i + 1], env)]);
  }
  if (more) {
    wrap(ret, "(", ")");
  }
  return ret;
};
SPEC_DASH_OPS["set-in!"] = sf_DASH_set_DASH_in;
SPEC_DASH_OPS["=>>"] = sf_DASH_set_DASH_in;
////////////////////////////////////////////////////////////////////////////////
//name: [sf-set] in file: compiler.ky near line: 721
const sf_DASH_set = function(ast, env) {
  if ( (!(!(0 === mod(kirbystdlibref.count(ast), 2)))) ) {
    error_BANG("invalid-arity", ast);
  }
  let more = false;
  let ret = node_QTE(ast);
  for (let i = 1, sz = kirbystdlibref.count(ast), ____break = false; ((!____break) && (i < sz)); i = (i + 2)) {
    if ( (i > 1) ) {
      ret.add(",");
      more = true;
    }
    ret.add([tx_STAR(ast[i], env), "=", tx_STAR(ast[i + 1], env)]);
  }
  if (more) {
    wrap(ret, "(", ")");
  }
  return ret;
};
SPEC_DASH_OPS["set!"] = sf_DASH_set;
SPEC_DASH_OPS["=>"] = sf_DASH_set;
////////////////////////////////////////////////////////////////////////////////
//name: [meta??] in file: compiler.ky near line: 737
const meta_QUERY__QUERY = function(obj, env) {
  let mobj = null;
  if ( (Array.isArray(obj) && (3 === kirbystdlibref.count(obj)) && ("with-meta" == [obj[0]].join(""))) ) {
    mobj = evalMeta(obj[2], env);
    obj[1]["____meta"] = mobj;
    obj = obj[1];
  }
  return [mobj, obj];
};
////////////////////////////////////////////////////////////////////////////////
//name: [sf-fn] in file: compiler.ky near line: 749
//(fn [x y] ...)
const sf_DASH_fn = function(ast, env) {
  let ret = node_QTE(ast);
  let fargs = null;
  let body = Array.prototype.slice.call(ast, 2);
  let G____12 = meta_QUERY__QUERY(ast[1], env);
  let args = G____12[1];
  if ( (!Array.isArray(args)) ) {
    error_BANG("invalid-fargs", ast);
  }
  fargs = doFuncArgs(ast, args, env);
  return wrap(ret, null, ["function (", fargs[0], ") {\n", fargs[1], txDo(body, env, true), "}"]);
};
SPEC_DASH_OPS["fn"] = sf_DASH_fn;
////////////////////////////////////////////////////////////////////////////////
//name: [fmtRegoSpecOps] in file: compiler.ky near line: 765
const fmtRegoSpecOps = function(alias, fname) {
  return [parser.jsid("SPEC-OPS"), "[\"", alias, "\"] = ", fname].join("");
};
////////////////////////////////////////////////////////////////////////////////
//name: [fmtSpecOps] in file: compiler.ky near line: 769
const fmtSpecOps = function(fname, attrs) {
  let ks = (attrs["opcode"] || []);
  let out = ks.map(function() {
    let ____args = Array.prototype.slice.call(arguments);
    return fmtRegoSpecOps([____args[0]].join(""), fname);
  }).join(";\n");
  return ((!(0 === kirbystdlibref.count(ks))) ?
    [out, ";\n"].join("") :
    out);
};
////////////////////////////////////////////////////////////////////////////////
//name: [writeFuncInfo] in file: compiler.ky near line: 776
const writeFuncInfo = function(fname, src) {
  let file = ast.source.slice((ast.source.lastIndexOf("/") + 1));
  let s = ["//fn: [", fname, "] in file: ", file, ",line: ", ast.line, "\n"].join("");
  let len = s.length;
  if ( (len < 80) ) {
    len = 80;
  }
  return (function() {
    let G__5 = tnodeEx(["/".repeat(len), "\n"].join(""));
    G__5.add(s);
    return G__5;
  }).call(this);
};
////////////////////////////////////////////////////////////////////////////////
//name: [sf-func] in file: compiler.ky near line: 787
const sf_DASH_func = function(ast, env) {
  let fname0 = [ast[0]].join("");
  let mtd_QUERY = (fname0 == "method");
  let private_QUERY = fname0.endsWith("-");
  let fname = tx_STAR(ast[1], env);
  let dot_QUERY = contains_QUERY(fname, ".");
  let fargs = null;
  let ret = node_QTE(ast);
  let G____13 = ((typeof (ast[2]) === "string") ?
    [ast[2], 3] :
    [null, 2]);
  let doc = G____13[0];
  let pargs = G____13[1];
  let body = Array.prototype.slice.call(ast, (pargs + 1));
  let G____14 = meta_QUERY__QUERY(ast[pargs], env);
  let hints = G____14[0];
  let args = G____14[1];
  if ( (!Array.isArray(args)) ) {
    error_BANG("invalid-fargs", ast);
  }
  fargs = doFuncArgs(ast, args, env);
  if (mtd_QUERY) {
    if (hints.static) {
      ret.add("static ");
    }
    ret.add([fname, " ("]);
    if ( (fname == "constructor") ) {
      conj_BANG(body, symbol("this"));
    }
  } else {
    if (dot_QUERY) {
      ret.add([fname, " = function ("]);
    } else {
      if (true) {
        ret.add(["const ", fname, " = function ("]);
      }
    }
  }
  ret.add([fargs[0], ") {\n", fargs[1], txDo(body, env, true), "};\n"]);
  if ( (!(0 === kirbystdlibref.count(hints))) ) {
    ret.add(fmtSpecOps(fname, hints));
  }
  if (doc) {
    ret.prepend(writeDoc(doc));
  }
  ret.prepend(writeFuncInfo(fname0, ast));
  if ( ((!private_QUERY) && (!dot_QUERY) && (!mtd_QUERY) && (1 === eng.globalEnv().countNSPCache())) ) {
    EXTERNS[fname] = fname;
  }
  return ret;
};
SPEC_DASH_OPS["defn"] = sf_DASH_func;
SPEC_DASH_OPS["defn-"] = sf_DASH_func;
////////////////////////////////////////////////////////////////////////////////
//name: [sf-try] in file: compiler.ky near line: 826
const sf_DASH_try = function(ast, env) {
  let stmtQ = stmt_QUERY(ast);
  let sz = kirbystdlibref.count(ast);
  let ret = node_QTE(ast);
  let t,
    f,
    c;
  f = last(ast);
  if ( (Array.isArray(f) && ("finally" == [f[0]].join(""))) ) {
    (f = pop_BANG(ast)[0], sz = kirbystdlibref.count(ast));
  } else {
    f = null;
  }
  c = null;
  if ( (sz > 1) ) {
    c = ast[(sz - 1)];
  }
  if ( (Array.isArray(c) && ("catch" == [c[0]].join(""))) ) {
    if ( ((kirbystdlibref.count(c) < 2) || (!symbol_QUERY(c[1]))) ) {
      error_BANG("invalid-catch", ast);
    }
    c = pop_BANG(ast)[0];
  } else {
    c = null;
  }
  if ( ((f === null) && (c === null)) ) {
    error_BANG("invalid-try", ast);
  }
  ret.add(["try {\n", txDo(exprHint(ast.slice(1), (!stmtQ)), env), "\n}"]);
  if (c) {
    t = c[1];
    ret.add([["catch (", t, ") {\n"].join(""), txDo(exprHint(Array.prototype.slice.call(c, 2), (!stmtQ)), env), ";\n}\n"]);
  }
  if (f) {
    ret.add(["finally {\n", txDo(exprHint(f.slice(1), false), env, false), ";\n}\n"]);
  }
  if ( (!stmtQ) ) {
    wrap(ret, "(function(){\n", "}).call(this)");
  }
  return ret;
};
SPEC_DASH_OPS["try"] = sf_DASH_try;
////////////////////////////////////////////////////////////////////////////////
//name: [sf-if] in file: compiler.ky near line: 867
const sf_DASH_if = function(ast, env) {
  let stmtQ = stmt_QUERY(ast);
  let ret = node_QTE(ast);
  let a1 = exprHint(ast[1], (!stmtQ));
  let a2 = exprHint(ast[2], (!stmtQ));
  let a3 = ((kirbystdlibref.count(ast) > 3) ?
    ast[3] :
    null);
  let elze = (a3 ?
    exprHint(a3, (!stmtQ)) :
    null);
  (a1 = tx_STAR(a1, env), a2 = tx_STAR(a2, env), elze = tx_STAR(elze, env));
  return wrap(ret, null, (stmtQ ?
    ["if (", a1, ") {\n", a2, ";\n}",(a3 ?
      tnodeEx([" else { \n", elze, ";\n}"]) :
      "")] :
    ["(", a1, " ?\n", a2, " :\n",(elze || "null"), ")"]));
};
SPEC_DASH_OPS["if"] = sf_DASH_if;
////////////////////////////////////////////////////////////////////////////////
//name: [sf-get] in file: compiler.ky near line: 886
const sf_DASH_get = function(ast, env) {
  if ( (!(kirbystdlibref.count(ast) === 3)) ) {
    error_BANG("invalid-arity", ast);
  }
  let ret = node_QTE(ast);
  return wrap(ret, null, [tx_STAR(ast[1], env), "[", tx_STAR(ast[2], env), "]"]);
};
SPEC_DASH_OPS["nth"] = sf_DASH_get;
SPEC_DASH_OPS["get"] = sf_DASH_get;
////////////////////////////////////////////////////////////////////////////////
//name: [sf-array] in file: compiler.ky near line: 892
const sf_DASH_array = function(ast, env) {
  let ret = node_QTE(ast);
  if ( (0 === kirbystdlibref.count(ast)) ) {
    ret.add("[]");
  } else {
    if ( (!vector_QUERY(ast)) ) {
      ast.splice(0, 1);
    }
    ret.add("[\n");
    for (let i = 0, sz = kirbystdlibref.count(ast), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
      if ( (i > 0) ) {
        ret.add(",\n");
      }
      ret.add(tx_STAR(ast[i], env));
    }
    ret.add("\n]");
  }
  return ret;
};
SPEC_DASH_OPS["vec"] = sf_DASH_array;
////////////////////////////////////////////////////////////////////////////////
//name: [sf-object] in file: compiler.ky near line: 906
const sf_DASH_object = function(ast, env) {
  let ret = node_QTE(ast);
  if ( (0 === kirbystdlibref.count(ast)) ) {
    ret.add("{}");
  } else {
    if ( (!map_QUERY(ast)) ) {
      ast.splice(0, 1);
    }
    ret.add("{\n");
    for (let i = 0, sz = kirbystdlibref.count(ast), ____break = false; ((!____break) && (i < sz)); i = (i + 2)) {
      if ( (i > 0) ) {
        ret.add(",\n");
      }
      ret.add([tx_STAR(ast[i], env), ": ", tx_STAR(ast[i + 1], env)]);
    }
    ret.add("\n}");
  }
  return ret;
};
SPEC_DASH_OPS["hashmap"] = sf_DASH_object;
var icache = [];
////////////////////////////////////////////////////////////////////////////////
//name: [includeFile] in file: compiler.ky near line: 924
const includeFile = function(fname) {
  return (contains_QUERY(icache, fname) ?
    tnode() :
    (function() {
      let src = fs.readFileSync(fname, "utf-8");
      conj_BANG(icache, fname);
      return txTree(parser.parser(src, fname), eng.globalEnv());
    }).call(this));
};
////////////////////////////////////////////////////////////////////////////////
//name: [sf-include] in file: compiler.ky near line: 932
const sf_DASH_include = function(ast, env) {
  let ret = [];
  let dir = path.dirname(ast.source);
  let fname,
    e;
  for (let i = 1, sz = kirbystdlibref.count(ast), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
    e = ast[i];
    if ( ((!Array.isArray(e)) || (1 !== kirbystdlibref.count(e))) ) {
      error_BANG("invalid-include", ast);
    }
    fname = [e[0]].join("");
    if (fname) {
      fname = fname.replace(/[\"]/g, "");
    }
    try {
      fname = fs.realpathSync([dir, "/", fname].join(""));
    } catch (e) {
      error_BANG("file-access", ast);
    }
    try {
      conj_BANG(ret, includeFile(fname));
    } catch (e) {
      error_BANG("file-read", ast);
    }
    finally {
      eng.globalEnv().popNSP();
    }
  }
  return ((0 === kirbystdlibref.count(ret)) ?
    tnode() :
    ret);
};
////////////////////////////////////////////////////////////////////////////////
//name: [sf-require] in file: compiler.ky near line: 959
const sf_DASH_require = function(ast, env) {
  let as,
    path,
    v,
    e,
    refers,
    renames;
  let ret = node_QTE(ast);
  for (let i = 1, sz = kirbystdlibref.count(ast), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
    (e = ast[i], as = [gensym("R__")].join(""), refers = null, renames = null);
    if ( ((!Array.isArray(e)) || (kirbystdlibref.count(e) < 3)) ) {
      error_BANG("invalid-require", ast);
    }
    path = [e[0]].join("");
    for (let j = 1, sz = kirbystdlibref.count(e), ____break = false; ((!____break) && (j < sz)); j = (j + 1)) {
      v = e[j];
      if ( (v == "as") ) {
        as = [e[j + 1]].join("");
        ++j;
      } else {
        if ( (v == "refer") ) {
          refers = e[j + 1];
          ++j;
        } else {
          if ( (v == "rename") ) {
            renames = e[j + 1];
            ++j;
          } else {
            null;
          }
        }
      }
    }
    ret.add(["const ", parser.jsid(as), "= require(", tx_STAR(path, env), ");\n"]);
    for (let i = 0, sz = kirbystdlibref.count(refers), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
      v = tx_STAR(refers[i], env);
      ret.add(["const ", v, "=", as, "[\"", v, "\"];\n"]);
    }
    for (let i = 0, sz = kirbystdlibref.count(renames), ____break = false; ((!____break) && (i < sz)); i = (i + 2)) {
      (e = tx_STAR(renames[i], env), v = tx_STAR(renames[i + 1], env));
      ret.add(["const ", v, "=", as, "[\"", e, "\"];\n"]);
    }
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//name: [evalMeta] in file: compiler.ky near line: 996
const evalMeta = function(ast, env) {
  return (Array.isArray(ast) ?
    JSON.parse([tx_STAR(ast, env)].join("")) :
    (keyword_QUERY(ast) ?
      JSON.parse([tx_STAR([ast, true], env)].join("")) :
      (symbol_QUERY(ast) ?
        JSON.parse([tx_STAR([symbol("tag"), ast], env)].join("")) :
        (true ?
          error_BANG("invalid-meta", ast) :
          null))));
};
////////////////////////////////////////////////////////////////////////////////
//name: [sf-ns] in file: compiler.ky near line: 1012
const sf_DASH_ns = function(ast, env) {
  if ( (!(kirbystdlibref.count(ast) >= 2)) ) {
    error_BANG("invalid-arity", ast);
  }
  let ret = [];
  let e = null;
  let G____15 = meta_QUERY__QUERY(ast[1], env);
  let hints = G____15[0];
  let nsp = G____15[1];
  if ( (!symbol_QUERY(nsp)) ) {
    error_BANG("invalid-namespace", ast);
  }
  eng.globalEnv().pushNSP([nsp].join(""));
  ast = Array.prototype.slice.call(ast, 2);
  for (let i = 0, sz = kirbystdlibref.count(ast), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
    e = ast[i];
    if ( (pairs_QUERY(e) && ("include" == [e[0]].join(""))) ) {
      conj_BANG(ret, sf_DASH_include(e));
    } else {
      if ( (pairs_QUERY(e) && ("require" == [e[0]].join(""))) ) {
        conj_BANG(ret, sf_DASH_require(e));
      } else {
        null;
      }
    }
  }
  nsp = eng.globalEnv().peekNSP();
  if ( ((nsp === "czlab.kirby.macros") || (nsp === "czlab.kirby.stdlib")) ) {
    null;
  } else {
    if (nsp.startsWith("czlab.kirby.")) {
      conj_BANG(ret, tnodeEx("const kirbystdlibref=std;\n"));
    } else {
      if (true) {
        conj_BANG(ret, sf_DASH_require([kirbystdlibref.symbol("require"), ["kirby", kirbystdlibref.keyword(":as"), kirbystdlibref.symbol("kirbystdlibref")]]));
      }
    }
  }
  return ret;
};
SPEC_DASH_OPS["ns"] = sf_DASH_ns;
////////////////////////////////////////////////////////////////////////////////
//name: [maybeStripStdlib] in file: compiler.ky near line: 1043
const maybeStripStdlib = function(cmd) {
  let lib = "kirbystdlibref.";
  let nsp = eng.globalEnv().peekNSP();
  cmd = [cmd].join("");
  return ((cmd.startsWith(lib) && (nsp === "czlab.kirby.stdlib")) ?
    cmd.slice(lib.length) :
    cmd);
};
////////////////////////////////////////////////////////////////////////////////
//name: [sf-comment] in file: compiler.ky near line: 1053
const sf_DASH_comment = function(ast, env) {
  return node_QTE(ast);
};
SPEC_DASH_OPS["comment"] = sf_DASH_comment;
////////////////////////////////////////////////////////////////////////////////
//name: [sf-for] in file: compiler.ky near line: 1056
const sf_DASH_for = function(ast, env) {
  let stmtQ = stmt_QUERY(ast);
  let ret = node_QTE(ast);
  let body = exprHint(Array.prototype.slice.call(ast, 2), false);
  if ( (0 === kirbystdlibref.count(body)) ) {
    tnode();
  } else {
    sf_DASH_floop(ret, ast[1], body, env, stmtQ);
  }
  return ret;
};
SPEC_DASH_OPS["for"] = sf_DASH_for;
////////////////////////////////////////////////////////////////////////////////
//name: [sf-floop] in file: compiler.ky near line: 1065
const sf_DASH_floop = function(ret, args, body, env, stmtQ) {
  let vars = [];
  let recurs = [];
  let tst,
    nb,
    e;
  for (let i = 0, sz = kirbystdlibref.count(args), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
    e = args[i];
    if ( (e == "while") ) {
      tst = args[i + 1];
      ++i;
    } else {
      if ( (e == "recur") ) {
        recurs = Array.prototype.slice.call(args, (i + 1));
        ____break = true;
      } else {
        if (symbol_QUERY(e)) {
          conj_BANG(vars, e, args[i + 1]);
          ++i;
        } else {
          null;
        }
      }
    }
  }
  ret.add("for (");
  for (let i = 0, sz = kirbystdlibref.count(vars), ____break = false; ((!____break) && (i < sz)); i = (i + 2)) {
    if ( (i === 0) ) {
      ret.add("let ");
    }
    if ( (i !== 0) ) {
      ret.add(",");
    }
    ret.add([tx_STAR(vars[i], env), "=", tx_STAR(vars[i + 1], env)]);
  }
  ret.add(((0 === kirbystdlibref.count(vars)) ?
    "let ____break=false;" :
    ",____break=false;"));
  nb = [kirbystdlibref.symbol("not"), kirbystdlibref.symbol("____break")];
  if (tst) {
    tst = [symbol("and"), nb, tst];
  } else {
    tst = nb;
  }
  ret.add([tx_STAR(tst, env), "; "]);
  for (let i = 0, k = 0, sz = kirbystdlibref.count(recurs), ____break = false; ((!____break) && (i < sz)); i = (i + 1), k = (k + 2)) {
    if ( (i !== 0) ) {
      ret.add(",");
    }
    ret.add([tx_STAR(vars[k], env), "=", tx_STAR(recurs[i], env)]);
  }
  ret.add(["){\n", txDo(body, env, false), "}\n"]);
  if ( (!stmtQ) ) {
    wrap(ret, "(function() {\n", "}).call(this)");
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//name: [sf-jscode] in file: compiler.ky near line: 1103
const sf_DASH_jscode = function(ast, env) {
  return node_QTE(ast, tnodeEx([ast[1]].join("").replace(parser.REGEX.dquoteHat, "").replace(parser.REGEX.dquoteEnd, "")));
};
SPEC_DASH_OPS["js#"] = sf_DASH_jscode;
////////////////////////////////////////////////////////////////////////////////
//name: [sf-macro] in file: compiler.ky near line: 1110
const sf_DASH_macro = function(ast, env) {
  let pms = [];
  let args = ast[2];
  let body = Array.prototype.slice.call(ast, 3);
  let doc,
    x,
    e,
    ev;
  if ( (typeof (args) === "string") ) {
    (doc = args, args = ast[3], body = Array.prototype.slice.call(ast, 4));
  }
  for (let i = 0, sz = kirbystdlibref.count(args), ____break = false; ((!____break) && (i < sz)); i = (i + 1)) {
    (e = args[i], ev = [e].join(""));
    if ( (ev === "&") ) {
      if (Array.isArray(args[i + 1])) {
        e = args[i + 1];
        ++i;
        for (let j = 0, sz = kirbystdlibref.count(e), ____break = false; ((!____break) && (j < sz)); j = (j + 1)) {
          x = e[j];
          if ( (!symbol_QUERY(x)) ) {
            error_BANG("syntax-error", ast);
          }
          conj_BANG(pms, x);
        }
      } else {
        conj_BANG(pms, e, args[i + 1]);
        ++i;
      }
    } else {
      if ( (!symbol_QUERY(e)) ) {
        error_BANG("syntax-error", ast);
      } else {
        if (true) {
          conj_BANG(pms, e);
        }
      }
    }
  }
  ast = [ast[0], ast[1], [symbol("fn*"), pms].concat(body)];
  let a1 = [ast[1]].join("");
  let a2 = ast[2];
  let func = eng.compute(a2, env);
  (func["____macro"] = true, func["____doc"] = doc);
  eng.setMacro(a1, func);
  return node_QTE(ast, tnode());
};
SPEC_DASH_OPS["defmacro"] = sf_DASH_macro;
////////////////////////////////////////////////////////////////////////////////
//name: [sf-unary] in file: compiler.ky near line: 1152
const sf_DASH_unary = function(ast, env) {
  if ( (!(kirbystdlibref.count(ast) === 2)) ) {
    error_BANG("invalid-arity", ast);
  }
  let G____16 = ast;
  let a0 = G____16[0];
  let a1 = G____16[1];
  let ret = node_QTE(ast);
  if ( (a0 == "not") ) {
    a0 = symbol("!");
  }
  ret.add(["(", tx_STAR(a0, env), tx_STAR(a1, env), ")"]);
  return ret;
};
SPEC_DASH_OPS["not"] = sf_DASH_unary;
SPEC_DASH_OPS["~"] = sf_DASH_unary;
SPEC_DASH_OPS["!"] = sf_DASH_unary;
////////////////////////////////////////////////////////////////////////////////
//name: [spitExterns] in file: compiler.ky near line: 1160
const spitExterns = function() {
  let s = "";
  let ks = Object.keys(EXTERNS);
  if ( (!(0 === kirbystdlibref.count(ks))) ) {
    (s = ks.map(function() {
      let ____args = Array.prototype.slice.call(arguments);
      return [____args[0], ": ", ____args[0]].join("");
    }).join(",\n"), s = ["\n\nmodule.exports = {\n", s, "\n};\n\n"].join(""));
  }
  return s;
};
////////////////////////////////////////////////////////////////////////////////
//name: [banner] in file: compiler.ky near line: 1167
const banner = function() {
  return ["/*", "Auto generated by Kirby - v", MODULE_DASH_VERSION, " ", eng.globalEnv().firstNSP(), " - ", new Date(), "*/\n\n"].join("");
};
////////////////////////////////////////////////////////////////////////////////
//name: [cleanCode] in file: compiler.ky near line: 1174
const cleanCode = function(code) {
  let tmp = null;
  let arr = [];
  let G__6 = code.split("\n");
  for (let G__8 = 0, G__7 = false, ____break = false; ((!____break) && ((!G__7) && (G__8 < G__6.length))); G__8 = (G__8 + 1)) {
    let s = G__6[G__8];
    let tmp = s.trim();
    if ( (!true) ) {
      G__7 = true;
    }
    if ( ((!G__7) && true) ) {
      if ( ((!(0 === kirbystdlibref.count(tmp))) && (tmp !== ";")) ) {
        conj_BANG(arr, s);
      }
    }
  }
  null;
  return arr.join("\n");
};
////////////////////////////////////////////////////////////////////////////////
//name: [transpileCode] in file: compiler.ky near line: 1183
const transpileCode = function(codeStr, fname, options) {
  eng.globalEnv().resetNSPCache();
  EXTERNS = {};
  let outNode = txTree(parser.parser(codeStr, fname), eng.globalEnv());
  let G____17 = options;
  let source_DASH_map = G____17["source-map"];
  let format = G____17["format"];
  let cstr = "";
  let fopts = {};
  let extra = spitExterns();
  format = true;
  cstr = (source_DASH_map ?
    (function() {
      let outFile = [path.basename(fname, ".ky"), ".js"].join("");
      let srcMap = [outFile, ".map"].join("");
      let output = outNode.toStringWithSourceMap({
        "file": outFile
      });
      fs.writeFileSync(srcMap, output.map);
      return [output.code, extra, "\n//# sourceMappingURL=", path.relative(path.dirname(fname), srcMap)].join("");
    }).call(this) :
    [outNode, extra].join(""));
  if (format) {
    cstr = esfmt.format(cstr, fopts);
  }
  cstr = cleanCode(cstr);
  return ((0 === kirbystdlibref.count(cstr)) ?
    "" :
    [banner(), cstr].join(""));
};
////////////////////////////////////////////////////////////////////////////////
//name: [transpileXXX] in file: compiler.ky near line: 1211
const transpileXXX = function(code, file, options) {
  return (function() {
    try {
      return transpileCode(code, file, options);
    } catch (e) {
      if (console) {
        console.log([e.stack].join(""));
      }
      return (function() {
        throw e ;
      }).call(this);
    }
  }).call(this);
};
////////////////////////////////////////////////////////////////////////////////
//name: [transpileWithSrcMap] in file: compiler.ky near line: 1217
const transpileWithSrcMap = function(code, file) {
  let G____18 = Array.prototype.slice.call(arguments, 2);
  let options = G____18[0];
  return transpileXXX(code, file, opt_QUERY__QUERY(options, {}));
};
////////////////////////////////////////////////////////////////////////////////
//name: [transpile] in file: compiler.ky near line: 1222
const transpile = function(code, file) {
  let G____19 = Array.prototype.slice.call(arguments, 2);
  let options = G____19[0];
  return transpileXXX(code, file, opt_QUERY__QUERY(options, {}));
};
////////////////////////////////////////////////////////////////////////////////
//name: [parseWithSourceMap] in file: compiler.ky near line: 1227
const parseWithSourceMap = function(codeStr, fname) {
  let outNode = txTree(parser.parser(codeStr, fname));
  outNode.prepend(banner());
  return outNode.toStringWithSourceMap();
};
var version = MODULE_DASH_VERSION;
module.exports = {
  transpileWithSrcMap: transpileWithSrcMap,
  transpile: transpile,
  parseWithSourceMap: parseWithSourceMap,
  version: version
};