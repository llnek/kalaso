;; Copyright (c) 2013-2017, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http:;;opensource.org;licenses;eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author "Kenneth Leung"}

  czlab.kirby.play)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(js# "function Keyword(k) {this.value=k; return this;}")
(js# "Keyword.prototype.toString = function() { return this.value; }")
(js# "function Symbol(s) {this.value=s; return this;}")
(js# "Symbol.prototype.toString = function() { return this.value; }")
(js# "function Atom(v) {this.value=v; return this;}")
(js# "Atom.prototype.toString = function() { return this.value; }")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- throwE [token msg]
  (throw (new Error
              (if token
                (str msg
                     "\nnear line " token.line
                     "\nin file " token.source)
                (str msg "\nnear EOF ")))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- nextToken [tokens]
  (do-with [t (nth tokens
                   tokens.pos)] (++ tokens.pos)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- peekToken [tokens] (nth tokens tokens.pos))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- toSymbol [s] (new Symbol s))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- toKeyword [k] (new Keyword k))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- parseAtom "" [tokens]
  (var token (nextToken tokens)
       tn (or (if token (.-name token)) ""))
  (cond
    (empty? tn)
    undefined
    ;--
    (REGEX.float.test tn)
    (parseFloat tn)
    ;--
    (or (REGEX.hex.test tn)
        (REGEX.int.test tn))
    (parseInt tn)
    ;--
    (and (.startsWith tn  "\"")
         (.endsWith tn "\""))
    tn
    ;--
    (.startsWith tn ":")
    (toKeyword (.slice tn 1))
    ;--
    (or (= "nil" tn)
        (= "null" tn))
    null
    ;--
    (= "true" tn)
    true
    ;--
    (= "false" tn)
    false
    ;--
    :else
    (toSymbol tn)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- parseBlock(tokens head tail)

  (var token (nextToken tokens)
       tn (if token (.-name token)))

  (if (not= tn head)
    (throwE token (str "expected '" head "'")))

  (do-with [ret
            (loop [ast []
                   token (peekToken tokens)]
              (if (or (nichts? token)
                      (= tail (.-name token)))
                (if token
                  ast
                  (throwE token (str "expected '" tail "', got EOF")))
                (recur (addAst ast
                               (parseMore tokens))
                       (peekToken tokens))))]
    (nextToken tokens)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- parseList [tokens]
  (do-with [v (parseBlock tokens "(" ")")]
           (set! v "eTYPE" tkn-list)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- parseVec [tokens]
  (do-with [v (parseBlock tokens "[" "]")]
           (set! v "eTYPE" tkn-vector)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- parseMap [tokens]
  (var v (parseBlock tokens "{"  "}"))
  (if (odd? (alen v))
    (throw (new Error "expected even count in map")))
  (do-with [ret {}]
    (for ((i 0) (< i (alen v)) (i (+ i 2)))
      (set! ret (nth v i) (nth v (inc i))))
    (set! ret "eTYPE" tkn-map)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- skipAndParse [tokens func]
  (nextToken tokens)
  (func tokens))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- parseMore [tokens]
  (var tmp nil
       token (peekToken tokens))
  (when (some? token)
    (case (.-name token)
      "'" (skipAndParse tokens (# [(toSymbol "quote")
                                   (parseMore tokens)]))
      ;--
      "`" (skipAndParse tokens (# [(toSymbol "quasi-quote")
                                   (parseMore tokens)]))
      ;--
      "~" (skipAndParse tokens (# [(toSymbol "unquote")
                                   (parseMore tokens)]))
      ;--
      "~@" (skipAndParse tokens (# [(toSymbol "splice-unquote")
                                    (parseMore tokens)]))
      ;--
      "^" (skipAndParse tokens
                        (# (set! tmp (parseMore tokens))
                           [(toSymbol "with-meta")
                            (parseMore tokens) tmp]))
      ;--
      "@" (skipAndParse tokens (# [(toSymbol "deref")
                                   (parseMore tokens)]))
      ;--
      ")" (throwE token "unexpected ')'")
      "(" (parseList tokens)
      ;--
      "]" (throwE token "unexpected ']'")
      "[" (parseVec tokens)
      ;--
      "}" (throwE token "unexpected '}'")
      "{" (parseMap tokens)
      ;--
      (";" ",") (do->undef (nextToken tokens))
      ;--
      (parseAtom tokens))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- addAst "" [ast f]
  (if-not (undef? f) (.push ast f)) ast)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- parseSource "" [source fname]
  (var tokens (tokenize source fname)
       tlen (alen tokens))
  (set! tokens "pos" 0)
  (do-with [ast []]
    (loop [f (parseMore tokens)]
      (addAst ast f)
      (if-not (< tokens.pos tlen)
        ast
        (recur (parseMore tokens))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- tokenize "" [source fname]
  (var len (alen source)
       token ""
       line 1
       tcol 0
       col 0
       pos 0
       ch nil
       nx nil
       esc? false
       str? false
       comment? false)

  (do-with [tree []]
    (var toke! (fn [ln col s]
                 (if s
                   (.push tree
                          (tnode fname ln col s s))) ""))
    (while (< pos len)
      (set! ch (.charAt source pos))
      (++ col)
      (++ pos)
      (set! nx (.charAt source pos))
      (when (= ch "\n")
        (set! col 0)
        (++ line)
        (if comment? (toggle! comment?)))
      (cond
        ;--
        comment?
        nil
        ;--
        esc?
        (do (toggle! esc?)
            (+= token ch))
        ;--
        (= ch "\"")
        (if-not str?
          (do (set! tcol col)
              (toggle! str?)
              (+= token ch))
          (do (toggle! str?)
              (+= token ch)
              (set! token (toke! line tcol token))))
        ;--
        str?
        (do (if (= ch "\n") (set! ch "\\n"))
            (if (= ch "\\") (set! esc? true))
            (+= token ch))
        ;--
        (or (= ch "'")
            (= ch "`")
            (= ch "@")
            (= ch "^"))
        (if (and (empty? token)
                 (not (REGEX.wspace.test nx)))
          (do (set! tcol col)
              (toke! line tcol ch))
          (+= token ch))
        ;--
        (= ch "~")
        (if (and (empty? token)
                 (not (REGEX.wspace.test nx)))
          (do (set! tcol col)
              (if (= nx "@")
                (do (++ pos)
                    (toke! line tcol "~@"))
                (toke! line tcol ch)))
          (+= token ch))
        ;--
        (or (= ch "[")
            (= ch "]")
            (= ch "{")
            (= ch "}")
            (= ch "(")
            (= ch ")"))
        (do (set! token (toke! line tcol token))
            (set! tcol col)
            (toke! line tcol ch))
        ;--
        (= ch ";")
        (do (set! token (toke! line tcol token))
            (set! tcol col)
            (set! comment? true))
        ;-- comma treated as whitespace
        (or (= ch ",")
            (REGEX.wspace.test ch))
        (set! token
              (toke! (if (= ch "\n")
                          (dec line) line) tcol token))
        :else
        (do (when (empty? token) (set! tcol col))
            (+= token ch))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- dumpTree [tree]
  (var obj nil
       indent (or (nth arguments 1) 0)
       pad (.repeat " " indent))
  (for ((i 0)
        (< i (alen tree)) (i (inc i)))
    (set! obj (nth tree i))
    (cond
      (list? obj)
      (do (console.log (str pad "<block>"))
          (dumpTree obj (+ indent 2))
          (console.log (str pad "</block>")))
      :else
      (let [s (+ "" obj)]
        (console.log
          (str pad
               "<atom>"
               (-> (.replace s (regexs "&" "g") "&amp;")
                   (.replace (regexs "<" "g") "&lt;")
                   (.replace (regexs ">" "g") "&gt;"))
               "</atom>"))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF
(defn- drop [c n] (.slice c n))
(defn- take [c n] (.slice c 0 n))
(defmacro cdr [c] (drop ~c 1))

(defn- evalTree [tree]
  (loop [e (car tree)
         xs (.shift tree)]
    (if (empty? xs)
      ret
      (do (evalMore e)
          (recur (car xs) (.shift xs))))))

(defn- evalMore [obj]
  (if (and (list? obj)
           (= tkn-list (.-eTYPE obj)))
    (evalList obj) (evalAtom obj)))

(defn- evalList [list]
  (loop [x (car list)
         xs (.shift list)]
    (if (empty? xs)
      ret
      (do (evalMore e)
          (recur (car xs) (.shift xs))))))

(comment
(defn- evalAtom [obj]
  (cond
    (inst? Keyword obj)
    (inst? Symbol obj)
    (boolean? obj)
    (number? obj)
    (string? obj)
    (null? obj)
    (vector? obj)
    (map? obj))))






