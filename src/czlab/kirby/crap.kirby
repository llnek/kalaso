;; Copyright (c) 2013-2017, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http:;;opensource.org;licenses;eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author "Kenneth Leung"}

  czlab.kirby.reader

  (include "./core.kirby")

  (require ["source-map" :as *smap*]
           ["path" :as *path*]
           ["fs" :as *fs*]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(js# "function Keyword(k) {this.value=k; return this;}")
(js# "Keyword.prototype.toString = function() { return this.value; }")
(js# "function Symbol(s) {this.value=s; return this;}")
(js# "Symbol.prototype.toString = function() { return this.value; }")
(js# "function Atom(v) {this.value=v; return this;}")
(js# "Atom.prototype.toString = function() { return this.value; }")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defmacro throwE "" [msg] (throw (new Error ~msg)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- collectToken "" [ret token]
  (if (not= ";" token) (.push ret token)) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- tokenize "" [source fname]
  ;;/[\s,]*(~@|[\[\]{}()'`~^@]|"(?:\\.|[^\\"])*"|;.*|[^\s\[\]{}('"`,;)]*)/g
  (var re (regexs "[\\s,]*(~@|[\\[\\]\\{}()'`~^@]|\"(?:\\\\.|[^\\\\\"])*\"|;.*|[^\\s\\[\\]\\{}('\"`,;)]*)" "g"))
  (loop [ret []
         match (.exec re source)]
    (if (or (nichts? match)
            (empty? (nth match 1)))
      ret
      (recur (collectToken ret (nth match 1))
             (.exec re source)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- nextToken [tokens]
  (do-with [t (nth tokens
                   tokens.pos)] (++ tokens.pos)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- peekToken [tokens] (nth tokens tokens.pos))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- toSymbol [s] (new Symbol s))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- toKeyword [k] (new Keyword k))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- parseAtom "" [tokens]
  (var token (nextToken tokens)
       t0 (nth token 0))
  (cond
    (REGEX.float.test token)
    (parseFloat token)
    (or (REGEX.hex.test token)
        (REGEX.int.test token))
    (parseInt token)
    (= "\"" t0)
    (-> (.slice token 1 (eindex token))
        (.replace (regexs "\\\\\"" "g") "\"")
        (.replace (regexs "\\\\n" "g") "\n")
        (.replace (regexs "\\\\\\\\" "g") "\\"))
    (= ":" t0)
    (toKeyword (.slice token 1))
    (= "nil" token)
    null
    (= "true" token)
    true
    (= "false" token)
    false
    :else
    (toSymbol token)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- parseBlock(tokens head tail)

  (if (not= (nextToken tokens) head)
    (throwE (str "expected '" head "'")))

  (var ret
       (loop [ast []
              token (peekToken tokens)]
         (if (or (nichts? token)
                 (= tail token))
           (if token
             ast
             (throwE (str "expected '" tail "', got EOF")))
           (recur (addAst ast (parseForm tokens))
                  (peekToken tokens)))))
  (nextToken tokens)
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- parseList [tokens]
  (do-with [v (parseBlock tokens "(" ")")]
           (set! v "eTYPE" tkn-list)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- parseVec [tokens]
  (do-with [v (parseBlock tokens "[" "]")]
           (set! v "eTYPE" tkn-vector)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- parseMap [tokens]
  (var v (parseBlock tokens "{"  "}"))
  (if (odd? (alen v))
    (throw (new Error "expected even count in map")))
  (do-with [ret {}]
    (for ((i 0) (< i (alen v)) (i (+ i 2)))
      (set! ret (nth v i) (nth v (inc i))))
    (set! ret "eTYPE" tkn-map)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- skipAndParse [tokens func]
  (nextToken tokens)
  (func tokens))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- parseForm [tokens]
  (var tmp nil
       token (peekToken tokens))
  (case token
    ";" undefined
    "'" (skipAndParse tokens (# [(toSymbol "quote")
                                 (parseForm tokens)]))
    "`" (skipAndParse tokens (# [(toSymbol "quasi-quote")
                                 (parseForm tokens)]))
    "~" (skipAndParse tokens (# [(toSymbol "unquote")
                                 (parseForm tokens)]))
    "~@" (skipAndParse tokens (# [(toSymbol "splice-unquote")
                                  (parseForm tokens)]))
    "^" (skipAndParse tokens
                      (# (set! tmp (parseForm tokens))
                         [(toSymbol "with-meta")
                          (parseForm tokens) tmp]))
    "@" (skipAndParse tokens (# [(toSymbol "deref")
                                 (parseForm tokens)]))

    ")" (throwE "unexpected \")\"")
    "(" (parseList tokens)

    "]" (throwE "unexpected \"]\"")
    "[" (parseVec tokens)

    "}" (throwE "unexpected \"}\"")
    "{" (parseMap tokens)

    (parseAtom tokens)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- addAst "" [ast f]
  (if-not (undef? f) (.push ast f)) ast)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- parseSource "" [source fname]
  (var tokens (tokenize source fname)
       tlen (alen tokens))
  (loop [ast []
         f (parseForm tokens)]
    (if (>= tokens.pos tlen)
      ast
      (recur (addAst ast f)
             (parseForm tokens)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(def- TreeNode (.-SourceNode  *smap*))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(def- REGEX
  { :noret (regex "^def\\b|^var\\b|^set!\\b|^throw\\b")
    :id (regex "^[a-zA-Z_$][?\\-*!0-9a-zA-Z_$]*$")
    :id2 (regex "^[*\\-][?\\-*!0-9a-zA-Z_$]+$")
    :float (regex "^[-+]?[0-9]+\\.[0-9]+$")
    ;;/^-?[0-9][0-9.]*$/
    :int (regex "^[-+]?[0-9]+$")
    ;;/^-?[0-9]+$/
    :hex (regex "^[-+]?0x")
    :macroGet (regex "^#slice@(\\d+)")
    :dquoteHat (regex "^\"")
    :dquoteEnd (regex "\"$")
    :func (regex "^function\\b")
    :query (regexs "\\?" "g")
    :bang (regexs "!" "g")
    :dash (regexs "-" "g")
    :star (regexs "\\*" "g")
    :wspace (regex "\\s") })

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(def- *reserved*
  {"compare" ["!=" "==" "=" ">" ">=" "<" "<="]
   "arith" ["+" "-" "*" "/" "%"]
   "logic" ["||" "&&"]
   "bitwise" ["^" "&" "|" "<<" ">>" ">>>"]
   "incdec" ["++" "--"]
   "unary" ["~" "!"]
   "assign" ["+=" "-=" "*="
             "/=" "%=" "<<="
             ">>=" ">>>=" "&=" "|=" "^="]
   "builtin" ["quote" "syntax-quote" "quasi-quote"
              "unquote" "unquote-splice"
              "repeat-n" "do" "doto" "case"
              "range" "def-" "def" "var"
              "new" "throw" "while"
              "aset" "set!" "fn"
              "defn-" "defn"
              "try" "if" "get" "aget" "str"
              "list" "[" "vec" "{" "hash-map"
              "ns" "comment" "for" "cons"
              "js#" "defmacro"]})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(def- *reserved-keys*
  (-> (reduce (fn [acc x]
                (.concat acc x))
              []
              (values *reserved*))
      (zipmap [])))

;(console.log (str "sssss = " (keys *reserved-keys*)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(def- tkn-string "STRING")
(def- tkn-number "NUMBER")
(def- tkn-symbol "SYMBOL")
(def- tkn-ident "IDENT")
(def- tkn-atom "ATOM")
(def- tkn-hat "HAT")
(def- tkn-meta "HAT-META")
(def- tkn-ns "NS")
(def- tkn-quote "QUOTE")
(def- tkn-back-tick "BACKTICK")
(def- tkn-list "LIST")
(def- tkn-tree "TREE")
(def- tkn-map "MAP")
(def- tkn-vector "VECTOR")
(def- tkn-array "ARRAY")
(def- tkn-object "OBJECT")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defmacro name?? [obj] (get?? ~obj :name ""))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- nodeTag [obj src line col type]
  (when obj
    (set! obj :source src)
    (set! obj :column col)
    (set! obj :line line)
    (set! obj :isMeta false)
    (set! obj :eTYPE type)) obj)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- testid? [name]
  (or (REGEX.id.test name) (REGEX.id2.test name)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- normalizeId [name]
  (var pfx "")
  (when (and (string? name)
             (= "-" (.charAt name 0)))
    (set! pfx "-")
    (set! name (.slice name 1)))
  (if (testid? name)
    (-> (str pfx name)
        (.replace REGEX.query "_QUERY")
        (.replace REGEX.bang "_BANG")
        (.replace REGEX.dash "_")
        (.replace REGEX.star "_STAR"))
    (if (= pfx "") name (str pfx name))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;use this function to generate code, we need to escape out funny
;;chars in names
(defn- tnodeString []
  (var me this)
  (do-with [s ""]
    (.walk me
           (fn [chunk hint]
             (if (and (= hint.name chunk)
                      (string? chunk))
               (set! chunk (normalizeId chunk)))
             (+= s chunk)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- tnode [source line col chunk name type]
  (var args? (js-args?))
  (do-with [n nil]
    (if args?
      (set! n
            (if name
              (new TreeNode line col source chunk name)
              (new TreeNode line col source chunk)))
      (set! n (new TreeNode)))
    (set! n :isMeta false)
    (set! n :eTYPE type)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- tnodeEx [chunk name type]
  (tnode nil nil nil chunk name type))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- addToken [tree token ctx]
  (var n nil t tkn-symbol)
  (do-with [ret ""]
    (when token
      (if (= ":else" token) (set! token "true"))
      (if (= "nil" token) (set! token "null"))
      (cond
        (and (.startsWith token "\"")
             (.endsWith token "\""))
        (set! t tkn-string)
        (or (REGEX.float.test token)
            (REGEX.int.test token)
            (REGEX.hex.test token))
        (set! t tkn-number)
        (= "`" token)
        (set! t tkn-back-tick)
        (.startsWith token ":")
        (set! token (str "\"" (.slice token 1) "\""))
        (.startsWith token "'")
        (set! token (str "\"" (.slice token 1) "\""))
        :else
        (set! t tkn-ident))
      (when (= tkn-ident t)
        (if-not (and (empty? tree)
                     (contains? *reserved-keys* token))
          (set! token (normalizeId token))))
      (set! n (tnode ctx.file
                     ctx.line
                     (dec ctx.tcol) token token t))
      (conj!! tree n))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- lexer [prevToken ctx]
  (var ____BREAK! nil
       formType nil
       token ""
       ch nil
       nxch nil
       escStr? false
       inStr? false
       comment? false)

  (set! prevToken (or prevToken ""))
  (do-with [tree []]
    (nodeTag tree
             (get ctx :source)
             (get ctx :line)
             0
             (cond
               (.endsWith prevToken "{") tkn-object
               (= "[" prevToken) tkn-array
               :else tkn-list))
    (if (.startsWith prevToken "^")
      (set! tree :isMeta true))
    (set! ____BREAK! false)
    (while (and (not ____BREAK!)
                (< ctx.pos (alen ctx.codeStr)))
      (set! ch (.charAt ctx.codeStr ctx.pos))
      (++ ctx.colno)
      (++ ctx.pos)
      (set! nxch (.charAt ctx.codeStr ctx.pos))
      (when (= ch "\n")
        (++ ctx.lineno)
        (set! ctx.colno 1)
        (if comment? (toggle! comment?)))
      (cond
        comment?
        nil
        escStr?
        (do (toggle! escStr?)
            (+= token ch))
        (= ch "\"")
        (do (toggle! inStr?)
            (+= token ch))
        inStr?
        (do (if (= ch "\n") (set! ch "\\n"))
            (if (= ch "\\") (set! escStr? true))
            (+= token ch))
        (= ch "'")
        (+= token ch)
        (or (= ch "[")
            (= ch "]"))
        (do (set! token (addToken tree token ctx))
            (set! ctx.tcol ctx.colno)
            (if (= ch "[")
              (do (set! formType tkn-array)
                  (conj!! tree (lexer ch ctx)))
              (do (set! formType nil)
                  (set! ____BREAK! true))))
        (or (= ch "{")
            (= ch "}"))
        (do (set! token (addToken tree token ctx))
            (set! ctx.tcol ctx.colno)
            (if (= ch "{")
              (do (set! formType tkn-object)
                  (conj!! tree (lexer ch ctx)))
              (do (set! formType nil)
                  (set! ____BREAK! true))))
        (= ch ";")
        (set! comment? true)
        (= ch "^")
        (if (REGEX.wspace.test nxch)
          (do (+= token ch)
              (set! token (addToken tree token ctx)))
          (do (set! token (addToken tree token ctx))
              (if (not= "{" nxch) (syntax! :e0 tree))
              (++ ctx.pos)
              (set! ctx.tcol ctx.colno)
              (set! formType tkn-object)
              (conj!! tree (lexer "^{" ctx))))
        (or (= ch "(")
            (= ch ")"))
        (do (set! token (addToken tree token ctx))
            (set! ctx.tcol ctx.colno)
            (if (= ch "(")
              (do (set! formType tkn-list)
                  (conj!! tree (lexer ch ctx)))
              (do (set! formType nil)
                  (set! ____BREAK! true))))
        (REGEX.wspace.test ch)
        (do (if (= ch "\n") (-- ctx.lineno))
            (set! token (addToken tree token ctx))
            (if (= ch "\n") (++ ctx.lineno))
            (set! ctx.tcol ctx.colno))
        :else
        (+= token ch)))
    ;;final check!
    (if inStr? (syntax! 'e3 tree))
    (case formType
      tkn-array (syntax! 'e5 tree)
      tkn-object (syntax! 'e7 tree)
      tkn-list (syntax! 'e8 tree))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

