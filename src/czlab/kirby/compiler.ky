;; Copyright Â© 2013-2018, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc "Transpiles kirby code to js code."
      :author "Kenneth Leung"}

  czlab.kirby.compiler

  (:require ["source-map" :as smap])
  (:require ["./stdlib"
             :as std
             :refer [lambdaArg? pairs? into! println
                     seq merge contains? last typeid
                     prn primitive set? map? vector?
                     opt?? some? primitive? regexObj?
                     unquote-str quote-str rseq cons
                     not-empty conj! list? obj? cons!
                     gensym count pop! partition
                     difference carve split-with
                     concat symbol keyword symbol? keyword?]]
            ["./engine"
             :as rt
             :refer [KBSTDLR KBSTDLIB KBPFX EXPKEY]]
            ["./reader" :as reader :refer [jsid]])
  (:require ["fs" :as fs]
            ["path" :as path]
            ["esformatter" :as esfmt]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- ERRORS-MAP {
  :no-sourcemap-info "Expected source map info"
  :invalid-fargs "Invalid function args"
  :invalid-catch "Invalid catch clause"
  :invalid-try "Invalid try clause"
  :invalid-require "Invalid require clause"
  :invalid-namespace "Invalid namespace clause"
  :destruct-args "Bad destructure args"
  :outside-macro "Invalid clause outside of macro"
  :file-access "Failed file access"
  :file-read "Failed file read"
  :file-open "Failed to open file"
  :unknown-keyword "Unknown keyword"
  :invalid-arity "Invalid function arity"
  :invalid-meta "Invalid meta data"
  :syntax-error "Syntax error"
  :empty-form "Invalid form (empty)" })

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- ARRSLICE "Array.prototype.slice.call"
        JSARGS "arguments"
        LARGS "____args" BREAK "____break" MOD-VER "1.0.0")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- GET-INDEX (str KBSTDLR ".getIndex"))
(const- GET-PROP (str KBSTDLR ".getProp"))
(const- KEYW (str KBSTDLR ".keyword"))
(const- SYMB (str KBSTDLR ".symbol"))
(const- COUNT (str KBSTDLR ".count"))
(const- MODLO (str KBSTDLR ".modulo"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- *externs* ? *macros* ? *vars* ?
      *last-line* 0 *last-col* 0 SPEC-OPS `{} MATH-OP-REGEX #/^[-+][0-9]+$/)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- unmangle
  "Ensure name is compliant" ^String [s]
  (->> (map #(reader/jsid %) (.split s ".")) (join ".")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn tnodeEx
  "" [name &[chunk]] (tnode nil nil nil chunk name))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn tnode
  "" [&[src ln col chunk name]]
  (new smap/SourceNode
       (opt?? ln nil)
       (opt?? col nil)
       (opt?? src nil)
       (opt?? chunk nil) (opt?? name nil)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- doFuncArgs "Deal with possible destructuring
                  of args in function definition"
  ^Array [args env]
  (with-local-vars [fargs (node' args)
                    fdefs (node' args)
                    ret [fargs fdefs]
                    pms [] rval ? out ?])
  (floop [e args :index i]
    (set! rval (node' args)
          out (node' args))
    (cond (symbol? e)
          (if (== e "&")
            (do->break!
              (set! e (nexth args i))
              (.add rval [ARRSLICE "(" JSARGS "," $(i) ")"])
              (.add fdefs ["let "
                           (tx* (if (symbol? e)
                                  e (dstru* e out env)) env)
                           "=" rval ";\n" out]))
            (conj! pms (if (== e "_") (xfi e (gensym "U__")) e)))
          (array? e)
          (do (.add rval [JSARGS "[" $(i) "]"])
              (conj! pms (dstru* e out env))
              (.add fdefs out))
          :else
          (error! :destruct-args args)))
  (each #(.add fargs (tx* % env)) pms)
  (join "," fargs)
  ;;return back a list of function arguments, and the
  ;;rest of local variables in case of varargs or
  ;;arg-destructions
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- dstru* "Decide on what the
                 rhs should be referred to 'as'"
  ^Symbol [coll out env]
  (with-local-vars [rhs (gensym)])
  (floop [e coll :index i]
    (when (and (keyword? e)
               (== e :as))
      (set! rhs (symbol $(nexth coll i)))
      (break-out-of-loop!)))
  (xfi coll rhs)
  ;handle a vec or a map destructure only
  (.add out (cond (map? coll) (dmap! rhs coll env)
                  (vector? coll) (dvec! rhs coll env)
                  :else "")) rhs)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- dvec! "Destruct a vec" [src coll env]
  (with-local-vars [ret (node' coll)
                    rval ? out ? as (tx* src env)])
  (floop [e coll :index i]
    (set! rval (node' coll)
          out (node' coll))
    (cond (symbol? e)
          (cond (== e "&")
                (do->break!
                  (set! e (nexth coll i))
                  (.add rval [ARRSLICE "(" as "," $(i) ")"])
                  (.add ret ["let "
                             (tx* (if-not (symbol? e)
                                    (dstru* e out env) e) env)
                             "=" rval ";\n" out]))
                :else
                (if-not (== e "_")
                  (.add ret ["let "
                             (tx* e env) "="
                             (slib! GET-INDEX) "(" as "," $(i) ");\n"])))
          (array? e)
          (do (.add rval [as "[" $(i) "]"])
              (.add ret ["let "
                         (tx* (dstru* e out env) env) "=" rval ";\n" out]))
          (keyword? e)
          (if (== e :as)
            (++ i)
            (error! :unknown-keyword coll))
          :else (error! :syntax-error coll))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- dmap! "Destruct a map" [src coll env]
  (with-local-vars [ret (node' coll)
                    arr ? as (tx* src env)])
  (floop [e coll :index i :step 2]
    (if (keyword? e)
      (cond (or (== e :keys)
                (== e :strs))
            (doseq [a' (nexth coll i)]
              (.add ret ["let "
                         (tx* a' env) "="
                         (slib! GET-PROP)
                         "(" as "," (std/quote-str $(a')) ");\n"]))
            (== e :as) nil
            :else (error! :unknown-keyword coll))
      ;else
      (error! :syntax-error coll))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- simple? "Nothing complex" [ast]
  (or (undef? ast) (nil? ast) (str? ast) (num? ast) (bool? ast)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- wrap "" [ret head tail]
  (when ret
    (if head (.prepend ret head))
    (if tail (.add ret tail))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- exprHint
  "Flag the AST if it is an expression" [ast flag]
  ;if ast is a simple-ton, wrap (box) it with a Primitive object.
  (doto (if (simple? ast) (primitive ast) ast) (oset! :____expr flag)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- stmt? "" [ast]
  (if (simple? ast) (error! :syntax-error ast)) (false? ast.____expr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- error! "" [e & [ast msg]]
  (raise! (get ERRORS-MAP e)
          (if msg (str " : " msg))
          (if (and ast (num? ast.line)) (str "\nline: " ast.line))
          (if (and ast (str? ast.source)) (str "\nfile: " ast.source))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- testre? "Test a regex" [re x] (if x (.test re x) #f))
(defn- fn?? "" [cmd]
  (if (testre? reader/REGEX.func cmd) (str "(" cmd ")") cmd))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- pad "" [n] ^String (.repeat " " n))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- node' "" ^SourceNode [ast & [obj]]
  (doto (opt?? obj (tnode))
    (oset! :source ast.source :line ast.line :column ast.column)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txTree
  "Process a file unit.  Sort out all the macros first then others.
  Also, always check first for (ns ...)"
  ^SourceNode [root env]
  (with-local-vars [ms [] os []
                    n1 (_1 root)
                    ret (node' root)])
  (if-not (== "ns" (_1 n1))
    (raise! "(ns ...) must be first form in file"))
  (conj! ms n1)
  (doseq [t (rest root)]
    (conj! (if (and (array? t)
                    (symbol? (_1 t))
                    (== "defmacro" (_1 t))) ms os) t))
  (each (fn [r]
          (set! *last-line* r.line *last-col* r.col)
          (if-some [t (tx* r env)] (.add ret [t ";\n"]))) (concat ms os)) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txForm "" [expr env]
  (if (array? expr)
    (each #(aset %3 %2 (tx* %1 env)) expr)) expr)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txAtom "" ^Any [a]
  (with-local-vars [s (str a)])
  (cond (lambdaArg? a)
        (str LARGS "[" (-1 (int (rest s))) "]")
        (regexObj? a)
        (node' a (tnodeEx s (rest s)))
        (keyword? a)
        (node' a (tnodeEx s (quote-str s)))
        (symbol? a)
        (node' a (tnodeEx s (unmangle s)))
        (nil? a)
        "null"
        (primitive? a)
        (do (set! a a.value s $(a))
            (cond (string? a)
                  (quote-str a)
                  (nil? a) "null" :else s))
        (string? a)
        (quote-str a)
        :else (reader/jsid s)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- tx* "" [x & [env]]
  (if (array? x) (txPairs x env) (txAtom x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- gcmd "" ^String [ast]
  (cond (map? ast) "hash-map"
        (obj? ast) "object"
        (vector? ast) "vec"
        (set? ast) "hash-set"
        (list? ast) "list"
        (and (array? ast)
             (not (array? (_1 ast)))) $(_1 ast) :else ""))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quoteSingle "" ^String [a]
  (cond (keyword? a) (str (slib! KEYW) "(\"" a.value "\")")
        (symbol? a) (str (slib! SYMB) "(\"" a.value "\")")
        (primitive? a) (do (set! a a.value)
                           (cond (string? a)
                                 (quote-str a)
                                 (nil? a) "null" :else $(a)))
        (string? a) (quote-str a)
        :else $(a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quote! "" ^SourceNode [ast env]
  ;(assertInfo ast)
  (if (array? ast)
    (if (map? ast)
      (quoteMap ast env) (quoteBlock ast env)) (quoteSingle ast)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quoteMap "" ^SourceNode [ast env]
  (with-local-vars [cma ""
                    ret (node' ast)])
  (floop [a' ast :step 2 :index i]
    (if (> i 0) (.add ret ","))
    (.add ret [(quote! a' env)
               " , " (quote! (nexth ast i) env)]))
  (if-not (empty? ast) (set! cma ","))
  (wrap ret ["[" (slib! SYMB) "(\"hash-map\")" cma] "]"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quoteBlock "" ^SourceNode [ast env]
  (with-local-vars [ret (node' ast)])
  (floop [a' ast :index i]
    (if (> i 0) (.add ret ","))
    (.add ret (quote! a' env))) (wrap ret "[" "]"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- spreadInfo "" ^Any [from to]
  (if (and from
           (not (simple? from))
           (number? from.line) (array? to))
    (do (xfi from to)
        (doseq [t' to]
          (spreadInfo from t'))) (xfi from to)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txPairs "" ^SourceNode [ast env]
  (with-local-vars [nsp (std/peekNSP)
                    stmtQ (stmt? ast)
                    ret (node' ast) cmd (gcmd ast)
                    e1 (_1 ast) orig ast op ? tmp ? mc (rt/getMacro cmd)])
  (xfi e1 ret)
  (xfi e1 ast)
  ;;always handle macro calls first
  (when mc
    (set! ast (rt/expand?? ast env mc)
          ast (xfi orig (exprHint ast (not stmtQ))))
    (spreadInfo orig ast)
    (set! cmd (gcmd ast)))
  ;;handle (+1 ) or (-1 ) cases
  (when (reader/REGEX.int.test cmd)
    (set! cmd (if-not (or (starts-with? cmd "+")
                          (starts-with? cmd "-"))
                (str "+" cmd) cmd)
          ast (xfi ast [(symbol (ch@ cmd 0))
                        (_2 ast) (int (rest cmd))]) cmd $(_1 ast)))
  ;;maybe special form
  (set! op (get SPEC-OPS cmd))
  ;;handle all cases
  (cond (== cmd "with-meta")
        (.add ret (tx* (_2 (meta?? ast env)) env))
        (starts-with? cmd ".-")
        (.add ret [(tx* (_2 ast) env)
                   "." (tx* (symbol (.slice cmd 2)) env)])
        (starts-with? cmd ".@")
        (.add ret [(tx* (_2 ast) env) "["
                   (.slice cmd (if (starts-with? cmd ".@+") 3 2))
                   (if (starts-with? cmd ".@+") "+1" "") "]"])
        (starts-with? cmd ".")
        (.add ret
              (concat [(tx* (_2 ast) env) (tx* (symbol cmd) env)]
                      "(" (join "," (for [a' (slice ast 2)] (tx* a' env))) ")"))
        (some? op)
        (set! ret (op ast env))
        (and (or (== cmd "splice-unquote")
                 (== cmd "unquote")
                 (== cmd "syntax-quote"))
             (not (starts-with? (get nsp :id) KBPFX)))
        (error! :outside-macro ast)
        :else
        (do (set! cmd (if (pairs? ast)
                        $(_1 (txForm ast env)) (tx* ast env)))
            (if-not cmd (error! :empty-form ast))
            (set! cmd (slib! cmd))
            (.add ret (if (pairs? ast)
                        [(fn?? cmd) "(" (join "," (rest ast)) ")"] cmd))))
  (node' ast ret))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- writeDoc "Convert to jsdoc" ^Array [doc]
  (->> (if doc (std/split (unquote-str doc) "\n") [])
       (map #(let [s (.trim (str %))]
                  (if (not-empty s) (str "//" s "\n"))))
       (filter #(not-empty %))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txDo "A Do block" ^SourceNode [ast env & [return?]]
  (with-local-vars [stmtQ (stmt? ast)
                    ret (node' ast)
                    e ? end (last-index ast)])
  ;;should we return something?
  (set! return?
        (if stmtQ #f (opt?? return? #t)))
  (floop [a' ast :end end]
    (.add ret [(tx* (exprHint a' #f) env) ";\n"]))
  (when (>= end 0)
    (set! e (tx* (exprHint (.@end ast)
                           (not stmtQ)) env))
    (.add ret (if-not return?
                [e ";\n"] ["return " e ";\n"]))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- isMeta? "" [obj]
  (and (array? obj) (= 3 (n# obj))
       (symbol? (_1 obj)) (== "with-meta" $(_1 obj))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- meta?? "" ^Array [obj env]
  (if (isMeta? obj)
    (let [[_ e2 e3] obj]
      (oset! e2
             :____meta
             (evalMeta e3 env)) [e2.____meta e2]) [nil obj]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fmtSpecOps "" ^String [fname attrs]
  (with-local-vars [f #(str (reader/jsid :SPEC-OPS)
                            "[" (std/quote-str %1) "] = " fname)])
  (if-some+ [out (->> (get attrs :opcode)
                      (map f)
                      (join ";\n"))] (str out ";\n") ""))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- writeFuncPre "" [pre env]
  (with-local-vars
   [ret (node' pre)
    c2 ['if-not (concat ['and] pre)
        ['throw ['Error "Precondition failed"]]]])
  (.add ret [(-> (exprHint c2 #f) (tx* env)) ";\n"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- writeFuncInfo "" ^String [fname ast]
  (with-local-vars
   [file (if ast.source
           (.slice ast.source
             (+1 (.lastIndexOf ast.source "/"))) "?")
    s (str "//fn: [" fname "] in file: "
           file ", line: " (or ast.line "?") "\n")
    len (alen s)])
  (if (< len 80) (set! len 80))
  (str (.repeat "/" len) "\n" s))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- evalMeta "" ^Object [ast env]
  (-> (cond (array? ast)
            ast
            (keyword? ast)
            (into! :map [ast #t])
            (symbol? ast)
            (into! :map [(keyword ":tag") ast])
            :else
            (error! :invalid-meta ast)) (rt/compute env)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- slib! "Maybe strip out kirbyref" ^String [cmd]
  (with-local-vars [nsp (std/peekNSP)
                    lib (str KBSTDLR ".")])
  (set! cmd $(cmd))
  (if (and (starts-with? cmd lib)
           (== (get nsp :id) KBSTDLIB)) (.slice cmd (alen lib)) cmd))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- assertArity "" [kond ast]
  (if-not kond (error! :invalid-arity ast)) (assertInfo ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- assertInfo "" [ast]
  (if (and false
           ast
           (not (simple? ast))
           (not (number? ast.line)))
    (error! :no-sourcemap-info ast)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- loadRLib
  "Load in all the exported macros from the external lib" ^String [info env]
  (with-local-vars [ast ? s ?
                    {:keys [ns macros vars]} info])
  ;(println "loadlib has " (n# macros) " macros")
  (each-key (fn [v k]
              ;;scope all macro names
              (set! ast (rt/readAST v)
                    s (symbol (str ns "/" $(_2 ast))))
              (aset ast 1 s) (rt/compute ast env)) macros) ns)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- loadRVars
  "" [info env]
  [(map #(symbol %) (get info :vars))
   (reduce #(conj! %1 %2) #{} (get info :vars))])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- isPub? "" [ast]
  (not (ends-with? (str (if (array? ast) (_1 ast) ast)) "-")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;special-forms
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn sf-juxt

  "Takes a set of functions and returns a fn that is the juxtaposition
of those fns.  The returned fn takes a variable number of args, and
returns a vector containing the result of applying each fn to the
args (left-to-right).
((juxt a b c) x) => [(a x) (b x) (c x)]"

  ^{:opcode ["juxt"] :tag SourceNode} [ast env]

  (with-local-vars [ret (node' ast)])
  (doseq [a' (rest ast)
          :let [f $(gensym "F__")]]
    (.add ret ["let " f "=" (tx* a' env) ";\n"
               "ret.push(" f ".apply(this," LARGS "));\n"]))
  (wrap ret
        ["function () {\nlet ret=[],"
         LARGS "=" ARRSLICE "(" JSARGS ");\n"] "return ret;\n}"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-deref

  "Returns an atom's current state."

  ^{:opcode ["deref"] :tag SourceNode} [ast env]

  (assertArity (= (n# ast) 2) ast)
  (.add (node' ast) [(tx* (_2 ast) env) ".value"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-compose

  "Takes a set of functions and returns a fn that is the composition
of those fns.  The returned fn takes a variable number of args,
applies the rightmost of fns to the args, the next
fn (right-to-left) to the result, etc."

  ^{:opcode ["comp"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 2) ast)
  (with-local-vars [ret (node' ast)
                    f ? r ? prev ?
                    start (last-index ast)])
  ;go backwards -> right to left
  ;keep track of prev result so that we can thread it
  ;to next function
  (rloop [a' ast :start start :end 0 :index i]
    (set! f $(gensym "F__") r $(gensym "R__"))
    (.add ret ["let " f "=" (tx* a' env) ";\n"
               "let " r "=" f
               (if (= i start)
                 (str ".apply(this," LARGS) (str "(" prev)) ");\n"])
    (set! prev r))
  (wrap ret
        ["function () {\nlet "
         LARGS "=" ARRSLICE "(" JSARGS ");\n"]
        ["return " prev ";\n" "}"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-quote
  "Returns the unevaluated form"
  ^{:opcode ["quote"] :tag SourceNode} [ast env]
  (assertArity (= (n# ast) 2) ast)
  (wrap (node' ast) nil (quote! (_2 ast) env)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-deftype
  "Define a Class"
  ^{:opcode ["deftype" "deftype-"] :tag SourceNode}
  [ast env]
  (assertArity (>= (n# ast) 3) ast)
  (with-local-vars
   [pub? (isPub? ast)
    par (_1 (.@2 ast))
    ret (node' ast)
    czn (_2 ast)
    czname (tx* czn env)
    [doc mtds] (if (string? (.@3 ast))
                 [(.@3 ast) (slice ast 4)] [nil (slice ast 3)])])
  (rt/addVar czn {:ns (std/*ns*) })
  (.add ret ["class " czname
             (if par (str " extends " (tx* par env)) "") " {\n"])
  (doseq [m mtds :let [mtd 'method m1 (_1 m)]]
    (xfi m1 mtd) ;;pass line info
    (cons! mtd m) ;fake a keyword 'method' in front
    (rt/addVar (str czn "." m1) {:ns (std/*ns*) })
    ;compiles it like a function
    (.add ret [(sf-func m env #f) "\n"]))
  ;stick doco in front, if any
  (if doc (.prepend ret (writeDoc doc)))
  ;maybe export this type?
  (when pub?
    (conj! *vars* czn)
    (assoc! *externs* czname czname))
  (.add ret "}\n"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-compOp "Handle comparison operators."

  ^{:opcode [">" ">=" "<" "<="
             "not=" "!=" "==" "="] :tag SourceNode} [ast env]

  (assertArity (and (>= (n# ast) 3)
                    (odd? (n# ast))) ast)
  (with-local-vars [ret (node' ast)
                    op ? cmd $(_1 ast)])
  (cond (== cmd "not=") (aset ast 0 '!==)
        (== cmd "=") (aset ast 0 '===))
  (set! op $(_1 ast))
  (floop [a' ast :start 1 :end (last-index ast) :index i]
    (if (not= i 1) (.add ret " && "))
    (.add ret [(tx* a' env)
               " " op " " (tx* (nexth ast i) env)]))
  (wrap ret "(" ")"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-arithOp
  "Handles math operators"
  ^{:opcode ["bit-shift-left" "bit-shift-right"
             "unsigned-bit-shift-right"
             "or" "and" "exp" "rem"
             "+" "-" "*" "/" "div" "mod"
             "bit-and" "bit-or" "bit-not" "bit-xor"] :tag SourceNode}
  [ast env]

  (assertArity (>= (n# ast) 2) ast)
  (with-local-vars
    [ret (node' ast)
     e1 $(_1 ast)
     cmd (case e1
           "unsigned-bit-shift-right" ">>>"
           "bit-shift-right" ">>"
           "bit-shift-left" "<<"
           "bit-and" "&"
           "bit-or" "|"
           "bit-not" "~"
           "bit-xor" "^"
           "rem" "%"
           "div" "/"
           "and" "&&"
           "or" "||"
           "exp" "**"
           e1)])
  (cond (== "mod" cmd)
        (.add ret [MODLO "("
                   (tx* (_2 ast) env) "," (tx* (_3 ast) env) ")"])
        (== "~" cmd)
        (.add ret ["~" (tx* (_2 ast) env)])
        :else
        (do ;handle negative number e.g. (- -2)= -1*-2
            (if (and (== "-" cmd)
                     (= 2 (n# ast))) (.add ret "-1 * "))
            (floop [a' ast :start 1 :index i]
                   (when (> (n# ast) 2)
                     (if (> i 1) (.add ret (str " " cmd " "))))
                   (.add ret (tx* a' env)))))
  (wrap ret "(" ")"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-do

  "Evaluates the expressions in order and returns the value of the last. If no
expressions are supplied, returns nil."

  ^{:opcode ["do"] :tag SourceNode} [ast env]

  (with-local-vars [ret (node' ast)
                    stmtQ (stmt? ast)])
  (.add ret (txDo (exprHint
                    (xfi ast
                         (rest ast))
                    (not stmtQ)) env (not stmtQ)))
  (if stmtQ
    (wrap ret "if (true) {\n" "\n}\n")
    (wrap ret "(function() {\n"  "}).call(this)")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-case

  "Takes an expression, and a set of clauses.
 Each clause can take the form of either:
 test-constant result-expr
 (test-constant1 ... test-constantN)  result-expr
 The test-constants are not evaluated. They must be compile-time
literals, and need not be quoted.  If the expression is equal to a
test-constant, the corresponding result-expr is returned. A single
default expression can follow the clauses, and its value will be
returned if no clause matches."

  ^{:opcode ["case"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 4) ast)
  (with-local-vars
    [stmtQ (stmt? ast) ret (node' ast) tst (_2 ast)
     brk ";\nbreak;\n" gs $(gensym "C__")
     dft (if (odd? (n# ast)) (_1 (pop! ast)))])
  (floop [a' ast :start 2 :step 2 :index i]
    (with-local-vars [c (tx* (nexth ast i) env)])
    (if (pairs? a')
      (floop [j' a' :index j]
        (.add ret ["case " (tx* j' env) ":\n"
                   (if (= j (last-index a'))
                     (str gs "=" c brk) "")]))
      (.add ret ["case " (tx* a' env) ":\n" gs "=" c brk])))
  ;maybe add the default clause
  (if dft (.add ret ["default:\n" gs "=" (tx* dft env) brk]))
  ;wrap the switch construct around it
  (wrap ret ["switch (" (tx* tst env) ") {\n"] "}")
  (if stmtQ
    (wrap ret ["let " gs ";\n"] "")
    (wrap ret
          (str "(function() { let " gs ";\n")
          (str "return " gs ";}).call(this)"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-let
  "" ^{:opcode ["letx"] :tag SourceNode} [ast env]
  (vars stmtQ (stmt? ast)
        ret (node' ast)
        e1 (_1 ast) e2 (_2 ast))
  ;change the "let" to "do"
  (aset ast 0 (xfi e1 (symbol "do")))
  (into! undefined
         (cons! (xfi e2 (symbol "vars"))  e2))
  (sf-do ast env))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-var

  "Creates a variable with an initial value"

  ^{:opcode ["const-" "const"
             "def-" "def" "vars" "locals"] :tag SourceNode} [ast env]

  (assertArity (odd? (n# ast)) ast)
  (with-local-vars [ret (node' ast) cmd $(_1 ast)
                    vs [] keys {}
                    pub? (or (== cmd "def") (== cmd "const"))])
  (set! cmd (if (starts-with? cmd "const")
              "const" (if (or (== cmd "locals") (== cmd "vars")) "let" "var")))
  ;deal with 1 level destruction
  (floop [lhs ast :start 1 :step 2 :index i]
    (with-local-vars [rhs (nexth ast i)
                      out (node' ast)
                      x ? rval (tx* rhs env)])
    (if (symbol? lhs)
      (do (set! x lhs lhs (tx* lhs env))
          (if-not (== "let" cmd)
            (rt/addVar $(x) {:ns (std/*ns*) }))
          (assoc! keys lhs lhs)
          (conj! vs $(x))
          (.add ret [cmd " " lhs "=" rval ";\n"]))
      (.add ret ["let " (tx* (dstru* lhs out env) env) "=" rval ";\n" out])))
  (when pub?
    (each #(conj! *vars* %) vs)
    (each-key #(assoc! *externs* %2 %1) keys)) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-inst?

  "Evaluates x and tests if it is an instance of the class
  c. Returns true or false.
  (inst? c x)"

  ^{:opcode ["inst?"] :tag SourceNode} [ast env]

  (assertArity (= (n# ast) 3) ast)
  (wrap (node' ast) nil ["(" (tx* (_3 ast) env)
                         " instanceof " (tx* (_2 ast) env) ")"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-delete

  "Delete an object or property of an object."

  ^{:opcode ["delete!"] :tag SourceNode} [ast env]

  (assertArity (and (>= (n# ast) 2)
                    (< (n# ast) 4)) ast)
  (with-local-vars [ret (node' ast)])
  (.add ret ["delete " (tx* (_2 ast) env)])
  (if (> (n# ast) 2)
    (.add ret ["[" (tx* (.@2 ast) env) "]"])) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-dissoc!

  "Remove a key from Map."

  ^{:opcode ["dissoc!"] :tag SourceNode} [ast env]

  (assertArity (= (n# ast) 3) ast)
  (.add (node' ast)
        [(slib! (str KBSTDLR
                        "." (tx* (symbol "dissoc!") env)))
         "(" (tx* (_2 ast) env) "," (tx* (.@2 ast) env) ")"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-new

  "The args, if any, are evaluated from left to right,
  and passed to the constructor of the class
  named by Classname. The constructed object is returned.
  e.g.
  (new Error 'a' 3)"

  ^{:opcode ["new"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 2) ast)
  (wrap (node' ast) "new " (tx* (xfi ast (rest ast)) env)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-throw

  "Throw an exception"

  ^{:opcode ["throw"] :tag SourceNode} [ast env]

  (assertArity (= (n# ast) 2) ast)
  (with-local-vars [ret (node' ast)
                    stmtQ (stmt? ast)])
  (.add ret ["throw " (tx* (xfi ast (_2 ast)) env)])
  (if-not stmtQ
    (wrap ret "(function (){ " ";}).call(this)")) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-x-opop

  "Unary operator for increment & decrement"
  ^{:opcode ["++" "--" "++$" "--$"] :tag SourceNode} [ast env]

  (assertArity (= (n# ast) 2) ast)
  (with-local-vars [cmd $(_1 ast)
                    a2 (tx* (_2 ast) env)])
  (.add (node' ast)
        (if (ends-with? cmd "$")
          [a2 (.slice cmd 0 -1)] [cmd a2])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-x-eq

  "Compound assignment operators"

  ^{:opcode ["+=" "-=" "*=" "/="
             "div=" "rem=" "exp="
             "bit-and="
             "bit-or="
             "bit-xor="
             "bit-shift-left="
             "bit-shift-right="
             "unsigned-bit-shift-right="]
       :tag SourceNode} [ast env]

  (assertArity (= (n# ast) 3) ast)
  (with-local-vars
   [a0 $(_1 ast)
    cmd (case a0
          "unsigned-bit-shift-right=" ">>>="
          "bit-shift-right=" ">>="
          "bit-shift-left=" "<<="
          "bit-xor=" "^="
          "bit-or=" "|="
          "bit-and=" "&="
          "div=" "/="
          "rem=" "%="
          "exp=" "**=" a0)])
  (wrap (node' ast)
        "("
        [(tx* (_2 ast) env)
         " " cmd " " (tx* (_3 ast) env) ")"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-assoc!
  "Object property assignment or array index setter."
  ^{:opcode ["assoc!"] :tag SourceNode} [ast env]
  (assertArity (even? (n# ast)) ast)
  (with-local-vars [ret (node' ast)
                    obj (tx* (_2 ast) env)])
  (floop [a' ast :start 2 :step 2 :index i]
    (if (> i 2) (.add ret ","))
    (.add ret
          [(slib! (str KBSTDLR "." (tx* (symbol "assoc!") env)))
           "(" obj ","
           (tx* (xfi ast a') env) ","
           (tx* (xfi ast (nexth ast i)) env) ")"]))
  (wrap ret "(" ")"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-assign!
  "Object property assignment or array index setter."
  ^{:opcode ["oset!" "aset"] :tag SourceNode} [ast env]
  (assertArity (even? (n# ast)) ast)
  (with-local-vars [ret (node' ast)
                    obj (tx* (_2 ast) env)])
  (floop [a' ast :start 2 :step 2 :index i]
    (if (> i 2) (.add ret ","))
    (.add ret [obj
               "[" (tx* (xfi ast a') env) "]"
               "=" (tx* (xfi ast (nexth ast i)) env)]))
  (wrap ret "(" ")"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-set

  "Set value(s) to variable(s).
  e.g. (set! a 2 b 4 ...)"

  ^{:opcode ["set!" "var-set"] :tag SourceNode} [ast env]

  (with-local-vars [ret (node' ast)])
  (assertArity (odd? (n# ast)) ast)
  (floop [a' ast :start 1 :step 2 :index i]
    (if (> i 1) (.add ret ","))
    (.add ret [(tx* a' env)
               "=" (tx* (xfi ast (nexth ast i)) env)]))
  (wrap ret "(" ")"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-fn

  "Defines an anonymous function. See defn.
  (fn attrs? [x y] ...)"

  ^{:opcode ["fn"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 2) ast)
  (with-local-vars [body (xfi ast (slice ast 2))
                    [_ args] (meta?? (_2 ast) env)])
  (if-not (array? args)
    (error! :invalid-fargs ast))
  (with-local-vars
    [fargs (doFuncArgs (xfi ast args) env)])
  (wrap (node' ast)
        nil
        ["function (" (_1 fargs) ") {\n"
         (_2 fargs) (txDo body env #t) "}"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-func

  "Defines a function. Use defn- to indicate privacy (no export).
  (defn name doc-string? attr-map? [params*] ...)"

  ^{:opcode ["defn" "defn-"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 2) ast)
  (with-local-vars
    [mtd? (== $(_1 ast) "method") pub? (isPub? ast)
     fname0 $(_2 ast) fname $(tx* (_2 ast) env)
     dot? (contains? fname ".")
     ret (node' ast (tnodeEx fname))
     [doc pargs] (if (string? (_3 ast))
                   [(nth ast 2) 3] [nil 2])
     body (xfi ast (slice ast (+1 pargs)))
     b1 (_1 body)
     [attrs args] (meta?? (nth ast pargs) env)])
  (if-not mtd? (rt/addVar fname0 {:ns (std/*ns*) }))
  (if-not (array? args) (error! :invalid-fargs ast))
  (with-local-vars [pre ? post ?
                    fargs (doFuncArgs (xfi ast args) env)])
  (set! attrs (or attrs {}))
  (when (map? b1)
    (floop [e b1 :step 2 :index i]
      (with-local-vars [e2 (nexth b1 i)])
      (when (and (keyword? e)
                 (array? e2))
        (cond (== e :post) (set! post e2)
              (== e :pre) (set! pre e2)))))
  (cond mtd?
        (do (if (.-static attrs)
              (.add ret "static "))
            (.add ret (str fname " ("))
            (if (== fname "constructor")
              (conj! body 'this)))
        dot?
        (.add ret (str fname " = function ("))
        :else
        (.add ret (str "const " fname " = function (")))
  (.add ret [(_1 fargs) ") {\n" (_2 fargs)])
  (when (or pre post)
    (set! body (rest body))
    (.add ret (writeFuncPre (xfi ast pre) env)))
  (.add ret [(txDo body env #t) "};\n"])
  (if (not-empty attrs)
    (.add ret (fmtSpecOps fname attrs)))
  (if doc
    (.prepend ret (writeDoc doc)))
  (when (and pub?
             (not dot?)
             (not mtd?))
    (conj! *vars* fname0)
    (assoc! *externs* fname fname))
  (.prepend ret (writeFuncInfo fname0 ast)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-try

  "The exprs are evaluated and, if no exceptions occur, the value of the last
is returned. If an exception occurs and catch clauses are provided, each is
examined in turn and the first for which the thrown exception is an instance
of the named class is considered a matching catch clause. If there is a
matching catch clause, its exprs are evaluated in a context in which name is
bound to the thrown exception, and the value of the last is the return value
of the function. If there is no matching catch clause, the exception
propagates out of the function. Before returning, normally or abnormally,
any finally exprs will be evaluated for their side effects."

  ^{:opcode ["try"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 2) ast)
  (with-local-vars [stmtQ (stmt? ast)
                    t ? f ? c ? sz (n# ast) ret (node' ast)])
  ;;look for finally
  (set! f (last ast))
  (if (and (array? f)
           (== $(_1 f) :finally))
    (do (pop! ast)
        (set! sz (n# ast))
        (xfi (_1 f) f))
    (nil! f))
  ;;look for catch
  (nil! c)
  (if (> sz 1)
    (set! c (nth ast (-1 sz))))
  (if (and (array? c)
           (== $(_1 c) :catch))
    (do (if (or (< (n# c) 2)
                (not (symbol? (_2 c))))
          (error! :invalid-catch ast))
        (pop! ast)
        (xfi (_1 c) c))
    (nil! c))
  ;;try needs either a catch or finally or both
  (if (and (nil? f)
           (nil? c)) (error! :invalid-try ast))
  (.add ret ["try {\n"
             (txDo (exprHint (xfi ast (rest ast))
                             (not stmtQ)) env) "\n}"])
  (when c
    (set! t (_2 c))
    (.add ret ["catch (" (tx* t env) ") {\n"
               (txDo (exprHint (xfi c (slice c 2))
                               (not stmtQ)) env) ";\n}\n"]))
  (when f
    (.add ret ["finally {\n",
               (txDo (exprHint (xfi f (rest f)) #f) env #f) ";\n}\n"]))
  (if-not stmtQ
    (wrap ret "(function(){\n" "}).call(this)")) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-if

  "Evaluates test. If truthy evaluates 'then' otherwise 'else'.

  (if test then else)
  (if test then)"

  ^{:opcode ["if"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 3) ast)
  (with-local-vars [stmtQ (stmt? ast)
                    ret (node' ast)
                    ;test is always an expression
                    a1 (exprHint (xfi ast (_2 ast)) #t)
                    a2 (exprHint (xfi ast (_3 ast)) (not stmtQ))
                    m? (> (n# ast) 3)
                    a3 (if m? (xfi ast (.@3 ast)))
                    elze (if m? (exprHint a3 (not stmtQ)))])
  (set! a1 (tx* a1 env)
        a2 (tx* a2 env)
        elze (tx* elze env))
  (wrap ret
        nil
        (if stmtQ
          ["if (" a1 ") {\n" a2 ";\n}"
           (if m? (str " else { \n" elze ";\n}") "")]
          ["(" a1 " ?\n" a2 " :\n" (or elze "null") ")"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-get

  "Returns the named property of an object,
  or value at the index of an array.

  (get obj \"age\")
  (aget obj 4)
  (nth obj 3)"

  ^{:opcode ["oget" "nth" "get" "aget"] :tag SourceNode} [ast env]

  (assertArity (= (n# ast) 3) ast)
  (with-local-vars [ret (node' ast)
                    a0 $(_1 ast)
                    cmd (slib! GET-PROP)])
  (if (== a0 "get")
    (wrap ret
          nil [cmd "("
               (tx* (xfi ast (_2 ast)) env)
               "," (tx* (xfi ast (_3 ast)) env) ")"])
    (wrap ret
          nil [(tx* (xfi ast (_2 ast)) env)
               "[" (tx* (xfi ast (_3 ast)) env) "]"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-array

  "Creates a new vector containing the args.

  (vec \"hello\" \"world\")
  (vec 1 2 3)
  [1 2 3]
  [\"hello\" \"world\"]"

  ^{:opcode ["vec" "array"] :tag SourceNode} [ast env]

  (with-local-vars [ret (node' ast)])
  (assertArity true ast)
  (if-not (vector? ast)
    (if-not (or (== "vec" $(_1 ast))
                (== "array" $(_1 ast)))
      (raise! :syntax-error "expecting vec")
      (set! ast (rest ast))))
  (doseq [a' ast]
    (.add ret (tx* (xfi ast a') env)))
  (.join ret ",")
  (wrap ret "[" "]"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-objObj
  "Returns a new object with supplied key-mappings.
  (object \"a\" 1 \"b\" 2)
  {:a 1 :b 2}"
  ^{:opcode ["object" "js-obj"] :tag SourceNode} [ast env]
  (with-local-vars [ret (node' ast)])
  (assertArity true ast)
  (if-not (obj? ast)
    (if-not (or (== "object" $(_1 ast))
                (== "js-obj" $(_1 ast)))
      (raise! :syntax-error "expecting object")
      (set! ast (rest ast))))
  (floop [a' ast :index i :step 2]
    (.add ret (str (tx* a' env)
                   ": " (tx* (xfi ast (nexth ast i)) env))))
  (.join ret ",")
  (wrap ret "{" "}"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-mapObj
  ""
  ^{:opcode ["hash-map"] :tag SourceNode} [ast env]
  (with-local-vars [ret (node' ast)])
  (assertArity true ast)
  (if-not (map? ast)
    (if-not (== "hash-map" $(_1 ast))
      (raise! :syntax-error "expecting hash-map")
      (set! ast (rest ast))))
  (floop [a' ast :index i :step 2]
    (.add ret (str "[" (tx* a' env)
                   "," (tx* (xfi ast (nexth ast i)) env) "]")))
  (.join ret ",")
  (wrap ret "(new Map([" "]))"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-setObj

  "Returns a new Set.
  (set 1 2 3)"

  ^{:opcode ["hash-set"] :tag SourceNode} [ast env]

  (with-local-vars [ret (node' ast)])
  (assertArity true ast)
  (if-not (set? ast)
    (if-not (== "hash-set" $(_1 ast))
      (raise! :syntax-error "expecting hash-set")
      (set! ast (rest ast))))
  (doseq [a' ast] (.add ret (tx* a' env)))
  (.join ret ",")
  (wrap ret "(new Set([" "]))"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- require! "" [path]
  ;(println "require path = " path)
  (try (require path)
       (catch e
         (println "warning: failed to load lib: " path) nil)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-require2 "" [ret fdir ast env]

  (with-local-vars [used ? rlib ? as $(gensym "R__")
                    rpath $(_1 ast) mcs ? nsp ?
                    vvv ? info ? libpath ? refers ? renames ?])
  (if (symbol? rpath)
    (set! rpath (quote-str (str rpath))))
  ;;scan options
  (floop [v ast :start 1 :index j :step 2]
    (condp == v
      :as (set! as $(nexth ast j))
      :refer (set! refers (nexth ast j))
      :rename (set! renames (nexth ast j))))
  ;;resolve requested module path
  (set! libpath (tx* (if (contains? rpath "./")
                       (path/resolve fdir rpath) rpath) env))
  ;;add the (actual) require line
  (.add ret ["const " (reader/jsid as)
             "= require(" (tx* rpath env) ");\n"])
  ;;load the lib
  (set! rlib (require! (unquote-str libpath)))
  (if rlib (set! info (get rlib EXPKEY)))
  (rt/addLib $(as) rlib)
  ;;look into module's metadata
  (when info
    (set! mcs (get info :macros)
          vvv (loadRVars info env)
          nsp (loadRLib info env)))
  (set! mcs (or mcs {})
        vvv (or vvv [])
        used #{}
        nsp (or nsp ""))
  (if (and (keyword? refers)
           vvv
           (== refers :all)) (set! refers (_1 vvv)))
  ;;look into renames
  (floop [ro renames :step 2 :index i]
    (with-local-vars [rn (.@+i renames)
                      ev $(ro) rs $(rn)])
    (when info
      (if-not (or (get mcs ev)
                  (contains? (_2 vvv) ev)) (raise! "Unknown var: '" ev "'"))
      (if (or (get mcs rs)
              (contains? (_2 vvv) rs))
        (raise! "Cannot rename var: '" ev "' to existing var: '" rs "'")))
    (rt/addVar rs {:ns nsp})
    (conj! used ev)
    (.add ret ["const " (tx* rn env) "=" as "[\"" (tx* ro env) "\"];\n"]))
  ;;look into refers
  (floop [r refers]
    (with-local-vars [rs $(r) v (tx* r env)])
    (when-not (contains? used rs)
      (when info
        (if-not (or (get mcs rs)
                    (contains? (_2 vvv) rs)) (raise! "Unknown var: '" rs "'")))
      (rt/addVar rs {:ns nsp})
      (.add ret ["const " v "=" as "[\"" v "\"];\n"]))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-require

  "Loads libs.

  (:require [\"z\" :rename {hello goodbye}])
  (:require [\"a\" :as A])
  (:require [\"b\"]
            [\"c\" :refer [hello world]])"

  ^SourceNode [ast env]

  (assertArity (>= (n# ast) 2) ast)
  (with-local-vars [ret (node' ast)
                    fdir (path/dirname ast.source)])
  (doseq [a' (rest ast)]
    (if-not (and (array? a')
                 (or (symbol? (_1 a'))
                     (string? (_1 a')))) (error! :invalid-require ast))
    (sf-require2 ret fdir a' env)) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-ns

  "(ns name doc-string? attr-map? references*)

  Creates a namespace, references can be zero or more of:
  (:require ...)

  (ns ^{:doc \"some doc\"} hello.world.core ...)"

  ^{:opcode ["ns"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 2) ast)
  (with-local-vars [ret [] doc nil e nil
                    mobj nil pos 2
                    [attrs nsp] (meta?? (_2 ast) env)])
  (if-not (symbol? nsp)
    (error! :invalid-namespace ast))
  (when (string? (.@pos ast))
    (set! attrs (or attrs {}))
    (assoc! attrs :doc (.@pos ast)) (++ pos))
  (when (map? (.@pos ast))
    (set! mobj (evalMeta (.@pos ast) env)
          attrs (merge attrs mobj))
    (++ pos)
    (oset! nsp :____meta attrs))
  (std/pushNSP $(nsp) attrs)
  ;;(println (str "Processing namespace: " $(nsp)))
  (set! ast (xfi ast (slice ast pos)))
  (doseq [e ast]
    (when (pairs? e)
      (cond
        (== $(_1 e) :require)
        (conj! ret (sf-require (xfi ast e) env)))))
  ;;force a internal reference to stdlib for user files
  ;;unless processing internal files
  (set! nsp (std/*ns*))
  (cond
    (== nsp (str KBPFX "stdlib"))
    nil
    (starts-with? nsp KBPFX)
    (conj! ret
           (str "const " KBSTDLR "=std;\n"))
    :else
    (->> (-> (xfi ast '(require ["kirby" :as kirbystdlibref]))
             (sf-require env))
         (conj! ret )))
  (conj! ret
         (str "const "
              std/MODULE_NAMESPACE
              "= " (std/quote-str nsp) ";\n")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-comment "" ^{:opcode ["comment"] :tag String} [ast env] "")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-while

  "Generates native for loop."

  ^{:opcode ["while"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 2) ast)
  (with-local-vars [stmtQ (stmt? ast)
                    ret (node' ast)
                    body (exprHint (xfi ast (slice ast 2)) #f)])
  (if (empty? body)
    ret (sf-wloop ret (_2 ast) body env stmtQ)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-wloop
  "For loop implementation"
  ^SourceNode [ret tst body env stmtQ]

  (with-local-vars [nb '(not ____break)])
  (.add ret "for (let ____break=false; ")
  (xfi ret nb)
  (set! tst ['and nb tst])
  (xfi ret tst)
  (.add ret [(tx* tst env) ";"
             "){\n" (txDo body env #f) "}\n"])
  (if-not stmtQ
    (wrap ret "(function() {\n"  "; return null; }).call(this)")) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-forxxx

  "Generates native for loop."

  ^{:opcode ["floop" "rloop"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 2) ast)
  (with-local-vars [stmtQ (stmt? ast)
                    ret (node' ast)
                    body (exprHint (xfi ast (slice ast 2)) #f)])
  (if (empty? body)
    ret
    (sf-foop ret
             $(_1 ast) (xfi ast (_2 ast)) body env stmtQ)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-foop
  "For loop implementation"
  ^SourceNode [ret cmd args body env stmtQ]

  (with-local-vars
    [vars ['____coll nil '____index 0]
     incr? (== cmd "floop")
     decr? (== cmd "rloop")
     recurs []
     indexer ? tst ?
     nb ? sz ? begin 0
     lvar ? coll ? start ? end ? step ?])
  (when (symbol? (_1 args))
    (set! begin 2 lvar (_1 args) coll (_2 args))
    (set! vars ['____coll coll '____index 0]))
  (floop [e args :start begin :step 2 :index i]
    (cond (== e :while)
          (set! tst (nexth args i))
          (== e :index)
          (aset vars 2 (nexth args i))
          (== e :recur)
          (set! recurs (nexth args i))
          (== e :start)
          (set! start (nexth args i))
          (== e :end)
          (set! end (nexth args i))
          (== e :step)
          (set! step (nexth args i))
          (symbol? e)
          (conj! vars e (nexth args i))))
  (set! indexer (nth vars 2))
  (when (undef? start)
    (if incr? (set! start 0))
    (if decr? (set! start ['- ['n# '_coll] 1])))
  (aset vars 3 start)
  (when (undef? end)
    (set! end (if decr? -1 (if incr? ['n# '____coll]))))
  (conj! vars '____end  end)
  (when (undef? tst)
    (if incr?
      (set! tst ['<  indexer '____end]))
    (if decr?
      (set! tst ['>  indexer '____end])))
  (.add ret "for (")
  (floop [e vars :step 2 :index i]
    (if (= i 0) (.add ret "let "))
    (if (not= i 0) (.add ret ","))
    (.add ret [(tx* e env) "=" (tx* (nexth vars i) env)]))
  (.add ret ["," BREAK "=false;"])
  (set! nb '(not ____break))
  (xfi ret nb)
  (set! tst (if (def? tst)
              ['and nb tst] nb))
  (xfi ret tst)
  (.add ret [(tx* tst env) "; "])
  (if (undef? step) (set! step 1))
  (if incr? (cons! ['+ indexer step] recurs))
  (if decr? (cons! ['- indexer step] recurs))
  (floop [e recurs k 2 :index i :recur [(+2 k)]]
    (if (not= i 0) (.add ret ","))
    (.add ret [(tx* (nth vars k) env) "=" (tx* e env)]))
  (.add ret ["){\n"
             (if (def? lvar)
               (sf-var (xfi args ['vars lvar
                                  ['nth '____coll indexer]]) env) "")
             (txDo body env #f) "}\n"])
  (if-not stmtQ
    (wrap ret "(function() {\n"  "; return null; }).call(this)")) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-jscode

  "Inject raw native code fragment.

  (raw# \"console.log('hi');\")"

  ^{:opcode ["raw#"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 2) ast)
  (with-local-vars [s $(_2 ast)
                    name (reader/jsid "sf-jscode")])
  (->>
    (if (and (ends-with? s "\"")
             (starts-with? s "\""))
      (.slice s 1 -1) s) (tnodeEx name) (node' ast)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-macro

  "Like defn, but the resulting function name is declared as a
macro and will be used as a macro by the compiler when it is
called.

  (defmacro macro-name [args] ...)"

  ^{:opcode ["defmacro"] :tag String} [ast env]

  (assertArity (>= (n# ast) 4) ast)
  (with-local-vars [pms []
                    args (_3 ast)
                    body (slice ast 3)
                    mname ? mobj ? doc ? x ?])
  ;;deal with docstring
  (when (string? args)
    (set! doc args args (.@3 ast) body (slice ast 4)))
  ;;in-case of meta data
  (set! x (meta?? args env)
        args (_2 x) mobj (_1 x))
  ;;deal with var-args
  (floop [e args :index i]
    (with-local-vars [ev $(e)])
    (cond (== ev "&")
          (if (array? (nexth args i))
            (do (set! e (nexth args i))
                (++ i)
                (doseq [x e]
                  (if-not (symbol? x)
                    (error! :syntax-error ast))
                  (conj! pms x)))
            (do (conj! pms e (nexth args i))
                (++ i)))
          (not (symbol? e))
          (error! :syntax-error ast)
          :else
          (conj! pms e)))
  ;ask engine to compile this macro and stores it
  (set! mname (_2 ast)
        ast ['macro* mname pms (_1 body)])
  (rt/addVar mname {:ns (std/*ns*) })
  ;if not private, need to export it
  (if-not (and mobj
               (true? (get mobj :private)))
    (assoc! *macros* mname (prn ast #t)))
  ;compile it
  (rt/compute ast env) "")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-unary

  "Special unary operators."

  ^{:opcode ["not" "!"] :tag SourceNode} [ast env]

  (assertArity (= (n# ast) 2) ast)
  (with-local-vars [[a0 a1] ast])
  (if (== a0 "not") (set! a0 '!))
  (.add (node' ast) ["(" $(tx* a0 env) $(tx* a1 env) ")"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-listc

  "List comprehension. Takes a vector of one or more
 binding-form/collection-expr pairs, each followed by zero or more
 modifiers, and yields a lazy sequence of evaluations of expr.
 Collections are iterated in a nested fashion, rightmost fastest,
 and nested coll-exprs can refer to bindings created in prior
 binding-forms.  Supported modifiers are: :let [binding-form expr ...],
 :while test, :when test."

  ^{:opcode ["for"] :tag SourceNode} [ast env]

  (with-local-vars [cap (gensym)])
  (wrap (node' ast)
        ["(function() {\n" "let " $(cap) "=[];\n"]
        [(sf-doseq (exprHint ast #f) env cap)
         "return " $(cap) ";\n}).call(this)"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-doseq

  "Repeatedly executes body (presumably for side-effects) with
bindings and filtering as provided by \"for\".  Does not retain
the head of the sequence. Returns nil."

  ^{:opcode ["doseq"] :tag SourceNode} [ast env & [capRes]]

  (with-local-vars
    [body (exprHint (xfi ast (slice ast 2)) #f)
     while' (gensym) inner "" ret ? fst #t
     kount (slib! COUNT)
     stmtQ (stmt? ast)
     args (_2 ast)
     _ (assert (even? (n# args))
               "bindings not even")
     [x y] (split-with
             #(not (keyword? %)) args)
     ;reverse the bindings (inside out)
     arr (rseq (partition 2 x))])
  (loop [p1 (_1 arr)
         pn (rest arr)]
    (when p1
      (with-local-vars [e' (gensym)
                        n' (gensym)])
      (set! ret (node' ast))
      (.add ret
            ["for(let " $(n') "=0,"
             (if (empty? pn) (str $(while') "=true,") "")
             $(e') "=" (tx* (_2 p1) env) ","
             "____sz=" kount "(" $(e') ")"
             (if fst ",____break=false" "") "; ("
             (if fst "!____break && " "")
             $(while') " && "
             "(" $(n') " < ____sz)"
             "); ++" $(n') "){\n"])
      (.add ret (sf-var (xfi ast ['vars (_1 p1) ['nth e' n']]) env))
      (if fst
        (do (false! fst)
            (doseq-binds while' ret y body ast env capRes))
        (.add ret inner))
      (.add ret "}\n")
      (set! inner ret)
      (if (not-empty pn)
        (recur (_1 pn) (rest pn)))))
  (if-not stmtQ
    (wrap ret
          "(function() {\n"
          "; return null; }).call(this)")) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- doseq-binds "" [while' ret binds body ast env capRes]
  (with-local-vars [patch (node' ast)])
  (each (fn [[k expr]]
          (condp == k
            :let (.add ret (sf-var (xfi ast (cons 'vars expr))))
            :when (do (.add ret ["if (" (tx* expr env) ") {\n"])
                      (.add patch "}\n"))
            :while (do (.add ret ["if (!(" (tx* expr env) ")) { "
                                  $(while') "=false; ____break=true; } else {\n"])
                       (.add patch "}\n"))))
        (partition 2 binds))
  ;;if capturing the result, must be expression
  (if capRes (exprHint body #t))
  (if capRes
    (.add ret [$(capRes) ".push((function() {\n"
               (txDo body env #t) "\n}).call(this));\n"])
    (.add ret (txDo body env #f)))
  (.add ret patch))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- xfi "Transfer source map info" ^Any [from to]
  (when (and from
             to
             (not (number? to.line))
             (number? from.line))
    (oset! to
           :source (.-source from)
           :line (.-line from)
           :column (.-column from))) to)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- spitMacros "Dump all macros to string." []
  (if (empty? *macros*)
    "{}"
    (-> (map (fn [[k v]]
               (str (quote-str (str k))
                    ":" (quote-str v))) (seq *macros*))
        (.join ",\n")
        (std/wrap-str  "{\n" "}\n"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- spitVars "Dump all public vars to string." []
  (if (empty? *vars*)
    "[]"
    (-> (map #(quote-str $(%)) *vars*) (.join ",") (std/wrap-str  "[ " "]"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- spitExterns "Write out export info" ^String []
  (str "\n\nmodule.exports = {\n"
       (str EXPKEY
            ": { ns: " (quote-str (std/*ns*))
            ", vars: " (spitVars)
            ", macros: " (spitMacros) " }")
       (if (not-empty *vars*)
         (str ",\n" (join ",\n" (map #(str (reader/jsid %)
                                           ":"
                                           (reader/jsid %)) *vars*)))) "\n};\n"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- banner "Banner text for the target file" ^String []
  (with-local-vars [{:keys [id meta]} (std/peekNSP)])
  (str "/*" "Auto generated by Kirby v" MOD-VER
       " - " (new Date) "\n" "  " id "\n" (if meta (prn meta #t) "") "\n" "*/\n\n"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- cleanCode "Get rid of empty lines or no-op lines" ^String [code]
  (->> (.split code "\n")
       (map #(if-some+ [s (.trim %)]
                       (if (not= s ";") %))) (filter #(not-empty %)) (join "\n")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpile*

  "Compiles a source file, returning the translated source and
  possible error object."

  ^Array [source fname options]

  (with-local-vars
    [ret (-> (reader/parse source fname) (txTree (rt/genv)))
     {:keys [source-map no-format verbose]} options
     err ?
     [fmap smap] (map #(str
                         (path/basename fname ".ky") %) [".js" ".map"])])
  ;;wantr source map? generate the map file
  (when source-map
    (with-local-vars [sout (->> `{:skipValidation #t :file fmap}
                                (.toStringWithSourceMap ret))])
    (set! ret sout.code)
    (fs/writeFileSync smap sout.map))
  ;;construct the final source
  (set! cstr
        (str ret
             (spitExterns)
             (if source-map
               (str "\n//# sourceMappingURL="
                    (path/relative (path/dirname fname) smap)))))
  ;;code isn't in nice format, make it nice
  ;;if error => most likely generated bad code
  (try (if-not no-format
         (set! cstr (esfmt/format cstr `{})))
       (catch e (set! err e)))
  ;;clean final source
  (set! cstr (cleanCode cstr))
  [(if (empty? cstr) "" (str (banner) cstr)) err])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn transpile

  "Compile kirby file to target source"
  ^Array [code file & [options]]

  (binding [*last-line* 0 *last-col* 0
            *externs* {} *macros* {}
            *vars* (std/into! :vector [])]
    (try (->> (opt?? options `{})
              (transpile* code file ))
         (catch e
           (println "Error near line: "
                    *last-line* ", col: " *last-col* "\n" (str e))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn dbgAST
  "Dump AST to xml" ^String [source fname]
  (-> (reader/parse source fname) (reader/dumpTree  fname)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const version MOD-VER)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

