;; Copyright (c) 2013-2017, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author "Kenneth Leung"}

  czlab.kirby.compiler

  (require ["./stdlib"
            :as std
            :refer [lambda-arg? hashmap pairs? contains? last typeid
                    prn primitive map? vector? opt?? some?
                    primitive? not-empty conj! list?
                    extendAttr gensym count
                    symbol keyword symbol? keyword?]]
           ["./parser" :as parser]
           ["./engine" :as eng])
  (require ["fs" :as fs]
           ["path" :as path]
           ["esformatter" :as esfmt]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- ERRORS-MAP {
  :e0 "Syntax Error"
  :e1 "Empty statement"
  :e2 "Invalid characters in function name"
  :e3 "End of File encountered, unterminated string"
  :e4 "Closing square bracket, without an opening square bracket"
  :e5 "End of File encountered, unterminated array"
  :e6 "Closing curly brace, without an opening curly brace"
  :e7 "End of File encountered, unterminated javascript object '}'"
  :e8 "End of File encountered, unterminated parenthesis"
  :e9 "Invalid character in var name"
  :e10 "Extra chars at end of file. Maybe an extra ')'."
  :e11 "Cannot Open include File"
  :e12 "Invalid no of arguments to "
  :e13 "Invalid Argument type to "
  :e14 "End of File encountered, unterminated regular expression"
  :e15 "Invalid vararg position, must be last argument."
  :e16 "Invalid arity (args > expected) to "
  :e17 "Invalid arity (args < expected) to "})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- MODULE-VERSION "1.0.0")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- EXTERNS nil
      SPEC-OPS {}
      MATH-OP-REGEX /^[-+][0-9]+$/)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- simple? "" [ast]
  (or (undef? ast) (nil? ast) (string? ast) (number? ast) (boolean? ast)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- exprHint "" [ast flag]
  (if (simple? ast)
    (set! ast (primitive ast)))
  (set-in! ast :____expr flag) ast)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- stmt? "" [ast]
  (if (simple? ast)
    (raise! "Cant test expr? on primitive"))
  (false? ast.____expr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- error! "" [e &[line file msg]]
  (raise! (get ERRORS-MAP e)
          (if msg (str " : " msg))
          (if line (str "\nLine no " line))
          (if file (str "\nFile " file))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- syntax! "" [ecode &[ast cmd]]
  (error! ecode
          (if ast ast.line 0)
          (if ast ast.source 0) cmd))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- pad "" [z] (.repeat " " z))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- testre? "" [re x] (if x (re.test x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- node' "" [src &[obj]]
  (set! obj (opt?? obj (tnode)))
  (when src
    (set! obj.source src.source
          obj.column src.column obj.line src.line)) obj)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txTree "" [root env]
  (var ret (node' root))
  (doseq [r root
          :let [tmp (tx* r env)]
          :when (some? tmp)]
    (ret.add [tmp "\n"])) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txExpr "" [expr env]
  (each (fn [a i arr]
          (set-in! arr i (tx* a env))) expr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txAtom "" [a]
  (var s $(a))
  (cond (lambda-arg? a)
        (str "____args[" s "]")
        (keyword? a)
        (str "\"" s "\"")
        (symbol? a)
        (parser/jsid s)
        (nil? a)
        "null"
        (primitive? a)
        (do (set! a a.value)
            (cond (string? a) a
                  (nil? a) "null"
                  :else $(a)))
        :else s))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- tx* "" [x &[env]]
  (try
    (if (array? x) (txPairs x env) (txAtom x))
    (catch e
      (println "Error in file: " x.source
                ", near line: " x.line
                ", column: " x.column)
      (throw e))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- findCmd "" [ast]
  (cond (vector? ast)
        "vec"
        (map? ast)
        "hashmap"
        (list? ast)
        "list"
        (array? ast)
        $(1st ast)
        :else ""))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quoteSingle "" [a]
  (cond (keyword? a)
        (str "keyword(\":" a "\")")
        (symbol? a)
        (str "symbol(\"" a "\")")
        (primitive? a)
        (do (set! a a.value)
            (cond (string? a) a
                  (nil? a) "null"
                  :else $(a)))
        :else $(a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quote! "" [ast env]
  (if (array? ast)
    (if (map? ast)
      (quoteMap ast env)
      (quoteBlock ast env))
    (quoteSingle ast)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quoteMap "" [ast env]
  (var comma ""
       ret (node' ast))
  (for [i 0 sz (n# ast)
        :while (< i sz) :recur (+2 i)]
    (if (> i 0) (ret.add ","))
    (ret.add [(quote! (.@i ast) env)
              " : " (quote! (.@+i ast) env)]))
  (if-not (empty? ast) (set! comma ","))
  (ret.prepend ["[" "symbol(\"hashmap\")" comma])
  (ret.add "]")
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quoteBlock "" [ast env]
  (var ret (node' ast))
  (for [i 0 sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (if (> i 0) (ret.add ","))
    (ret.add (quote! (.@i ast) env)))
  (ret.prepend "[")
  (ret.add "]")
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-quote "" ^{:opcode ["quote"]} [ast env]
  (var ret (node' ast))
  (ret.add (quote! (2nd ast) env))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txPairs "" [ast env]
  (var stmtQ (stmt? ast)
       cmd (findCmd ast)
       ret (node' ast)
       specop nil tmp nil
       mc (eng/getMacro cmd))
  ;;handle macro calls
  (when mc
    (set! ast (eng/expandMacro ast env mc)
          ast (exprHint ast (not stmtQ))
          cmd (findCmd ast)))
  ;;handle (+1 ) or (-1 ) cases
  (when (parser/REGEX.int.test cmd)
    (var c0 (ch@ cmd 0))
    (if (and (not= c0 "-")
             (not= c0 "+"))
      (set! cmd (str "+" cmd)))
    (set! ast [(symbol (ch@ cmd 0))
               (2nd ast)
               (int (rest cmd))]
          cmd $(1st ast)))
  ;;maybe special form
  (set! specop (get SPEC-OPS cmd))
  ;;handle all cases
  (cond
    (== cmd "with-meta")
    (do (set! tmp (2nd ast))
        (if-not (simple? tmp)
          (do (set-in! tmp
                       :____meta
                       (evalMeta (.@2 ast) env))
              (ret.add (tx* tmp env)))
          (raise! "cant with-meta simple value")))
    (cmd.startsWith ".-")
    (ret.add [(tx* (2nd ast) env)
              "."
              (tx* (symbol (cmd.slice 2)))])
    (cmd.startsWith ".@")
    (do (var onemore? #f pos 2)
        (when (cmd.startsWith ".@+")
          (++ pos)
          (true! onemore?))
        (ret.add [(tx* (2nd ast) env)
                  "["
                  (cmd.slice pos)
                  (if onemore? "+1]" "]")]))
    (cmd.startsWith ".")
    (do (ret.add [(tx* (2nd ast) env) cmd "("])
        (for [n 2 sz (n# ast)
              :while (< n sz) :recur (+1 n)]
          (if (not= n 2) (ret.add ","))
          (ret.add (tx* (.@n ast) env)))
        (ret.add ")"))
    (some? specop)
    (set! ret (specop ast env))
    :else
    (do (if (pairs? ast)
          (do (txExpr ast env)
              (set! cmd (1st ast)))
          (set! cmd (tx* ast)))
        (if-not cmd (syntax! :e1 ast))
        (set! cmd (maybeStripStdlib cmd))
        (if (pairs? ast)
          (do (if (testre? parser/REGEX.func cmd)
                (set! cmd (tnodeEx ["(" cmd ")"])))
              (ret.add [cmd
                        "("
                        (join "," (tnodeEx (rest ast))) ")"]))
          (ret.add cmd))))
  (node' ast ret))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- writeDoc "Convert to jsdoc"
  [doc]
  (var out [])
  (if doc
    (->> (-> (doc.replace parser/REGEX.dquoteHat "")
             (.replace parser/REGEX.dquoteEnd "")
             (.split "\\n"))
         (each #(let [s (.trim (str %))]
                  (if (not-empty s)
                    (conj! out (str "//" s "\n"))))))) out)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-deftype
  "Define a JS Class"
  ^{:opcode ["deftype" "deftype-"]}
  [ast env]
  (var private? (ends? $(1st ast) "-")
       czname (tx* (2nd ast))
       par (1st (.@2 ast))
       czargs (.@3 ast) ret (node' ast))
  (var~ n m doc mtds)
  (if (string? (.@4 ast))
    (do (set! doc (.@4 ast)
              mtds (ast.slice 5)))
    (set! mtds (ast.slice 4)))
  (ret.add ["class " czname])
  (if par
    (ret.add [" extends " (tx* par env)]))
  (ret.add " {\n")
  (for [i 0 pos 0 sz (n# mtds)
        :while (< i sz) :recur (+1 i)]
    (set! m (.@i mtds))
    (set! pos (if (string? (2nd m)) 3 2))
    (when (and (== (1st m) "constructor")
               (not-empty args))
      (txExpr args env)
      (for [x 0 sz (n# args)
            :while (< x sz) :recur (+2 x)]
        (set-in! args
                 x
                 (str "\"" (.@x args) "\"")))
      (m.splice pos 0
        (concat [(symbol "set-in!")
                 (symbol "this")] args)))
    (m.unshift (symbol "method"))
    (ret.add (sf-func m env #f))
    (ret.add "\n"))
  (ret.add "}\n")
  (if doc (ret.prepend (writeDoc doc)))
  (if (and (not private?)
           (= 1 (.countNSPCache (eng/globalEnv))))
      (set-in! EXTERNS czname czname))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-compOp ""
  ^{:opcode ["not=" "!=" "=="
             "=" ">" ">=" "<" "<="]}
  [ast env]
  (var ret (node' (tnode) ast)
       cmd (1st ast))
  (if (or (== cmd "not=")
          (== cmd "!="))
    (set-in! ast 0 (symbol "!==")))
  (if (== cmd "=")
    (set-in! ast 0 (symbol "===")))
  (txExpr ast env)
  (for [i 0 op (ast.shift)
        :while (< i (last-index ast)) :recur (+1 i)]
    (ret.add (tnodeEx [(.@i ast)
                       " " op
                       " " (.@+i ast)])))
  (join " && " ret)
  (ret.prepend "(")
  (ret.add ")")
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-arithOp
  ""
  ^{:opcode ["+" "-" "*" "div" "%"  "mod"
             "or" "and"
             "^" "&" "|" "<<" ">>" ">>>"]}
  [ast env]
  (var op (tnode)
       ret (node' (tnode) ast))
  (txExpr ast env)
  (var e1 (ast.shift) cmd $(e1))
  (if (== cmd "mod") (set! cmd "%"))
  (if (== cmd "div") (set! cmd "/"))
  (if (== cmd "and") (set! cmd "&&"))
  (if (== cmd "or") (set! cmd "||"))
  (if (= 1 (n# ast))
    (if (== "-" cmd) (ret.add "-"))
    (op.add [""  cmd  ""]))
  (ret.add ast)
  (if (> (n# ast) 1) (join op ret))
  (ret.prepend "(")
  (ret.add ")")
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txDo "" [ast env & [return?]]
  (var ret (node' (tnode) ast)
       stmtQ (stmt? ast)
       e nil end (last-index ast))
  (set! return?
        (if stmtQ false (opt?? return? true)))
  (for [i 0 :while (< i end) :recur (+1 i)]
    (set! e (exprHint (.@i ast) #f))
    (ret.add [(tx* e env) ";\n"]))
  (when (>= end 0)
    (set! e (exprHint (.@end ast)
                      (not stmtQ))
          e (tx* e env))
    (if-not return?
      (ret.add [e ";\n"])
      (ret.add ["return " e ";\n"])))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-do
  "" ^{:opcode ["do"]} [ast env]
  (var ret (node' (tnode) ast)
       stmtQ (stmt? ast)
       body (exprHint (rest ast) (not stmtQ)))
  (ret.add (txDo body env (not stmtQ)))
  (if stmtQ
    nil;(ret.prepend "{\n")
    (ret.prepend "(function() {\n"))
  (if stmtQ
    nil;(ret.add "}")
    (ret.add "}).call(this)"))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-case
  "" ^{:opcode ["case"]} [ast env]
  (var ret (node' (tnode) ast)
       stmtQ (stmt? ast)
       brk ";\nbreak;\n"
       tst (2nd ast) _x $(gensym "C____"))
  (var~ e t c dft)
  (if (odd? (n# ast))
    (set! dft (ast.pop)))
  (for [i 2 sz (n# ast)
        :while (< i sz) :recur (+2 i)]
    (set! e (.@i ast)
          c (.@+i ast))
    (if (pairs? e)
      (for [j 0 sz (n# e)
            :while (< j sz) :recur (+1 j)]
        (ret.add ["case "
                  (tx* (.@j e)) ":\n"])
        (if (= j (last-index e))
          (ret.add [_x "="
                    (tx* c env) brk])))
      (do (ret.add ["case " (tx* e) ":\n"
                    _x "="
                    (tx* c env) brk]))))
  (when dft
    (ret.add ["default:\n"
              _x "="
              (tx* dft env) brk]))
  (ret.prepend ["switch ("
                (tx* tst env) ") {\n"])
  (ret.add "}")
  (if stmtQ
    (ret.prepend ["let " _x ";\n"])
    (ret.prepend ["(function() { let " _x ";\n"]))
  (if stmtQ
    nil;(ret.add "}")
    (ret.add ["return " _x ";}).call(this)"]))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-vardefs
  ""
  ^{:opcode ["def~-" "def~" "var~"]}
  [ast env]

  (var ret (node' (tnode) ast)
       cmd $(1st ast)
       kks {}
       private? (.endsWith cmd "-"))
  (if-not (== "let" cmd) (set! cmd "var"))
  (for [i 1 s nil sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (set! s (tx* (.@i ast)))
    (ret.add s)
    (set-in! kks s nil))
  (ret.join ",")
  (ret.prepend (str cmd " "))
  (ret.add ";\n")
  (if (and (not private?)
           (= 1 (.countNSPCache (eng/globalEnv))))
    (each-key (fn [v k]
                (set-in! EXTERNS k k)) kks))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-const
  ""
  ^{:opcode ["const" "const-"]}
  [ast env]

  (var ret (node' (tnode) ast)
       cmd $(1st ast)
       keys []
       vname nil
       private? (.endsWith cmd "-"))
  (var~ rval rc lhs rhs)
  (set! ast (rest ast) cmd "const")
  (for [i 0 sz (n# ast)
       :while (< i sz) :recur (+2 i)]
    (set! lhs (.@i ast)
          rhs (.@+i ast)
          rval (tx* rhs env))
    (if (symbol? lhs)
      (do (set! lhs (tx* lhs))
          (conj! keys lhs)
          (ret.add [cmd " " lhs "= " rval ";\n"]))
      (do (set! out (tnode))
          (set! rhs (destruct* lhs out))
          (ret.add ["let " (tx* rhs) "=" rval ";\n"])
          (ret.add out))))
  (when (and (not private?)
             (= 1 (.countNSPCache (eng/globalEnv))))
    (each #(set-in! EXTERNS % %) keys))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-var
  ""
  ^{:opcode ["def" "def-" "var"]}
  [ast env]

  (var ret (node' (tnode) ast)
       tmp nil vname nil
       cmd $(1st ast)
       keys []
       private? (not= cmd "def"))
  (var~ rval rc lhs rhs)
  (set! ast (rest ast)
        cmd (if (== cmd "var") "let" "var"))
  (for [i 0 sz (n# ast)
        :while (< i sz) :recur (+2 i)]
    (set! lhs (.@i ast)
          rhs (.@+i ast)
          rval (tx* rhs env))
    (if (symbol? lhs)
      (do (set! lhs (tx* lhs)
                tmp [cmd " " lhs "= " rval ";\n"])
          (conj! keys lhs)
          (ret.add tmp))
      (do (set! out (tnode))
          (set! rhs (destruct* lhs out))
          (ret.add ["let " (tx* rhs) "=" rval ";\n"])
          (ret.add out))))
  (when (and (not private?)
             (= 1 (.countNSPCache (eng/globalEnv))))
    (each (fn [k]
            (set-in! EXTERNS k k)) keys))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-inst?
  "" ^{:opcode ["inst?"]} [ast env]
  (var ret (node' (tnode) ast))
  (ret.add ["("
            (tx* (.@2 ast) env)
            " instanceof "
            (tx* (2nd ast) env) ")"])
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-delete
  "" ^{:opcode ["delete!"]} [ast env]
  (var ret (node' (tnode) ast))
  (ret.add ["delete " (tx* (2nd ast) env)])
  (if (> (n# ast) 2)
    (ret.add ["[" (tx* (.@2 ast)) "]"]))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-new
  "" ^{:opcode ["new"]} [ast env]
  (var ret (node' (tnode) ast))
  (ret.add (tx* (rest ast) env))
  (ret.prepend "new ")
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-throw
  "" ^{:opcode ["throw"]} [ast env]
  (var ret (node' (tnode) ast)
       stmtQ (stmt? ast))
  (ret.add ["throw " (tx* (2nd ast) env)])
  (when-not stmtQ
    (ret.prepend "(function (){ ")
    (ret.add ";}).call(this)"))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-x-opop
  "" ^{:opcode ["++" "--"]} [ast env]
  (txExpr ast env)
  (node' (tnodeEx [(1st ast)
                   (2nd ast)]) ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-x-eq
  "" ^{:opcode ["+=" "-=" "*="
                "/=" "%=" "<<="
                ">>=" ">>>=" "&=" "|=" "^="]} [ast env]
  (txExpr ast env)
  (node' (tnodeEx [(2nd ast)
                   " "
                   (1st ast)
                   " " (.@2 ast)])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-set-in
  "" ^{:opcode ["set-in!"]} [ast env]
  (assert (even? (n# ast))
          "set-in: bad arg count")
  (var ret (node' (tnode) ast)
       more #f
       obj (tx* (2nd ast) env))
  (for [i 2 sz (n# ast)
        :while (< i sz) :recur (+2 i)]
    (when (> i 2)
      (ret.add ",")
      (true! more))
    (ret.add [obj "[" (tx* (.@i ast) env) "]"
              "=" (tx* (.@+i ast) env)]))
  (when more
    (ret.prepend "(")
    (ret.add ")"))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-set
  "" ^{:opcode ["set!"]} [ast env]
  (assert (odd? (n# ast))
          "set: bad arg count")
  (var more #f
       ret (node' (tnode) ast))
  (for [i 1 sz (n# ast)
        :while (< i sz) :recur (+2 i)]
    (when (> i 1)
      (ret.add ",")
      (true! more))
    (ret.add [(tx* (.@i ast) env)
              "=" (tx* (.@+i ast) env)]))
  (when more
    (ret.prepend "(")
    (ret.add ")"))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-fn
  "" ^{:opcode ["fn"]} [ast env]
  (var ret (node' (tnode) ast)
       args (2nd ast)
       fargs nil
       hints {}
       body (ast.slice 2))
  (when (and (= 3 (n# args))
             (== "with-meta" (1st args))
             (array? (2nd args)))
    (set! hints (evalMeta (.@2 args) env)
          args (2nd args)))
  (set! fargs (processFuncArgs args env))
  (ret.add ["function (" (1st fargs) ") {\n"
            (2nd fargs) (txDo body env #t) "}"])
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fmtRegoSpecOps
  "" [alias fname]
  (str (rdr/jsid :SPEC-OPS)
       "[\"" alias "\"] = " fname))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fmtSpecOps "" [fname attrs]
  (var ks (or (get attrs "opcode") [])
       out (->> (map #(fmtRegoSpecOps
                        (str %) fname) ks)
                (join ";\n")))
  (if (not-empty ks) (str out ";\n") out))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- writeFuncInfo "" [fname src]
  (var file (ast.source.slice (+1 (ast.source.lastIndexOf "/")))
       s (str "//name: [" fname "] in file: "
              file " near line: " ast.line "\n")
       len (alen s))
  (if (< len 80)  (set! len 80))
  (doto (tnodeEx (str (.repeat "/" len) "\n"))
    (.add s)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-func
  ""
  ^{:opcode ["defn" "defn-"]}
  [ast env]

  (var mtd? (== (1st ast) "method")
       fname0 $(1st ast)
       fname (tx* (2nd ast) env)
       dot? (contains? fname ".")
       ret (node' (tnode) ast)
       hints {}
       fargs nil
       e2 (.@2 ast)
       doc nil args 2 body 3
       private? (.endsWith $(1st ast) "-"))
  (if (string? e2)
    (set! doc 2 args 3))
  (set! body (+1 args))
  (if doc (set! doc (nth ast doc)))
  (set! args (nth ast args)
        body (ast.slice body))
  (when (and (= 3 (n# args))
             (== "with-meta" (1st args))
             (array? (2nd args)))
    (set! hints (evalMeta (.@2 args) env)
          args (2nd args)))
  (set! fargs (processFuncArgs args env))
  (cond mtd?
        (do (if (.-static hints)
              (ret.add "static "))
            (ret.add [fname " ("])
            (if (== fname "constructor")
              (body.push (symbol "this"))))
        dot?
        (ret.add [fname " = function ("])
        :else
        (ret.add ["const " fname " = function ("]))
  (ret.add [(1st fargs)
            ") {\n"
            (2nd fargs)
            (txDo body env #t) "};\n"])
  (if (not-empty hints)
    (ret.add (fmtSpecOps fname hints)))
  (if doc
    (ret.prepend (writeDoc doc)))
  (ret.prepend (writeFuncInfo fname0 ast))
  (if (and (not private?)
           (not dot?)
           (not mtd?)
           (= 1 (.countNSPCache (eng/globalEnv))))
    (set-in! EXTERNS fname fname))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-try
  "" ^{:opcode ["try"]} [ast env]
  (var stmtQ (stmt? ast)
       sz (n# ast)
       ret (node' (tnode) ast))
  (var~ t f c)
  ;;look for finally
  (set! f (last ast))
  (if (and (array? f)
           (== "finally" (1st f)))
    (set! f (ast.pop)
          sz (n# ast))
    (nil! f))
  ;;look for catch
  (nil! c)
  (if (> sz 1)
    (set! c (nth ast (-1 sz))))
  (if (and (array? c)
           (== "catch" (1st c)))
    (do (if (or (< (n# c) 2)
                (not (symbol? (2nd c)))) (syntax! :e0 ast))
        (set! c (ast.pop)))
    (nil! c))
  ;;try needs either a catch or finally or both
  (if (and (nil? f) (nil? c)) (syntax! :e0 ast))
  (ret.add ["try {\n"
            (txDo (exprHint (rest ast)
                            (not stmtQ)) env) "\n}"])
  (when c
    (set! t (2nd c))
    (ret.add [(str "catch (" t ") {\n")
              (txDo (exprHint (c.slice 2)
                              (not stmtQ)) env) ";\n}\n"]))
  (when f
    (ret.add ["finally {\n",
              (txDo (exprHint (rest f) #f) env #f) ";\n}\n"]))
  (when-not stmtQ
    (ret.prepend "(function(){\n")
    (ret.add "}).call(this)"))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-if
  "" ^{:opcode ["if"]} [ast env]

  (var ret (node' (tnode) ast)
       stmtQ (stmt? ast)
       a1 (exprHint (2nd ast) (not stmtQ))
       a2 (exprHint (.@2 ast) (not stmtQ))
       a3 (if (> (n# ast) 3) (.@3 ast))
       elze (if a3 (exprHint a3 (not stmtQ))))
  (set! a1 (tx* a1 env)
        a2 (tx* a2 env)
        elze (tx* elze env))
  (if stmtQ
    (do (ret.add ["if (" a1 ") {\n" a2 ";\n}"])
        (if a3 (ret.add [" else { \n" elze ";\n}"])))
    (ret.add ["(" a1 " ?\n" a2 " :\n" (or elze "null") ")"]))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-nth ""
  ^{:opcode ["nth"]} [ast env]

  (var ret (node' (tnode) ast))
  (txExpr ast env)
  (ret.add [(2nd ast) "[" (.@2 ast) "]"])
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-get
  "" ^{:opcode ["aget" "get"]} [ast env]

  (var ret (node' (tnode) ast))
  (txExpr ast env)
  (ret.add [(2nd ast) "[" (.@2 ast) "]"])
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-array
  "" ^{:opcode ["vec"]} [ast env]

  (var ret (node' (tnode) ast))
  (if (empty? ast)
    (ret.add "[]")
    (do (if-not (vector? ast)
          (ast.splice 0 1))
        (txExpr ast env)
        (ret.add "[\n")
        (for [i 0 sz (n# ast)
              :while (< i sz) :recur (+1 i)]
          (if (> i 0) (ret.add ",\n"))
          (ret.add (.@i ast)))
        (ret.add "\n]")))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-object
  "" ^{:opcode ["hashmap"]} [ast env]

  (var ret (node' (tnode) ast))
  (if (empty? ast)
    (ret.add "{}")
    (do (if-not (map? ast)
          (ast.splice 0 1))
        (txExpr ast env)
        (ret.add "{\n")
        (for [i 0 sz (n# ast)
              :while (< i sz) :recur (+2 i)]
          (if (> i 0) (ret.add ",\n"))
          (ret.add [(.@i ast) ": " (.@+i ast)]))
        (ret.add "\n}")))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- icache [])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- includeFile [fname]
  (if (contains? icache fname)
    (tnode)
    (let [src (fs/readFileSync fname "utf-8")]
      (conj! icache fname)
      (txTree (parser/parser src fname)
              (eng/globalEnv )))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-include "" [ast env]
  (var ret []
       dir (path/dirname ast.source))
  (var~ fname e)
  (for [i 1 sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i ast))
    (if (or (not (array? e))
            (not= 1 (n# e))) (syntax! :e0 ast))
    (set! fname (1st e))
    (if fname
      (set! fname (fname.replace /[\"]/g "")))
    (try
      (set! fname (fs/realpathSync
                    (str dir "/" fname)))
      (catch e
        (syntax! :e11 ast)))
    (try
      (conj! ret (includeFile fname))
      (finally
        (.popNSP (eng/globalEnv)))))
  (if (empty? ret) (tnode) ret))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-require "" [ast env]
  (var~ as path v e refers renames)
  (var ret (node' (tnode) ast))
  (for [i 1 sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i ast)
          as $(gensym "R____")
          refers nil renames nil)
    (if (or (not (array? e))
            (< (n# e) 3)) (syntax! :e0 ast))
    (set! path (1st e))
    (for [j 1 sz (n# e)
          :while (< j sz) :recur (+1 j)]
      (set! v (.@j e))
      (cond (== v "as")
            (do (set! as $(.@+j e))
                (++ j))
            (== v "refer")
            (do (set! refers (.@+j e))
                (++ j))
            (== v "rename")
            (do (set! renames (.@+j e))
                (++ j))))
    (ret.add ["const " (rdr/jsid as)
              "= require("
              (tx* path) ");\n"])
    (for [i 0 sz (n# refers)
          :while (and refers
                      (< i sz)) :recur (+1 i)]
      (set! v (tx* (.@i refers)))
      (ret.add ["const " v "=" as "[\"" v "\"];\n"]))
    (for [i 0 sz (n# renames)
          :while (and renames
                      (< i sz)) :recur (+2 i)]
      (set! e (tx* (.@i renames))
            v (tx* (.@+i renames)))
      (ret.add ["const " v
                "=" as "[\"" e "\"];\n"])))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- evalMeta "" [ast env]
  (cond
    (array? ast)
    (JSON/parse $(tx* ast env))
    (keyword? ast)
    (->> (tx* [ast #t] env)
         (str )
         (JSON/parse ))
    (symbol? ast)
    (->> (tx* [(symbol "tag") ast] env)
         (str )
         (JSON/parse ))
    :else
    (raise! "Bad meta value" (prn ast))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-ns
  "" ^{:opcode ["ns"]} [ast env]
  (var ret [] e nil
       hints {} nsp (2nd ast))
  (when (and (array? nsp)
             (= 3 (n# nsp))
             (== "with-meta" (1st nsp))
             (symbol? (2nd nsp)))
    (set! hints (evalMeta (.@2 nsp) env)
          nsp (2nd nsp)))
  (.pushNSP (eng/globalEnv) $(nsp))
  (set! ast (ast.slice 2))
  (for [i 0 sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i ast))
    (cond (and (pairs? e)
               (== "include" (1st e)))
          (conj! ret (sf-include e))
          (and (pairs? e)
               (== "require" (1st e)))
          (conj! ret (sf-require e))))
  ;;force a internal reference to stdlib for user files
  (set! nsp (.peekNSP (eng/globalEnv)))
  (cond
    (or (= nsp "czlab.kirby.macros")
        (= nsp "czlab.kirby.stdlib"))
    nil
    (nsp.startsWith "czlab.kirby.")
    (conj! ret (tnodeEx "const kirbystdlibref=std;\n"))
    :else
    (->> '(require ["kirby" :as kirbystdlibref])
         (sf-require )
         (conj! ret )))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- maybeStripStdlib "" [cmd]
  (var lib "kirbystdlibref."
       nsp (.peekNSP (eng/globalEnv)))
  (set! cmd $(cmd))
  (if (and (cmd.startsWith lib)
           (= nsp "czlab.kirby.stdlib"))
    (cmd.slice (n# lib))
    cmd))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-comment
  "" ^{:opcode ["comment"]}
  [ast env] (node' (tnode) ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-for
  "" ^{:opcode ["for"]} [ast env]
  (var ret (node' (tnode) ast)
       stmtQ (stmt? ast)
       body (exprHint (ast.slice 2) #f))
  (if (empty? body)
    (tnode)
    (sf-floop ret (2nd ast) body env stmtQ))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-floop "" [ret args body env stmtQ]
  (var vars [] recurs [])
  (var~ tst nb e)
  (for [i 0 sz (n# args)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i args))
    (cond (== e "while")
          (do (set! tst (.@+i args)) (++ i))
          (== e "recur")
          (do (set! recurs (args.slice (+1 i)))
              (break-out-of-loop!))
          (symbol? e)
          (do (conj! vars e (.@+i args))
              (++ i))))
  (ret.add "for (")
  (for [i 0 sz (n# vars)
        :while (< i sz) :recur (+2 i)]
    (if (= i 0) (ret.add "let "))
    (if (not= i 0) (ret.add ","))
    (ret.add [(tx* (.@i vars))
              "=" (tx* (.@+i vars) env)]))
  (if (empty? vars)
    (ret.add "let ____break=false;")
    (ret.add ",____break=false;"))
  (set! nb '(not ____break))
  (if tst
    (set! tst [(symbol "and") nb tst])
    (set! tst nb))
  (ret.add (tx* tst env))
  (ret.add "; ")
  (for [i 0 k 0 sz (n# recurs)
        :while (< i sz) :recur (+1 i)(+2 k)]
    (if (not= i 0) (ret.add ","))
    (ret.add [(tx* (.@k vars))
              "=" (tx* (.@i recurs) env)]))
  (ret.add "){\n")
  (ret.add (txDo body env #f))
  (ret.add "}\n")
  (when-not stmtQ
    (ret.prepend "(function() {\n")
    (ret.add "}).call(this)"))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-jscode
  "" ^{:opcode ["js#"]} [ast env]
  (node' (tnodeEx (-> $(2nd ast)
                      (.replace rdr/REGEX.dquoteHat "")
                      (.replace rdr/REGEX.dquoteEnd ""))) ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-macro
  "" ^{:opcode ["defmacro"]} [ast env]

  (var pms []
       args (.@2 ast)
       body (ast.slice 3))
  (var~ x e ev)
  (when (string? args)
    (set! doc args
          args (.@3 ast)
          body (ast.slice 4)))
  (for [i 0 sz (n# args)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i args) ev $(e))
    (cond (= ev "&")
          (if (array? (.@+i args))
            (do (set! e (.@+i args))
                (++ i)
                (for [j 0 sz (n# e)
                      :while (< j sz) :recur (+1 j)]
                  (set! x (.@j e))
                  (if-not (symbol? x)
                    (raise! "Bad optional arg for macro"))
                  (conj! pms x)))
            (do (conj! pms e (.@+i args))
                (++ i)))
          (not (symbol? e))
          (raise! "Bad optional arg for macro")
          :else
          (conj! pms e)))
  (set! ast
        [(1st ast)
         (2nd ast)
         (concat [(symbol "fn*") pms] body)])
  (var a1 $(2nd ast)
       a2 (.@2 ast)
       func (eng/compute a2 env))
  (set-in! func :____macro #t)
  (if doc
    (set-in! func :____doc doc))
  (eng/setMacro a1 func)
  (node' (tnode) ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-unary
  "" ^{:opcode ["not" "~" "!"]} [ast env]

  (var ret (node' (tnode) ast)
       [a0 a1] ast)
  (if (== a0 "not") (set! a0 (symbol "!")))
  (ret.add ["(" (tx* a0 env) (tx* a1 env) ")"])
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- spitExterns "" []
  (var s "" ks (keys EXTERNS))
  (when (not-empty ks)
    (set! s (join ",\n"
                  (map #(str % ": " %) ks))
          s (str "\n\nmodule.exports = {\n" s "\n};\n\n")))
  s)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- banner "" []
  (str "/*"
       "Auto generated by Kirby - v"
       MODULE-VERSION " "
       (.firstNSP (eng/globalEnv)) " - " (new Date) "*/\n\n"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- cleanCode "" [code]
  (var tmp nil arr [])
  (doseq [s (code.split "\n")]
    (set! tmp (s.trim))
    (if (and (not-empty tmp)
             (not= tmp ";")) (conj! arr s)))
  (join "\n" arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileCode "" [codeStr fname options]
  (.resetNSPCache (eng/globalEnv))
  (set! EXTERNS {})
  (var outNode (txTree (parser/parser codeStr fname)
                       (eng/globalEnv))
       {:keys [source-map format]} options
       cstr ""
       fopts {}
       extra (spitExterns))
  (true! format)
  (set! cstr
        (if source-map
          (let [outFile (str (path/basename fname ".ky") ".js")
                srcMap (str outFile ".map")
                output (outNode.toStringWithSourceMap {:file outFile})]
            (fs/writeFileSync srcMap output.map)
            (str output.code
                 extra
                 "\n//# sourceMappingURL="
                 (path/relative (path/dirname fname) srcMap)))
          (str outNode extra)))
  (if format
    (set! cstr (esfmt/format cstr fopts)))
  (set! cstr (cleanCode cstr))
  ;;(if format (set! cstr (esfmt/format cstr fopts)))
  (if (empty? cstr) "" (str (banner) cstr)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileXXX "" [code file options]
  (try
    (transpileCode code file options)
    (catch e
      (when e
        (println (.-stack e)) (throw e)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn transpileWithSrcMap
  "" [code file & [options]]
  (transpileXXX code
                file
                (opt?? options {})))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn transpile
  "" [code file & [options]]
  (transpileXXX code
                file
                (opt?? options {})))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn parseWithSourceMap "" [codeStr fname]
  (var outNode (txTree (parser/parser codeStr fname)))
  (outNode.prepend (banner))
  (outNode.toStringWithSourceMap ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(def version MODULE-VERSION)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- processFuncArgs "" [args env]
  (var pms [] fdefs (tnode) fargs (tnode))
  (var~ rhs e ev rval out)
  (for [i 0 sz (count args)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i args))
    (cond
      (symbol? e)
      (if (== e "&")
        (do (set! rval (tnode))
            (rval.add ["Array.prototype.slice.call(arguments," $(i) ")"])
            (set! e (.@+i args))
            (if (symbol? e)
              (do (set! rhs e)
                  (fdefs.add ["let " (tx* rhs) "=" rval ";\n"]))
              (do (set! out (tnode))
                  (set! rhs (destruct* e out))
                  (fdefs.add ["let " (tx* rhs) "=" rval ";\n"])
                  (fdefs.add out)))
            (break-out-of-loop!))
        (conj! pms e))
      (array? e)
      (do (set! rval (tnode))
          (rval.add ["arguments[" $(i) "]"])
          (set! out (tnode))
          (set! rhs (destruct* e out))
          (conj! pms rhs)
          (fdefs.add ["let " (tx* rhs) "=" rval ";\n"])
          (fdefs.add out))
      :else
      (raise! "bad")))
  (for [i 0 sz (count pms)
        :while (< i sz) :recur (+1 i)]
    (fargs.add (tx* (.@i pms))))
  (fargs.join ",")
  [fargs fdefs])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destruct* "" [coll out]
  (var rhs (gensym) e nil)
  (for [i 0 sz (count coll)
       :while (< i sz) :recur (+1 i)]
    (set! e (.@i coll))
    (if (and (keyword? e)
             (== e "as"))
      (set! rhs (.@+i coll))
      (break-out-of-loop!)))
  (cond
    (map? coll)
    (out.add (destruct-Map rhs coll))
    (vector? coll)
    (out.add (destruct-Vec rhs coll)))
  rhs)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destruct-Vec "" [src coll]
  (var~ e rhs rval out)
  (var ret (tnode))
  (set! src (tx* src))
  (for [i 0 sz (count coll)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i coll))
    (cond
      (symbol? e)
      (cond
        (== e "_") nil
        (== e "&")
        (do (set! rval (tnode))
            (rval.add ["Array.prototype.slice.call("
                       src "," $(i) ")"])
            (set! out (tnode))
            (set! e (.@+i coll))
            (if (symbol? e)
              (set! rhs e)
              (set! rhs (destruct* e out)))
            (ret.add ["let " (tx* rhs) "=" rval ";\n"])
            (ret.add out)
            (break-out-of-loop!))
        :else
        (do (set! out (tnode))
            (out.add ["let " (tx* e)
                      "=" src "[" $(i) "];\n"])
            (ret.add out)))
      (array? e)
      (do (set! rval (tnode))
          (rval.add [src "[" $(i) "]"])
          (set! out (tnode))
          (set! rhs (destruct* e out))
          (ret.add ["let " (tx* rhs) "=" rval ";\n"])
          (ret.add out))
      (keyword? e)
      (if (== e "as")
        (++ i)
        (raise! "Bad keyword"))
      :else (raise! "")))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destruct-Map "" [src coll]
  (var ret (tnode))
  (var~ e arr)
  (set! src (tx* src))
  (for [i 0 sz (count coll)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i coll))
    (cond
      (keyword? e)
      (cond
        (or (== e "keys")
            (== e "strs"))
        (let [arr (.@+i coll)]
          (++ i)
          (for [j 0 sz (count arr)
                :while (< j sz) :recur (+1 j)]
            (set! e (.@j arr))
            (ret.add ["let " (tx* e) "=" src "[\"" $(e) "\"];\n"])))
        :else (raise! "bad keyword" e))
      :else (raise! "bad destruction" e)))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

