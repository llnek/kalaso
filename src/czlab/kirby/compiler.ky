;; Copyright (c) 2013-2017, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns ^{:doc ""
      :author "Kenneth Leung"}
  czlab.kirby.compiler
  (:require ["source-map" :as smap])
  (:require ["./stdlib"
             :as std
             :refer [lambda-arg? hashmap pairs? into!
                     contains? last typeid
                     prn primitive map? vector?
                     opt?? some? primitive?
                     not-empty conj! list?
                     gensym count pop! slice
                     symbol keyword symbol? keyword?]]
            ["./engine" :as eng]
            ["./parser" :as parser])
  (:require ["fs" :as fs]
            ["path" :as path]
            ["esformatter" :as esfmt]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- ERRORS-MAP {
  :no-sourcemap-info "Expected source map info"
  :invalid-fargs "Invalid function args"
  :invalid-catch "Invalid catch clause"
  :invalid-try "Invalid try clause"
  :invalid-include "Invalid include clause"
  :invalid-require "Invalid require clause"
  :invalid-namespace "Invalid namespace clause"
  :destruct-args "Bad destructure args"
  :outside-macro "Invalid clause outside of macro"
  :file-access "Failed file access"
  :file-read "Failed file read"
  :file-open "Failed to open file"
  :unknown-keyword "Unknown keyword"
  :invalid-arity "Invalid function arity"
  :invalid-meta "Invalid meta data"
  :syntax-error "Syntax error"
  :empty-form "Invalid form (empty)" })

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- MODULE-VERSION "1.0.0")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- *externs* nil
      SPEC-OPS {}
      MATH-OP-REGEX /^[-+][0-9]+$/)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn tnodeEx "Create a node"
  [name &[chunk]] (tnode nil nil nil chunk name))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn tnode "Create a token
            with source information"
  [&[source line col chunk name]]
  (new smap/SourceNode
       (opt?? line nil)
       (opt?? col nil)
       (opt?? source nil)
       (opt?? chunk nil) (opt?? name nil)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- doFuncArgs "Deal with possible destructuring
                  of args in function definition"
  [args ast env]
  (var~ e ev rval out)
  (var pms []
       [fargs fdefs :as ret] [(node' ast) (node' ast)])
  (for [i 0 sz (n# args)
        :while (< i sz) :recur (+1 i)]
    (=> e (.@i args))
    (cond
      (symbol? e)
      (if (== e "&")
        ;vargs
        (do (=> rval (node' ast)
                e (.@+i args))
            (rval.add ["Array.prototype.slice.call(arguments," $(i) ")"])
            (if (symbol? e)
              (fdefs.add ["let "
                          (tx* e env) "=" rval ";\n"])
              (do (=> out (node' ast)
                      e (destruct* e out env ast))
                  (fdefs.add ["let "
                              (tx* e env)
                              "=" rval ";\n" out])))
            (break-out-of-loop!))
        ;ignore _
        (do (if (== e "_")
              (=> e (gensym "U__"))) (conj! pms e)))
      (array? e)
      (do (=> rval (node' ast)
              out (node' ast)
              e (destruct* e out env ast))
          (rval.add ["arguments[" $(i) "]"])
          (conj! pms e)
          (fdefs.add ["let "
                      (tx* e env)
                      "=" rval ";\n" out]))
      :else
      (error! :destruct-args ast)))
  (each #(fargs.add (tx* % env)) pms)
  (join "," fargs)
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destruct* "" [coll out env ast]
  ;decide on what the rhs should be referred to "as"
  (var rhs (gensym) e nil)
  (for [i 0 sz (n# coll)
        :while (< i sz) :recur (+1 i)]
    (=> e (.@i coll))
    (when (and (keyword? e)
               (== e "as"))
      (=> rhs (.@+i coll))
      (break-out-of-loop!)))
  ;handle a vec or a map destructure only
  (cond
    (map? coll)
    (out.add (destructMap rhs coll env ast))
    (vector? coll)
    (out.add (destructVec rhs coll env ast)))
  rhs)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destructVec "" [src coll env ast]
  (=> src (tx* src env))
  (var~ e rval out)
  (var ret (node' ast))
  (for [i 0 sz (n# coll)
        :while (< i sz) :recur (+1 i)]
    (=> e (.@i coll))
    (cond
      (symbol? e)
      (cond
        (== e "_") nil
        (== e "&")
        (do (=> rval (node' ast)
                out (node' ast)
                e (.@+i coll))
            (rval.add ["Array.prototype.slice.call(" src "," $(i) ")"])
            (if-not (symbol? e)
              (=> e (destruct* e out env ast)))
            (ret.add ["let "
                      (tx* e env)
                      "=" rval ";\n" out])
            (break-out-of-loop!))
        :else
        (ret.add ["let "
                  (tx* e env)
                  "=" src "[" $(i) "];\n"]))
      (array? e)
      (do (=> rval (node' ast)
              out (node' ast)
              e (destruct* e out env ast))
          (rval.add [src "[" $(i) "]"])
          (ret.add ["let "
                    (tx* e env)
                    "=" rval ";\n" out]))
      (keyword? e)
      (if (== e "as")
        (++ i)
        (error! :unknown-keyword ast))
      :else (error! :syntax-error ast))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destructMap "" [src coll env ast]
  (=> src (tx* src env))
  (var ret (node' ast))
  (var~ e arr)
  (for [i 0 sz (n# coll)
        :while (< i sz) :recur (+1 i)]
    (=> e (.@i coll))
    (cond
      (keyword? e)
      (cond
        (or (== e "keys")
            (== e "strs"))
        (do (=> arr (.@+i coll))
            (++ i)
            (for [j 0 sz (n# arr)
                  :while (< j sz) :recur (+1 j)]
              (=> e (.@j arr))
              (ret.add ["let "
                        (tx* e env)
                        "=" src "[\"" $(e) "\"];\n"])))
        :else
        (error! :unknown-keyword ast))
      :else
      (error! :syntax-error ast))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- simple? "" [ast]
  (or (undef? ast) (nil? ast) (str? ast) (num? ast) (bool? ast)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- wrap "" [ret head tail]
  (if head (ret.prepend head))
  (if tail (ret.add tail))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- exprHint "" [ast flag]
  (if (simple? ast) (=> ast (primitive ast))) (=>> ast :____expr flag) ast)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- stmt? "" [ast]
  (if (simple? ast) (error! :syntax-error ast)) (false? ast.____expr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- error! "" [e & [ast msg]]
  (raise! (get ERRORS-MAP e)
          (if msg (str " : " msg))
          (if (and ast ast.line) (str "\nline: " ast.line))
          (if (and ast ast.source) (str "\nfile: " ast.source))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- testre? "" [re x] (if x (re.test x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- pad "" [n] (.repeat " " n))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- node' "" [ast & [obj]]
  (=> obj (opt?? obj (tnode)))
  (=>> obj :source ast.source
           :line ast.line
           :column ast.column) obj)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txTree "" [root env]
  (var ret (node' root))
  (doseq [r root
          :let [t (tx* r env)]
          :when (some? t)] (ret.add [t "\n"])) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txForm "" [expr env]
  (if (array? expr)
    (each (fn [a i arr]
            (=>> arr i (tx* a env))) expr)) expr)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txAtom "" [a]
  (cond (lambda-arg? a)
        (str "____args[" $(a) "]")
        (keyword? a)
        (str "\"" (parser/jsid $(a)) "\"")
        (symbol? a)
        (parser/jsid $(a))
        (nil? a)
        "null"
        (primitive? a)
        (do (=> a a.value)
            (cond (string? a) (std/wrap-str a)
                  (nil? a) "null"
                  :else $(a)))
        (string? a)
        (std/wrap-str a)
        :else (parser/jsid $(a))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- tx* "" [x & [env]] (if (array? x) (txPairs x env) (txAtom x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- gcmd "" [ast]
  (cond (map? ast) "hashmap"
        (vector? ast) "vec"
        (list? ast) "list"
        (and (array? ast)
             (not (array? (1st ast)))) $(1st ast) :else ""))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quoteSingle "" ^String [a]
  (cond (keyword? a)
        (str (maybeStripStdlib "kirbystdlibref.keyword")
             "(\":" a "\")")
        (symbol? a)
        (str (maybeStripStdlib "kirbystdlibref.symbol")
             "(\"" a "\")")
        (primitive? a)
        (do (set! a a.value)
            (cond (string? a) (std/wrap-str a)
                  (nil? a) "null"
                  :else $(a)))
        (string? a)
        (std/wrap-str a)
        :else $(a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quote! "" [ast env]
  (assertInfo ast)
  (if (array? ast)
    (if (map? ast)
      (quoteMap ast env)
      (quoteBlock ast env))
    (quoteSingle ast)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quoteMap "" [ast env]
  (var comma ""
       ret (node' ast))
  (for [i 0 sz (n# ast)
        :while (< i sz) :recur (+2 i)]
    (if (> i 0) (ret.add ","))
    (ret.add [(quote! (.@i ast) env)
              " : " (quote! (.@+i ast) env)]))
  (if-not (empty? ast) (=> comma ","))
  (wrap ret ["[" "symbol(\"hashmap\")" comma] "]"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quoteBlock "" [ast env]
  (var ret (node' ast))
  (for [i 0 sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (if (> i 0) (ret.add ","))
    (ret.add (quote! (.@i ast) env)))
  (wrap ret "[" "]"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- spread "" [from to]
  (if (and from
           (not (simple? from))
           (number? from.line)
           (array? to))
    (do (xfi from to)
        (for [i 0 sz (n# to)
              :while (< i sz) :recur (+1 i)]
          (spread from (.@i to))))
    (xfi from to)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txPairs "" [ast env]
  (var stmtQ (stmt? ast)
       ret (node' ast)
       cmd (gcmd ast)
       e1 (1st ast)
       orig ast
       op nil tmp nil
       mc (eng/getMacro cmd))
  (xfi e1 ret)
  (xfi e1 ast)
  ;;handle macro calls
  (when mc
    (=> ast (eng/expandMacro ast env mc)
        ast (xfi orig (exprHint ast (not stmtQ))))
    (spread orig ast)
    (=> cmd (gcmd ast)))
  ;;handle (+1 ) or (-1 ) cases
  (when (parser/REGEX.int.test cmd)
    (if-not (or (starts? cmd "+")
                (starts? cmd "-"))
      (=> cmd (str "+" cmd)))
    (=> ast (xfi ast [(symbol (ch@ cmd 0))
                      (2nd ast)
                      (int (rest cmd))])
        cmd $(1st ast)))
  ;;maybe special form
  (=> op (get SPEC-OPS cmd))
  ;;handle all cases
  (cond
    (== cmd "with-meta")
    (ret.add (tx* (2nd (meta?? ast env)) env))
    (starts? cmd ".-")
    (ret.add [(tx* (2nd ast) env)
              "." (tx* (symbol (cmd.slice 2)) env)])
    (starts? cmd ".@")
    (do (=> tmp (if (starts? cmd ".@+") [3 #t] [2 #f]))
        (ret.add [(tx* (2nd ast) env)
                  "[" (cmd.slice (1st tmp)) (if (2nd tmp) "+1]" "]")]))
    (starts? cmd ".")
    (do (ret.add [(tx* (2nd ast) env) cmd "("])
        (for [n 2 sz (n# ast)
              :while (< n sz) :recur (+1 n)]
          (if (not= n 2) (ret.add ","))
          (ret.add (tx* (.@n ast) env)))
        (ret.add ")"))
    (some? op)
    (=> ret (op ast env))
    (or (== cmd "splice-unquote")
        (== cmd "unquote")
        (== cmd "quasiquote"))
    (error! :outside-macro ast)
    :else
    (do (if (pairs? ast)
          (do (txForm ast env)
              (=> cmd $(1st ast)))
          (=> cmd (tx* ast env)))
        (if-not cmd (error! :empty-form ast))
        (=> cmd (maybeStripStdlib cmd))
        (if (pairs? ast)
          (ret.add
            [(if (testre? parser/REGEX.func cmd)
               (str "(" cmd ")") cmd)
             "(" (join "," (rest ast)) ")"])
          (ret.add cmd))))
  (node' ast ret))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- writeDoc "Convert to jsdoc"
  [doc]
  (var out [])
  (if doc
    (->> (.split (std/unwrap-str doc) "\n")
         (each #(let [s (.trim (str %))]
                  (if (not-empty s)
                    (conj! out (str "//" s "\n"))))))) out)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txDo "" [ast env & [return?]]
  (var stmtQ (stmt? ast)
       ret (node' ast)
       e nil end (last-index ast))
  (=> return?
      (if stmtQ false (opt?? return? true)))
  (for [i 0 :while (< i end) :recur (+1 i)]
    (=> e (exprHint (.@i ast) #f))
    (ret.add [(tx* e env) ";\n"]))
  (when (>= end 0)
    (=> e (exprHint (.@end ast)
                    (not stmtQ))
        e (tx* e env))
    (ret.add (if-not return?
               [e ";\n"]
               ["return " e ";\n"]))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- meta?? "" [obj env]
  (var mobj nil)
  (when (and (array? obj)
             (= 3 (n# obj))
             (== "with-meta"
                 $(1st obj)))
    (=> mobj (evalMeta (.@2 obj) env))
    (=>> (2nd obj) :____meta mobj)
    (=> obj (2nd obj)))
  [mobj obj])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fmtRegoSpecOps "" [alias fname]
  (str (parser/jsid :SPEC-OPS) "[\"" alias "\"] = " fname))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fmtSpecOps "" [fname attrs]
  (var ks (or (get attrs "opcode") [])
       out (->> (map #(fmtRegoSpecOps
                        (str %) fname) ks) (join ";\n")))
  (if (not-empty ks) (str out ";\n") out))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- writeFuncInfo "" [fname ast]
  (var file (if ast.source
              (ast.source.slice
                (+1 (ast.source.lastIndexOf "/"))) "?")
       s (str "//fn: ["
              fname "] in file: "
              file ",line: " (or ast.line "?") "\n")
       len (alen s))
  (if (< len 80)  (=> len 80))
  (str (.repeat "/" len) "\n" s))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- icache [])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- includeFile [fname ast]
  (if (contains? icache fname)
    (node' ast)
    (let [src (fs/readFileSync fname "utf-8")]
      (conj! icache fname)
      (txTree (parser/parse src fname) (eng/globalEnv )))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- evalMeta "" [ast env]
  (var x
       (cond (array? ast)
             ast
             (keyword? ast)
             (into! :map [ast #t])
             (symbol? ast)
             (into! :map [(keyword ":tag") ast])
             :else
             (error! :invalid-meta ast))
       v (eng/compute x env))
  ;(console.log (str "meta-obj=" (JSON/stringify v)))
  v)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- maybeStripStdlib "" ^String [cmd]
  (var lib "kirbystdlibref."
       nsp (.peekNSP (eng/globalEnv)))
  (=> cmd $(cmd))
  (if (and (starts? cmd lib)
           (= nsp "czlab.kirby.stdlib"))
    (cmd.slice (alen lib)) cmd))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- assertArity "" [kond ast]
  (if-not kond (error! :invalid-arity ast))
  (assertInfo ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- assertInfo "" [ast]
  (if (and false
           ast
           (not (simple? ast))
           (not (number? ast.line)))
    (error! :no-sourcemap-info ast)))

;;kenl
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-quote ""
  ^{:opcode ["quote"] :tag SourceNode} [ast env]
  (assertArity (= (n# ast) 2) ast)
  (var ret (node' ast))
  (wrap ret nil (quote! (2nd ast) env)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-deftype
  "Define a JS Class"
  ^{:opcode ["deftype" "deftype-"] :tag SourceNode}
  [ast env]
  (assertArity (>= (n# ast) 4) ast)
  (var ret (node' ast))
  (var~ mtd pos n m)
  (var private? (ends? $(1st ast) "-")
       czname (tx* (2nd ast) env)
       par (1st (.@2 ast))
       czargs (.@3 ast)
       [doc mtds] (if (str? (.@4 ast))
                    [(.@4 ast) (slice ast 5)]
                    [nil (slice ast 4)]))
  (ret.add ["class " czname])
  (if par (ret.add [" extends " (tx* par env)]))
  (ret.add " {\n")
  (doseq [m mtds]
    ;;doc string?
    (=> mtd 'method
        pos (if (str? (2nd m)) 3 2))
    ;;pass line info
    (xfi (1st m) mtd)
    (xfi (1st m) m)
    (when (and (== $(1st m)
                   "constructor")
               (not-empty czargs))
      (for [x 0 sz (n# czargs)
            :while (< x sz) :recur (+2 x)]
        (=>> czargs x $(.@x czargs)))
      (m.splice pos 0
        (concat ['set-in! 'this] czargs)))
    (m.unshift mtd)
    (ret.add [(sf-func m env #f) "\n"]))
  (ret.add "}\n")
  (if doc (ret.prepend (writeDoc doc)))
  (if (and (not private?)
           (= 1 (.countNSPCache
                  (eng/globalEnv))))
      (=>> *externs* czname czname)) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-compOp "" ^{:opcode ["not=" "!="
                               "==" "="
                               ">" ">=" "<" "<="]} [ast env]
  (assertArity (and (>= (n# ast) 3)
                    (odd? (n# ast))) ast)
  (var ret (node' ast)
       cmd $(1st ast))
  (cond (== cmd "not=") (=>> ast 0 '!==)
        (== cmd "=") (=>> ast 0 '===))
  (for [i 1 op (tx* (1st ast) env)
        :while (< i (last-index ast)) :recur (+1 i)]
    (if (not= i 1) (ret.add " && "))
    (ret.add [(tx* (.@i ast) env)
              " " op " " (tx* (.@+i ast) env)]))
  (wrap ret "(" ")"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-arithOp
  ""
  ^{:opcode ["bitwise-lshift" "bitwise-rshift" "bitwise-zrshift"
             "+" "-" "*" "div" "mod"
             "or" "and" "exp" "rem"
             "bitwise-and" "bitwise-or" "bitwise-not" "bitwise-xor"]}
  [ast env]
  (assertArity (>= (n# ast) 2) ast)
  (var e1 (tx* (1st ast) env)
       cmd $(e1) ret (node' ast))
  (cond (== cmd "bitwise-zrshift") (=> cmd ">>>")
        (== cmd "bitwise-rshift") (=> cmd ">>")
        (== cmd "bitwise-lshift") (=> cmd "<<")
        (== cmd "bitwise-and") (=> cmd "&")
        (== cmd "bitwise-or") (=> cmd "|")
        (== cmd "bitwise-not") (=> cmd "~")
        (== cmd "bitwise-xor") (=> cmd "^")
        (== cmd "rem") (=> cmd "%")
        (== cmd "div") (=> cmd "/")
        (== cmd "and") (=> cmd "&&")
        (== cmd "or") (=> cmd "||")
        (== cmd "exp") (=> cmd "**"))
  (if (and (== "-" cmd)
           (= 2 (n# ast))) (ret.add "-"))
  (for [i 1 sz (n# ast)
        :while (< i sz) : recur (+1 i)]
    (when (> sz 2)
      (if (> i 1) (ret.add cmd)))
    (ret.add (tx* (.@i ast) env)))
  (wrap ret "(" ")"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-do
  "" ^{:opcode ["do"]} [ast env]
  (assertArity true ast)
  (var ret (node' ast)
       stmtQ (stmt? ast))
  (ret.add (txDo (exprHint (xfi ast (rest ast))
                           (not stmtQ)) env (not stmtQ)))
  (if stmtQ
    (wrap ret nil "")
    (wrap ret
          "(function() {\n" "}).call(this)")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-case
  "" ^{:opcode ["case"]} [ast env]
  (assertArity (>= (n# ast) 4) ast)
  (var stmtQ (stmt? ast)
       ret (node' ast)
       tst (2nd ast)
       brk ";\nbreak;\n"
       gs $(gensym "C__"))
  (var~ e t c dft)
  (if (odd? (n# ast))
    (=> dft (1st (pop! ast))))
  (for [i 2 sz (n# ast)
        :while (< i sz) :recur (+2 i)]
    (=> e (.@i ast)
        c (.@+i ast))
    (if (pairs? e)
      (for [j 0 sz (n# e)
            :while (< j sz) :recur (+1 j)]
        (ret.add ["case " (tx* (.@j e) env) ":\n"])
        (if (= j (last-index e))
          (ret.add [gs "=" (tx* c env) brk])))
      (ret.add ["case " (tx* e env) ":\n"
                gs "=" (tx* c env) brk])))
  (if dft
    (ret.add ["default:\n"
              gs "=" (tx* dft env) brk]))
  (wrap ret ["switch (" (tx* tst env) ") {\n"] "}")
  (if stmtQ
    (wrap ret ["let " gs ";\n"] "")
    (wrap ret
          ["(function() { let " gs ";\n"]
          ["return " gs ";}).call(this)"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-vardefs "" ^{:opcode ["def~-"
                                "def~" "var~"]} [ast env]
  (assertArity (>= (n# ast) 2) ast)
  (var ret (node' ast)
       cmd $(1st ast)
       keys {}
       private? (not= cmd "def~"))
  (if (starts? cmd "def")
    (=> cmd "var") (=> cmd "let"))
  (for [i 1 s nil sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (=> s (tx* (.@i ast) env))
    (=>> keys s nil)
    (if (> i 1) (ret.add ","))
    (ret.add s))
  (wrap ret (str cmd " ") ";\n")
  (if (and (not private?)
           (= 1 (.countNSPCache
                  (eng/globalEnv))))
    (each-key (fn [v k] (=>> *externs* k k)) keys)) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-var "" ^{:opcode ["const-"
                            "const"
                            "def-"
                            "def"
                            "var"]} [ast env]
  (assertArity (odd? (n# ast)) ast)
  (var ret (node' ast)
       cmd $(1st ast)
       keys []
       tmp nil vname nil
       private? (and (not= cmd "const")
                     (not= cmd "def")))
  (var~ rval rc lhs rhs)
  (=> cmd (if (starts? cmd "const")
            "const"
            (if (== cmd "var") "let" "var")))
  (for [i 1 sz (n# ast)
        :while (< i sz) :recur (+2 i)]
    (=> lhs (.@i ast)
        rhs (.@+i ast)
        rval (tx* rhs env))
    (if (symbol? lhs)
      (do (=> lhs (tx* lhs env)
              tmp [cmd " " lhs "=" rval ";\n"])
          (conj! keys lhs)
          (ret.add tmp))
      (do (=> out (node' ast)
              rhs (destruct* lhs out env ast))
          (ret.add ["let "
                    (tx* rhs env)
                    "=" rval ";\n" $(out)]))))
  (when (and (not private?)
             (= 1 (.countNSPCache
                    (eng/globalEnv))))
    (each (fn [k] (=>> *externs* k k)) keys)) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-inst?
  "" ^{:opcode ["inst?"]} [ast env]
  (assertArity (= (n# ast) 3) ast)
  (var ret (node' ast))
  (wrap ret nil ["(" (tx* (.@2 ast) env)
                 " instanceof " (tx* (2nd ast) env) ")"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-delete
  "" ^{:opcode ["delete!"]} [ast env]
  (assertArity (and (>= (n# ast) 2)
                    (< (n# ast) 4)) ast)
  (var ret (node' ast))
  (ret.add ["delete "
            (tx* (2nd ast) env)])
  (if (> (n# ast) 2)
    (ret.add ["[" (tx* (.@2 ast) env) "]"])) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-new
  "" ^{:opcode ["new"]} [ast env]
  (assertArity (>= (n# ast) 2) ast)
  (var ret (node' ast))
  (wrap ret "new " (tx* (xfi ast (rest ast)) env)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-throw
  "" ^{:opcode ["throw"]} [ast env]
  (assertArity (>= (n# ast) 2) ast)
  (var ret (node' ast)
       stmtQ (stmt? ast))
  (ret.add ["throw " (tx* (xfi ast (2nd ast)) env)])
  (if-not stmtQ
    (wrap ret
          "(function (){ "
          ";}).call(this)")) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-x-opop
  "" ^{:opcode ["++" "--" "++$" "--$"]} [ast env]
  (assertArity (= (n# ast) 2) ast)
  (var ret (node' ast)
       cmd $(1st ast)
       a2 (tx* (2nd ast) env))
  (if (ends? cmd "$")
    (ret.add [a2 (cmd.slice 0 -1)])
    (ret.add [cmd a2])) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-x-eq
  "" ^{:opcode ["+="
                "-="
                "*="
                "div="
                "rem="
                "exp="
                "bitwise-and="
                "bitwise-or="
                "bitwise-xor="
                "bitwise-lshift="
                "bitwise-rshift="
                "bitwise-zrshift="]} [ast env]
  (assertArity (= (n# ast) 3) ast)
  (var cmd $(1st ast)
       ret (node' ast))
  (cond
    (== cmd "bitwise-zrshift=") (=> cmd ">>>=")
    (== cmd "bitwise-rshift=") (=> cmd ">>=")
    (== cmd "bitwise-lshift=") (=> cmd "<<=")
    (== cmd "bitwise-xor=") (=> cmd "^=")
    (== cmd "bitwise-or=") (=> cmd "|=")
    (== cmd "bitwise-and=") (=> cmd "&=")
    (== cmd "div=") (=> cmd "/=")
    (== cmd "rem=") (=> cmd "%=")
    (== cmd "exp=") (=> cmd "**="))
  (wrap ret nil [(tx* (2nd ast) env)
                 " " cmd " " (tx* (.@2 ast) env)]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-set-in
  "" ^{:opcode ["set-in!" "=>>"]} [ast env]
  (assertArity (even? (n# ast)) ast)
  (var ret (node' ast)
       more #f
       obj (tx* (2nd ast) env))
  (for [i 2 sz (n# ast)
        :while (< i sz) :recur (+2 i)]
    (when (> i 2)
      (ret.add ",")
      (true! more))
    (ret.add [obj
              "[" (tx* (xfi ast (.@i ast)) env) "]"
              "=" (tx* (xfi ast (.@+i ast)) env)]))
  (if more (wrap ret "(" ")")) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-set
  "" ^{:opcode ["set!" "=>"]} [ast env]
  (assertArity (odd? (n# ast)) ast)
  (var more #f
       ret (node' ast))
  (for [i 1 sz (n# ast)
        :while (< i sz) :recur (+2 i)]
    (when (> i 1)
      (ret.add ",")
      (true! more))
    (ret.add [(tx* (.@i ast) env)
              "=" (tx* (xfi ast (.@+i ast)) env)]))
  (if more (wrap ret "(" ")")) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-fn
  "(fn [x y] ...)" ^{:opcode ["fn"]} [ast env]
  (assertArity (>= (n# ast) 2) ast)
  (var ret (node' ast)
       fargs nil
       body (xfi ast (slice ast 2))
       [_ args] (meta?? (2nd ast) env))
  (if-not (array? args)
    (error! :invalid-fargs ast))
  (=> fargs (doFuncArgs (xfi ast args) ast env))
  (wrap ret nil ["function ("
                 (1st fargs)
                 ") {\n"
                 (2nd fargs)
                 (txDo body env #t) "}"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-func "" ^{:opcode ["defn" "defn-"]} [ast env]
  (assertArity (>= (n# ast) 2) ast)
  (var private? (ends? $(1st ast) "-")
       mtd? (== $(1st ast) "method")
       fname0 $(2nd ast)
       fname (tx* (2nd ast) env)
       dot? (contains? fname ".")
       fargs nil
       ret (node' ast
                  (tnodeEx fname))
       [doc pargs] (if (str? (.@2 ast))
                     [(nth ast 2) 3] [nil 2])
       body (xfi ast (slice ast (+1 pargs)))
       [hints args] (meta?? (nth ast pargs) env))
  (if-not (array? args)
    (error! :invalid-fargs ast))
  (=> fargs (doFuncArgs (xfi ast args) ast env))
  (=> hints (or hints {}))
  (cond mtd?
        (do (if (.-static hints)
              (ret.add "static "))
            (ret.add [fname " ("])
            (if (== fname "constructor")
              (conj! body 'this)))
        dot?
        (ret.add [fname " = function ("])
        :else
        (ret.add ["const " fname " = function ("]))
  (ret.add [(1st fargs)
            ") {\n"
            (2nd fargs)
            (txDo body env #t) "};\n"])
  (if (not-empty hints)
    (ret.add (fmtSpecOps fname hints)))
  (if doc
    (ret.prepend (writeDoc doc)))
  (ret.prepend (writeFuncInfo fname0 ast))
  (if (and (not private?)
           (not dot?)
           (not mtd?)
           (= 1 (.countNSPCache
                  (eng/globalEnv)))) (=>> *externs* fname fname)) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-try "" ^{:opcode ["try"]} [ast env]
  (assertArity (>= (n# ast) 2) ast)
  (var stmtQ (stmt? ast)
       sz (n# ast)
       ret (node' ast))
  (var~ t f c)
  ;;look for finally
  (=> f (last ast))
  (if (and (array? f)
           (== "finally" $(1st f)))
    (do (pop! ast)
        (=> sz (n# ast))
        (xfi (1st f) f))
    (nil! f))
  ;;look for catch
  (nil! c)
  (if (> sz 1)
    (=> c (nth ast (-1 sz))))
  (if (and (array? c)
           (== "catch" $(1st c)))
    (do (if (or (< (n# c) 2)
                (not (symbol? (2nd c))))
          (error! :invalid-catch ast))
        (pop! ast)
        (xfi (1st c) c))
    (nil! c))
  ;;try needs either a catch or finally or both
  (if (and (nil? f)
           (nil? c)) (error! :invalid-try ast))
  (ret.add ["try {\n"
            (txDo (exprHint (xfi ast (rest ast))
                            (not stmtQ)) env) "\n}"])
  (when c
    (=> t (2nd c))
    (ret.add [(str "catch (" (tx* t env) ") {\n")
              (txDo (exprHint (xfi c (slice c 2))
                              (not stmtQ)) env) ";\n}\n"]))
  (when f
    (ret.add ["finally {\n",
              (txDo (exprHint (xfi f (rest f)) #f) env #f) ";\n}\n"]))
  (if-not stmtQ
    (wrap ret "(function(){\n" "}).call(this)")) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-if "" ^{:opcode ["if"]} [ast env]
  (assertArity (>= (n# ast) 3) ast)
  (var stmtQ (stmt? ast)
       ret (node' ast)
       a1 (exprHint (xfi ast (2nd ast)) (not stmtQ))
       a2 (exprHint (xfi ast (.@2 ast)) (not stmtQ))
       m? (> (n# ast) 3)
       a3 (if m? (xfi ast (.@3 ast)))
       elze (if m? (exprHint a3 (not stmtQ))))
  (=> a1 (tx* a1 env)
      a2 (tx* a2 env)
      elze (tx* elze env))
  (wrap ret
        nil
        (if stmtQ
          ["if (" a1 ") {\n" a2 ";\n}"
           (if m? [" else { \n" elze ";\n}"] "")]
          ["(" a1 " ?\n" a2 " :\n" (or elze "null") ")"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-get "" ^{:opcode ["nth" "get"]} [ast env]
  (assertArity (= (n# ast) 3) ast)
  (var ret (node' ast))
  (wrap ret nil [(tx* (xfi ast (2nd ast)) env)
                 "[" (tx* (xfi ast (.@2 ast)) env) "]"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-array "" ^{:opcode ["vec"]} [ast env]
  (assertArity true ast)
  (var pos 0
       ret (node' ast))
  (if (empty? ast)
    (ret.add "[]")
    (do (if-not (vector? ast) (=> pos 1))
        (ret.add "[\n")
        (for [i pos sz (n# ast)
              :while (< i sz) :recur (+1 i)]
          (if (> i pos) (ret.add ",\n"))
          (ret.add (tx* (xfi ast (.@i ast)) env)))
        (ret.add "\n]"))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-object "" ^{:opcode ["hashmap"]} [ast env]
  (assertArity true ast)
  (var pos 0
       ret (node' ast))
  (if (empty? ast)
    (ret.add "{}")
    (do (if-not (map? ast) (=> pos 1))
        (ret.add "{\n")
        (for [i pos sz (n# ast)
              :while (< i sz) :recur (+2 i)]
          (if (> i pos) (ret.add ",\n"))
          (ret.add [(tx* (.@i ast) env)
                    ": " (tx* (xfi ast (.@+i ast)) env)]))
        (ret.add "\n}"))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-include "" [ast env]
  (assertArity (>= (n# ast) 2) ast)
  (var ret []
       dir (path/dirname ast.source))
  (var~ fname e)
  (for [i 1 sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (=> e (.@i ast))
    (if (or (not (array? e))
            (not= 1 (n# e)))
      (error! :invalid-include ast))
    (=> fname $(1st e))
    (if fname
      (=> fname (fname.replace /[\"]/g "")))
    (try
      (=> fname (fs/realpathSync
                  (str dir "/" fname)))
      (catch e
        (error! :file-access ast)))
    (try
      (conj! ret (includeFile fname ast))
      (catch e
        (error! :file-read ast))
      (finally
        (.popNSP (eng/globalEnv)))))
  (if (empty? ret) "" ret))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-require "" [ast env]
  (assertArity (>= (n# ast) 2) ast)
  (var~ as path v e refers renames)
  (var ret (node' ast))
  (for [i 1 sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (=> e (.@i ast)
        as $(gensym "R__")
        refers nil renames nil)
    (if (or (not (array? e))
            (< (n# e) 3)) (error! :invalid-require ast))
    (=> path $(1st e))
    (for [j 1 sz (n# e)
          :while (< j sz) :recur (+1 j)]
      (=> v (.@j e))
      (cond (== v "as")
            (do (=> as $(.@+j e))
                (++ j))
            (== v "refer")
            (do (=> refers (.@+j e))
                (++ j))
            (== v "rename")
            (do (=> renames (.@+j e))
                (++ j))))
    (ret.add ["const " (parser/jsid as)
              "= require(" (tx* path env) ");\n"])
    (for [i 0 sz (n# refers)
          :while (< i sz) :recur (+1 i)]
      (=> v (tx* (.@i refers) env))
      (ret.add ["const " v "=" as "[\"" v "\"];\n"]))
    (for [i 0 sz (n# renames)
          :while (< i sz) :recur (+2 i)]
      (=> e (tx* (.@i renames) env)
          v (tx* (.@+i renames) env))
      (ret.add ["const " v
                "=" as "[\"" e "\"];\n"]))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-ns "" ^{:opcode ["ns"]} [ast env]
  (assertArity (>= (n# ast) 2) ast)
  (var ret [] e nil
       [hints nsp] (meta?? (2nd ast) env))
  (if-not (symbol? nsp)
    (error! :invalid-namespace ast))
  (.pushNSP (eng/globalEnv) $(nsp))
  (=> ast (xfi ast (slice ast 2)))
  (for [i 0 sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (=> e (.@i ast))
    (cond (and (pairs? e)
               (== "include" $(1st e)))
          (conj! ret (sf-include (xfi ast e)))
          (and (pairs? e)
               (== "require" $(1st e)))
          (conj! ret (sf-require (xfi ast e)))))
  ;;force a internal reference to stdlib for user files
  (=> nsp (.peekNSP (eng/globalEnv)))
  (cond
    (or (= nsp "czlab.kirby.macros")
        (= nsp "czlab.kirby.stdlib"))
    nil
    (starts? nsp "czlab.kirby.")
    (conj! ret "const kirbystdlibref=std;\n")
    :else
    (->> (xfi ast '(require ["kirby" :as kirbystdlibref]))
         (sf-require )
         (conj! ret ))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-comment "" ^{:opcode ["comment"]} [ast env] "")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-for "" ^{:opcode ["for"]} [ast env]
  (assertArity (>= (n# ast) 2) ast)
  (var stmtQ (stmt? ast)
       ret (node' ast)
       body (exprHint (xfi ast (slice ast 2)) #f))
  (if (empty? body)
    (node' ast)
    (sf-floop ret
              (xfi ast (2nd ast))
              body env stmtQ)) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-floop "" [ret args body env stmtQ]
  (var vars [] recurs [])
  (var~ tst nb e)
  (for [i 0 sz (n# args)
        :while (< i sz) :recur (+1 i)]
    (=> e (.@i args))
    (cond (== e "while")
          (do (=> tst (.@+i args)) (++ i))
          (== e "recur")
          (do (=> recurs (slice args (+1 i)))
              (break-out-of-loop!))
          (symbol? e)
          (do (conj! vars e (.@+i args))
              (++ i))))
  (ret.add "for (")
  (for [i 0 sz (n# vars)
        :while (< i sz) :recur (+2 i)]
    (if (= i 0) (ret.add "let "))
    (if (not= i 0) (ret.add ","))
    (ret.add [(tx* (.@i vars) env)
              "=" $(tx* (.@+i vars) env)]))
  (ret.add (if (empty? vars)
             "let ____break=false;" ",____break=false;"))
  (=> nb '(not ____break))
  (xfi ret nb)
  (if tst
    (=> tst ['and nb tst])
    (=> tst nb))
  (xfi ret tst)
  (ret.add [$(tx* tst env) "; "])
  (for [i 0 k 0 sz (n# recurs)
        :while (< i sz) :recur (+1 i)(+2 k)]
    (if (not= i 0) (ret.add ","))
    (ret.add [(tx* (.@k vars) env)
              "=" $(tx* (.@i recurs) env)]))
  (ret.add ["){\n" (txDo body env #f) "}\n"])
  (if-not stmtQ
    (wrap ret "(function() {\n"  "}).call(this)")) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-jscode "" ^{:opcode ["js#"]} [ast env]
  (assertArity (>= (n# ast) 2) ast)
  (var s $(2nd ast)
       name (parser/jsid "sf-jscode"))
  (->>
    (if (and (ends? s "\"")
             (starts? s "\""))
      (s.slice 1 -1) s) (tnodeEx name) (node' ast)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-macro "" ^{:opcode ["defmacro"]} [ast env]
  (assertArity (>= (n# ast) 2) ast)
  (var pms [] args (.@2 ast) body (slice ast 3))
  (var~ doc x e ev)
  (when (str? args)
    (=> doc args args (.@3 ast) body (slice ast 4)))
  (for [i 0 sz (n# args)
        :while (< i sz) :recur (+1 i)]
    (=> e (.@i args) ev $(e))
    (cond (= ev "&")
          (if (array? (.@+i args))
            (do (=> e (.@+i args))
                (++ i)
                (for [j 0 sz (n# e)
                      :while (< j sz) :recur (+1 j)]
                  (=> x (.@j e))
                  (if-not (symbol? x)
                    (error! :syntax-error ast))
                  (conj! pms x)))
            (do (conj! pms e (.@+i args))
                (++ i)))
          (not (symbol? e))
          (error! :syntax-error ast)
          :else
          (conj! pms e)))
  (var a2 (concat ['fn* pms] body)
       func (eng/compute a2 env)
       a1 $(2nd ast))
  (=>> func :____macro #t :____doc doc)
  (eng/setMacro a1 func)
  "")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-unary "" ^{:opcode ["not" "~" "!"]} [ast env]
  (assertArity (= (n# ast) 2) ast)
  (var [a0 a1] ast
       ret (node' ast))
  (if (== a0 "not") (=> a0 '!))
  (ret.add ["(" $(tx* a0 env) $(tx* a1 env) ")"]) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- xfi "" [from to]
  (cond
    (and from to)
    (let [tline (.-line to)
          fline (.-line from)]
      (if (and (not (number? tline))
               (number? fline))
        (=>> to
             :source (.-source from)
             :line (.-line from)
             :column (.-column from))) to)
    :else to))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- spitExterns "" []
  (var s "" ks (keys *externs*))
  (when (not-empty ks)
    (=> s (join ",\n" (map #(str % ": " %) ks))
        s (str "\n\nmodule.exports = {\n" s "\n};\n\n"))) s)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- banner "" []
  (str "/*" "Auto generated by Kirby - v"
       MODULE-VERSION " "
       (.firstNSP (eng/globalEnv)) " - " (new Date) "*/\n\n"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- cleanCode "" [code]
  (var tmp nil arr [])
  (doseq [s (code.split "\n")
          :let [tmp (s.trim)]]
    (if (and (not-empty tmp)
             (not= tmp ";")) (conj! arr s)))
  (join "\n" arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpile* "" [source fname options]
  (.resetNSPCache (eng/globalEnv))
  (=> *externs* {})
  (var ret (txTree (parser/parse source fname)
                   (eng/globalEnv))
       {:keys [source-map format]} options
       fbase (path/basename fname ".ky")
       extra (spitExterns)
       fopts {}
       cstr
       (if source-map
         (let [fmap (str fbase ".js")
               smap (str fbase ".map")
               sout (ret.toStringWithSourceMap
                      {:skipValidation true :file fmap})]
           (fs/writeFileSync smap sout.map)
           (str sout.code
                extra
                "\n//# sourceMappingURL="
                (path/relative (path/dirname fname) smap)))
         (str ret extra)))
  (if format
    (=> cstr (esfmt/format cstr fopts)))
  (=> cstr (cleanCode cstr))
  ;;(if format (set! cstr (esfmt/format cstr fopts)))
  (if (empty? cstr) "" (str (banner) cstr)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn transpile
  "" [code file & [options]]
  (try (transpile* code file (opt?? options {}))
       (catch e
         (println (.-stack e)) (throw e))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn dbgAST
  "" [source fname]
  (parser/dumpTree (parser/parse source fname) fname))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(const version MODULE-VERSION)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

