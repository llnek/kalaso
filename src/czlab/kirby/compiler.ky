;; Copyright (c) 2013-2017, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns ^{:doc ""
      :author "Kenneth Leung"}
  czlab.kirby.compiler
  (:require ["source-map" :as smap])
  (:require ["./stdlib"
             :as std
             :refer [lambda-arg? hashmap pairs? into!
                     contains? last typeid
                     prn primitive map? vector?
                     opt?? some? primitive?
                     not-empty conj! list?
                     gensym count pop! slice
                     symbol keyword symbol? keyword?]]
            ["./engine" :as eng]
            ["./parser" :as parser :refer [jsid]])
  (:require ["fs" :as fs]
            ["path" :as path]
            ["esformatter" :as esfmt]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- ERRORS-MAP {
  :no-sourcemap-info "Expected source map info"
  :invalid-fargs "Invalid function args"
  :invalid-catch "Invalid catch clause"
  :invalid-try "Invalid try clause"
  :invalid-include "Invalid include clause"
  :invalid-require "Invalid require clause"
  :invalid-namespace "Invalid namespace clause"
  :destruct-args "Bad destructure args"
  :outside-macro "Invalid clause outside of macro"
  :file-access "Failed file access"
  :file-read "Failed file read"
  :file-open "Failed to open file"
  :unknown-keyword "Unknown keyword"
  :invalid-arity "Invalid function arity"
  :invalid-meta "Invalid meta data"
  :syntax-error "Syntax error"
  :empty-form "Invalid form (empty)" })

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- ARRSLICE "Array.prototype.slice.call")
(const- JSARGS "arguments")
(const- LARGS "____args")
(const- BREAK "____break")
(const- MODULE-VERSION "1.0.0")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- *externs* nil
      SPEC-OPS {}
      MATH-OP-REGEX #/^[-+][0-9]+$/)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn tnodeEx "Create a node"
  ^SourceNode [name &[chunk]] (tnode nil nil nil chunk name))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn tnode "Create a token
            with source information"
  ^SourceNode [&[source line col chunk name]]
  (new smap/SourceNode
       (opt?? line nil)
       (opt?? col nil)
       (opt?? source nil)
       (opt?? chunk nil) (opt?? name nil)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- doFuncArgs "Deal with possible destructuring
                  of args in function definition"
  ^Array [args env]
  (var~ e ev rval out)
  (var pms []
       [fargs fdefs :as ret] [(node' args) (node' args)])
  (for [i 0 sz (n# args)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i args))
    (cond
      (symbol? e)
      (if (== e "&")
        ;vargs
        (do (set! rval (node' args)
                e (.@+i args))
            (rval.add [ARRSLICE "(" JSARGS "," $(i) ")"])
            (if (symbol? e)
              (fdefs.add ["let "
                          (tx* e env) "=" rval ";\n"])
              (do (set! out (node' args)
                      e (destruct* e out env))
                  (fdefs.add ["let "
                              (tx* e env)
                              "=" rval ";\n" out])))
            (break-out-of-loop!))
        ;ignore _
        (do (if (== e "_")
              (set! e (xfi e (gensym "U__")))) (conj! pms e)))
      (array? e)
      (do (set! rval (node' args)
              out (node' args)
              e (destruct* e out env))
          (rval.add [JSARGS "[" $(i) "]"])
          (conj! pms e)
          (fdefs.add out))
      :else
      (error! :destruct-args args)))
  (each #(fargs.add (tx* % env)) pms)
  (join "," fargs)
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destruct* "Decide on what the
                 rhs should be referred to 'as'"
  ^Symbol [coll out env]
  (var rhs (xfi coll (gensym)) e nil)
  (for [i 0 sz (n# coll)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i coll))
    (when (and (keyword? e)
               (== e "as"))
      (set! rhs (std/keyword->symbol (.@+i coll)))
      (break-out-of-loop!)))
  ;handle a vec or a map destructure only
  (cond
    (map? coll)
    (out.add (destructMap rhs coll env))
    (vector? coll)
    (out.add (destructVec rhs coll env))) rhs)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destructVec "" ^SourceNode [src coll env]
  (var ret (node' coll)
       as (tx* src env))
  (var~ e rval out)
  (for [i 0 sz (n# coll)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i coll))
    (cond
      (symbol? e)
      (cond
        (== e "_") nil
        (== e "&")
        (do (set! rval (node' coll)
                out (node' coll)
                e (.@+i coll))
            (rval.add [ARRSLICE "(" as "," $(i) ")"])
            (if-not (symbol? e)
              (set! e (destruct* e out env)))
            (ret.add ["let "
                      (tx* e env)
                      "=" rval ";\n" out])
            (break-out-of-loop!))
        :else
        (ret.add ["let "
                  (tx* e env)
                  "=" as "[" $(i) "];\n"]))
      (array? e)
      (do (set! rval (node' coll)
              out (node' coll)
              e (destruct* e out env))
          (rval.add [as "[" $(i) "]"])
          (ret.add ["let "
                    (tx* e env)
                    "=" rval ";\n" out]))
      (keyword? e)
      (if (== e "as")
        (++ i)
        (error! :unknown-keyword coll))
      :else (error! :syntax-error coll))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destructMap "" ^SourceNode [src coll env]
  (var ret (node' coll)
       as (tx* src env))
  (var~ e arr)
  (for [i 0 sz (n# coll)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i coll))
    (cond
      (keyword? e)
      (cond
        (or (== e "keys")
            (== e "strs"))
        (do (set! arr (.@+i coll))
            (++ i)
            (for [j 0 sz (n# arr)
                  :while (< j sz) :recur (+1 j)]
              (set! e (.@j arr))
              (ret.add ["let "
                        (tx* e env)
                        "=" as "[\"" $(e) "\"];\n"])))
        :else
        (error! :unknown-keyword coll))
      :else
      (error! :syntax-error coll))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- simple? "" ^Boolean [ast]
  (or (undef? ast) (nil? ast) (str? ast) (num? ast) (bool? ast)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- wrap "" ^SourceNode [ret head tail]
  (if head (ret.prepend head))
  (if tail (ret.add tail)) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- exprHint "" ^Array [ast flag]
  (if (simple? ast) (set! ast (primitive ast))) (assoc! ast :____expr flag) ast)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- stmt? "" ^Boolean [ast]
  (if (simple? ast) (error! :syntax-error ast)) (false? ast.____expr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- error! "" [e & [ast msg]]
  (raise! (get ERRORS-MAP e)
          (if msg (str " : " msg))
          (if (and ast ast.line) (str "\nline: " ast.line))
          (if (and ast ast.source) (str "\nfile: " ast.source))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- testre? "" ^Boolean [re x] (if x (re.test x) false))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- pad "" [n] ^String (.repeat " " n))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- node' "" ^SourceNode [ast & [obj]]
  (set! obj (opt?? obj (tnode)))
  (assoc! obj
          :source ast.source
          :line ast.line
          :column ast.column) obj)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txTree "" ^SourceNode [root env]
  (var ret (node' root))
  (doseq [r root
          :let [t (tx* r env)]
          :when (some? t)] (ret.add [t "\n"])) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txForm "" ^Any [expr env]
  (if (array? expr)
    (each (fn [a i arr]
            (set-in! arr i (tx* a env))) expr)) expr)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txAtom "Returns a SourceNode or String" ^Any [a]
  (var s $(a))
  (cond (lambda-arg? a)
        (str LARGS "[" s "]")
        (keyword? a)
        (node' a (tnodeEx (jsid s) (str "\"" (jsid s) "\"")))
        (symbol? a)
        (node' a (tnodeEx (jsid s) (jsid s)))
        (nil? a)
        "null"
        (primitive? a)
        (do (set! a a.value s $(a))
            (cond (string? a) (std/wrap-str a)
                  (nil? a) "null"
                  :else s))
        (string? a)
        (std/wrap-str a)
        :else (jsid s)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- tx* "" ^Any [x & [env]]
  (if (array? x) (txPairs x env) (txAtom x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- gcmd "" ^String [ast]
  (cond (map? ast) "hashmap"
        (vector? ast) "vec"
        (list? ast) "list"
        (and (array? ast)
             (not (array? (1st ast)))) $(1st ast) :else ""))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quoteSingle "" ^String [a]
  (cond (keyword? a)
        (str (maybeStripStdlib "kirbystdlibref.keyword")
             "(\":" a "\")")
        (symbol? a)
        (str (maybeStripStdlib "kirbystdlibref.symbol")
             "(\"" a "\")")
        (primitive? a)
        (do (set! a a.value)
            (cond (string? a) (std/wrap-str a)
                  (nil? a) "null"
                  :else $(a)))
        (string? a)
        (std/wrap-str a)
        :else $(a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quote! "" ^SourceNode [ast env]
  (assertInfo ast)
  (if (array? ast)
    (if (map? ast)
      (quoteMap ast env)
      (quoteBlock ast env))
    (quoteSingle ast)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quoteMap "" ^SourceNode [ast env]
  (var comma ""
       ret (node' ast))
  (for [i 0 sz (n# ast)
        :while (< i sz) :recur (+2 i)]
    (if (> i 0) (ret.add ","))
    (ret.add [(quote! (.@i ast) env)
              " : " (quote! (.@+i ast) env)]))
  (if-not (empty? ast) (set! comma ","))
  (wrap ret ["[" "symbol(\"hashmap\")" comma] "]"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quoteBlock "" ^SourceNode [ast env]
  (var ret (node' ast))
  (for [i 0 sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (if (> i 0) (ret.add ","))
    (ret.add (quote! (.@i ast) env)))
  (wrap ret "[" "]"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- spreadInfo "" ^Any [from to]
  (if (and from
           (not (simple? from))
           (number? from.line)
           (array? to))
    (do (xfi from to)
        (for [i 0 sz (n# to)
              :while (< i sz) :recur (+1 i)]
          (spreadInfo from (.@i to))))
    (xfi from to)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txPairs "" ^SourceNode [ast env]
  (var nsp (.peekNSP (eng/globalEnv))
       stmtQ (stmt? ast)
       ret (node' ast)
       cmd (gcmd ast)
       e1 (1st ast)
       orig ast
       op nil tmp nil
       mc (eng/getMacro cmd))
  (xfi e1 ret)
  (xfi e1 ast)
  ;;handle macro calls
  (when mc
    (set! ast (eng/expand?? ast env mc)
        ast (xfi orig (exprHint ast (not stmtQ))))
    (spreadInfo orig ast)
    (set! cmd (gcmd ast)))
  ;;handle (+1 ) or (-1 ) cases
  (when (parser/REGEX.int.test cmd)
    (if-not (or (starts? cmd "+")
                (starts? cmd "-"))
      (set! cmd (str "+" cmd)))
    (set! ast (xfi ast [(symbol (ch@ cmd 0))
                      (2nd ast)
                      (int (rest cmd))])
        cmd $(1st ast)))
  ;;maybe special form
  (set! op (get SPEC-OPS cmd))
  ;;handle all cases
  (cond
    (== cmd "with-meta")
    (ret.add (tx* (2nd (meta?? ast env)) env))
    (starts? cmd ".-")
    (ret.add [(tx* (2nd ast) env)
              "." (tx* (symbol (cmd.slice 2)) env)])
    (starts? cmd ".@")
    (do (set! tmp (if (starts? cmd ".@+") [3 #t] [2 #f]))
        (ret.add [(tx* (2nd ast) env)
                  "[" (cmd.slice (1st tmp)) (if (2nd tmp) "+1]" "]")]))
    (starts? cmd ".")
    (do (ret.add [(tx* (2nd ast) env) cmd "("])
        (for [n 2 sz (n# ast)
              :while (< n sz) :recur (+1 n)]
          (if (not= n 2) (ret.add ","))
          (ret.add (tx* (.@n ast) env)))
        (ret.add ")"))
    (some? op)
    (set! ret (op ast env))
    (and (or (== cmd "splice-unquote")
             (== cmd "unquote")
             (== cmd "syntax-quote"))
         (not (starts? nsp "czlab.kirby.")))
    (error! :outside-macro ast)
    :else
    (do (if (pairs? ast)
          (do (txForm ast env)
              (set! cmd $(1st ast)))
          (set! cmd (tx* ast env)))
        (if-not cmd (error! :empty-form ast))
        (set! cmd (maybeStripStdlib cmd))
        (if (pairs? ast)
          (ret.add
            [(if (testre? parser/REGEX.func cmd)
               (str "(" cmd ")") cmd)
             "(" (join "," (rest ast)) ")"])
          (ret.add cmd))))
  (node' ast ret))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- writeDoc "Convert to jsdoc" ^Array [doc]
  (var out [])
  (if doc
    (->> (.split (std/unwrap-str doc) "\n")
         (each #(let [s (.trim (str %))]
                  (if (not-empty s)
                    (conj! out (str "//" s "\n"))))))) out)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txDo "" ^SourceNode [ast env & [return?]]
  (var stmtQ (stmt? ast)
       ret (node' ast)
       e nil end (last-index ast))
  (set! return?
      (if stmtQ false (opt?? return? true)))
  (for [i 0 :while (< i end) :recur (+1 i)]
    (set! e (exprHint (.@i ast) #f))
    (ret.add [(tx* e env) ";\n"]))
  (when (>= end 0)
    (set! e (exprHint (.@end ast)
                    (not stmtQ))
        e (tx* e env))
    (ret.add (if-not return?
               [e ";\n"]
               ["return " e ";\n"]))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- meta?? "" ^Array [obj env]
  (var mobj nil)
  (when (and (array? obj)
             (= 3 (n# obj))
             (== "with-meta"
                 $(1st obj)))
    (set! mobj (evalMeta (.@2 obj) env))
    (assoc! (2nd obj) :____meta mobj)
    (set! obj (2nd obj)))
  [mobj obj])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fmtRegoSpecOps "" ^String [alias fname]
  (str (parser/jsid :SPEC-OPS) "[\"" alias "\"] = " fname))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fmtSpecOps "" ^String [fname attrs]
  (var ks (or (get attrs "opcode") [])
       out (->> (map #(fmtRegoSpecOps
                        (str %) fname) ks) (join ";\n")))
  (if (not-empty ks) (str out ";\n") out))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- writeFuncInfo "" ^String [fname ast]
  (var file (if ast.source
              (ast.source.slice
                (+1 (ast.source.lastIndexOf "/"))) "?")
       s (str "//fn: ["
              fname "] in file: "
              file ",line: " (or ast.line "?") "\n")
       len (alen s))
  (if (< len 80)  (set! len 80))
  (str (.repeat "/" len) "\n" s))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- icache [])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- includeFile ^SourceNode [fname ast]
  (if (contains? icache fname)
    (node' ast)
    (let [src (eng/slurp fname)]
      (conj! icache fname)
      (txTree (parser/parse src fname) (eng/globalEnv )))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- evalMeta "" ^Object [ast env]
  (var x
       (cond (array? ast)
             ast
             (keyword? ast)
             (into! :map [ast #t])
             (symbol? ast)
             (into! :map [(keyword ":tag") ast])
             :else
             (error! :invalid-meta ast))
       v (eng/compute x env))
  ;(console.log (str "meta-obj=" (JSON/stringify v)))
  v)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- maybeStripStdlib "" ^String [cmd]
  (var lib "kirbystdlibref."
       nsp (.peekNSP (eng/globalEnv)))
  (set! cmd $(cmd))
  (if (and (starts? cmd lib)
           (= nsp "czlab.kirby.stdlib"))
    (cmd.slice (alen lib)) cmd))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- assertArity "" ^Any [kond ast]
  (if-not kond (error! :invalid-arity ast))
  (assertInfo ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- assertInfo "" ^Any [ast]
  (if (and false
           ast
           (not (simple? ast))
           (not (number? ast.line)))
    (error! :no-sourcemap-info ast)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;special-forms
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn sf-juxt "" ^{:opcode ["juxt"] :tag SourceNode} [ast env]
  (var ret (node' ast))
  (ret.add ["function () {\n"
            "let ret=[]," LARGS "=" ARRSLICE "(" JSARGS ");\n"])
  (for [i 1 f nil sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (set! f $(gensym "F__"))
    (ret.add ["let " f "=" (tx* (.@i ast) env) ";\n"
              "ret.push(" f ".apply(this,____args));\n"]))
  (ret.add "return ret;\n}") ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-deref ""
  ^{:opcode ["deref"] :tag SourceNode} [ast env]
  (assertArity (= (n# ast) 2) ast)
  (var ret (node' ast))
  (ret.add [(tx* (2nd ast) env) ".value"])
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-compose ""
  ^{:opcode ["comp"] :tag SourceNode} [ast env]
  (assertArity (>= (n# ast) 2) ast)
  (var ret (node' ast)
       end (last-index ast))
  (var~ f r prev)
  (ret.add ["function () {\n"])
  (ret.add ["let " LARGS "=" ARRSLICE "(" JSARGS ");\n"])
  (for [i end :while (> i 0) :recur (-1 i)]
    (set! f $(gensym "F__") r $(gensym "R__"))
    (ret.add ["let " f "=" (tx* (.@i ast) env) ";\n"])
    (if (= i end)
      (ret.add ["let " r "=" f ".apply(this," LARGS ");\n"])
      (ret.add ["let " r "=" f "(" prev ");\n"]))
    (set! prev r))
  (ret.add ["return " prev ";\n"])
  (ret.add "}"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-quote ""
  ^{:opcode ["quote"] :tag SourceNode} [ast env]
  (assertArity (= (n# ast) 2) ast)
  (var ret (node' ast))
  (wrap ret nil (quote! (2nd ast) env)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-deftype
  "Define a JS Class"
  ^{:opcode ["deftype" "deftype-"] :tag SourceNode}
  [ast env]
  (assertArity (>= (n# ast) 4) ast)
  (var ret (node' ast))
  (var~ mtd pos n m)
  (var private? (ends? $(1st ast) "-")
       czname (tx* (2nd ast) env)
       par (1st (.@2 ast))
       czargs (.@3 ast)
       [doc mtds] (if (str? (.@4 ast))
                    [(.@4 ast) (slice ast 5)]
                    [nil (slice ast 4)]))
  (ret.add ["class " czname])
  (if par (ret.add [" extends " (tx* par env)]))
  (ret.add " {\n")
  (doseq [m mtds]
    ;;doc string?
    (set! mtd 'method
        pos (if (str? (2nd m)) 3 2))
    ;;pass line info
    (xfi (1st m) mtd)
    (xfi (1st m) m)
    (when (and (== $(1st m)
                   "constructor")
               (not-empty czargs))
      (for [x 0 sz (n# czargs)
            :while (< x sz) :recur (+2 x)]
        (set-in! czargs x $(.@x czargs)))
      (m.splice pos 0
        (concat ['assoc! 'this] czargs)))
    (m.unshift mtd)
    (ret.add [(sf-func m env #f) "\n"]))
  (ret.add "}\n")
  (if doc (ret.prepend (writeDoc doc)))
  (if (and (not private?)
           (= 1 (.countNSPCache
                  (eng/globalEnv))))
      (assoc! *externs* czname czname)) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-compOp "" ^{:opcode ["not=" "!="
                               "==" "="
                               ">" ">=" "<" "<="]
                      :tag SourceNode} [ast env]
  (assertArity (and (>= (n# ast) 3)
                    (odd? (n# ast))) ast)
  (var ret (node' ast)
       cmd $(1st ast))
  (cond (== cmd "not=") (set-in! ast 0 '!==)
        (== cmd "=") (set-in! ast 0 '===))
  (for [i 1 op (tx* (1st ast) env)
        :while (< i (last-index ast)) :recur (+1 i)]
    (if (not= i 1) (ret.add " && "))
    (ret.add [(tx* (.@i ast) env)
              " " op " " (tx* (.@+i ast) env)]))
  (wrap ret "(" ")"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-arithOp
  ""
  ^{:opcode ["bitwise-lshift" "bitwise-rshift" "bitwise-zrshift"
             "+" "-" "*" "/" "div" "mod"
             "or" "and" "exp" "rem"
             "bitwise-and" "bitwise-or" "bitwise-not" "bitwise-xor"]
    :tag SourceNode}
  [ast env]
  (assertArity (>= (n# ast) 2) ast)
  (var e1 (tx* (1st ast) env)
       cmd $(e1) ret (node' ast))
  (cond (== cmd "bitwise-zrshift") (set! cmd ">>>")
        (== cmd "bitwise-rshift") (set! cmd ">>")
        (== cmd "bitwise-lshift") (set! cmd "<<")
        (== cmd "bitwise-and") (set! cmd "&")
        (== cmd "bitwise-or") (set! cmd "|")
        (== cmd "bitwise-not") (set! cmd "~")
        (== cmd "bitwise-xor") (set! cmd "^")
        (== cmd "rem") (set! cmd "%")
        (== cmd "div") (set! cmd "/")
        (== cmd "and") (set! cmd "&&")
        (== cmd "or") (set! cmd "||")
        (== cmd "exp") (set! cmd "**"))
  (if (and (== "-" cmd)
           (= 2 (n# ast))) (ret.add "-1 * "))
  (for [i 1 sz (n# ast)
        :while (< i sz) : recur (+1 i)]
    (when (> sz 2)
      (if (> i 1) (ret.add cmd)))
    (ret.add (tx* (.@i ast) env)))
  (wrap ret "(" ")"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-do
  "" ^{:opcode ["do"] :tag SourceNode} [ast env]
  (assertArity true ast)
  (var ret (node' ast)
       stmtQ (stmt? ast))
  (ret.add (txDo (exprHint (xfi ast (rest ast))
                           (not stmtQ)) env (not stmtQ)))
  (if stmtQ
    (wrap ret nil "")
    (wrap ret
          "(function() {\n" "}).call(this)")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-case
  "" ^{:opcode ["case"] :tag SourceNode} [ast env]
  (assertArity (>= (n# ast) 4) ast)
  (var stmtQ (stmt? ast)
       ret (node' ast)
       tst (2nd ast)
       brk ";\nbreak;\n"
       gs $(gensym "C__"))
  (var~ e t c dft)
  (if (odd? (n# ast))
    (set! dft (1st (pop! ast))))
  (for [i 2 sz (n# ast)
        :while (< i sz) :recur (+2 i)]
    (set! e (.@i ast)
        c (.@+i ast))
    (if (pairs? e)
      (for [j 0 sz (n# e)
            :while (< j sz) :recur (+1 j)]
        (ret.add ["case " (tx* (.@j e) env) ":\n"])
        (if (= j (last-index e))
          (ret.add [gs "=" (tx* c env) brk])))
      (ret.add ["case " (tx* e env) ":\n"
                gs "=" (tx* c env) brk])))
  (if dft
    (ret.add ["default:\n"
              gs "=" (tx* dft env) brk]))
  (wrap ret ["switch (" (tx* tst env) ") {\n"] "}")
  (if stmtQ
    (wrap ret ["let " gs ";\n"] "")
    (wrap ret
          ["(function() { let " gs ";\n"]
          ["return " gs ";}).call(this)"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-vardefs "" ^{:opcode ["def~-"
                                "def~" "var~"]
                       :tag SourceNode} [ast env]
  (assertArity (>= (n# ast) 2) ast)
  (var ret (node' ast)
       cmd $(1st ast)
       keys {}
       private? (not= cmd "def~"))
  (if (starts? cmd "def")
    (set! cmd "var") (set! cmd "let"))
  (for [i 1 s nil sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (set! s (tx* (.@i ast) env))
    (assoc! keys s nil)
    (if (> i 1) (ret.add ","))
    (ret.add s))
  (wrap ret (str cmd " ") ";\n")
  (if (and (not private?)
           (= 1 (.countNSPCache
                  (eng/globalEnv))))
    (each-key (fn [v k] (assoc! *externs* k k)) keys)) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-var "" ^{:opcode ["const-"
                            "const"
                            "def-"
                            "def"
                            "var"]
                   :tag SourceNode} [ast env]
  (assertArity (odd? (n# ast)) ast)
  (var ret (node' ast)
       cmd $(1st ast)
       keys []
       tmp nil vname nil
       private? (and (not= cmd "const")
                     (not= cmd "def")))
  (var~ rval rc lhs rhs)
  (set! cmd (if (starts? cmd "const")
            "const"
            (if (== cmd "var") "let" "var")))
  (for [i 1 sz (n# ast)
        :while (< i sz) :recur (+2 i)]
    (set! lhs (.@i ast)
        rhs (.@+i ast)
        rval (tx* rhs env))
    (if (symbol? lhs)
      (do (set! lhs (tx* lhs env)
              tmp [cmd " " lhs "=" rval ";\n"])
          (conj! keys lhs)
          (ret.add tmp))
      (do (set! out (node' ast)
              rhs (destruct* lhs out env ast))
          (ret.add ["let "
                    (tx* rhs env)
                    "=" rval ";\n" $(out)]))))
  (when (and (not private?)
             (= 1 (.countNSPCache
                    (eng/globalEnv))))
    (each (fn [k] (assoc! *externs* k k)) keys)) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-inst?
  "" ^{:opcode ["inst?"] :tag SourceNode} [ast env]
  (assertArity (= (n# ast) 3) ast)
  (var ret (node' ast))
  (wrap ret nil ["(" (tx* (.@2 ast) env)
                 " instanceof " (tx* (2nd ast) env) ")"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-delete
  "" ^{:opcode ["delete!"] :tag SourceNode} [ast env]
  (assertArity (and (>= (n# ast) 2)
                    (< (n# ast) 4)) ast)
  (var ret (node' ast))
  (ret.add ["delete "
            (tx* (2nd ast) env)])
  (if (> (n# ast) 2)
    (ret.add ["[" (tx* (.@2 ast) env) "]"])) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-new
  "" ^{:opcode ["new"] :tag SourceNode} [ast env]
  (assertArity (>= (n# ast) 2) ast)
  (var ret (node' ast))
  (wrap ret "new " (tx* (xfi ast (rest ast)) env)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-throw
  "" ^{:opcode ["throw"] :tag SourceNode} [ast env]
  (assertArity (>= (n# ast) 2) ast)
  (var ret (node' ast)
       stmtQ (stmt? ast))
  (ret.add ["throw " (tx* (xfi ast (2nd ast)) env)])
  (if-not stmtQ
    (wrap ret
          "(function (){ "
          ";}).call(this)")) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-x-opop
  "" ^{:opcode ["++" "--" "++$" "--$"] :tag SourceNode} [ast env]
  (assertArity (= (n# ast) 2) ast)
  (var ret (node' ast)
       cmd $(1st ast)
       a2 (tx* (2nd ast) env))
  (if (ends? cmd "$")
    (ret.add [a2 (cmd.slice 0 -1)])
    (ret.add [cmd a2])) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-x-eq
  "" ^{:opcode ["+="
                "-="
                "*="
                "div="
                "rem="
                "exp="
                "bitwise-and="
                "bitwise-or="
                "bitwise-xor="
                "bitwise-lshift="
                "bitwise-rshift="
                "bitwise-zrshift="]
       :tag SourceNode} [ast env]
  (assertArity (= (n# ast) 3) ast)
  (var cmd $(1st ast)
       ret (node' ast))
  (cond
    (== cmd "bitwise-zrshift=") (set! cmd ">>>=")
    (== cmd "bitwise-rshift=") (set! cmd ">>=")
    (== cmd "bitwise-lshift=") (set! cmd "<<=")
    (== cmd "bitwise-xor=") (set! cmd "^=")
    (== cmd "bitwise-or=") (set! cmd "|=")
    (== cmd "bitwise-and=") (set! cmd "&=")
    (== cmd "div=") (set! cmd "/=")
    (== cmd "rem=") (set! cmd "%=")
    (== cmd "exp=") (set! cmd "**="))
  (wrap ret nil [(tx* (2nd ast) env)
                 " " cmd " " (tx* (.@2 ast) env)]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-setin!
  "" ^{:opcode ["set-in!" "assoc!" "=>>"] :tag SourceNode} [ast env]
  (assertArity (even? (n# ast)) ast)
  (var ret (node' ast)
       more #f
       obj (tx* (2nd ast) env))
  (for [i 2 sz (n# ast)
        :while (< i sz) :recur (+2 i)]
    (when (> i 2)
      (ret.add ",")
      (true! more))
    (ret.add [obj
              "[" (tx* (xfi ast (.@i ast)) env) "]"
              "=" (tx* (xfi ast (.@+i ast)) env)]))
  (if more (wrap ret "(" ")")) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-set
  "" ^{:opcode ["set!" "=>"] :tag SourceNode} [ast env]
  (assertArity (odd? (n# ast)) ast)
  (var more #f
       ret (node' ast))
  (for [i 1 sz (n# ast)
        :while (< i sz) :recur (+2 i)]
    (when (> i 1)
      (ret.add ",")
      (true! more))
    (ret.add [(tx* (.@i ast) env)
              "=" (tx* (xfi ast (.@+i ast)) env)]))
  (if more (wrap ret "(" ")")) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-fn
  "(fn [x y] ...)" ^{:opcode ["fn"] :tag SourceNode} [ast env]
  (assertArity (>= (n# ast) 2) ast)
  (var ret (node' ast)
       fargs nil
       body (xfi ast (slice ast 2))
       [_ args] (meta?? (2nd ast) env))
  (if-not (array? args)
    (error! :invalid-fargs ast))
  (set! fargs (doFuncArgs (xfi ast args) env))
  (wrap ret nil ["function ("
                 (1st fargs)
                 ") {\n"
                 (2nd fargs)
                 (txDo body env #t) "}"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-func "" ^{:opcode ["defn" "defn-"]
                    :tag SourceNode} [ast env]
  (assertArity (>= (n# ast) 2) ast)
  (var private? (ends? $(1st ast) "-")
       mtd? (== $(1st ast) "method")
       fname0 $(2nd ast)
       fname $(tx* (2nd ast) env)
       dot? (contains? fname ".")
       fargs nil
       ret (node' ast
                  (tnodeEx fname))
       [doc pargs] (if (str? (.@2 ast))
                     [(nth ast 2) 3] [nil 2])
       body (xfi ast (slice ast (+1 pargs)))
       [hints args] (meta?? (nth ast pargs) env))
  (if-not (array? args)
    (error! :invalid-fargs ast))
  (set! fargs (doFuncArgs (xfi ast args) env))
  (set! hints (or hints {}))
  (cond mtd?
        (do (if (.-static hints)
              (ret.add "static "))
            (ret.add [fname " ("])
            (if (== fname "constructor")
              (conj! body 'this)))
        dot?
        (ret.add [fname " = function ("])
        :else
        (ret.add ["const " fname " = function ("]))
  (ret.add [(1st fargs)
            ") {\n"
            (2nd fargs)
            (txDo body env #t) "};\n"])
  (if (not-empty hints)
    (ret.add (fmtSpecOps fname hints)))
  (if doc
    (ret.prepend (writeDoc doc)))
  (ret.prepend (writeFuncInfo fname0 ast))
  (if (and (not private?)
           (not dot?)
           (not mtd?)
           (= 1 (.countNSPCache
                  (eng/globalEnv)))) (assoc! *externs* fname fname)) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-try "" ^{:opcode ["try"] :tag SourceNode} [ast env]
  (assertArity (>= (n# ast) 2) ast)
  (var stmtQ (stmt? ast)
       sz (n# ast)
       ret (node' ast))
  (var~ t f c)
  ;;look for finally
  (set! f (last ast))
  (if (and (array? f)
           (== "finally" $(1st f)))
    (do (pop! ast)
        (set! sz (n# ast))
        (xfi (1st f) f))
    (nil! f))
  ;;look for catch
  (nil! c)
  (if (> sz 1)
    (set! c (nth ast (-1 sz))))
  (if (and (array? c)
           (== "catch" $(1st c)))
    (do (if (or (< (n# c) 2)
                (not (symbol? (2nd c))))
          (error! :invalid-catch ast))
        (pop! ast)
        (xfi (1st c) c))
    (nil! c))
  ;;try needs either a catch or finally or both
  (if (and (nil? f)
           (nil? c)) (error! :invalid-try ast))
  (ret.add ["try {\n"
            (txDo (exprHint (xfi ast (rest ast))
                            (not stmtQ)) env) "\n}"])
  (when c
    (set! t (2nd c))
    (ret.add [(str "catch (" (tx* t env) ") {\n")
              (txDo (exprHint (xfi c (slice c 2))
                              (not stmtQ)) env) ";\n}\n"]))
  (when f
    (ret.add ["finally {\n",
              (txDo (exprHint (xfi f (rest f)) #f) env #f) ";\n}\n"]))
  (if-not stmtQ
    (wrap ret "(function(){\n" "}).call(this)")) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-if "" ^{:opcode ["if"] :tag SourceNode} [ast env]
  (assertArity (>= (n# ast) 3) ast)
  (var stmtQ (stmt? ast)
       ret (node' ast)
       a1 (exprHint (xfi ast (2nd ast)) true)
       a2 (exprHint (xfi ast (.@2 ast)) (not stmtQ))
       m? (> (n# ast) 3)
       a3 (if m? (xfi ast (.@3 ast)))
       elze (if m? (exprHint a3 (not stmtQ))))
  (set! a1 (tx* a1 env)
      a2 (tx* a2 env)
      elze (tx* elze env))
  (wrap ret
        nil
        (if stmtQ
          ["if (" a1 ") {\n" a2 ";\n}"
           (if m? [" else { \n" elze ";\n}"] "")]
          ["(" a1 " ?\n" a2 " :\n" (or elze "null") ")"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-get "" ^{:opcode ["nth" "get"]
                   :tag SourceNode} [ast env]
  (assertArity (= (n# ast) 3) ast)
  (var ret (node' ast))
  (wrap ret nil [(tx* (xfi ast (2nd ast)) env)
                 "[" (tx* (xfi ast (.@2 ast)) env) "]"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-array "" ^{:opcode ["vec"]
                     :tag SourceNode} [ast env]
  (assertArity true ast)
  (var pos 0
       ret (node' ast))
  (if (empty? ast)
    (ret.add "[]")
    (do (if-not (vector? ast) (set! pos 1))
        (ret.add "[\n")
        (for [i pos sz (n# ast)
              :while (< i sz) :recur (+1 i)]
          (if (> i pos) (ret.add ",\n"))
          (ret.add (tx* (xfi ast (.@i ast)) env)))
        (ret.add "\n]"))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-object "" ^{:opcode ["hashmap"]
                      :tag SourceNode} [ast env]
  (assertArity true ast)
  (var pos 0
       ret (node' ast))
  (if (empty? ast)
    (ret.add "{}")
    (do (if-not (map? ast) (set! pos 1))
        (ret.add "{\n")
        (for [i pos sz (n# ast)
              :while (< i sz) :recur (+2 i)]
          (if (> i pos) (ret.add ",\n"))
          (ret.add [(tx* (.@i ast) env)
                    ": " (tx* (xfi ast (.@+i ast)) env)]))
        (ret.add "\n}"))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-include "" ^Array [ast env]
  (assertArity (>= (n# ast) 2) ast)
  (var ret []
       dir (path/dirname ast.source))
  (var~ fname e)
  (for [i 1 sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i ast))
    (if (or (not (array? e))
            (not= 1 (n# e)))
      (error! :invalid-include ast))
    (set! fname $(1st e))
    (if fname
      (set! fname (fname.replace #/[\"]/g "")))
    (try
      (set! fname (fs/realpathSync
                  (str dir "/" fname)))
      (catch e
        (error! :file-access ast)))
    (try
      (conj! ret (includeFile fname ast))
      (catch e
        (error! :file-read ast))
      (finally
        (.popNSP (eng/globalEnv)))))
  (if (empty? ret) "" ret))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-require "" ^SourceNode [ast env]
  (assertArity (>= (n# ast) 2) ast)
  (var~ as path v e refers renames)
  (var ret (node' ast))
  (for [i 1 sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i ast)
        as $(gensym "R__")
        refers nil renames nil)
    (if (or (not (array? e))
            (< (n# e) 3)) (error! :invalid-require ast))
    (set! path $(1st e))
    (for [j 1 sz (n# e)
          :while (< j sz) :recur (+1 j)]
      (set! v (.@j e))
      (cond (== v "as")
            (do (set! as $(.@+j e))
                (++ j))
            (== v "refer")
            (do (set! refers (.@+j e))
                (++ j))
            (== v "rename")
            (do (set! renames (.@+j e))
                (++ j))))
    (ret.add ["const " (parser/jsid as)
              "= require(" (tx* path env) ");\n"])
    (for [i 0 sz (n# refers)
          :while (< i sz) :recur (+1 i)]
      (set! v (tx* (.@i refers) env))
      (ret.add ["const " v "=" as "[\"" v "\"];\n"]))
    (for [i 0 sz (n# renames)
          :while (< i sz) :recur (+2 i)]
      (set! e (tx* (.@i renames) env)
          v (tx* (.@+i renames) env))
      (ret.add ["const " v
                "=" as "[\"" e "\"];\n"]))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-ns "" ^{:opcode ["ns"] :tag SourceNode} [ast env]
  (assertArity (>= (n# ast) 2) ast)
  (var ret [] e nil
       [hints nsp] (meta?? (2nd ast) env))
  (if-not (symbol? nsp)
    (error! :invalid-namespace ast))
  (.pushNSP (eng/globalEnv) $(nsp))
  (set! ast (xfi ast (slice ast 2)))
  (for [i 0 sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i ast))
    (cond (and (pairs? e)
               (== "include" $(1st e)))
          (conj! ret (sf-include (xfi ast e)))
          (and (pairs? e)
               (== "require" $(1st e)))
          (conj! ret (sf-require (xfi ast e)))))
  ;;force a internal reference to stdlib for user files
  (set! nsp (.peekNSP (eng/globalEnv)))
  (cond
    (or (= nsp "czlab.kirby.macros")
        (= nsp "czlab.kirby.stdlib"))
    nil
    (starts? nsp "czlab.kirby.")
    (conj! ret "const kirbystdlibref=std;\n")
    :else
    (->> (xfi ast '(require ["kirby" :as kirbystdlibref]))
         (sf-require )
         (conj! ret ))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-comment "" ^{:opcode ["comment"] :tag String} [ast env] "")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-for "" ^{:opcode ["for"] :tag SourceNode} [ast env]
  (assertArity (>= (n# ast) 2) ast)
  (var stmtQ (stmt? ast)
       ret (node' ast)
       body (exprHint (xfi ast (slice ast 2)) #f))
  (if (empty? body)
    (node' ast)
    (sf-floop ret
              (xfi ast (2nd ast))
              body env stmtQ)) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-floop "" ^SourceNode [ret args body env stmtQ]
  (var vars [] recurs [])
  (var~ tst nb e)
  (for [i 0 sz (n# args)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i args))
    (cond (== e "while")
          (do (set! tst (.@+i args)) (++ i))
          (== e "recur")
          (do (set! recurs (slice args (+1 i)))
              (break-out-of-loop!))
          (symbol? e)
          (do (conj! vars e (.@+i args))
              (++ i))))
  (ret.add "for (")
  (for [i 0 sz (n# vars)
        :while (< i sz) :recur (+2 i)]
    (if (= i 0) (ret.add "let "))
    (if (not= i 0) (ret.add ","))
    (ret.add [(tx* (.@i vars) env)
              "=" $(tx* (.@+i vars) env)]))
  (ret.add (if (empty? vars)
             "let ____break=false;" ",____break=false;"))
  (set! nb '(not ____break))
  (xfi ret nb)
  (if tst
    (set! tst ['and nb tst])
    (set! tst nb))
  (xfi ret tst)
  (ret.add [$(tx* tst env) "; "])
  (for [i 0 k 0 sz (n# recurs)
        :while (< i sz) :recur (+1 i)(+2 k)]
    (if (not= i 0) (ret.add ","))
    (ret.add [(tx* (.@k vars) env)
              "=" $(tx* (.@i recurs) env)]))
  (ret.add ["){\n" (txDo body env #f) "}\n"])
  (if-not stmtQ
    (wrap ret "(function() {\n"  "}).call(this)")) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-jscode "" ^{:opcode ["js#"] :tag SourceNode} [ast env]
  (assertArity (>= (n# ast) 2) ast)
  (var s $(2nd ast)
       name (parser/jsid "sf-jscode"))
  (->>
    (if (and (ends? s "\"")
             (starts? s "\""))
      (s.slice 1 -1) s) (tnodeEx name) (node' ast)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-macro "" ^{:opcode ["defmacro"] :tag String} [ast env]
  (assertArity (>= (n# ast) 2) ast)
  (var pms [] args (.@2 ast) body (slice ast 3))
  (var~ doc x e ev)
  (when (str? args)
    (set! doc args args (.@3 ast) body (slice ast 4)))
  (for [i 0 sz (n# args)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i args) ev $(e))
    (cond (= ev "&")
          (if (array? (.@+i args))
            (do (set! e (.@+i args))
                (++ i)
                (for [j 0 sz (n# e)
                      :while (< j sz) :recur (+1 j)]
                  (set! x (.@j e))
                  (if-not (symbol? x)
                    (error! :syntax-error ast))
                  (conj! pms x)))
            (do (conj! pms e (.@+i args))
                (++ i)))
          (not (symbol? e))
          (error! :syntax-error ast)
          :else
          (conj! pms e)))
  (eng/compute ['macro*
                (2nd ast) pms (1st body)] env) "")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-unary "" ^{:opcode ["not" "~" "!"]
                     :tag SourceNode} [ast env]
  (assertArity (= (n# ast) 2) ast)
  (var [a0 a1] ast
       ret (node' ast))
  (if (== a0 "not") (set! a0 '!))
  (ret.add ["(" $(tx* a0 env) $(tx* a1 env) ")"]) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- xfi "" ^Any [from to]
  (cond
    (and from to)
    (let [tline (.-line to)
          fline (.-line from)]
      (if (and (not (number? tline))
               (number? fline))
        (assoc! to
             :source (.-source from)
             :line (.-line from)
             :column (.-column from))) to)
    :else to))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- spitExterns "" ^String []
  (var s "" ks (keys *externs*))
  (when (not-empty ks)
    (set! s (join ",\n" (map #(str % ": " %) ks))
        s (str "\n\nmodule.exports = {\n" s "\n};\n\n"))) s)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- banner "" ^String []
  (str "/*" "Auto generated by Kirby - v"
       MODULE-VERSION " "
       (.firstNSP (eng/globalEnv)) " - " (new Date) "*/\n\n"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- cleanCode "" ^String [code]
  (var tmp nil arr [])
  (doseq [s (code.split "\n")
          :let [tmp (s.trim)]]
    (if (and (not-empty tmp)
             (not= tmp ";")) (conj! arr s)))
  (join "\n" arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpile* "" ^Array [source fname options]
  (.resetNSPCache (eng/globalEnv))
  (set! *externs* {})
  (var ret (txTree (parser/parse source fname)
                   (eng/globalEnv))
       {:keys [source-map format]} options
       fbase (path/basename fname ".ky")
       extra (spitExterns)
       fopts {}
       err nil
       cstr
       (if source-map
         (let [fmap (str fbase ".js")
               smap (str fbase ".map")
               sout (ret.toStringWithSourceMap
                      {:skipValidation true :file fmap})]
           (fs/writeFileSync smap sout.map)
           (str sout.code
                extra
                "\n//# sourceMappingURL="
                (path/relative (path/dirname fname) smap)))
         (str ret extra)))
  (try
    (if format (set! cstr
                   (esfmt/format cstr fopts)))
    (catch e (set! err e)))
  (set! cstr (cleanCode cstr))
  (vec (if (empty? cstr) "" (str (banner) cstr)) err))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn transpile
  "" ^Array [code file & [options]]
  (try (transpile* code file (opt?? options {}))
       (catch e
         (println (.-stack e)) (throw e))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn dbgAST
  "" ^String [source fname]
  (parser/dumpTree (parser/parse source fname) fname))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const version MODULE-VERSION)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

