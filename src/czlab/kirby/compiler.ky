;; Copyright (c) 2013-2018, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc "Transpiles kirby code to js code."
      :author "Kenneth Leung"}

  czlab.kirby.compiler

  (:require ["source-map" :as smap])
  (:require ["./stdlib"
             :as std
             :refer [lambdaArg? pairs? into! println
                     seq merge contains? last typeid
                     prn primitive set? map? vector?
                     opt?? some? primitive? regexObj?
                     unquote-str quote-str
                     not-empty conj! list? obj?
                     difference carve
                     gensym count pop!
                     symbol keyword symbol? keyword?]]
            ["./engine"
             :as rt
             :refer [KBSTDLR KBSTDLIB KBPFX EXPKEY]]
            ["./reader" :as reader :refer [jsid]])
  (:require ["fs" :as fs]
            ["path" :as path]
            ["esformatter" :as esfmt]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- ERRORS-MAP (object
  :no-sourcemap-info "Expected source map info"
  :invalid-fargs "Invalid function args"
  :invalid-catch "Invalid catch clause"
  :invalid-try "Invalid try clause"
  :invalid-require "Invalid require clause"
  :invalid-namespace "Invalid namespace clause"
  :destruct-args "Bad destructure args"
  :outside-macro "Invalid clause outside of macro"
  :file-access "Failed file access"
  :file-read "Failed file read"
  :file-open "Failed to open file"
  :unknown-keyword "Unknown keyword"
  :invalid-arity "Invalid function arity"
  :invalid-meta "Invalid meta data"
  :syntax-error "Syntax error"
  :empty-form "Invalid form (empty)" ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- ARRSLICE "Array.prototype.slice.call")
(const- JSARGS "arguments")
(const- LARGS "____args")
(const- BREAK "____break")
(const- MOD-VER "1.0.0")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- *externs* nil
      *macros* nil
      *last-line* 0
      *last-col* 0
      SPEC-OPS (object )
      MATH-OP-REGEX #/^[-+][0-9]+$/)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- unmangle "" [s]
  (->> (map #(reader/jsid %) (.split s ".")) (join ".")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn tnodeEx "Create a node"
  ^SourceNode [name &[chunk]] (tnode nil nil nil chunk name))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn tnode "Create a token
            with source information"
  ^SourceNode [&[source line col chunk name]]
  (new smap/SourceNode
       (opt?? line nil)
       (opt?? col nil)
       (opt?? source nil)
       (opt?? chunk nil) (opt?? name nil)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- doFuncArgs "Deal with possible destructuring
                  of args in function definition"
  ^Array [args env]
  (var pms []
       [fargs fdefs :as ret]
       [(node' args) (node' args)])
  (var~ e ev rval out)
  (for [i 0 sz (n# args)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i args))
    (cond
      (symbol? e)
      (if (== e "&")
        ;vargs
        (do->break!
          (set! rval (node' args)
                e (.@+i args))
          (rval.add [ARRSLICE "(" JSARGS "," (numStr i) ")"])
          (if (symbol? e)
            (fdefs.add ["let "
                        (tx* e env) "=" rval ";\n"])
            (do (set! out (node' args)
                      e (destruct* e out env))
                (fdefs.add ["let "
                            (tx* e env) "=" rval ";\n" out]))))
        ;ignore _
        (do (if (== e "_")
              (set! e (xfi e (gensym "U__")))) (conj! pms e)))
      (array? e)
      (do (set! rval (node' args)
                out (node' args)
                e (destruct* e out env))
          (rval.add [JSARGS "[" (numStr i) "]"])
          (conj! pms e)
          (fdefs.add out))
      :else
      (error! :destruct-args args)))
  (each #(fargs.add (tx* % env)) pms)
  (join "," fargs)
  ;;return back a list of function arguments, and the
  ;;rest of local variables in case of varargs or
  ;;arg-destructions
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destruct* "Decide on what the
                 rhs should be referred to 'as'"
  ^Symbol [coll out env]
  (var rhs (gensym))
  (var~ e)
  (for [i 0 sz (n# coll)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i coll))
    (when (and (keyword? e)
               (== e :as))
      (set! rhs (symbol $(.@+i coll)))
      (break-out-of-loop!)))
  (set! rhs (xfi coll rhs))
  ;handle a vec or a map destructure only
  (cond
    (map? coll)
    (out.add (destructMap rhs coll env))
    (vector? coll)
    (out.add (destructVec rhs coll env))) rhs)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destructVec "" ^SourceNode [src coll env]
  (var ret (node' coll)
       as (tx* src env))
  (var~ e rval out)
  (for [i 0 sz (n# coll)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i coll))
    (cond
      (symbol? e)
      (cond
        (== e "_") nil
        (== e "&")
        (do->break!
          (set! rval (node' coll)
                out (node' coll)
                e (.@+i coll))
          (rval.add [ARRSLICE "(" as "," (numStr i) ")"])
          (if-not (symbol? e)
            (set! e (destruct* e out env)))
          (ret.add ["let "
                    (tx* e env) "=" rval ";\n" out]))
        :else
        (ret.add ["let " (tx* e env) "="
                  (stripStd (str KBSTDLR ".getIndex")) "(" as "," (numStr i) ");\n"]))
        ;(ret.add ["let " (tx* e env) "=" as "[" (numStr i) "];\n"]))

      (array? e)
      (do (set! rval (node' coll)
                out (node' coll)
                e (destruct* e out env))
          (rval.add [as "[" (numStr i) "]"])
          (ret.add ["let "
                    (tx* e env) "=" rval ";\n" out]))
      (keyword? e)
      (if (== e :as)
        (++ i)
        (error! :unknown-keyword coll))
      :else (error! :syntax-error coll))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destructMap "" ^SourceNode [src coll env]
  (var ret (node' coll)
       as (tx* src env))
  (var~ e arr)
  (for [i 0 sz (n# coll)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i coll))
    (if (keyword? e)
      (cond
        (or (== e :keys)
            (== e :strs))
        (do (set! arr (.@+i coll))
            (++ i)
            (for [j 0 sz (n# arr)
                  :while (< j sz) :recur (+1 j)]
              (set! e (.@j arr))
              ;(ret.add ["let " (tx* e env) "=" as "[" (std/quote-str $(e)) "];\n"])))
              (ret.add ["let " (tx* e env) "="
                        (stripStd (str KBSTDLR ".getProp"))
                        "(" as "," (std/quote-str $(e)) ");\n"])))

        (== e :as)
        (++ i)
        :else
        (error! :unknown-keyword coll))
      ;else
      (error! :syntax-error coll))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- simple? "" [ast]
  (or (undef? ast) (nil? ast) (str? ast) (num? ast) (bool? ast)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- wrap "" ^SourceNode [ret head tail]
  (if head (ret.prepend head))
  (if tail (ret.add tail)) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- exprHint "" ^Array [ast flag]
  (if (simple? ast)
    (set! ast (primitive ast)))
  (assign! ast :____expr flag) ast)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- stmt? "" [ast]
  (if (simple? ast) (error! :syntax-error ast)) (false? ast.____expr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- error! "" [e & [ast msg]]
  (raise! (get ERRORS-MAP e)
          (if msg (str " : " msg))
          (if (and ast ast.line) (str "\nline: " ast.line))
          (if (and ast ast.source) (str "\nfile: " ast.source))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- testre? "" [re x] (if x (re.test x) #f))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- pad "" [n] ^String (.repeat " " n))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- node' "" ^SourceNode [ast & [obj]]
  (set! obj (opt?? obj (tnode)))
  (assign! obj
           :source ast.source
           :line ast.line
           :column ast.column) obj)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txTree
  "Process a file unit.  Sort out all the macros first then others.
  Also, always check first for (ns ...)"
  ^SourceNode [root env]
  (var ms [] os []
       n1 (1st root)
       ret (node' root))
  (var~ t f)
  (if-not (== "ns" (1st n1))
    (raise! "(ns ...) must be first form in file"))
  (conj! ms n1)
  (for [i 1 sz (n# root)
        :while (< i sz) :recur (+1 i)]
    (set! t (.@i root))
    (if (and (array? t)
             (symbol? (1st t))
             (== "defmacro" (1st t)))
      (conj! ms t)
      (conj! os t)))
  (doseq [r (.concat ms os)]
    (set! *last-line* r.line *last-col* r.col)
    (if-some [t (tx* r env)] (ret.add [t ";\n"])))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txForm "" ^Any [expr env]
  (if (array? expr)
    (each (fn [a i arr]
            (aset arr i (tx* a env))) expr)) expr)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txAtom "Returns a SourceNode or String" ^Any [a]
  (var s (str a))
  (cond (lambdaArg? a)
        (str LARGS "[" (-1 (int (rest s))) "]")
        (regexObj? a)
        (node' a (tnodeEx s (rest s)))
        (keyword? a)
        (node' a (tnodeEx s (quote-str s)))
        (symbol? a)
        (node' a (tnodeEx s (unmangle s)))
        (nil? a)
        "null"
        (primitive? a)
        (do (set! a a.value s $(a))
            (cond (string? a)
                  (quote-str a)
                  (nil? a) "null" :else s))
        (string? a)
        (quote-str a)
        :else (reader/jsid s)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- tx* "" ^Any [x & [env]]
  (if (array? x) (txPairs x env) (txAtom x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- gcmd "" ^String [ast]
  (cond (map? ast) "hash-map"
        (obj? ast) "object"
        (vector? ast) "vec"
        (set? ast) "hash-set"
        (list? ast) "list"
        (and (array? ast)
             (not (array? (1st ast)))) $(1st ast) :else ""))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quoteSingle "" ^String [a]
  (cond (keyword? a)
        (str (stripStd (str KBSTDLR ".keyword"))
             "(\"" a.value "\")")
        (symbol? a)
        (str (stripStd (str KBSTDLR ".symbol"))
             "(\"" a.value "\")")
        (primitive? a)
        (do (set! a a.value)
            (cond (string? a) (quote-str a)
                  (nil? a) "null"
                  :else $(a)))
        (string? a)
        (quote-str a)
        :else $(a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quote! "" ^SourceNode [ast env]
  (assertInfo ast)
  (if (array? ast)
    (if (map? ast)
      (quoteMap ast env)
      (quoteBlock ast env))
    (quoteSingle ast)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quoteMap "" ^SourceNode [ast env]
  (var cma ""
       ret (node' ast))
  (for [i 0 sz (n# ast)
        :while (< i sz) :recur (+2 i)]
    (if (> i 0) (ret.add ","))
    (ret.add [(quote! (.@i ast) env)
              " , " (quote! (.@+i ast) env)]))
  (if-not (empty? ast) (set! cma ","))
  (wrap ret ["["
             (stripStd (str KBSTDLR ".symbol")) "(\"hash-map\")" cma] "]"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quoteBlock "" ^SourceNode [ast env]
  (var ret (node' ast))
  (for [i 0 sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (if (> i 0) (ret.add ","))
    (ret.add (quote! (.@i ast) env)))
  (wrap ret "[" "]"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- spreadInfo "" ^Any [from to]
  (if (and from
           (not (simple? from))
           (number? from.line)
           (array? to))
    (do (xfi from to)
        (for [i 0 sz (n# to)
              :while (< i sz) :recur (+1 i)]
          (spreadInfo from (.@i to))))
    (xfi from to)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txPairs "" ^SourceNode [ast env]
  (var nsp (std/peekNSP)
       stmtQ (stmt? ast)
       ret (node' ast)
       cmd (gcmd ast)
       e1 (1st ast)
       orig ast
       op nil tmp nil
       mc (rt/getMacro cmd))
  (xfi e1 ret)
  (xfi e1 ast)
  ;;handle macro calls
  (when mc
    (set! ast (rt/expand?? ast env mc)
          ast (xfi orig (exprHint ast (not stmtQ))))
    (spreadInfo orig ast)
    (set! cmd (gcmd ast)))
  ;;handle (+1 ) or (-1 ) cases
  (when (reader/REGEX.int.test cmd)
    (if-not (or (starts-with? cmd "+")
                (starts-with? cmd "-"))
      (set! cmd (str "+" cmd)))
    (set! ast (xfi ast [(symbol (ch@ cmd 0))
                        (2nd ast)
                        (int (rest cmd))])
          cmd $(1st ast)))
  ;;maybe special form
  (set! op (get SPEC-OPS cmd))
  ;;handle all cases
  (cond
    (== cmd "with-meta")
    (ret.add (tx* (2nd (meta?? ast env)) env))
    (starts-with? cmd ".-")
    (ret.add [(tx* (2nd ast) env)
              "." (tx* (symbol (cmd.slice 2)) env)])
    (starts-with? cmd ".@")
    (do (set! tmp (if (starts-with? cmd ".@+") [3 #t] [2 #f]))
        (ret.add [(tx* (2nd ast) env)
                  "[" (cmd.slice (1st tmp)) (if (2nd tmp) "+1]" "]")]))
    (starts-with? cmd ".")
    (do (ret.add [(tx* (2nd ast) env)
                  (tx* (symbol cmd) env) "("])
        (for [n 2 sz (n# ast)
              :while (< n sz) :recur (+1 n)]
          (if (not= n 2) (ret.add ","))
          (ret.add (tx* (.@n ast) env)))
        (ret.add ")"))
    (some? op)
    (set! ret (op ast env))
    (and (or (== cmd "splice-unquote")
             (== cmd "unquote")
             (== cmd "syntax-quote"))
         (not (starts-with? (get nsp :id) KBPFX)))
    (error! :outside-macro ast)
    :else
    (do (if (pairs? ast)
          (do (txForm ast env)
              (set! cmd $(1st ast)))
          (set! cmd (tx* ast env)))
        (if-not cmd (error! :empty-form ast))
        (set! cmd (stripStd cmd))
        (if (pairs? ast)
          (ret.add
            [(if (testre? reader/REGEX.func cmd) (str "(" cmd ")") cmd)
             "(" (join "," (rest ast)) ")"])
          (ret.add cmd))))
  (node' ast ret))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- writeDoc "Convert to jsdoc" ^Array [doc]
  (var out [])
  (if doc
    (->> (.split (unquote-str doc) "\n")
         (each #(let [s (.trim (str %))]
                  (if (not-empty s)
                    (conj! out (str "//" s "\n"))))))) out)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txDo "" ^SourceNode [ast env & [return?]]
  (var stmtQ (stmt? ast)
       ret (node' ast)
       e nil end (last-index ast))
  (set! return?
        (if stmtQ #f (opt?? return? #t)))
  (for [i 0 :while (< i end) :recur (+1 i)]
    (set! e (exprHint (.@i ast) #f))
    (ret.add [(tx* e env) ";\n"]))
  (when (>= end 0)
    (set! e (exprHint (.@end ast)
                      (not stmtQ))
          e (tx* e env))
    (ret.add (if-not return?
               [e ";\n"]
               ["return " e ";\n"]))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- meta?? "" ^Array [obj env]
  (var mobj nil)
  (when (and (array? obj)
             (= 3 (n# obj))
             (symbol? (1st obj))
             (== "with-meta" $(1st obj)))
    (set! mobj (evalMeta (.@2 obj) env))
    (assign! (2nd obj) :____meta mobj)
    (set! obj (2nd obj)))
  [mobj obj])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fmtRegoSpecOps "" ^String [alias fname]
  (str (reader/jsid :SPEC-OPS) "[\"" alias "\"] = " fname))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fmtSpecOps "" ^String [fname attrs]
  (var ks (or (get attrs :opcode) [])
       out (->> (map #(fmtRegoSpecOps
                        (str %) fname) ks) (join ";\n")))
  (if (not-empty ks) (str out ";\n") out))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- writeFuncPre "" [pre env]
  (var ret (node' pre)
       c2 ['if-not (concat ['and] pre)
           ['throw ['Error "Precondition failed"]]])
  (ret.add [(-> (exprHint c2 #f) (tx* env)) ";\n"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- writeFuncInfo "" ^String [fname ast]
  (var file (if ast.source
              (ast.source.slice
                (+1 (ast.source.lastIndexOf "/"))) "?")
       s (str "//fn: [" fname "] in file: "
              file ", line: " (or ast.line "?") "\n")
       len (alen s))
  (if (< len 80) (set! len 80))
  (str (.repeat "/" len) "\n" s))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- evalMeta "" ^Object [ast env]
  (var x
       (cond (array? ast)
             ast
             (keyword? ast)
             (into! :map [ast #t])
             (symbol? ast)
             (into! :map [(keyword ":tag") ast])
             :else
             (error! :invalid-meta ast))
       v (rt/compute x env))
  ;(console.log (str "meta-obj=" (JSON/stringify v)))
  v)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- stripStd "" ^String [cmd]
  (var lib (str KBSTDLR ".")
       nsp (std/peekNSP))
  (set! cmd $(cmd))
  (if (and (starts-with? cmd lib)
           (== (get nsp :id) KBSTDLIB)) (.slice cmd (alen lib)) cmd))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- assertArity "" ^Any [kond ast]
  (if-not kond (error! :invalid-arity ast))
  (assertInfo ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- assertInfo "" ^Any [ast]
  (if (and false
           ast
           (not (simple? ast))
           (not (number? ast.line)))
    (error! :no-sourcemap-info ast)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- loadRLib
  "Load in all the exported macros from the external lib" ^String [info env]
  (var {:keys [ns macros]} info)
  (var~ ast s)
  ;(println "loadlib has " (n# macros) " macros")
  (each-key (fn [v k]
              (set! ast (rt/readAST v)
                    s (symbol (str ns "/" $(2nd ast))))
              (aset ast 1 s)
              (rt/compute ast env)) macros) ns)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;special-forms
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn sf-juxt

  "Takes a set of functions and returns a fn that is the juxtaposition
of those fns.  The returned fn takes a variable number of args, and
returns a vector containing the result of applying each fn to the
args (left-to-right).
((juxt a b c) x) => [(a x) (b x) (c x)]"

  ^{:opcode ["juxt"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 2) ast)
  (var ret (node' ast))
  (ret.add ["function () {\n"
            "let ret=[]," LARGS "=" ARRSLICE "(" JSARGS ");\n"])
  (for [i 1 f nil sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (set! f $(gensym "F__"))
    (ret.add ["let " f "=" (tx* (.@i ast) env) ";\n"
              "ret.push(" f ".apply(this," LARGS "));\n"]))
  (ret.add "return ret;\n}"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-deref

  "Returns an atom's current state."

  ^{:opcode ["deref"] :tag SourceNode} [ast env]

  (assertArity (= (n# ast) 2) ast)
  (var ret (node' ast))
  (ret.add [(tx* (2nd ast) env) ".value"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-compose

  "Takes a set of functions and returns a fn that is the composition
of those fns.  The returned fn takes a variable number of args,
applies the rightmost of fns to the args, the next
fn (right-to-left) to the result, etc."

  ^{:opcode ["comp"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 2) ast)
  (var ret (node' ast)
       end (last-index ast))
  (var~ f r prev)
  (ret.add ["function () {\n"])
  (ret.add ["let " LARGS "=" ARRSLICE "(" JSARGS ");\n"])
  ;go backwards -> right to left
  ;keep track of prev result so that we can thread it
  ;to next function
  (for [i end :while (> i 0) :recur (-1 i)]
    (set! f $(gensym "F__") r $(gensym "R__"))
    (ret.add ["let " f "=" (tx* (.@i ast) env) ";\n"])
    (if (= i end)
      (ret.add ["let " r "=" f ".apply(this," LARGS ");\n"])
      (ret.add ["let " r "=" f "(" prev ");\n"]))
    (set! prev r))
  (ret.add ["return " prev ";\n" "}"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-quote
  "Returns the unevaluated form"
  ^{:opcode ["quote"] :tag SourceNode} [ast env]
  (assertArity (= (n# ast) 2) ast)
  (var ret (node' ast))
  (wrap ret nil (quote! (2nd ast) env)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-deftype
  "Define a JS Class"
  ^{:opcode ["deftype" "deftype-"] :tag SourceNode}
  [ast env]
  (assertArity (>= (n# ast) 3) ast)
  (var~ mtd pos n m cn)
  (var ret (node' ast))
  (var pub? (not (ends-with? $(1st ast) "-"))
       czname0 (2nd ast)
       czname (tx* czname0 env)
       par (1st (.@2 ast))
       ;maybe a docstring is there?
       [doc mtds] (if (str? (.@3 ast))
                    [(.@3 ast) (slice ast 4)]
                    [nil (slice ast 3)]))
  ;put var into genv
  (.addVar env
           czname0
           {:ns (std/*ns*) :alias czname0 :type :class})
  (ret.add ["class " czname])
  (if par (ret.add [" extends " (tx* par env)]))
  (ret.add " {\n")
  (doseq [m mtds]
    ;;maybe doc string?
    (set! mtd 'method
          m1 (1st m)
          cn (str czname0 "." m1)
          pos (if (str? (2nd m)) 3 2))
    ;;pass line info
    (each #(xfi m1 %) [mtd m])
    ;fake a keyword 'method' in front
    (m.unshift mtd)
    ;put scoped-method into env
    (.addVar env
             cn
             {:ns (std/*ns*) :alias cn :type :method})
    ;compiles it like a function
    (ret.add [(sf-func m env #f) "\n"]))
  ;stick doco in front, if any
  (if doc (ret.prepend (writeDoc doc)))
  ;maybe export this type?
  (if pub? (assoc! *externs* czname czname))
  (ret.add "}\n"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-compOp "Handle comparison operators."

  ^{:opcode ["not=" "!="
             "==" "="
             ">" ">=" "<" "<="]
    :tag SourceNode} [ast env]

  (assertArity (and (>= (n# ast) 3)
                    (odd? (n# ast))) ast)

  (var ret (node' ast)
       end 0
       a0 (1st ast) cmd $(a0))
  (cond (== cmd "not=") (aset ast 0 '!==)
        (== cmd "=") (aset ast 0 '===))
  (set! a0 (1st ast)
        end (last-index ast))
  (for [i 1 op (str a0)
        :while (< i end) :recur (+1 i)]
    (if (not= i 1) (ret.add " && "))
    (ret.add [(tx* (.@i ast) env)
              " " op " " (tx* (.@+i ast) env)]))
  (wrap ret "(" ")"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-arithOp
  "Handles math operators"
  ^{:opcode ["bit-shift-left" "bit-shift-right" "unsigned-bit-shift-right"
             "+" "-" "*" "/" "div" "mod"
             "or" "and" "exp" "rem"
             "bit-and" "bit-or" "bit-not" "bit-xor"]
    :tag SourceNode}
  [ast env]

  (assertArity (>= (n# ast) 2) ast)
  (var ret (node' ast)
       e1 $(1st ast)
       cmd (case e1
             "unsigned-bit-shift-right" ">>>"
             "bit-shift-right" ">>"
             "bit-shift-left" "<<"
             "bit-and" "&"
             "bit-or" "|"
             "bit-not" "~"
             "bit-xor" "^"
             "rem" "%"
             "div" "/"
             "and" "&&"
             "or" "||"
             "exp" "**"
             e1))
  (cond
    (== "mod" cmd)
    (ret.add [KBSTDLR ".modulo("
              (tx* (.@1 ast) env) "," (tx* (.@2 ast) env) ")"])
    (== "~" cmd)
    (ret.add ["~" (tx* (.@1 ast) env)])
    :else
    (do ;handle negative number e.g. (- -2)= -1*-2
        (if (and (== "-" cmd)
                 (= 2 (n# ast))) (ret.add "-1 * "))
        (for [i 1 sz (n# ast)
              :while (< i sz) :recur (+1 i)]
          (when (> sz 2)
            (if (> i 1) (ret.add [" " cmd " "])))
          (ret.add (tx* (.@i ast) env)))))
  (wrap ret "(" ")"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-do

  "Evaluates the expressions in order and returns the value of the last. If no
expressions are supplied, returns nil."

  ^{:opcode ["do"] :tag SourceNode} [ast env]

  (assertArity true ast)
  (var ret (node' ast)
       stmtQ (stmt? ast))
  (ret.add (txDo (exprHint (xfi ast (rest ast))
                           (not stmtQ)) env (not stmtQ)))
  (if stmtQ
    (wrap ret nil "")
    (wrap ret
          "(function() {\n" "}).call(this)")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-case

  "Takes an expression, and a set of clauses.
 Each clause can take the form of either:
 test-constant result-expr
 (test-constant1 ... test-constantN)  result-expr
 The test-constants are not evaluated. They must be compile-time
literals, and need not be quoted.  If the expression is equal to a
test-constant, the corresponding result-expr is returned. A single
default expression can follow the clauses, and its value will be
returned if no clause matches."

  ^{:opcode ["case"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 4) ast)
  (var stmtQ (stmt? ast)
       ret (node' ast)
       tst (2nd ast)
       brk ";\nbreak;\n"
       gs $(gensym "C__"))
  (var~ e t c dft)
  ;look for any default clause
  (if (odd? (n# ast))
    (set! dft (1st (pop! ast))))
  (for [i 2 sz (n# ast)
        :while (< i sz) :recur (+2 i)]
    (set! e (.@i ast)
          c (.@+i ast)
          c (tx* c env))
    (if (pairs? e)
      (for [j 0 sz (n# e)
            :while (< j sz) :recur (+1 j)]
        (ret.add ["case " (tx* (.@j e) env) ":\n"])
        (if (= j (last-index e))
          (ret.add [gs "=" c brk])))
      (ret.add ["case " (tx* e env) ":\n" gs "=" c brk])))
  ;maybe add the default clause
  (if dft
    (ret.add ["default:\n"
              gs "=" (tx* dft env) brk]))
  ;wrap the switch construct around it
  (wrap ret ["switch (" (tx* tst env) ") {\n"] "}")
  (if stmtQ
    (wrap ret ["let " gs ";\n"] "")
    (wrap ret
          ["(function() { let " gs ";\n"]
          ["return " gs ";}).call(this)"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-vardefs
  "For JS style var defs with no rvalue, e.g. let x,y;"
  ^{:opcode ["def~-" "def~" "var~"]
    :tag SourceNode} [ast env]
  (assertArity (>= (n# ast) 2) ast)
  (var ret (node' ast)
       cmd $(1st ast)
       keys {}
       pub? (== cmd "def~"))
  (if (starts-with? cmd "def")
    (set! cmd "var") (set! cmd "let"))
  (for [i 1 x nil s nil sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (set! x (.@i ast)
          s (tx* x env))
    (if-not (== "let" cmd)
      (.addVar env
               $(x)
               {:ns (std/*ns*) :alias $(x) :type :var}))
    (assoc! keys s s)
    (if (> i 1) (ret.add ","))
    (ret.add s))
  ;;exports
  (if pub? (each-key #(assoc! *externs* %2 %1) keys))
  (wrap ret (str cmd " ") ";\n"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-var

  "Creates a variable with an initial value"

  ^{:opcode ["const-" "const" "def-" "def" "var" "local-vars"]
    :tag SourceNode} [ast env]

  (assertArity (odd? (n# ast)) ast)
  (var ret (node' ast)
       cmd $(1st ast)
       keys {}
       tmp nil vname nil
       pub? (or (== cmd "def")
                (== cmd "const")))
  (var~ rval rc lhs rhs)
  (set! cmd (if (starts-with? cmd "const")
              "const"
              (if (== cmd "var") "let" "var")))
  ;deal with 1 level destruction
  (for [i 1 x nil sz (n# ast)
        :while (< i sz) :recur (+2 i)]
    (set! lhs (.@i ast)
          rhs (.@+i ast)
          rval (tx* rhs env))
    (if (symbol? lhs)
      (do (set! x lhs
                lhs (tx* lhs env))
          (if-not (== "let" cmd)
            (.addVar env
                     $(x)
                     {:ns (std/*ns*) :alias $(x) :type :var}))
          (assoc! keys lhs lhs)
          (ret.add [cmd " " lhs "=" rval ";\n"]))
      (do (set! out (node' ast)
                rhs (destruct* lhs out env))
          (ret.add ["let " (tx* rhs env) "=" rval ";\n" out]))))
  (if pub?
    (each-key #(assoc! *externs* %2 %1) keys)) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-inst?

  "Evaluates x and tests if it is an instance of the class
  c. Returns true or false.
  (inst? c x)"

  ^{:opcode ["inst?"] :tag SourceNode} [ast env]

  (assertArity (= (n# ast) 3) ast)
  (wrap (node' ast) nil ["(" (tx* (3rd ast) env)
                         " instanceof " (tx* (2nd ast) env) ")"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-delete

  "Delete an object or property of an object."

  ^{:opcode ["delete!"] :tag SourceNode} [ast env]

  (assertArity (and (>= (n# ast) 2)
                    (< (n# ast) 4)) ast)
  (var ret (node' ast))
  (ret.add ["delete "
            (tx* (2nd ast) env)])
  (if (> (n# ast) 2)
    (ret.add ["[" (tx* (.@2 ast) env) "]"])) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-dissoc!

  "Remove a key from Map."

  ^{:opcode ["dissoc!"] :tag SourceNode} [ast env]

  (assertArity (= (n# ast) 3) ast)
  (var ret (node' ast))
  (ret.add
    [(stripStd (str KBSTDLR
                    "." (tx* (symbol "dissoc!") env)))
     "("
     (tx* (2nd ast) env)
     "," (tx* (.@2 ast) env) ")"]) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-new

  "The args, if any, are evaluated from left to right,
  and passed to the constructor of the class
  named by Classname. The constructed object is returned.
  e.g.
  (new Error 'a' 3)"

  ^{:opcode ["new"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 2) ast)
  (wrap (node' ast) "new " (tx* (xfi ast (rest ast)) env)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-throw

  "Throw an exception"

  ^{:opcode ["throw"] :tag SourceNode} [ast env]

  (assertArity (= (n# ast) 2) ast)
  (var ret (node' ast)
       stmtQ (stmt? ast))
  (ret.add ["throw " (tx* (xfi ast (2nd ast)) env)])
  (if-not stmtQ
    (wrap ret
          "(function (){ "
          ";}).call(this)")) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-x-opop

  "Unary operator for increment & decrement"
  ^{:opcode ["++" "--" "++$" "--$"] :tag SourceNode} [ast env]

  (assertArity (= (n# ast) 2) ast)
  (var ret (node' ast)
       cmd $(1st ast)
       a2 (tx* (2nd ast) env))
  (ret.add
    (if (ends-with? cmd "$")
      [a2 (cmd.slice 0 -1)] [cmd a2])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-x-eq

  "Compound assignment operators"

  ^{:opcode ["+=" "-=" "*=" "/="
             "div=" "rem=" "exp="
             "bit-and="
             "bit-or="
             "bit-xor="
             "bit-shift-left="
             "bit-shift-right="
             "unsigned-bit-shift-right="]
       :tag SourceNode} [ast env]

  (assertArity (= (n# ast) 3) ast)
  (var a0 $(1st ast)
       cmd (case a0
             "unsigned-bit-shift-right=" ">>>="
             "bit-shift-right=" ">>="
             "bit-shift-left=" "<<="
             "bit-xor=" "^="
             "bit-or=" "|="
             "bit-and=" "&="
             "div=" "/="
             "rem=" "%="
             "exp=" "**=" a0))
  (wrap (node' ast)
        "("
        [(tx* (2nd ast) env)
         " " cmd " " (tx* (3rd ast) env) ")"] ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-assoc!
  "Object property assignment or array index setter."
  ^{:opcode ["assoc!"] :tag SourceNode} [ast env]
  (assertArity (even? (n# ast)) ast)
  (var ret (node' ast)
       obj (tx* (2nd ast) env))
  (for [i 2 sz (n# ast)
        :while (< i sz) :recur (+2 i)]
    (if (> i 2) (ret.add ","))
    (ret.add
      [(stripStd (str KBSTDLR "." (tx* (symbol "assoc!") env)))
       "(" obj ","
       (tx* (xfi ast (.@i ast)) env) ","
       (tx* (xfi ast (.@+i ast)) env) ")"]))
  (wrap ret "(" ")"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-assign!
  "Object property assignment or array index setter."
  ^{:opcode ["oset!" "assign!" "aset"] :tag SourceNode} [ast env]
  (assertArity (even? (n# ast)) ast)
  (var ret (node' ast)
       obj (tx* (2nd ast) env))
  (for [i 2 sz (n# ast)
        :while (< i sz) :recur (+2 i)]
    (if (> i 2) (ret.add ","))
    (ret.add [obj
              "[" (tx* (xfi ast (.@i ast)) env) "]"
              "=" (tx* (xfi ast (.@+i ast)) env)]))
  (wrap ret "(" ")"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-set

  "Set value(s) to variable(s).
  e.g. (set! a 2 b 4 ...)"

  ^{:opcode ["set!" "var-set"] :tag SourceNode} [ast env]

  (assertArity (odd? (n# ast)) ast)
  (var ret (node' ast))
  (for [i 1 sz (n# ast)
        :while (< i sz) :recur (+2 i)]
    (if (> i 1) (ret.add ","))
    (ret.add [(tx* (.@i ast) env)
              "=" (tx* (xfi ast (.@+i ast)) env)]))
  (wrap ret "(" ")"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-fn

  "Defines an anonymous function. See defn.
  (fn attrs? [x y] ...)"

  ^{:opcode ["fn"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 2) ast)
  (var body (xfi ast (slice ast 2))
       [_ args] (meta?? (2nd ast) env))
  (if-not (array? args)
    (error! :invalid-fargs ast))
  (var fargs (doFuncArgs (xfi ast args) env))
  (wrap (node' ast)
        nil
        ["function (" (1st fargs) ") {\n"
         (2nd fargs) (txDo body env #t) "}"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-func

  "Defines a function. Use defn- to indicate privacy (no export).
  (defn name doc-string? attr-map? [params*] ...)"

  ^{:opcode ["defn" "defn-"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 2) ast)
  (var pub? (not (ends-with? $(1st ast) "-"))
       mtd? (== $(1st ast) "method")
       fname0 $(2nd ast)
       fname $(tx* (2nd ast) env)
       dot? (contains? fname ".")
       ret (node' ast (tnodeEx fname))
       [doc pargs] (if (str? (3rd ast))
                     [(nth ast 2) 3] [nil 2])
       body (xfi ast (slice ast (+1 pargs)))
       b1 (1st body)
       [attrs args] (meta?? (nth ast pargs) env))
  (if-not mtd?
    (.addVar env
             fname0
             {:ns (std/*ns*) :alias fname0 :type :fn}))
  (if-not (array? args)
    (error! :invalid-fargs ast))
  (var fargs (doFuncArgs (xfi ast args) env))
  (var~ pre post)
  (set! attrs (or attrs {}))
  (when (map? b1)
    (for [i 0 e nil e2 nil sz (n# b1)
          :while (< i sz) :recur (+2 i)]
      (set! e (.@i b1) e2 (.@+i b1))
      (when (and (keyword? e)
                 (array? e2))
        (cond (== e :post) (set! post e2)
              (== e :pre) (set! pre e2)))))
  (cond mtd?
        (do (if (.-static attrs)
              (ret.add "static "))
            (ret.add [fname " ("])
            (if (== fname "constructor")
              (conj! body 'this)))
        dot?
        (ret.add [fname " = function ("])
        :else
        (ret.add ["const " fname " = function ("]))
  (ret.add [(1st fargs) ") {\n" (2nd fargs)])
  (when (or pre post)
    (set! body (rest body))
    (ret.add (writeFuncPre (xfi ast pre) env)))
  (ret.add [(txDo body env #t) "};\n"])
  (if (not-empty attrs)
    (ret.add (fmtSpecOps fname attrs)))
  (if doc
    (ret.prepend (writeDoc doc)))
  (if (and pub?
           (not dot?)
           (not mtd?))
    (assoc! *externs* fname fname))
  (ret.prepend (writeFuncInfo fname0 ast)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-try

  "The exprs are evaluated and, if no exceptions occur, the value of the last
is returned. If an exception occurs and catch clauses are provided, each is
examined in turn and the first for which the thrown exception is an instance
of the named class is considered a matching catch clause. If there is a
matching catch clause, its exprs are evaluated in a context in which name is
bound to the thrown exception, and the value of the last is the return value
of the function. If there is no matching catch clause, the exception
propagates out of the function. Before returning, normally or abnormally,
any finally exprs will be evaluated for their side effects."

  ^{:opcode ["try"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 2) ast)
  (var stmtQ (stmt? ast)
       sz (n# ast)
       ret (node' ast))
  (var~ t f c)
  ;;look for finally
  (set! f (last ast))
  (if (and (array? f)
           (== $(1st f) :finally))
    (do (pop! ast)
        (set! sz (n# ast))
        (xfi (1st f) f))
    (nil! f))
  ;;look for catch
  (nil! c)
  (if (> sz 1)
    (set! c (nth ast (-1 sz))))
  (if (and (array? c)
           (== $(1st c) :catch))
    (do (if (or (< (n# c) 2)
                (not (symbol? (2nd c))))
          (error! :invalid-catch ast))
        (pop! ast)
        (xfi (1st c) c))
    (nil! c))
  ;;try needs either a catch or finally or both
  (if (and (nil? f)
           (nil? c)) (error! :invalid-try ast))
  (ret.add ["try {\n"
            (txDo (exprHint (xfi ast (rest ast))
                            (not stmtQ)) env) "\n}"])
  (when c
    (set! t (2nd c))
    (ret.add [(str "catch (" (tx* t env) ") {\n")
              (txDo (exprHint (xfi c (slice c 2))
                              (not stmtQ)) env) ";\n}\n"]))
  (when f
    (ret.add ["finally {\n",
              (txDo (exprHint (xfi f (rest f)) #f) env #f) ";\n}\n"]))
  (if-not stmtQ
    (wrap ret "(function(){\n" "}).call(this)")) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-if

  "Evaluates test. If truthy evaluates 'then' otherwise 'else'.

  (if test then else)
  (if test then)"

  ^{:opcode ["if"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 3) ast)
  (var stmtQ (stmt? ast)
       ret (node' ast)
       ;test is always an expression
       a1 (exprHint (xfi ast (2nd ast)) #t)
       a2 (exprHint (xfi ast (3rd ast)) (not stmtQ))
       m? (> (n# ast) 3)
       a3 (if m? (xfi ast (.@3 ast)))
       elze (if m? (exprHint a3 (not stmtQ))))
  (set! a1 (tx* a1 env)
        a2 (tx* a2 env)
        elze (tx* elze env))
  (wrap ret
        nil
        (if stmtQ
          ["if (" a1 ") {\n" a2 ";\n}"
           (if m? [" else { \n" elze ";\n}"] "")]
          ["(" a1 " ?\n" a2 " :\n" (or elze "null") ")"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-get

  "Returns the named property of an object,
  or value at the index of an array.

  (get obj \"age\")
  (aget obj 4)
  (nth obj 3)"

  ^{:opcode ["oget" "nth" "get" "aget"] :tag SourceNode} [ast env]

  (assertArity (= (n# ast) 3) ast)
  (var a0 $(_1 ast)
       cmd (stripStd (str KBSTDLR ".getProp")))
  (if (== a0 "get")
    (wrap (node' ast)
          nil [cmd "("
               (tx* (xfi ast (2nd ast)) env)
               "," (tx* (xfi ast (3rd ast)) env) ")"])
    (wrap (node' ast)
          nil [(tx* (xfi ast (2nd ast)) env)
               "[" (tx* (xfi ast (3rd ast)) env) "]"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-array

  "Creates a new vector containing the args.

  (vec \"hello\" \"world\")
  (vec 1 2 3)
  [1 2 3]
  [\"hello\" \"world\"]"

  ^{:opcode ["vec"] :tag SourceNode} [ast env]

  (assertArity true ast)
  (var pos 0
       ret (node' ast))
  (if (empty? ast)
    (ret.add "[]")
    (do (if-not (vector? ast) (set! pos 1))
        (ret.add "[ ")
        (for [i pos sz (n# ast)
              :while (< i sz) :recur (+1 i)]
          (if (> i pos) (ret.add ", "))
          (ret.add (tx* (xfi ast (.@i ast)) env)))
        (ret.add " ]"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-objObj
  "Returns a new object with supplied key-mappings.
  (object \"a\" 1 \"b\" 2)
  {:a 1 :b 2}"
  ^{:opcode ["object"] :tag SourceNode} [ast env]
  (assertArity true ast)
  (var pos 0
       ret (node' ast))
  (if-not (obj? ast) (set! pos 1))
  (for [i pos sz (n# ast)
        :while (< i sz) :recur (+2 i)]
    (if (> i pos) (ret.add ", "))
    (ret.add [(tx* (.@i ast) env)
              ": " (tx* (xfi ast (.@+i ast)) env)]))
  (wrap ret "{" "}"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-mapObj
  ""
  ^{:opcode ["hash-map"] :tag SourceNode} [ast env]
  (assertArity true ast)
  (var pos 0
       ret (node' ast))
  (if-not (map? ast) (set! pos 1))
  (for [i pos sz (n# ast)
        :while (< i sz) :recur (+2 i)]
    (if (> i pos) (ret.add ","))
    (ret.add ["[" (tx* (.@i ast) env)
              "," (tx* (xfi ast (.@+i ast)) env) "]"]))
  (wrap ret "(new Map([" "]))"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-setObj

  "Returns a new Set.
  (set 1 2 3)"

  ^{:opcode ["hash-set"] :tag SourceNode} [ast env]

  (assertArity true ast)
  (var pos 0
       ret (node' ast))
  (if-not (set? ast)(set! pos 1))
  (for [i pos sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (if (> i pos) (ret.add ", "))
    (ret.add (tx* (.@i ast) env)))
  (wrap ret "(new Set([" "]))"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- require! "" [path]
  ;(println "require path = " path)
  (require path))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-require

  "Loads libs.

  (:require [\"z\" :rename {hello goodbye}])
  (:require [\"a\" :as A])
  (:require [\"b\"]
            [\"c\" :refer [hello world]])"

  ^SourceNode [ast env]

  (assertArity (>= (n# ast) 2) ast)
  (var~ rlib as rpath v mcs nsp macros_only
        info libpath e refers renames)
  (var ret (node' ast)
       fdir (path/dirname ast.source))
  (for [i 1 sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i ast)
          as $(gensym "R__")
          macros_only #f
          refers nil renames nil)
    (if-not (and (array? e)
                 (string? (1st e))) (error! :invalid-require ast))
    (set! rpath $(1st e))
    (for [j 1 sz (n# e)
          :while (< j sz) :recur (+1 j)]
      (set! v (.@j e))
      (cond (== v :as)
            (do (set! as $(.@+j e))
                (++ j))
            (== v :only)
            (do (if (== $(.@+j e) :macros)
                  (true! macros_only))
                (++ j))
            (== v :refer)
            (do (set! refers (.@+j e))
                (++ j))
            (== v :rename)
            (do (set! renames (.@+j e))
                (++ j))))
    (if (.includes rpath "./")
      (set! libpath (path/resolve fdir rpath))
      (set! libpath rpath))
    (set! libpath (tx* libpath env))
    (if-not macros_only
      (ret.add ["const " (reader/jsid as)
                "= require(" (tx* rpath env) ");\n"]))
    ;load the lib
    (set! rlib (require! (unquote-str libpath))
          info (get rlib EXPKEY))
    (if info
      (set! mcs (get info :macros)
            nsp (loadRLib info env)))
    (.addLib env $(as) rlib)
    (set! mcs (or mcs {}))
    (for [i 0 t nil r nil rs nil
          f nil m nil sz (n# refers)
          :while (< i sz) :recur (+1 i)]
      (set! r (.@i refers)
            rs $(r)
            v (tx* r env)
            f (get rlib (reader/jsid rs))
            m (get mcs rs))
      (if f (set! t (typeid f)))
      (if m (set! t :marco))
      (if-not (or f m) (raise! "Unknown var " rs))
      (.addVar env
               rs
               {:ns nsp :alias rs :type t})
      (ret.add ["const " v "=" as "[\"" v "\"];\n"]))
    (for [i 0 t nil r nil rs nil
          ro nil f nil m nil sz (n# renames)
          :while (< i sz) :recur (+2 i)]
      (set! ro (.@i renames)
            e (tx* ro env)
            r (.@+i renames)
            rs $(r)
            v (tx* r env)
            f (get rlib (reader/jsid $(ro)))
            m (get mcs $(ro)))
      (if f (set! t (typeid f)))
      (if m (set! t :marco))
      (if-not (or f m) (raise! "Unknown var " ro))
      (.addVar env
               rs
               {:ns nsp :alias $(ro) :type t})
      (ret.add ["const " v
                "=" as "[\"" e "\"];\n"]))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-ns

  "(ns name doc-string? attr-map? references*)

  Creates a namespace, references can be zero or more of:
  (:require ...)

  (ns ^{:doc \"some doc\"} hello.world.core ...)"

  ^{:opcode ["ns"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 2) ast)
  (var ret [] doc nil e nil
       mobj nil pos 2
       [attrs nsp] (meta?? (2nd ast) env))
  (if-not (symbol? nsp)
    (error! :invalid-namespace ast))
  (when (string? (.@pos ast))
    (set! attrs (or attrs {}))
    (assoc! attrs :doc (.@pos ast)) (++ pos))
  (when (map? (.@pos ast))
    (set! mobj (evalMeta (.@pos ast) env)
          attrs (merge attrs mobj))
    (++ pos)
    (assign! nsp :____meta attrs))
  (std/pushNSP $(nsp) attrs)
  ;;(println (str "Processing namespace: " $(nsp)))
  (set! ast (xfi ast (slice ast pos)))
  (for [i 0 sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i ast))
    (when (pairs? e)
      (cond
        (== $(1st e) :require)
        (conj! ret (sf-require (xfi ast e) env)))))
  ;;force a internal reference to stdlib for user files
  ;;unless processing internal files
  (set! nsp (std/*ns*))
  (cond
    (= nsp (str KBPFX "stdlib"))
    nil
    (starts-with? nsp KBPFX)
    (conj! ret
           (str "const " KBSTDLR "=std;\n"))
    :else
    (->> (-> (xfi ast '(require ["kirby" :as kirbystdlibref]))
             (sf-require env))
         (conj! ret )))
  (conj! ret
         (str "const "
              std/MODULE_NAMESPACE
              "= " (std/quote-str nsp) ";\n")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-comment "" ^{:opcode ["comment"] :tag String} [ast env] "")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-for

  "Generates native (js) for loop.

  (for [initial-vars :while test :recur update-vars] ...)"

  ^{:opcode ["for"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 2) ast)
  (var stmtQ (stmt? ast)
       ret (node' ast)
       body (exprHint (xfi ast (slice ast 2)) #f))
  (if (empty? body)
    ret
    (sf-floop ret
              (xfi ast (2nd ast))
              body env stmtQ)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-floop
  "For loop implementation"
  ^SourceNode [ret args body env stmtQ]

  (var vars [] recurs [])
  (var~ tst nb e)
  (for [i 0 sz (n# args)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i args))
    (cond (== e :while)
          (do (set! tst (.@+i args)) (++ i))
          (== e :recur)
          (do->break! (set! recurs (slice args (+1 i))))
          (symbol? e)
          (do (conj! vars e (.@+i args)) (++ i))))
  (ret.add "for (")
  (for [i 0 sz (n# vars)
        :while (< i sz) :recur (+2 i)]
    (if (= i 0) (ret.add "let "))
    (if (not= i 0) (ret.add ","))
    (ret.add [(tx* (.@i vars) env)
              "=" $(tx* (.@+i vars) env)]))
  (ret.add (if (empty? vars)
             (str "let " BREAK "=false;")
             (str "," BREAK "=false;")))
  (set! nb '(not ____break))
  (xfi ret nb)
  (if tst
    (set! tst ['and nb tst])
    (set! tst nb))
  (xfi ret tst)
  (ret.add [$(tx* tst env) "; "])
  (for [i 0 k 0 sz (n# recurs)
        :while (< i sz) :recur (+1 i)(+2 k)]
    (if (not= i 0) (ret.add ","))
    (ret.add [(tx* (.@k vars) env)
              "=" $(tx* (.@i recurs) env)]))
  (ret.add ["){\n" (txDo body env #f) "}\n"])
  (if-not stmtQ
    (wrap ret "(function() {\n"  "}).call(this)")) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-jscode

  "Inject raw native (js) code fragment.

  (raw# \"console.log('hi');\")"

  ^{:opcode ["raw#" "js#"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 2) ast)
  (var s $(2nd ast)
       name (reader/jsid "sf-jscode"))
  (->>
    (if (and (ends-with? s "\"")
             (starts-with? s "\""))
      (s.slice 1 -1) s) (tnodeEx name) (node' ast)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-macro

  "Like defn, but the resulting function name is declared as a
macro and will be used as a macro by the compiler when it is
called.

  (defmacro macro-name [args] ...)"

  ^{:opcode ["defmacro"] :tag String} [ast env]

  (assertArity (>= (n# ast) 4) ast)
  (var pms [] args (3rd ast) body (slice ast 3))
  (var~ mname mobj doc x e ev)
  (when (str? args)
    (set! doc args args (.@3 ast) body (slice ast 4)))
  (set! x (meta?? args env))
  (set! args (last x))
  (set! mobj (1st x))
  (for [i 0 sz (n# args)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i args) ev $(e))
    (cond (== ev "&")
          (if (array? (.@+i args))
            (do (set! e (.@+i args))
                (++ i)
                (for [j 0 sz (n# e)
                      :while (< j sz) :recur (+1 j)]
                  (set! x (.@j e))
                  (if-not (symbol? x)
                    (error! :syntax-error ast))
                  (conj! pms x)))
            (do (conj! pms e (.@+i args))
                (++ i)))
          (not (symbol? e))
          (error! :syntax-error ast)
          :else
          (conj! pms e)))
  ;ask engine to compile this macro and stores it
  (set! mname (2nd ast)
        ast ['macro* mname pms (1st body)])
  ;try to register it
  (.addVar env
           mname
           {:ns (std/*ns*) :alias nil :type :macro})
  ;if not private, need to export it
  (if-not (and mobj
               (true? (get mobj :private)))
    (assoc! *macros* mname (std/prn ast #t)))
  ;compile it
  (rt/compute ast env) "")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-unary

  "Special unary operators."

  ^{:opcode ["not" "!"] :tag SourceNode} [ast env]

  (assertArity (= (n# ast) 2) ast)
  (var [a0 a1] ast
       ret (node' ast))
  (if (== a0 "not") (set! a0 '!))
  (ret.add ["(" $(tx* a0 env) $(tx* a1 env) ")"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- getPrePost "" [obj]
  (var ret nil)
  (when (map? obj)
    (for [i 0 e nil e2 nil sz (n# obj)
          :while (< i sz) :recur (+2 i)]
      (set! e (.@i obj)
            e2 (.@+i obj))
      (if (and (keyword? e)
               (array? e2))
        (cond (== e :post)
              (set! ret (merge ret {:post e2}))
              (== e :pre)
              (set! ret (merge ret {:pre e2}))))))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- xfi "Transfer source map info" ^Any [from to]
  (cond
    (and from to)
    (let [tline (.-line to)
          fline (.-line from)]
      (if (and (not (number? tline))
               (number? fline))
        (assign! to
                 :source (.-source from)
                 :line (.-line from)
                 :column (.-column from))) to)
    :else to))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- spitMacros "" []
  (if (empty? *macros*)
    ""
    (-> (map (fn [[k v]]
             (str (quote-str (str k))
                  ":" (quote-str v))) (seq *macros*))
        (.join ",\n")
        (std/wrap-str  "const ____macros = {\n" "};\n"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- spitExterns "Write out export info" ^String []
  (var mc (if (empty? *macros*) "{}" "____macros")
       s2 ""
       s1 (str EXPKEY
               ": { ns: "
               (quote-str (std/*ns*))
               ", macros: " mc " }"))
  (when (not-empty *externs*)
    (set! s2
          (str ",\n"
               (join ",\n"
                     (map (fn [[k v]]
                            (str k ":" v)) (seq *externs*))))))
  (str "\n\nmodule.exports = {\n" s1 s2 "\n};\n"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- banner "Banner text for the target file" ^String []
  (var {:keys [id meta]} (std/peekNSP))
  (str "/*" "Auto generated by Kirby v" MOD-VER " - " (new Date) "\n"
       "  " id "\n"
       (if meta (std/prn meta #t) "") "\n"
       "*/\n\n"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- cleanCode "" ^String [code]
  (var tmp nil arr [])
  (doseq [s (.split code "\n")
          :let [tmp (s.trim)]]
    (if (and (not-empty tmp)
             (not= tmp ";")) (conj! arr s)))
  (join "\n" arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpile*

  "Compiles a source file, returning the translated source and
  possible error object."

  ^Array [source fname options]

  (var {:keys [source-map no-format verbose]} options
       ast (reader/parse source fname)
       env (rt/genv)
       ret (txTree ast env)
       fbase (path/basename fname ".ky")
       macros (spitMacros)
       extra (spitExterns)
       fopts {}
       err nil
       cstr
       (if source-map
         (let [fmap (str fbase ".js")
               smap (str fbase ".map")
               sout (ret.toStringWithSourceMap
                      (object :skipValidation #t :file fmap))]
           (fs/writeFileSync smap sout.map)
           (str sout.code
                macros
                extra
                "\n//# sourceMappingURL="
                (path/relative (path/dirname fname) smap)))
         (str ret macros extra)))
  (try
    (if-not no-format
      (set! cstr
            (esfmt/format cstr fopts)))
    (catch e (set! err e)))
  (set! cstr (cleanCode cstr))
  (var mcs (keys *macros*)
       lbs (keys (get env :libs))
       vas (keys (get env :vars)))
  ;(println (std/prn (get env :vars) #t))
  (when verbose
    (println "<macros>\n" (std/prn mcs #t))
    (println "<libs>\n" (std/prn lbs #t))
    (println "<vars>\n" (std/prn (difference vas mcs) #t)))
  (vec (if (empty? cstr) "" (str (banner) cstr)) err))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn transpile

  "Compile kirby file to target source"
  ^Array [code file & [options]]

  (set! *externs* {}
        *macros* {} *last-line* 0 *last-col* 0)
  (try
    (transpile* code file (opt?? options (object )))
    (catch e
      (println "Error near line: "
               *last-line* ", col: " *last-col* "\n" (str e)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn dbgAST
  "Dump AST to xml" ^String [source fname]
  (reader/dumpTree (reader/parse source fname) fname))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const version MOD-VER)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

