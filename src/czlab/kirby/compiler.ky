;; Copyright (c) 2013-2017, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns ^{:doc ""
      :author "Kenneth Leung"}
  czlab.kirby.compiler
  (require ["./stdlib"
            :as std
            :refer [lambda-arg? hashmap pairs?
                    contains? last typeid
                    prn primitive map? vector?
                    opt?? some? primitive?
                    not-empty conj! list?
                    gensym count pop! slice
                    symbol keyword symbol? keyword?]]
           ["./parser"
            :as parser
            :refer [tnode tnodeEx]]
           ["./engine" :as eng])
  (require ["fs" :as fs]
           ["path" :as path]
           ["esformatter" :as esfmt]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- ERRORS-MAP {
  :e0 "Syntax Error"
  :e1 "Empty statement"
  :e2 "Invalid characters in function name"
  :e3 "End of File encountered, unterminated string"
  :e4 "Closing square bracket, without an opening square bracket"
  :e5 "End of File encountered, unterminated array"
  :e6 "Closing curly brace, without an opening curly brace"
  :e7 "End of File encountered, unterminated javascript object '}'"
  :e8 "End of File encountered, unterminated parenthesis"
  :e9 "Invalid character in var name"
  :e10 "Extra chars at end of file. Maybe an extra ')'."
  :e11 "Cannot Open include File"
  :e12 "Invalid no of arguments to "
  :e13 "Invalid Argument type to "
  :e14 "End of File encountered, unterminated regular expression"
  :e15 "Invalid vararg position, must be last argument."
  :e16 "Invalid arity (args > expected) to "
  :e17 "Invalid arity (args < expected) to "})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- MODULE-VERSION "1.0.0")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- EXTERNS nil
      SPEC-OPS {}
      MATH-OP-REGEX /^[-+][0-9]+$/)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- processFuncArgs "" [ast args env]
  (var fargs (tnode)
       fdefs (tnode)
       pms [] ret [fargs fdefs])
  (var~ e ev rval out)
  (for [i 0 sz (n# args)
        :while (< i sz) :recur (+1 i)]
    (=> e (.@i args))
    (cond
      (symbol? e)
      (if (== e "&")
        (do (=> rval (tnode)
                e (.@+i args))
            (rval.add ["slice(arguments," $(i) ")"])
            (if (symbol? e)
              (fdefs.add ["let "
                          (tx* e env) "=" rval ";\n"])
              (do (=> out (tnode)
                      e (destruct* e out env ast))
                  (fdefs.add ["let "
                              (tx* e env)
                              "=" rval ";\n" out])))
            (break-out-of-loop!))
        (conj! pms e))
      (array? e)
      (do (=> rval (tnode)
              out (tnode)
              e (destruct* e out env ast))
          (rval.add ["arguments[" $(i) "]"])
          (conj! pms e)
          (fdefs.add ["let "
                      (tx* e env)
                      "=" rval ";\n" out]))
      :else
      (error! :destruct-args ast)))
  (each #(fargs.add (tx* % env)) pms)
  (join "," fargs)
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destruct* "" [coll out env ast]
  (var rhs (gensym) e nil)
  (for [i 0 sz (n# coll)
        :while (< i sz) :recur (+1 i)]
    (=> e (.@i coll))
    (if (and (keyword? e)
             (== e "as"))
      (=> rhs (.@+i coll))
      (break-out-of-loop!)))
  (cond
    (map? coll)
    (out.add (destruct-Map rhs coll env ast))
    (vector? coll)
    (out.add (destruct-Vec rhs coll env ast)))
  rhs)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destruct-Vec "" [src coll env ast]
  (=> src (tx* src env))
  (var~ e rval out)
  (var ret (tnode))
  (for [i 0 sz (n# coll)
        :while (< i sz) :recur (+1 i)]
    (=> e (.@i coll))
    (cond
      (symbol? e)
      (cond
        (== e "_") nil
        (== e "&")
        (do (=> rval (tnode)
                out (tnode)
                e (.@+i coll))
            (rval.add ["slice(" src "," $(i) ")"])
            (if-not (symbol? e)
              (=> e (destruct* e out env ast)))
            (ret.add ["let "
                      (tx* e env)
                      "=" rval ";\n" out])
            (break-out-of-loop!))
        :else
        (do (=> out (tnode))
            (out.add ["let "
                      (tx* e env)
                      "=" src "[" $(i) "];\n" out])))
      (array? e)
      (do (=> rval (tnode)
              out (tnode)
              e (destruct* e out env ast))
          (rval.add [src "[" $(i) "]"])
          (ret.add ["let "
                    (tx* e env)
                    "=" rval ";\n" out]))
      (keyword? e)
      (if (== e "as")
        (++ i)
        (error! :unknown-keyword ast))
      :else (error! :syntax-error ast))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destruct-Map "" [src coll env ast]
  (=> src (tx* src env))
  (var ret (tnode))
  (var~ e arr)
  (for [i 0 sz (n# coll)
        :while (< i sz) :recur (+1 i)]
    (=> e (.@i coll))
    (cond
      (keyword? e)
      (cond
        (or (== e "keys")
            (== e "strs"))
        (do (=> arr (.@+i coll))
            (++ i)
            (for [j 0 sz (n# arr)
                  :while (< j sz) :recur (+1 j)]
              (=> e (.@j arr))
              (ret.add ["let "
                        (tx* e env)
                        "=" src "[\"" $(e) "\"];\n"])))
        :else
        (error! :unknown-keyword ast))
      :else
      (error! :syntax-error ast))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- simple? "" [ast]
  (or (undef? ast) (nil? ast) (string? ast) (number? ast) (boolean? ast)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- wrap "" [ret head tail]
  (if head (ret.prepend head))
  (ret.add tail)
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- exprHint "" [ast flag]
  (if (simple? ast) (=> ast (primitive ast))) (=>> ast :____expr flag) ast)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- stmt? "" [ast]
  (if (simple? ast) (error! :syntax-error ast)) (false? ast.____expr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- error! "" [e ast & [msg]]
  (raise! (get ERRORS-MAP e)
          (if msg (str " : " msg))
          (if ast.line (str "\nline: " ast.line))
          (if ast.source (str "\nfile: " ast.source))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- testre? "" [re x] (if x (re.test x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- pad "" [n] (.repeat " " n))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- node' "" [ast & [obj]]
  (=> obj (opt?? obj (tnode)))
  (=>> obj :source ast.source
           :line ast.line
           :column ast.column) obj)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txTree "" [root env]
  (var ret (node' root))
  (doseq [r root
          :let [t (tx* r env)]
          :when (some? t)]
    (ret.add [t "\n"])) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txForm "" [expr env]
  (each (fn [a i arr]
          (=>> arr i (tx* a env))) expr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txAtom "" [a]
  (var s $(a))
  (cond (lambda-arg? a)
        (str "____args[" s "]")
        (keyword? a)
        (str "\"" s "\"")
        (symbol? a)
        (parser/jsid s)
        (nil? a)
        "null"
        (primitive? a)
        (do (=> a a.value)
            (cond (string? a) a
                  (nil? a) "null"
                  :else $(a)))
        :else s))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- tx* "" [x & [env]]
  (if (array? x)
    (txPairs x env) (txAtom x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- gcmd "" [ast]
  (cond (map? ast) "hashmap"
        (vector? ast) "vec"
        (list? ast) "list"
        (and (array? ast)
             (symbol? (1st ast))) $(1st ast) :else ""))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quoteSingle "" [a]
  (cond (keyword? a)
        (str "keyword(\":" a "\")")
        (symbol? a)
        (str "symbol(\"" a "\")")
        (primitive? a)
        (do (set! a a.value)
            (cond (string? a) a
                  (nil? a) "null"
                  :else $(a)))
        :else $(a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quote! "" [ast env]
  (if (array? ast)
    (if (map? ast)
      (quoteMap ast env)
      (quoteBlock ast env))
    (quoteSingle ast)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quoteMap "" [ast env]
  (var comma ""
       ret (node' ast))
  (for [i 0 sz (n# ast)
        :while (< i sz) :recur (+2 i)]
    (if (> i 0) (ret.add ","))
    (ret.add [(quote! (.@i ast) env)
              " : " (quote! (.@+i ast) env)]))
  (if-not (empty? ast) (set! comma ","))
  (wrap ret ["[" "symbol(\"hashmap\")" comma] "]"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quoteBlock "" [ast env]
  (var ret (node' ast))
  (for [i 0 sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (if (> i 0) (ret.add ","))
    (ret.add (quote! (.@i ast) env)))
  (wrap ret "[" "]"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txPairs "" [ast env]
  (var stmtQ (stmt? ast)
       ret (node' ast)
       cmd (gcmd ast)
       op nil tmp nil
       mc (eng/getMacro cmd))
  ;;handle macro calls
  (when mc
    (=> ast (eng/expandMacro ast env mc)
        ast (exprHint ast (not stmtQ))
        cmd (gcmd ast)))
  ;;handle (+1 ) or (-1 ) cases
  (when (parser/REGEX.int.test cmd)
    (var c0 (ch@ cmd 0))
    (if (and (not= c0 "-")
             (not= c0 "+"))
      (=> cmd (str "+" cmd)))
    (=> ast [(symbol (ch@ cmd 0))
             (2nd ast) (int (rest cmd))]
        cmd $(1st ast)))
  ;;maybe special form
  (=> op (get SPEC-OPS cmd))
  ;;handle all cases
  (cond
    (== cmd "with-meta")
    (do (=> tmp (2nd ast))
        (if-not (simple? tmp)
          (do (=>> tmp
                   :____meta
                   (evalMeta (.@2 ast) env))
              (ret.add (tx* tmp env)))
          (error! :invalid-meta ast)))
    (starts? cmd ".-")
    (ret.add [(tx* (2nd ast) env)
              "."
              (tx* (symbol (cmd.slice 2)) env)])
    (starts? cmd ".@")
    (do (var onemore? #f pos 2)
        (when (starts? cmd ".@+")
          (++ pos)
          (true! onemore?))
        (ret.add [(tx* (2nd ast) env)
                  "["
                  (cmd.slice pos)
                  (if onemore? "+1]" "]")]))
    (starts? cmd ".")
    (do (ret.add [(tx* (2nd ast) env) cmd "("])
        (for [n 2 sz (n# ast)
              :while (< n sz) :recur (+1 n)]
          (if (not= n 2) (ret.add ","))
          (ret.add (tx* (.@n ast) env)))
        (ret.add ")"))
    (some? op)
    (=> ret (op ast env))
    :else
    (do (if (pairs? ast)
          (do (txForm ast env)
              (=> cmd $(1st ast)))
          (=> cmd (tx* ast env)))
        (if-not cmd (error! :empty-form ast))
        (=> cmd (maybeStripStdlib cmd))
        (if (pairs? ast)
          (ret.add
            [(if (testre? parser/REGEX.func cmd)
               (tnodeEx ["(" cmd ")"]) cmd)
             "(" (join "," (tnodeEx (rest ast))) ")"])
          (ret.add cmd))))
  (node' ast ret))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- writeDoc "Convert to jsdoc"
  [doc]
  (var out [])
  (if doc
    (->> (-> (doc.replace parser/REGEX.dquoteHat "")
             (.replace parser/REGEX.dquoteEnd "")
             (.split "\\n"))
         (each #(let [s (.trim (str %))]
                  (if (not-empty s)
                    (conj! out (str "//" s "\n"))))))) out)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-quote "" ^{:opcode ["quote"]} [ast env]
  (if-not (= (n# ast) 2) (error! :invalid-arity ast))
  (var ret (node' ast))
  (wrap ret nil (quote! (2nd ast) env)))

:destruct-args
:unknown-keyword
:invalid-arity
:invalid-meta
:syntax-error
:empty-form


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-deftype
  "Define a JS Class"
  ^{:opcode ["deftype" "deftype-"]}
  [ast env]
  (if-not (>= (n# ast) 4) (syntax! :wrong-num-args ast))
  (var private? (ends? $(1st ast) "-")
       czname (tx* (2nd ast) env)
       par (1st (.@2 ast))
       czargs (.@3 ast)
       ret (node' ast))
  (var~ n m doc mtds)
  (if (string? (.@4 ast))
    (do (set! doc (.@4 ast)
              mtds (slice ast 5)))
    (set! mtds (slice ast 4)))
  (ret.add ["class " czname])
  (if par
    (ret.add [" extends " (tx* par env)]))
  (ret.add " {\n")
  (for [i 0 pos 0 sz (n# mtds)
        :while (< i sz) :recur (+1 i)]
    (set! m (.@i mtds))
    (set! pos (if (string? (2nd m)) 3 2))
    (when (and (== $(1st m)
                   "constructor")
               (not-empty czargs))
      (for [x 0 sz (n# czargs)
            :while (< x sz) :recur (+2 x)]
        (set-in! czargs
                 x
                 (str "\"" (.@x args) "\"")))
      (m.splice pos 0
        (concat [(symbol "set-in!")
                 (symbol "this")] czargs)))
    (m.unshift (symbol "method"))
    (ret.add [(sf-func m env #f) "\n"]))
  (ret.add "}\n")
  (if doc (ret.prepend (writeDoc doc)))
  (if (and (not private?)
           (= 1 (.countNSPCache
                  (eng/globalEnv))))
      (set-in! EXTERNS czname czname)) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-compOp ""
  ^{:opcode ["not=" "!="
             "==" "="
             ">" ">=" "<" "<="]} [ast env]
  (if-not (and (>= (n# ast) 3)
               (odd? (n# ast))) (syntax! :wrong-num-args ast))
  (var ret (node' ast)
       cmd $(1st ast))
  (cond (== cmd "not=")
        (set-in! ast 0 (symbol "!=="))
        (== cmd "=")
        (set-in! ast 0 (symbol "===")))
  (for [i 0 op (tx* (ast.shift) env)
        :while (< i (last-index ast)) :recur (+1 i)]
    (ret.add (tnodeEx [(tx* (.@i ast) env)
                       " "
                       op
                       " "
                       (tx* (.@+i ast) env)])))
  (join " && " ret)
  (wrap ret "(" ")"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-arithOp
  ""
  ^{:opcode ["bitwise-lshift" "bitwise-rshift" "bitwise-zrshift"
             "+" "-" "*" "div" "mod"
             "or" "and" "exp" "rem"
             "bitwise-and" "bitwise-or" "bitwise-not" "bitwise-xor"]}
  [ast env]
  (var e1 (tx* (ast.shift) env)
       op "" cmd $(e1) ret (node' ast))
  (cond (== cmd "bitwise-zrshift") (set! cmd ">>>")
        (== cmd "bitwise-rshift") (set! cmd ">>")
        (== cmd "bitwise-lshift") (set! cmd "<<")
        (== cmd "bitwise-and") (set! cmd "&")
        (== cmd "bitwise-or") (set! cmd "|")
        (== cmd "bitwise-not") (set! cmd "~")
        (== cmd "bitwise-xor") (set! cmd "^")
        (== cmd "rem") (set! cmd "%")
        (== cmd "div") (set! cmd "/")
        (== cmd "and") (set! cmd "&&")
        (== cmd "or") (set! cmd "||")
        (== cmd "exp") (set! cmd "**"))
  (if (= 1 (n# ast))
    (if (== "-" cmd) (ret.add "-"))
    (set! op cmd))
  (ret.add ast)
  (if (> (n# ast) 1) (join op ret))
  (wrap ret "(" ")"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txDo "" [ast env & [return?]]
  (var stmtQ (stmt? ast)
       ret (node' ast)
       e nil end (last-index ast))
  (set! return?
        (if stmtQ false (opt?? return? true)))
  (for [i 0 :while (< i end) :recur (+1 i)]
    (set! e (exprHint (.@i ast) #f))
    (ret.add [(tx* e env) ";\n"]))
  (when (>= end 0)
    (set! e (exprHint (.@end ast)
                      (not stmtQ))
          e (tx* e env))
    (ret.add (if-not return?
               [e ";\n"]
               ["return " e ";\n"]))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-do
  "" ^{:opcode ["do"]} [ast env]
  (var ret (node' ast)
       stmtQ (stmt? ast))
  (ret.add (txDo (exprHint (rest ast)
                           (not stmtQ))
                 env (not stmtQ)))
  (if stmtQ
    (wrap ret "" "")
    (wrap ret
          "(function() {\n" "}).call(this)")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-case
  "" ^{:opcode ["case"]} [ast env]
  (var stmtQ (stmt? ast)
       ret (node' ast)
       brk ";\nbreak;\n"
       tst (2nd ast)
       _x $(gensym "C__"))
  (var~ e t c dft)
  (if (odd? (n# ast))
    (set! dft (1st (pop! ast))))
  (for [i 2 sz (n# ast)
        :while (< i sz) :recur (+2 i)]
    (set! e (.@i ast)
          c (.@+i ast))
    (if (pairs? e)
      (for [j 0 sz (n# e)
            :while (< j sz) :recur (+1 j)]
        (ret.add ["case "
                  (tx* (.@j e) env) ":\n"])
        (if (= j (last-index e))
          (ret.add [_x "="
                    (tx* c env) brk])))
      (ret.add ["case " (tx* e env) ":\n"
                _x "=" (tx* c env) brk])))
  (if dft
    (ret.add ["default:\n"
              _x "=" (tx* dft env) brk]))
  (wrap ret ["switch ("
             (tx* tst env) ") {\n"] "}")
  (if stmtQ
    (wrap ret ["let " _x ";\n"] "")
    (wrap ret
          ["(function() { let " _x ";\n"]
          ["return " _x ";}).call(this)"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-vardefs "" ^{:opcode ["def~-"
                                "def~" "var~"]} [ast env]
  (var ret (node' ast)
       cmd $(1st ast)
       kks {}
       private? (ends? cmd "-"))
  (if-not (== "let" cmd) (set! cmd "var"))
  (for [i 1 s nil sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (set! s (tx* (.@i ast) env))
    (ret.add s)
    (set-in! kks s nil))
  (join "," ret)
  (wrap ret (str cmd " ") ";\n")
  (if (and (not private?)
           (= 1 (.countNSPCache
                  (eng/globalEnv))))
    (each-key (fn [v k]
                (set-in! EXTERNS k k)) kks)) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-var "" ^{:opcode ["const"
                            "const-"
                            "def"
                            "def-"
                            "var"]} [ast env]
  (if-not (odd? (n# ast)) (syntax! :wrong-num-args ast))
  (var ret (node' ast)
       cmd $(1st ast)
       keys []
       tmp nil vname nil
       private? (and (not= cmd "const")
                     (not= cmd "def")))
  (var~ rval rc lhs rhs)
  (set! ast (rest ast)
        cmd (if (starts? cmd "const")
              "const"
              (if (== cmd "var") "let" "var")))
  (for [i 0 sz (n# ast)
        :while (< i sz) :recur (+2 i)]
    (set! lhs (.@i ast)
          rhs (.@+i ast)
          rval (tx* rhs env))
    (if (symbol? lhs)
      (do (set! lhs (tx* lhs env)
                tmp [cmd " " lhs "=" rval ";\n"])
          (conj! keys lhs)
          (ret.add tmp))
      (do (set! out (tnode)
                rhs (destruct* lhs out env))
          (ret.add ["let "
                    (tx* rhs env)
                    "=" rval ";\n" out]))))
  (when (and (not private?)
             (= 1 (.countNSPCache
                    (eng/globalEnv))))
    (each (fn [k]
            (set-in! EXTERNS k k)) keys)) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-inst?
  "" ^{:opcode ["inst?"]} [ast env]
  (if-not (= (n# ast) 3) (syntax! :wrong-num-args ast))
  (var ret (node' ast))
  (wrap ret "" ["(" (tx* (.@2 ast) env)
                " instanceof " (tx* (2nd ast) env) ")"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-delete
  "" ^{:opcode ["delete!"]} [ast env]
  (if-not (and (>= (n# ast) 2)
               (< (n# ast) 4)) (syntax! :wrong-num-args ast))
  (var ret (node' ast))
  (ret.add ["delete "
            (tx* (2nd ast) env)])
  (if (> (n# ast) 2)
    (ret.add ["[" (tx* (.@2 ast) env) "]"])) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-new
  "" ^{:opcode ["new"]} [ast env]
  (var ret (node' ast))
  (wrap ret "new " (tx* (rest ast) env)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-throw
  "" ^{:opcode ["throw"]} [ast env]
  (var ret (node' ast)
       stmtQ (stmt? ast))
  (ret.add ["throw " (tx* (2nd ast) env)])
  (if-not stmtQ
    (wrap ret
          "(function (){ "
          ";}).call(this)")) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-x-opop
  "" ^{:opcode ["++" "--" "++$" "--$"]} [ast env]
  (if-not (= (n# ast) 2) (syntax! :wrong-num-args ast))
  (var cmd $(1st ast)
       ret (node' ast)
       a2 (tx* (2nd ast) env))
  (if (ends? cmd "$")
    (ret.add [a2 (cmd.slice 0 -1)])
    (ret.add [cmd a2])) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-x-eq
  "" ^{:opcode ["+="
                "-="
                "*="
                "div="
                "rem="
                "exp="
                "bitwise-and="
                "bitwise-or="
                "bitwise-xor="
                "bitwise-lshift="
                "bitwise-rshift="
                "bitwise-zrshift="]} [ast env]
  (if-not (= (n# ast) 3) (syntax! :wrong-num-args ast))
  (var cmd $(1st ast)
       ret (node' ast))
  (cond
    (== cmd "bitwise-zrshift=") (set! cmd ">>>=")
    (== cmd "bitwise-rshift=") (set! cmd ">>=")
    (== cmd "bitwise-lshift=") (set! cmd "<<=")
    (== cmd "bitwise-xor=") (set! cmd "^=")
    (== cmd "bitwise-or=") (set! cmd "|=")
    (== cmd "bitwise-and=") (set! cmd "&=")
    (== cmd "div=") (set! cmd "/=")
    (== cmd "rem=") (set! cmd "%=")
    (== cmd "exp=") (set! cmd "**="))
  (wrap ret "" [(tx* (2nd ast) env)
                " " cmd " " (tx* (.@2 ast) env)]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-set-in
  "" ^{:opcode ["set-in!" "=>>"]} [ast env]
  (if-not (even? (n# ast))
          (syntax! :wrong-num-args ast))
  (var ret (node' ast)
       more #f
       obj (tx* (2nd ast) env))
  (for [i 2 sz (n# ast)
        :while (< i sz) :recur (+2 i)]
    (when (> i 2)
      (ret.add ",")
      (true! more))
    (ret.add [obj "[" (tx* (.@i ast) env) "]"
              "=" (tx* (.@+i ast) env)]))
  (if more (wrap ret "(" ")")) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-set
  "" ^{:opcode ["set!" "=>"]} [ast env]
  (if-not (odd? (n# ast))
          (syntax! :wrong-num-args ast))
  (var more #f
       ret (node' ast))
  (for [i 1 sz (n# ast)
        :while (< i sz) :recur (+2 i)]
    (when (> i 1)
      (ret.add ",")
      (true! more))
    (ret.add [(tx* (.@i ast) env)
              "=" (tx* (.@+i ast) env)]))
  (if more (wrap ret "(" ")")) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-fn
  "(fn [x y] ...)" ^{:opcode ["fn"]} [ast env]
  (var ret (node' ast)
       args (2nd ast)
       fargs nil
       hints {}
       body (slice ast 2))
  (if-not (array? args) (syntax! :no-func-args ast))
  (when (and (= 3 (n# args))
             (== "with-meta"
                 $(1st args))
             (array? (2nd args)))
    (set! hints (evalMeta (.@2 args) env)
          args (2nd args)))
  (if-not (array? args) (syntax! :no-func-args ast))
  (set! fargs (processFuncArgs ast args env))
  (wrap ret "" ["function ("
                (1st fargs)
                ") {\n"
                (2nd fargs)
                (txDo body env #t) "}"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fmtRegoSpecOps "" [alias fname]
  (str (parser/jsid :SPEC-OPS) "[\"" alias "\"] = " fname))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fmtSpecOps "" [fname attrs]
  (var ks (or (get attrs "opcode") [])
       out (->> (map #(fmtRegoSpecOps
                        (str %) fname) ks) (join ";\n")))
  (if (not-empty ks) (str out ";\n") out))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- writeFuncInfo "" [fname src]
  (var file (ast.source.slice (+1 (ast.source.lastIndexOf "/")))
       s (str "//name: ["
              fname
              "] in file: "
              file
              ",line: " ast.line "\n")
       len (alen s))
  (if (< len 80)  (set! len 80))
  (doto (tnodeEx (str (.repeat "/" len) "\n")) (.add s)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-func
  ""
  ^{:opcode ["defn" "defn-"]}
  [ast env]
  (var fname0 $(1st ast) mtd? (== fname0 "method")
       fname (tx* (2nd ast) env)
       dot? (contains? fname ".")
       ret (node' ast) hints {}
       e2 (.@2 ast) args 2 body 3
       fargs nil doc nil
       private? (ends? fname0 "-"))
  (if (string? e2)
    (set! doc 2 args 3))
  (set! body (+1 args))
  (if doc (set! doc (nth ast doc)))
  (set! args (nth ast args)
        body (slice ast body))
  (if-not (array? args) (syntax! :no-func-args ast))
  (when (and (= 3 (n# args))
             (== "with-meta"
                 $(1st args))
             (array? (2nd args)))
    (set! hints (evalMeta (.@2 args) env)
          args (2nd args)))
  (if-not (array? args) (syntax! :no-func-args ast))
  (set! fargs (processFuncArgs ast args env))
  (cond mtd?
        (do (if (.-static hints)
              (ret.add "static "))
            (ret.add [fname " ("])
            (if (== fname "constructor")
              (body.push (symbol "this"))))
        dot?
        (ret.add [fname " = function ("])
        :else
        (ret.add ["const " fname " = function ("]))
  (ret.add [(1st fargs)
            ") {\n"
            (2nd fargs)
            (txDo body env #t) "};\n"])
  (if (not-empty hints)
    (ret.add (fmtSpecOps fname hints)))
  (if doc
    (ret.prepend (writeDoc doc)))
  (ret.prepend (writeFuncInfo fname0 ast))
  (if (and (not private?)
           (not dot?)
           (not mtd?)
           (= 1 (.countNSPCache
                  (eng/globalEnv))))
    (set-in! EXTERNS fname fname))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-try
  "" ^{:opcode ["try"]} [ast env]
  (var stmtQ (stmt? ast)
       sz (n# ast)
       ret (node' ast))
  (var~ t f c)
  ;;look for finally
  (set! f (last ast))
  (if (and (array? f)
           (== "finally" $(1st f)))
    (set! f (1st (pop! ast))
          sz (n# ast))
    (nil! f))
  ;;look for catch
  (nil! c)
  (if (> sz 1)
    (set! c (nth ast (-1 sz))))
  (if (and (array? c)
           (== "catch" $(1st c)))
    (do (if (or (< (n# c) 2)
                (not (symbol? (2nd c))))
          (syntax! :expected-symbol ast))
        (set! c (1st (pop! ast))))
    (nil! c))
  ;;try needs either a catch or finally or both
  (if (and (nil? f)
           (nil? c)) (syntax! :invalid-try-block ast))
  (ret.add ["try {\n"
            (txDo (exprHint (rest ast)
                            (not stmtQ)) env) "\n}"])
  (when c
    (set! t (2nd c))
    (ret.add [(str "catch (" t ") {\n")
              (txDo (exprHint (slice c 2)
                              (not stmtQ)) env) ";\n}\n"]))
  (when f
    (ret.add ["finally {\n",
              (txDo (exprHint (rest f) #f) env #f) ";\n}\n"]))
  (if-not stmtQ
    (wrap ret "(function(){\n" "}).call(this)")) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-if
  "" ^{:opcode ["if"]} [ast env]
  (var stmtQ (stmt? ast)
       ret (node' ast)
       a1 (exprHint (2nd ast) (not stmtQ))
       a2 (exprHint (.@2 ast) (not stmtQ))
       a3 (if (> (n# ast) 3) (.@3 ast))
       elze (if a3 (exprHint a3 (not stmtQ))))
  (set! a1 (tx* a1 env)
        a2 (tx* a2 env)
        elze (tx* elze env))
  (if stmtQ
    (do (ret.add ["if (" a1 ") {\n" a2 ";\n}"])
        (if a3 (ret.add [" else { \n" elze ";\n}"])))
    (ret.add ["(" a1 " ?\n" a2 " :\n" (or elze "null") ")"]))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-nth ""
  ^{:opcode ["nth"]} [ast env]
  (if-not (= (n# ast) 3) (syntax! :wrong-num-args ast))
  (var ret (node' ast))
  (wrap ret "" [(tx* (2nd ast) env)
                "[" (tx* (.@2 ast) env) "]"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-get
  "" ^{:opcode ["get"]} [ast env]
  (if-not (= (n# ast) 3) (syntax! :wrong-num-args ast))
  (var ret (node' ast))
  (wrap ret "" [(tx* (2nd ast) env)
                "[" (tx* (.@2 ast) env) "]"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-array
  "" ^{:opcode ["vec"]} [ast env]
  (var ret (node' ast))
  (if (empty? ast)
    (ret.add "[]")
    (do (if-not (vector? ast)
          (ast.splice 0 1))
        (ret.add "[\n")
        (for [i 0 sz (n# ast)
              :while (< i sz) :recur (+1 i)]
          (if (> i 0) (ret.add ",\n"))
          (ret.add (tx* (.@i ast) env)))
        (ret.add "\n]"))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-object
  "" ^{:opcode ["hashmap"]} [ast env]
  (var ret (node' ast))
  (if (empty? ast)
    (ret.add "{}")
    (do (if-not (map? ast)
          (ast.splice 0 1))
        (ret.add "{\n")
        (for [i 0 sz (n# ast)
              :while (< i sz) :recur (+2 i)]
          (if (> i 0) (ret.add ",\n"))
          (ret.add [(tx* (.@i ast) env)
                    ": " (tx* (.@+i ast) env)]))
        (ret.add "\n}"))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- icache [])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- includeFile [fname]
  (if (contains? icache fname)
    (tnode)
    (let [src (fs/readFileSync fname "utf-8")]
      (conj! icache fname)
      (txTree (parser/parser src fname) (eng/globalEnv )))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-include "" [ast env]
  (var ret []
       dir (path/dirname ast.source))
  (var~ fname e)
  (for [i 1 sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i ast))
    (if (or (not (array? e))
            (not= 1 (n# e)))
      (syntax! :bad-include-file ast))
    (set! fname $(1st e))
    (if fname
      (set! fname (fname.replace /[\"]/g "")))
    (try
      (set! fname (fs/realpathSync
                    (str dir "/" fname)))
      (catch e
        (syntax! :file-read-error ast)))
    (try
      (conj! ret (includeFile fname))
      (finally
        (.popNSP (eng/globalEnv)))))
  (if (empty? ret) (tnode) ret))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-require "" [ast env]
  (var~ as path v e refers renames)
  (var ret (node' ast))
  (for [i 1 sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i ast)
          as $(gensym "R__")
          refers nil renames nil)
    (if (or (not (array? e))
            (< (n# e) 3)) (syntax! :bad-require ast))
    (set! path $(1st e))
    (for [j 1 sz (n# e)
          :while (< j sz) :recur (+1 j)]
      (set! v (.@j e))
      (cond (== v "as")
            (do (set! as $(.@+j e))
                (++ j))
            (== v "refer")
            (do (set! refers (.@+j e))
                (++ j))
            (== v "rename")
            (do (set! renames (.@+j e))
                (++ j))))
    (ret.add ["const " (parser/jsid as)
              "= require(" (tx* path env) ");\n"])
    (for [i 0 sz (n# refers)
          :while (and refers
                      (< i sz)) :recur (+1 i)]
      (set! v (tx* (.@i refers) env))
      (ret.add ["const " v "=" as "[\"" v "\"];\n"]))
    (for [i 0 sz (n# renames)
          :while (and renames
                      (< i sz)) :recur (+2 i)]
      (set! e (tx* (.@i renames) env)
            v (tx* (.@+i renames) env))
      (ret.add ["const " v
                "=" as "[\"" e "\"];\n"]))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- evalMeta "" [ast env]
  (cond
    (array? ast)
    (JSON/parse $(tx* ast env))
    (keyword? ast)
    (->> (tx* [ast #t] env)
         (str )
         (JSON/parse ))
    (symbol? ast)
    (->> (tx* [(symbol "tag") ast] env)
         (str )
         (JSON/parse ))
    :else
    (syntax! :bad-meta ast)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-ns
  "" ^{:opcode ["ns"]} [ast env]
  (if-not (>= (n# ast) 2) (syntax! :wrong-num-args ast))
  (var ret [] e nil
       hints {} nsp (2nd ast))
  (when (and (array? nsp)
             (= 3 (n# nsp))
             (== "with-meta" $(1st nsp))
             (symbol? (2nd nsp)))
    (set! hints (evalMeta (.@2 nsp) env)
          nsp (2nd nsp)))
  (.pushNSP (eng/globalEnv) $(nsp))
  (set! ast (slice ast 2))
  (for [i 0 sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i ast))
    (cond (and (pairs? e)
               (== "include" $(1st e)))
          (conj! ret (sf-include e))
          (and (pairs? e)
               (== "require" $(1st e)))
          (conj! ret (sf-require e))))
  ;;force a internal reference to stdlib for user files
  (set! nsp (.peekNSP (eng/globalEnv)))
  (cond
    (or (= nsp "czlab.kirby.macros")
        (= nsp "czlab.kirby.stdlib"))
    nil
    (starts? nsp "czlab.kirby.")
    (conj! ret (tnodeEx "const kirbystdlibref=std;\n"))
    :else
    (->> '(require ["kirby" :as kirbystdlibref])
         (sf-require )
         (conj! ret ))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- maybeStripStdlib "" [cmd]
  (var lib "kirbystdlibref."
       nsp (.peekNSP (eng/globalEnv)))
  (set! cmd $(cmd))
  (if (and (starts? cmd lib)
           (= nsp "czlab.kirby.stdlib"))
    (cmd.slice (n# lib))
    cmd))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-comment "" ^{:opcode ["comment"]} [ast env] (node' ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-for
  "" ^{:opcode ["for"]} [ast env]
  (var stmtQ (stmt? ast)
       ret (node' ast)
       body (exprHint (slice ast 2) #f))
  (if (empty? body)
    (tnode)
    (sf-floop ret (2nd ast) body env stmtQ)) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-floop "" [ret args body env stmtQ]
  (var vars [] recurs [])
  (var~ tst nb e)
  (for [i 0 sz (n# args)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i args))
    (cond (== e "while")
          (do (set! tst (.@+i args)) (++ i))
          (== e "recur")
          (do (set! recurs (slice args (+1 i)))
              (break-out-of-loop!))
          (symbol? e)
          (do (conj! vars e (.@+i args))
              (++ i))))
  (ret.add "for (")
  (for [i 0 sz (n# vars)
        :while (< i sz) :recur (+2 i)]
    (if (= i 0) (ret.add "let "))
    (if (not= i 0) (ret.add ","))
    (ret.add [(tx* (.@i vars) env)
              "=" (tx* (.@+i vars) env)]))
  (ret.add (if (empty? vars)
             "let ____break=false;" ",____break=false;"))
  (set! nb '(not ____break))
  (if tst
    (set! tst [(symbol "and") nb tst])
    (set! tst nb))
  (ret.add (tx* tst env))
  (ret.add "; ")
  (for [i 0 k 0 sz (n# recurs)
        :while (< i sz) :recur (+1 i)(+2 k)]
    (if (not= i 0) (ret.add ","))
    (ret.add [(tx* (.@k vars) env)
              "=" (tx* (.@i recurs) env)]))
  (ret.add ["){\n" (txDo body env #f) "}\n"])
  (if-not stmtQ
    (wrap ret "(function() {\n"  "}).call(this)")) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-jscode
  "" ^{:opcode ["js#"]} [ast env]
  (node' ast
         (tnodeEx (-> $(2nd ast)
                      (.replace parser/REGEX.dquoteHat "")
                      (.replace parser/REGEX.dquoteEnd "")))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-macro
  "" ^{:opcode ["defmacro"]} [ast env]
  (var pms []
       args (.@2 ast)
       body (slice ast 3))
  (var~ x e ev)
  (when (string? args)
    (set! doc args
          args (.@3 ast)
          body (slice ast 4)))
  (for [i 0 sz (n# args)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i args) ev $(e))
    (cond (= ev "&")
          (if (array? (.@+i args))
            (do (set! e (.@+i args))
                (++ i)
                (for [j 0 sz (n# e)
                      :while (< j sz) :recur (+1 j)]
                  (set! x (.@j e))
                  (if-not (symbol? x)
                    (syntax! :expected-symbol ast))
                  (conj! pms x)))
            (do (conj! pms e (.@+i args))
                (++ i)))
          (not (symbol? e))
          (syntax! :expected-symbol ast)
          :else
          (conj! pms e)))
  (set! ast
        [(1st ast)
         (2nd ast)
         (concat [(symbol "fn*") pms] body)])
  (var a1 $(2nd ast)
       a2 (.@2 ast)
       func (eng/compute a2 env))
  (set-in! func :____macro #t)
  (if doc (set-in! func :____doc doc))
  (eng/setMacro a1 func)
  (node' ast (tnode)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-unary
  "" ^{:opcode ["not" "~" "!"]} [ast env]
  (if-not (= (n# ast) 2) (syntax! :wrong-num-args ast))
  (var [a0 a1] ast
       ret (node' ast))
  (if (== a0 "not") (set! a0 (symbol "!")))
  (ret.add ["(" (tx* a0 env) (tx* a1 env) ")"]) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- spitExterns "" []
  (var s "" ks (keys EXTERNS))
  (when (not-empty ks)
    (set! s (join ",\n"
                  (map #(str % ": " %) ks))
          s (str "\n\nmodule.exports = {\n" s "\n};\n\n")))
  s)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- banner "" []
  (str "/*"
       "Auto generated by Kirby - v"
       MODULE-VERSION " "
       (.firstNSP (eng/globalEnv)) " - " (new Date) "*/\n\n"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- cleanCode "" [code]
  (var tmp nil arr [])
  (doseq [s (code.split "\n")]
    (set! tmp (s.trim))
    (if (and (not-empty tmp)
             (not= tmp ";")) (conj! arr s)))
  (join "\n" arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileCode "" [codeStr fname options]
  (.resetNSPCache (eng/globalEnv))
  (set! EXTERNS {})
  (var outNode (txTree (parser/parser codeStr
                                      fname)
                       (eng/globalEnv))
       {:keys [source-map format]} options
       cstr ""
       fopts {}
       extra (spitExterns))
  (true! format)
  (set! cstr
        (if source-map
          (let [outFile (str (path/basename fname ".ky") ".js")
                srcMap (str outFile ".map")
                output (outNode.toStringWithSourceMap {:file outFile})]
            (fs/writeFileSync srcMap output.map)
            (str output.code
                 extra
                 "\n//# sourceMappingURL="
                 (path/relative (path/dirname fname) srcMap)))
          (str outNode extra)))
  (if format
    (set! cstr (esfmt/format cstr fopts)))
  (set! cstr (cleanCode cstr))
  ;;(if format (set! cstr (esfmt/format cstr fopts)))
  (if (empty? cstr) "" (str (banner) cstr)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileXXX "" [code file options]
  (try
    (transpileCode code file options)
    (catch e
      (println (.-stack e)) (throw e))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn transpileWithSrcMap
  "" [code file & [options]]
  (transpileXXX code
                file
                (opt?? options {})))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn transpile
  "" [code file & [options]]
  (transpileXXX code
                file
                (opt?? options {})))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn parseWithSourceMap "" [codeStr fname]
  (var outNode (txTree (parser/parser codeStr fname)))
  (outNode.prepend (banner))
  (outNode.toStringWithSourceMap ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(def version MODULE-VERSION)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

