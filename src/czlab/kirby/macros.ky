;; Copyright (c) 2013-2018, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns ^{:doc "Kirby's standard core library."
      :author "Kenneth Leung"}
  czlab.kirby.stdlib)

(defmacro assert* "" [c msg] `(if* ~c true (throw* ~msg)))

(defmacro cond* "" [&xs]
    (if* (> (count* xs) 0)
      (list* 'if*
            (first* xs)
            (nth* xs 1)
            (cons* 'cond* (rest* (rest* xs))))))

(defmacro _andp_* "" [&xs]
    (if* (= 1 ~(count* xs)) `~(first* xs) `(and ~@xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro empty? "" [coll] `(= 0 (kirbystdlibref/count ~coll)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro starts? "" [s arg] `(.startsWith ~s ~arg))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro ends? "" [s arg] `(.endsWith ~s ~arg))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro n# "" [coll] `(kirbystdlibref/count ~coll))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro 1st "" [x] `(first ~x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro 2nd "" [x] `(second ~x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro 3rd "" [x] `(nth ~x 2))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro trap! "" [&msgs]
  (let* [sz (count* msgs)]
    (if* (> sz 1)
      `(throw (join "" (vec ~@msgs)))
      (if* (> sz 0)
        `(throw ~(nth* msgs 0)) `(throw "error!")))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro merror "" [e] `(new Error ~e))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro raise! "" [&msgs]
  (let* [sz (count* msgs)]
    (if* (> sz 1)
      `(throw (merror (join "" (vec ~@msgs))))
      (if* (> sz 0)
        `(throw (merror ~(nth* msgs 0))) `(throw (merror "error!"))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro slice "" [arr &[start end]]
  (if* end
       `(Array.prototype.slice.call ~arr ~start ~end)
       (if* start
            `(Array.prototype.slice.call ~arr ~start)
            `(Array.prototype.slice.call ~arr))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro float "" [x] `(parseFloat ~x))
(defmacro int "" [x] `(parseInt ~x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro delay "" [f t] `(setTimeout ~f ~t))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro break-out-of-loop! "" [] `(set! ____break true))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro undef! "" [x] `(set! ~x undefined))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro nil! "" [x] `(set! ~x nil))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro last-index "" [coll] `(-1 (alen ~coll)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro rest "" [coll] `(.slice ~coll 1))
(defmacro cdr "" [coll] `(.slice ~coll 1))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro second "" [coll] `(nth ~coll 1))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro first "" [coll] `(nth ~coll 0))
(defmacro car "" [coll] `(nth ~coll 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro nexth "" [coll i] `(nth ~coll (+1 ~i)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro nth "" [coll i] `(get ~coll ~i))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro even? "" [&xs]
  `(_andp_* ~@(map* (lambda* [x] `(= 0 (kirbystdlibref/modulo ~x 2))) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro odd? "" [&xs]
  `(_andp_* ~@(map* (lambda* [x] `(not (even? ~x))) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro alen "" [coll] `(.-length ~coll))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro nzlen? "" [coll] `(> (alen ~coll) 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro zlen? "" [coll] `(= 0 (alen ~coll)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro type "" [obj] `(typeof ~obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro whatis? "" [obj] `(Object.prototype.toString.call ~obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro regex? "" [&xs]
  `(_andp_* ~@(map* (lambda* [x] `(= (whatis? ~x) "[object RegExp]")) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro array? "" [&xs]
  `(_andp_* ~@(map* (lambda* [x] `(Array.isArray ~x)) xs)))
(defmacro arr? "" [&xs] `(array? ~@xs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro date? "" [&xs]
  `(_andp_* ~@(map* (lambda* [x] `(= (whatis? ~x) "[object Date]")) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro bool? "" [&xs] `(boolean? ~@xs))
(defmacro boolean? "" [&xs]
  `(_andp_* ~@(map* (lambda* [x] `(= (typeof ~x) "boolean")) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro num? "" [&xs] `(number? ~@xs))
(defmacro number? "" [&xs]
  `(_andp_* ~@(map* (lambda* [x] `(= (typeof ~x) "number")) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro str? "" [&xs] `(string? ~@xs))
(defmacro string? "" [&xs]
  `(_andp_* ~@(map* (lambda* [x] `(= (typeof ~x) "string")) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro fn? "" [&xs]
  `(_andp_* ~@(map* (lambda* [x] `(= (typeof ~x) "function")) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro undef? "" [&xs]
  `(_andp_* ~@(map* (lambda* [x] `(= (typeof ~x) "undefined")) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro def? "" [&xs]
  `(_andp_* ~@(map* (lambda* [x] `(not= (typeof ~x) "undefined")) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro nil? "" [&xs]
  `(_andp_* ~@(map* (lambda* [x] `(= ~x null)) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro zero? "" [&xs]
  `(_andp_* ~@(map* (lambda* [x] `(= ~x 0)) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro one? "" [&xs]
  `(_andp_* ~@(map* (lambda* [x] `(= ~x 1)) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro neg? "" [&xs]
  `(_andp_* ~@(map* (lambda* [x] `(< ~x 0)) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro pos? "" [&xs]
  `(_andp_* ~@(map* (lambda* [x] `(> ~x 0)) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro values "" [obj] `(Object.values ~obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro keys "" [obj] `(Object.keys ~obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro properties "" [obj]
  `(Object.getOwnPropertyNames ~obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro assert "" [tst & msgs] `(if ~tst true (raise! ~@msgs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro false? "" [&xs]
  `(_andp_* ~@(map* (lambda* [x] `(= ~x false)) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro true? "" [&xs]
  `(_andp_* ~@(map* (lambda* [x] `(= ~x true)) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro when-not "" [tst & xs] `(when (not ~tst) ~@xs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro unless "" [tst & xs] `(when-not ~tst ~@xs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro if-not
  "" [tst then & [else]] `(if (not ~tst) ~then ~else))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro while "" [tst & xs] `(for [:while ~tst] ~@xs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro when "" [tst & xs] `(if ~tst (do ~@xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro cond "" [&xs]
  (let* [len (count* xs)]
    (do* (assert* (is-even? len) "cond expects even args")
         (if* (> len 0)
           (let* [c (nth* xs 0)
                  e (nth* xs 1)
                  r (rest* (rest* xs))]
             (if* (is-same? c "else")
               `(if true ~e)
               `(if ~c ~e (cond ~@r))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro -> "" [expr form & xs]
  (let* [x `(~(nth* form 0)
                    ~expr ~@(rest* form))]
    (if* (> (count* xs) 0) `(-> ~x ~@xs) `~x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro ->> "" [expr form & xs]
  (let* [x `(~@form ~expr)]
    (if* (> (count* xs) 0) `(->> ~x ~@xs) `~x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro let "" [bindings & xs] `(do (var ~@bindings) ~@xs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro single? "" [coll] `(= 1 (n# ~coll)))
(defmacro dual? "" [coll] `(= 2 (n# ~coll)))
(defmacro triple? "" [coll] `(= 3 (n# ~coll)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defmacro loop "" [bindings & more]
  (let*
    [es (evens* bindings)
     os (odds* bindings)]
    `((fn []
        (var _x_ nil recur nil
             _f_ (fn [~@es] ~@more) _r_ _f_)
        (set! recur
              (fn []
                (set! _x_ arguments)
                (raw# "if (_r_) {for(_r_=undefined;_r_===undefined;){_r_=_f_.apply(this,_x_);} return _r_;}")
                undefined))
        (recur ~@os)) this)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro concat "" [coll x] `(.concat ~coll ~x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro join "" [sep coll] `(.join ~coll ~sep))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro do-with "" [binding & xs]
  (let* [f (nth* binding 0)]
    `(let [~f ~(nth* binding 1)] ~@xs ~f)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro do->false "" [&xs]
  (let* [a (gensym*)] `(let [~a false] ~@xs ~a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro do->true "" [&xs]
  (let* [a (gensym*)] `(let [~a true] ~@xs ~a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro do->nil "" [&xs]
  (let* [a (gensym*)] `(let [~a nil] ~@xs ~a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro do->undef "" [&xs]
  (let* [a (gensym*)] `(let [~a undefined] ~@xs ~a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro do->break! "" [&xs]
  `(do ~@xs (break-out-of-loop!)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro inc "" [x] `(+1 ~x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro dec "" [x] `(-1 ~x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro dotimes "" [binding &xs]
  (let* [_t (gensym*)
         b1 (first* binding)]
    `(for [~b1 0 ~_t ~(nth* binding 1)
           :while (< ~b1 ~_t) :recur (+1 ~b1)] ~@xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro range "" [a & [b c]]
  (let* [start (if* b a 0)
         end (if* b b a)
         step (if* c c 1)]
    `(do-with [ret []]
       (for [i ~start
             :while (< i ~end) :recur (+ i ~step)]
         (ret.push i)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro apply
  "" [f this args] `(.apply ~f ~this ~args))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro apply*
  "" [f this & args]
  `(.apply ~f ~this (vec ~@args)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro ch@ "" [s pos] `(.charAt ~s ~pos))
(defmacro false! "" [x] `(set! ~x false))
(defmacro true! "" [x] `(set! ~x true))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro repeat "" [n x]
  `(do-with [ret []]
     (for [i 0
           :while (< i ~n)
           :recur (+1 i)] (ret.push ~x))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro doseq "" [bindings & xs]
  (let*
    [loopExpr (gensym*)
     escvar (gensym*)
     idxvar (gensym*)
     _let (if* (is-eq? (nth* bindings 2) ':let)
               (nth* bindings 3))
     _while (if* (is-eq? (nth* bindings 2) ':while)
                 (nth* bindings 3)
                 (if* (is-eq? (nth* bindings 4) ':while)
                      (nth* bindings 5)
                      (if* (is-eq? (nth* bindings 6) ':while)
                           (nth* bindings 7)
                           true)))
     _when (if* (is-eq? (nth* bindings 2) ':when)
                (nth* bindings 3)
                (if* (is-eq? (nth* bindings 4) ':when)
                     (nth* bindings 5)
                     (if* (is-eq? (nth* bindings 6) ':when)
                          (nth* bindings 7)
                          true)))]
    `(let [~loopExpr ~(nth* bindings 1)]
       (for [~idxvar 0
             ~escvar false
             :while (and (not ~escvar)
                         (< ~idxvar (alen ~loopExpr))) :recur (+1 ~idxvar)]
         (var ~(nth* bindings 0)
              (nth ~loopExpr ~idxvar))
         ~(if* _let `(var ~@_let))
         (if-not ~_while (set! ~escvar true))
         (when (and (not ~escvar) ~_when) ~@xs)) nil)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro if-some+ "" [binding then & [else]]
  (let* [tst (gensym*)]
    `(let [~tst ~(nth* binding 1)
           ~(first* binding) ~tst]
       (if (> (n# ~tst) 0) ~then ~else))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro if-some "" [binding then & [else]]
  (let* [tst (gensym*)]
    `(let [~tst ~(nth* binding 1)
           ~(first* binding) ~tst]
       (if (or (undef? ~tst)
               (nil? ~tst)) ~else ~then))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro if-let "" [binding then & [else]]
  (let* [tst (gensym*)]
    `(let [~tst ~(nth* binding 1)
           ~(first* binding) ~tst] (if ~tst ~then ~else))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro when-some+ "" [binding &xs]
  (let* [tst (gensym*)]
    `(let [~tst ~(nth* binding 1)
           ~(first* binding) ~tst]
       (when (> (n# ~tst) 0) ~@xs))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro when-some "" [binding &xs]
  (let* [tst (gensym*)]
    `(let [~tst ~(nth* binding 1)
           ~(first* binding) ~tst]
       (when-not (or (undef? ~tst)
                     (nil? ~tst)) ~@xs))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro when-let "" [binding &xs]
  (let* [tst (gensym*)]
    `(let [~tst ~(nth* binding 1)
           ~(first* binding) ~tst] (when ~tst ~@xs))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro doto "" [target & xs]
  (let* [v (gensym*)]
    `(let [~v ~target]
       ~@(map* (lambda* [e]
                    `(~(first* e) ~v ~@(rest* e))) xs) ~v)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro map "" [f coll] `(.map ~coll ~f))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro filter "" [p coll] `(.filter ~coll ~p))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro some "" [p coll] `(.some ~coll ~p))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro take "" [coll cnt] `(slice ~coll 0 ~cnt))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro constantly "" [x] `(fn [&xs] ~x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro drop "" [coll cnt] `(slice ~coll ~cnt))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro reduce2 "" [f coll] `(.reduce ~coll ~f))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro reduce
  "" [f start coll] `(.reduce ~coll ~f ~start))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro str [&xs] `(.join (vec ~@xs) ""))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro lambda "" [code]
  (let* [sz (count* code)
         body (if* (> sz 1)
                   code
                   (if* (> sz 0) (nth* code 0)))]
    `(fn [] (var ____args (slice arguments)) ~body)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro each "" [func coll] `(.forEach ~coll ~func))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro each-key "" [func obj]
  (let* [t (gensym*)]
    `(let [~t ~obj]
       (each (fn [e]
               (~func (nth e 1) (nth e 0)))
             (Object.entries ~t)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro dosync "" [&exprs] `(do ~@exprs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;monads
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro monad

  "Define a monad by defining the monad operations. The definitions
   are written like bindings to the monad operations bind and
   unit (required) and zero and plus (optional)."

  [docstring operations]

  `(do (var~ bind unit zero plus)
       (let [~@operations]
         (hashmap
           :bind bind :unit unit :zero zero :plus plus))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro defmonad

  "Define a named monad by defining the monad operations. The definitions
   are written like bindings to the monad operations bind and
   unit (required) and zero and plus (optional)."

  [name & [docs operations]]
  (let* [ds (if* (is-str? docs) docs "")
         ps (if* (is-str? docs)
                 operations
                 (if* (is-array? docs) docs))
         _ (assert* (is-array? ps)
                    "no macro operations")]
    `(const ~name (monad ~ds ~ps))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro dobind "" [mbind steps expr]
  (let* [mv (nth* steps 1)
         a1 (nth* steps 0)
         more (rest* (rest* steps))]
    `(~mbind ~mv
             (fn [~a1]
               ~(if* (not-empty* more)
                     `(dobind ~mbind ~more ~expr)
                     `(do ~expr))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro domonad
  "Monad comprehension. Takes the name of a monad, a vector of steps
   given as binding-form, and a result value
   specified by body."
  [monad steps body]
  `((fn [{:keys [bind unit zero] :as mo}]
      (var ret #(if (and (kirbystdlibref/nichts? %)
                         (def? zero)) zero (unit %)))
      (dobind bind ~steps (ret ~body))) ~monad))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;testing stuff
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro deftest
  "" [name & body] `(const ~name #(vec ~@body)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro ensure "" [form msg]
  `(kirbystdlibref/ensureTest ~form ~msg))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro ensureThrown "" [expected form msg]
  `(try ~form
        (kirbystdlibref/ensureTestThrown ~expected nil ~msg)
        (catch e
          (kirbystdlibref/ensureTestThrown ~expected e ~msg))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF





