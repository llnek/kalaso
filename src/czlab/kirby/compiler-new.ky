;; Copyright Â© 2013-2018, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc "Transpiles kirby code to js code."
      :author "Kenneth Leung"}

  czlab.kirby.compiler

  (:require ["source-map" :as smap])
  (:require ["./stdlib"
             :as std
             :refer [lambdaArg? pairs? into! println
                     seq merge contains? last typeid
                     prn primitive set? map? vector?
                     opt?? some? primitive? regexObj?
                     unquote-str quote-str rseq cons
                     not-empty conj! list? obj?
                     gensym count pop! partition
                     difference carve split-with
                     symbol keyword symbol? keyword?]]
            ["./engine"
             :as rt
             :refer [KBSTDLR KBSTDLIB KBPFX EXPKEY]]
            ["./reader" :as reader :refer [jsid]])
  (:require ["fs" :as fs]
            ["path" :as path]
            ["esformatter" :as esfmt]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- ERRORS-MAP {
  :no-sourcemap-info "Expected source map info"
  :invalid-fargs "Invalid function args"
  :invalid-catch "Invalid catch clause"
  :invalid-try "Invalid try clause"
  :invalid-require "Invalid require clause"
  :invalid-namespace "Invalid namespace clause"
  :destruct-args "Bad destructure args"
  :outside-macro "Invalid clause outside of macro"
  :file-access "Failed file access"
  :file-read "Failed file read"
  :file-open "Failed to open file"
  :unknown-keyword "Unknown keyword"
  :invalid-arity "Invalid function arity"
  :invalid-meta "Invalid meta data"
  :syntax-error "Syntax error"
  :empty-form "Invalid form (empty)" })

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- ARRSLICE "Array.prototype.slice.call"
        JSARGS "arguments"
        LARGS "____args" BREAK "____break" MOD-VER "1.0.0")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- *externs* nil
      *macros* nil
      *last-line* 0
      *last-col* 0
      SPEC-OPS (object )
      MATH-OP-REGEX #/^[-+][0-9]+$/)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- unmangle "" [s]
  (->> (map #(reader/jsid %) (.split s ".")) (join ".")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn tnodeEx "Create a node"
  ^SourceNode [name &[chunk]] (tnode nil nil nil chunk name))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn tnode "Create a token
            with source information"
  ^SourceNode [&[source line col chunk name]]
  (new smap/SourceNode
       (opt?? line nil)
       (opt?? col nil)
       (opt?? source nil)
       (opt?? chunk nil) (opt?? name nil)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- doFuncArgs "Deal with possible destructuring
                  of args in function definition"
  ^Array [args env]
  (with-local-vars [e ? ev ? rval ? out ?
                    pms []
                    [fargs fdefs :as ret]
                    [(node' args) (node' args)]])
  (for* [e args]
    (cond
      (symbol? e)
      (if (== e "&")
        ;vargs
        (do->break!
          (set! rval (node' args)
                e (nexth args ____index))
          (rval.add [ARRSLICE "(" JSARGS "," (numStr ____index) ")"])
          (if (symbol? e)
            (fdefs.add ["let "
                        (tx* e env) "=" rval ";\n"])
            (do (set! out (node' args)
                      e (destruct* e out env))
                (fdefs.add ["let "
                            (tx* e env) "=" rval ";\n" out]))))
        ;ignore _
        (do (if (== e "_")
              (set! e (xfi e (gensym "U__")))) (conj! pms e)))
      (array? e)
      (do (set! rval (node' args)
                out (node' args)
                e (destruct* e out env))
          (rval.add [JSARGS "[" (numStr ____index) "]"])
          (conj! pms e)
          (fdefs.add out))
      :else
      (error! :destruct-args args)))
  (each #(fargs.add (tx* % env)) pms)
  (join "," fargs)
  ;;return back a list of function arguments, and the
  ;;rest of local variables in case of varargs or
  ;;arg-destructions
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destruct* "Decide on what the
                 rhs should be referred to 'as'"
  ^Symbol [coll out env]
  (with-local-vars [e ? rhs (gensym)])
  (for* [e coll]
    (when (and (keyword? e)
               (== e :as))
      (set! rhs (symbol $(nexth coll ____index)))
      (break-out-of-loop!)))
  (set! rhs (xfi coll rhs))
  ;handle a vec or a map destructure only
  (cond
    (map? coll)
    (out.add (destructMap rhs coll env))
    (vector? coll)
    (out.add (destructVec rhs coll env))) rhs)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destructVec "" ^SourceNode [src coll env]
  (with-local-vars [ret (node' coll)
                    e ? rval ? out ?
                    as (tx* src env)])
  (for* [e coll]
    (cond
      (symbol? e)
      (cond
        (== e "_")
        nil
        (== e "&")
        (do->break!
          (set! rval (node' coll)
                out (node' coll)
                e (nexth coll ____index))
          (rval.add [ARRSLICE "(" as "," (numStr ____index) ")"])
          (if-not (symbol? e)
            (set! e (destruct* e out env)))
          (ret.add ["let "
                    (tx* e env) "=" rval ";\n" out]))
        :else
        (ret.add ["let " (tx* e env) "="
                  (stripStd (str KBSTDLR ".getIndex"))
                  "(" as "," (numStr ____index) ");\n"]))
      (array? e)
      (do (set! rval (node' coll)
                out (node' coll)
                e (destruct* e out env))
          (rval.add [as "[" (numStr ____index) "]"])
          (ret.add ["let "
                    (tx* e env) "=" rval ";\n" out]))
      (keyword? e)
      (if (== e :as)
        (++ ____index)
        (error! :unknown-keyword coll))
      :else (error! :syntax-error coll))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destructMap "" ^SourceNode [src coll env]
  (with-local-vars [ret (node' coll)
                    e ? arr ?
                    as (tx* src env)])
  (for* [e coll]
    (if (keyword? e)
      (cond
        (or (== e :keys)
            (== e :strs))
        (do (set! arr (nexth coll ____index))
            (++ ____index)
            (doseq [a' arr]
              (ret.add ["let " (tx* a' env) "="
                        (stripStd (str KBSTDLR ".getProp"))
                        "(" as "," (std/quote-str $(a')) ");\n"])))
        (== e :as)
        (++ ____index)
        :else
        (error! :unknown-keyword coll))
      ;else
      (error! :syntax-error coll))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- simple? "" [ast]
  (or (undef? ast) (nil? ast) (str? ast) (num? ast) (bool? ast)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- wrap "" ^SourceNode [ret head tail]
  (if head (ret.prepend head))
  (if tail (ret.add tail)) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- exprHint "" ^Array [ast flag]
  (if (simple? ast)
    (set! ast (primitive ast)))
  (oset! ast :____expr flag) ast)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- stmt? "" [ast]
  (if (simple? ast) (error! :syntax-error ast)) (false? ast.____expr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- error! "" [e & [ast msg]]
  (raise! (get ERRORS-MAP e)
          (if msg (str " : " msg))
          (if (and ast ast.line) (str "\nline: " ast.line))
          (if (and ast ast.source) (str "\nfile: " ast.source))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- testre? "" [re x] (if x (re.test x) #f))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- pad "" [n] ^String (.repeat " " n))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- node' "" ^SourceNode [ast & [obj]]
  (set! obj (opt?? obj (tnode)))
  (oset! obj
         :source ast.source
         :line ast.line
         :column ast.column) obj)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txTree
  "Process a file unit.  Sort out all the macros first then others.
  Also, always check first for (ns ...)"
  ^SourceNode [root env]
  (with-local-vars [ms [] os []
                    t ? f ?
                    n1 (_1 root)
                    ret (node' root)])
  (if-not (== "ns" (_1 n1))
    (raise! "(ns ...) must be first form in file"))
  (conj! ms n1)
  (doseq [t (rest root)]
    (if (and (array? t)
             (symbol? (_1 t))
             (== "defmacro" (_1 t)))
      (conj! ms t)
      (conj! os t)))
  (each (fn [r]
          (set! *last-line* r.line *last-col* r.col)
          (if-some [t (tx* r env)] (ret.add [t ";\n"])))
        (.concat ms os))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txForm "" ^Any [expr env]
  (if (array? expr)
    (each (fn [a i arr]
            (aset arr i (tx* a env))) expr)) expr)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txAtom "Returns a SourceNode or String" ^Any [a]
  (with-local-vars [s (str a)])
  (cond (lambdaArg? a)
        (str LARGS "[" (-1 (int (rest s))) "]")
        (regexObj? a)
        (node' a (tnodeEx s (rest s)))
        (keyword? a)
        (node' a (tnodeEx s (quote-str s)))
        (symbol? a)
        (node' a (tnodeEx s (unmangle s)))
        (nil? a)
        "null"
        (primitive? a)
        (do (set! a a.value s $(a))
            (cond (string? a)
                  (quote-str a)
                  (nil? a) "null" :else s))
        (string? a)
        (quote-str a)
        :else (reader/jsid s)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- tx* "" ^Any [x & [env]]
  (if (array? x) (txPairs x env) (txAtom x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- gcmd "" ^String [ast]
  (cond (map? ast) "hash-map"
        (obj? ast) "object"
        (vector? ast) "vec"
        (set? ast) "hash-set"
        (list? ast) "list"
        (and (array? ast)
             (not (array? (_1 ast)))) $(_1 ast) :else ""))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quoteSingle "" ^String [a]
  (cond (keyword? a)
        (str (stripStd (str KBSTDLR ".keyword"))
             "(\"" a.value "\")")
        (symbol? a)
        (str (stripStd (str KBSTDLR ".symbol"))
             "(\"" a.value "\")")
        (primitive? a)
        (do (set! a a.value)
            (cond (string? a) (quote-str a)
                  (nil? a) "null"
                  :else $(a)))
        (string? a)
        (quote-str a)
        :else $(a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quote! "" ^SourceNode [ast env]
  (assertInfo ast)
  (if (array? ast)
    (if (map? ast)
      (quoteMap ast env)
      (quoteBlock ast env))
    (quoteSingle ast)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quoteMap "" ^SourceNode [ast env]
  (var cma ""
       ret (node' ast))
  (for* [e ast :step 2]
    (if (pos? ____index) (ret.add ","))
    (ret.add [(quote! e env)
              " , " (quote! (nexth ast ____index) env)]))
  (if-not (empty? ast) (set! cma ","))
  (wrap ret ["["
             (stripStd (str KBSTDLR ".symbol")) "(\"hash-map\")" cma] "]"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quoteBlock "" ^SourceNode [ast env]
  (with-local-vars [ret (node' ast)])
  (for* [e ast]
    (if (pos? ____index) (ret.add ","))
    (ret.add (quote! e env)))
  (wrap ret "[" "]"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- spreadInfo "" ^Any [from to]
  (if (and from
           (not (simple? from))
           (number? from.line)
           (array? to))
    (do (xfi from to)
        (doseq [t' to]
          (spreadInfo from t')))
    (xfi from to)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txPairs "" ^SourceNode [ast env]
  (with-local-vars
   [nsp (std/peekNSP)
    stmtQ (stmt? ast)
    ret (node' ast)
    cmd (gcmd ast)
    e1 (1st ast)
    orig ast
    op nil tmp nil
    mc (rt/getMacro cmd)])
  (xfi e1 ret)
  (xfi e1 ast)
  ;;handle macro calls
  (when mc
    (set! ast (rt/expand?? ast env mc)
          ast (xfi orig (exprHint ast (not stmtQ))))
    (spreadInfo orig ast)
    (set! cmd (gcmd ast)))
  ;;handle (+1 ) or (-1 ) cases
  (when (reader/REGEX.int.test cmd)
    (if-not (or (starts-with? cmd "+")
                (starts-with? cmd "-"))
      (set! cmd (str "+" cmd)))
    (set! ast (xfi ast [(symbol (ch@ cmd 0))
                        (_2 ast)
                        (int (rest cmd))])
          cmd $(_1 ast)))
  ;;maybe special form
  (set! op (get SPEC-OPS cmd))
  ;;handle all cases
  (cond
    (== cmd "with-meta")
    (ret.add (tx* (_2 (meta?? ast env)) env))
    (starts-with? cmd ".-")
    (ret.add [(tx* (_2 ast) env)
              "." (tx* (symbol (.slice cmd 2)) env)])
    (starts-with? cmd ".@")
    (do (set! tmp (if (starts-with? cmd ".@+") [3 #t] [2 #f]))
        (ret.add [(tx* (_2 ast) env)
                  "[" (.slice cmd (_1 tmp)) (if (_2 tmp) "+1]" "]")]))
    (starts-with? cmd ".")
    (do (ret.add [(tx* (_2 ast) env)
                  (tx* (symbol cmd) env) "("])
        (for* [e ast :start 2]
          (if (not= ____index 2) (ret.add ","))
          (ret.add (tx* e env)))
        (ret.add ")"))
    (some? op)
    (set! ret (op ast env))
    (and (or (== cmd "splice-unquote")
             (== cmd "unquote")
             (== cmd "syntax-quote"))
         (not (starts-with? (get nsp :id) KBPFX)))
    (error! :outside-macro ast)
    :else
    (do (if (pairs? ast)
          (do (txForm ast env)
              (set! cmd $(_1 ast)))
          (set! cmd (tx* ast env)))
        (if-not cmd (error! :empty-form ast))
        (set! cmd (stripStd cmd))
        (if (pairs? ast)
          (ret.add
            [(if (testre? reader/REGEX.func cmd) (str "(" cmd ")") cmd)
             "(" (join "," (rest ast)) ")"])
          (ret.add cmd))))
  (node' ast ret))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- writeDoc "Convert to jsdoc" ^Array [doc]
  (with-local-vars [out []])
  (if doc
    (->> (.split (unquote-str doc) "\n")
         (each #(let [s (.trim (str %))]
                  (if (not-empty s)
                    (conj! out (str "//" s "\n"))))))) out)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txDo "" ^SourceNode [ast env & [return?]]
  (with-local-vars [stmtQ (stmt? ast)
                    ret (node' ast)
                    e nil end (last-index ast)])
  (set! return?
        (if stmtQ #f (opt?? return? #t)))
  (for* [e ast :end end]
    (ret.add [(tx* (exprHint e #f) env) ";\n"]))
  (when (>= end 0)
    (set! e (exprHint (.@end ast)
                      (not stmtQ))
          e (tx* e env))
    (ret.add (if-not return?
               [e ";\n"]
               ["return " e ";\n"]))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- meta?? "" ^Array [obj env]
  (with-local-vars [mobj nil])
  (when (and (array? obj)
             (= 3 (n# obj))
             (symbol? (_1 obj))
             (== "with-meta" $(_1 obj)))
    (set! mobj (evalMeta (.@2 obj) env))
    (oset! (_2 obj) :____meta mobj)
    (set! obj (_2 obj)))
  [mobj obj])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fmtRegoSpecOps "" ^String [alias fname]
  (str (reader/jsid :SPEC-OPS) "[\"" alias "\"] = " fname))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fmtSpecOps "" ^String [fname attrs]
  (with-local-vars
    [ks (or (get attrs :opcode) [])
     out (->> (map #(fmtRegoSpecOps
                      (str %) fname) ks) (join ";\n"))])
  (if (not-empty ks) (str out ";\n") out))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- writeFuncPre "" [pre env]
  (with-local-vars
   [ret (node' pre)
    c2 ['if-not (concat ['and] pre)
        ['throw ['Error "Precondition failed"]]]])
  (ret.add [(-> (exprHint c2 #f) (tx* env)) ";\n"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- writeFuncInfo "" ^String [fname ast]
  (with-local-vars
   [file (if ast.source
           (.slice ast.source
             (+1 (.lastIndexOf ast.source "/"))) "?")
    s (str "//fn: [" fname "] in file: "
           file ", line: " (or ast.line "?") "\n")
    len (alen s)])
  (if (< len 80) (set! len 80))
  (str (.repeat "/" len) "\n" s))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- evalMeta "" ^Object [ast env]
  (with-local-vars
   [x (cond (array? ast)
            ast
            (keyword? ast)
            (into! :map [ast #t])
            (symbol? ast)
            (into! :map [(keyword ":tag") ast])
            :else
            (error! :invalid-meta ast))
    v (rt/compute x env)])
  ;(console.log (str "meta-obj=" (JSON/stringify v)))
  v)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- stripStd "" ^String [cmd]
  (with-local-vars [lib (str KBSTDLR ".")
                    nsp (std/peekNSP)])
  (set! cmd $(cmd))
  (if (and (starts-with? cmd lib)
           (== (get nsp :id) KBSTDLIB)) (.slice cmd (alen lib)) cmd))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- assertArity "" ^Any [kond ast]
  (if-not kond (error! :invalid-arity ast))
  (assertInfo ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- assertInfo "" ^Any [ast]
  (if (and false
           ast
           (not (simple? ast))
           (not (number? ast.line)))
    (error! :no-sourcemap-info ast)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- loadRLib
  "Load in all the exported macros from the external lib" ^String [info env]
  (with-local-vars [ast ? s ?
                    {:keys [ns macros]} info])
  ;(println "loadlib has " (n# macros) " macros")
  (each-key (fn [v k]
              (set! ast (rt/readAST v)
                    s (symbol (str ns "/" $(_2 ast))))
              (aset ast 1 s)
              (rt/compute ast env)) macros) ns)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;special-forms
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn sf-juxt

  "Takes a set of functions and returns a fn that is the juxtaposition
of those fns.  The returned fn takes a variable number of args, and
returns a vector containing the result of applying each fn to the
args (left-to-right).
((juxt a b c) x) => [(a x) (b x) (c x)]"

  ^{:opcode ["juxt"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 2) ast)
  (with-local-vars [ret (node' ast)])
  (ret.add ["function () {\n"
            "let ret=[]," LARGS "=" ARRSLICE "(" JSARGS ");\n"])
  (doseq [a' (rest ast)
          :let [f $(gensym "F__")]]
    (ret.add ["let " f "=" (tx* a' env) ";\n"
              "ret.push(" f ".apply(this," LARGS "));\n"]))
  (ret.add "return ret;\n}"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-deref

  "Returns an atom's current state."

  ^{:opcode ["deref"] :tag SourceNode} [ast env]

  (assertArity (= (n# ast) 2) ast)
  (with-local-vars [ret (node' ast)])
  (ret.add [(tx* (_2 ast) env) ".value"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-compose

  "Takes a set of functions and returns a fn that is the composition
of those fns.  The returned fn takes a variable number of args,
applies the rightmost of fns to the args, the next
fn (right-to-left) to the result, etc."

  ^{:opcode ["comp"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 2) ast)
  (with-local-vars [ret (node' ast)
                    f ? r ? prev ?
                    end (last-index ast)])
  (ret.add ["function () {\n"])
  (ret.add ["let " LARGS "=" ARRSLICE "(" JSARGS ");\n"])
  ;go backwards -> right to left
  ;keep track of prev result so that we can thread it
  ;to next function
  (for* [e ast :start end :end 0 :step -1]
    (set! f $(gensym "F__")
          r $(gensym "R__"))
    (ret.add ["let " f "=" (tx* e env) ";\n"])
    (if (= ____index end)
      (ret.add ["let " r "=" f ".apply(this," LARGS ");\n"])
      (ret.add ["let " r "=" f "(" prev ");\n"]))
    (set! prev r))
  (ret.add ["return " prev ";\n" "}"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-quote
  "Returns the unevaluated form"
  ^{:opcode ["quote"] :tag SourceNode} [ast env]
  (assertArity (= (n# ast) 2) ast)
  (with-local-vars [ret (node' ast)])
  (wrap ret nil (quote! (_2 ast) env)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-deftype
  "Define a JS Class"
  ^{:opcode ["deftype" "deftype-"] :tag SourceNode}
  [ast env]
  (assertArity (>= (n# ast) 3) ast)
  (with-local-vars
   [pub? (not (ends-with? $(_1 ast) "-"))
    mtd ? pos ? n ? m ? cn ?
    ret (node' ast)
    czname0 (_2 ast)
    czname (tx* czname0 env)
    par (_1 (.@2 ast))
    ;maybe a docstring is there?
    [doc mtds] (if (str? (.@3 ast))
                 [(.@3 ast) (slice ast 4)]
                 [nil (slice ast 3)])])
  ;put var into genv
  (.addVar env
           czname0
           {:ns (std/*ns*) :alias czname0 :type :class})
  (ret.add ["class " czname])
  (if par (ret.add [" extends " (tx* par env)]))
  (ret.add " {\n")
  (each (fn [m]
          ;;maybe doc string?
          (set! mtd 'method
                m1 (_1 m)
                cn (str czname0 "." m1)
                pos (if (str? (_2 m)) 3 2))
          ;;pass line info
          (each #(xfi m1 %) [mtd m])
          ;fake a keyword 'method' in front
          (m.unshift mtd)
          ;put scoped-method into env
          (.addVar env
                   cn
                   {:ns (std/*ns*) :alias cn :type :method})
          ;compiles it like a function
          (ret.add [(sf-func m env #f) "\n"])) mtds)
  ;stick doco in front, if any
  (if doc (ret.prepend (writeDoc doc)))
  ;maybe export this type?
  (if pub? (assoc! *externs* czname czname))
  (ret.add "}\n"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-compOp "Handle comparison operators."

  ^{:opcode ["not=" "!="
             "==" "="
             ">" ">=" "<" "<="]
    :tag SourceNode} [ast env]

  (assertArity (and (>= (n# ast) 3)
                    (odd? (n# ast))) ast)

  (with-local-vars [ret (node' ast)
                    end 0
                    op ?
                    a0 (_1 ast) cmd $(a0)])
  (cond (== cmd "not=") (aset ast 0 '!==)
        (== cmd "=") (aset ast 0 '===))
  (set! a0 (_1 ast)
        op a0
        end (last-index ast))
  (for* [e ast :start 1 :end end]
    (if (not= ____index 1) (ret.add " && "))
    (ret.add [(tx* e env)
              " " op " " (tx* (nexth ast ____index) env)]))
  (wrap ret "(" ")"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-arithOp
  "Handles math operators"
  ^{:opcode ["bit-shift-left" "bit-shift-right" "unsigned-bit-shift-right"
             "+" "-" "*" "/" "div" "mod"
             "or" "and" "exp" "rem"
             "bit-and" "bit-or" "bit-not" "bit-xor"]
    :tag SourceNode}
  [ast env]

  (assertArity (>= (n# ast) 2) ast)
  (with-local-vars
    [ret (node' ast)
     e1 $(1st ast)
     cmd (case e1
           "unsigned-bit-shift-right" ">>>"
           "bit-shift-right" ">>"
           "bit-shift-left" "<<"
           "bit-and" "&"
           "bit-or" "|"
           "bit-not" "~"
           "bit-xor" "^"
           "rem" "%"
           "div" "/"
           "and" "&&"
           "or" "||"
           "exp" "**"
           e1)])
  (cond
    (== "mod" cmd)
    (ret.add [KBSTDLR ".modulo("
              (tx* (.@1 ast) env) "," (tx* (.@2 ast) env) ")"])
    (== "~" cmd)
    (ret.add ["~" (tx* (.@1 ast) env)])
    :else
    (do ;handle negative number e.g. (- -2)= -1*-2
        (if (and (== "-" cmd)
                 (= 2 (n# ast))) (ret.add "-1 * "))
        (for* [e ast :start 1]
          (when (> sz 2)
            (if (> ____index 1) (ret.add [" " cmd " "])))
          (ret.add (tx* e env)))))
  (wrap ret "(" ")"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-do

  "Evaluates the expressions in order and returns the value of the last. If no
expressions are supplied, returns nil."

  ^{:opcode ["do"] :tag SourceNode} [ast env]

  (assertArity true ast)
  (with-local-vars [ret (node' ast)
                    stmtQ (stmt? ast)])
  (ret.add (txDo (exprHint (xfi ast (rest ast))
                           (not stmtQ)) env (not stmtQ)))
  (if stmtQ
    (wrap ret nil "")
    (wrap ret
          "(function() {\n" "}).call(this)")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-case

  "Takes an expression, and a set of clauses.
 Each clause can take the form of either:
 test-constant result-expr
 (test-constant1 ... test-constantN)  result-expr
 The test-constants are not evaluated. They must be compile-time
literals, and need not be quoted.  If the expression is equal to a
test-constant, the corresponding result-expr is returned. A single
default expression can follow the clauses, and its value will be
returned if no clause matches."

  ^{:opcode ["case"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 4) ast)
  (with-local-vars
    [stmtQ (stmt? ast)
     ret (node' ast)
     e ? t ? c ? dft ?
     tst (_2 ast)
     brk ";\nbreak;\n"
     gs $(gensym "C__")])
  ;look for any default clause
  (if (odd? (n# ast))
    (set! dft (_1 (pop! ast))))
  (for* [e ast :start 2 :step 2]
    (set! c (tx* (nexth ast ____index) env))
    (if (pairs? e)
      (for* [e' e]
        (ret.add ["case " (tx* e' env) ":\n"])
        (if (= ____index (last-index e))
          (ret.add [gs "=" c brk])))
      (ret.add ["case " (tx* e env) ":\n" gs "=" c brk])))
  ;maybe add the default clause
  (if dft
    (ret.add ["default:\n"
              gs "=" (tx* dft env) brk]))
  ;wrap the switch construct around it
  (wrap ret ["switch (" (tx* tst env) ") {\n"] "}")
  (if stmtQ
    (wrap ret ["let " gs ";\n"] "")
    (wrap ret
          ["(function() { let " gs ";\n"]
          ["return " gs ";}).call(this)"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-var

  "Creates a variable with an initial value"

  ^{:opcode ["const-" "const" "def-" "def" "var" "vars"]
    :tag SourceNode} [ast env]

  (assertArity (odd? (n# ast)) ast)
  (with-local-vars [rval ? rc ? lhs ? rhs ?
                    ret (node' ast)
                    cmd $(_1 ast)
                    x ?
                    keys {}
                    tmp nil vname nil
                    pub? (or (== cmd "def")
                             (== cmd "const"))])
  (set! cmd (if (starts-with? cmd "const")
              "const"
              (if (or (== cmd "var")
                      (== cmd "vars")) "let" "var")))
  ;deal with 1 level destruction
  (for* [lhs ast :start 1 :step 2]
    (set! rhs (nexth ast ____index)
          rval (tx* rhs env))
    (if (symbol? lhs)
      (do (set! x lhs
                lhs (tx* lhs env))
          (if-not (== "let" cmd)
            (.addVar env
                     $(x)
                     {:ns (std/*ns*) :alias $(x) :type :var}))
          (assoc! keys lhs lhs)
          (ret.add [cmd " " lhs "=" rval ";\n"]))
      (do (set! out (node' ast)
                rhs (destruct* lhs out env))
          (ret.add ["let " (tx* rhs env) "=" rval ";\n" out]))))
  (if pub?
    (each-key #(assoc! *externs* %2 %1) keys)) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-inst?

  "Evaluates x and tests if it is an instance of the class
  c. Returns true or false.
  (inst? c x)"

  ^{:opcode ["inst?"] :tag SourceNode} [ast env]

  (assertArity (= (n# ast) 3) ast)
  (wrap (node' ast) nil ["(" (tx* (_3 ast) env)
                         " instanceof " (tx* (_2 ast) env) ")"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-delete

  "Delete an object or property of an object."

  ^{:opcode ["delete!"] :tag SourceNode} [ast env]

  (assertArity (and (>= (n# ast) 2)
                    (< (n# ast) 4)) ast)
  (with-local-vars [ret (node' ast)])
  (ret.add ["delete "
            (tx* (_2 ast) env)])
  (if (> (n# ast) 2)
    (ret.add ["[" (tx* (.@2 ast) env) "]"])) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-dissoc!

  "Remove a key from Map."

  ^{:opcode ["dissoc!"] :tag SourceNode} [ast env]

  (assertArity (= (n# ast) 3) ast)
  (with-local-vars [ret (node' ast)])
  (ret.add
    [(stripStd (str KBSTDLR
                    "." (tx* (symbol "dissoc!") env)))
     "("
     (tx* (_2 ast) env)
     "," (tx* (.@2 ast) env) ")"]) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-new

  "The args, if any, are evaluated from left to right,
  and passed to the constructor of the class
  named by Classname. The constructed object is returned.
  e.g.
  (new Error 'a' 3)"

  ^{:opcode ["new"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 2) ast)
  (wrap (node' ast) "new " (tx* (xfi ast (rest ast)) env)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-throw

  "Throw an exception"

  ^{:opcode ["throw"] :tag SourceNode} [ast env]

  (assertArity (= (n# ast) 2) ast)
  (with-local-vars [ret (node' ast)
                    stmtQ (stmt? ast)])
  (ret.add ["throw " (tx* (xfi ast (_2 ast)) env)])
  (if-not stmtQ
    (wrap ret
          "(function (){ "
          ";}).call(this)")) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-x-opop

  "Unary operator for increment & decrement"
  ^{:opcode ["++" "--" "++$" "--$"] :tag SourceNode} [ast env]

  (assertArity (= (n# ast) 2) ast)
  (with-local-vars [ret (node' ast)
                    cmd $(_1 ast)
                    a2 (tx* (_2 ast) env)])
  (ret.add
    (if (ends-with? cmd "$")
      [a2 (.slice cmd 0 -1)] [cmd a2])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-x-eq

  "Compound assignment operators"

  ^{:opcode ["+=" "-=" "*=" "/="
             "div=" "rem=" "exp="
             "bit-and="
             "bit-or="
             "bit-xor="
             "bit-shift-left="
             "bit-shift-right="
             "unsigned-bit-shift-right="]
       :tag SourceNode} [ast env]

  (assertArity (= (n# ast) 3) ast)
  (with-local-vars
   [a0 $(_1 ast)
    cmd (case a0
          "unsigned-bit-shift-right=" ">>>="
          "bit-shift-right=" ">>="
          "bit-shift-left=" "<<="
          "bit-xor=" "^="
          "bit-or=" "|="
          "bit-and=" "&="
          "div=" "/="
          "rem=" "%="
          "exp=" "**=" a0)])
  (wrap (node' ast)
        "("
        [(tx* (_2 ast) env)
         " " cmd " " (tx* (_3 ast) env) ")"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-assoc!
  "Object property assignment or array index setter."
  ^{:opcode ["assoc!"] :tag SourceNode} [ast env]
  (assertArity (even? (n# ast)) ast)
  (with-local-vars [ret (node' ast)
                    obj (tx* (_2 ast) env)])
  (for* [e ast :start 2 :step 2]
    (if (> ____index 2) (ret.add ","))
    (ret.add
      [(stripStd (str KBSTDLR "." (tx* (symbol "assoc!") env)))
       "(" obj ","
       (tx* (xfi ast e) env) ","
       (tx* (xfi ast (nexth ast ____index)) env) ")"]))
  (wrap ret "(" ")"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-assign!
  "Object property assignment or array index setter."
  ^{:opcode ["oset!" "aset"] :tag SourceNode} [ast env]
  (assertArity (even? (n# ast)) ast)
  (with-local-vars [ret (node' ast)
                    obj (tx* (_2 ast) env)])
  (for* [e ast :start 2 :step 2]
    (if (> ____index 2) (ret.add ","))
    (ret.add [obj
              "[" (tx* (xfi ast e) env) "]"
              "=" (tx* (xfi ast (nexth ast ____index)) env)]))
  (wrap ret "(" ")"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-set

  "Set value(s) to variable(s).
  e.g. (set! a 2 b 4 ...)"

  ^{:opcode ["set!" "var-set"] :tag SourceNode} [ast env]

  (assertArity (odd? (n# ast)) ast)
  (with-local-vars [ret (node' ast)])
  (for* [e ast :start 1 :step 2]
    (if (> ____index 1) (ret.add ","))
    (ret.add [(tx* e env)
              "=" (tx* (xfi ast (nexth ast ____index)) env)]))
  (wrap ret "(" ")"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-fn

  "Defines an anonymous function. See defn.
  (fn attrs? [x y] ...)"

  ^{:opcode ["fn"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 2) ast)
  (with-local-vars [body (xfi ast (slice ast 2))
                    [_ args] (meta?? (2nd ast) env)])
  (if-not (array? args)
    (error! :invalid-fargs ast))
  (with-local-vars
    [fargs (doFuncArgs (xfi ast args) env)])
  (wrap (node' ast)
        nil
        ["function (" (_1 fargs) ") {\n"
         (_2 fargs) (txDo body env #t) "}"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-func

  "Defines a function. Use defn- to indicate privacy (no export).
  (defn name doc-string? attr-map? [params*] ...)"

  ^{:opcode ["defn" "defn-"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 2) ast)
  (with-local-vars
    [pub? (not (ends-with? $(_1 ast) "-"))
     mtd? (== $(_1 ast) "method")
     fname0 $(_2 ast)
     fname $(tx* (_2 ast) env)
     dot? (contains? fname ".")
     ret (node' ast (tnodeEx fname))
     [doc pargs] (if (str? (_3 ast))
                   [(nth ast 2) 3] [nil 2])
     body (xfi ast (slice ast (+1 pargs)))
     b1 (_1 body)
     [attrs args] (meta?? (nth ast pargs) env)])
  (if-not mtd?
    (.addVar env
             fname0
             {:ns (std/*ns*) :alias fname0 :type :fn}))
  (if-not (array? args)
    (error! :invalid-fargs ast))
  (with-local-vars [pre ? post ? e ? e2 ?
                    fargs (doFuncArgs (xfi ast args) env)])
  (set! attrs (or attrs {}))
  (when (map? b1)
    (for* [e b1 :step 2]
      (set! e2 (nexth b1 ____index))
      (when (and (keyword? e)
                 (array? e2))
        (cond (== e :post) (set! post e2)
              (== e :pre) (set! pre e2)))))
  (cond mtd?
        (do (if (.-static attrs)
              (ret.add "static "))
            (ret.add [fname " ("])
            (if (== fname "constructor")
              (conj! body 'this)))
        dot?
        (ret.add [fname " = function ("])
        :else
        (ret.add ["const " fname " = function ("]))
  (ret.add [(_1 fargs) ") {\n" (_2 fargs)])
  (when (or pre post)
    (set! body (rest body))
    (ret.add (writeFuncPre (xfi ast pre) env)))
  (ret.add [(txDo body env #t) "};\n"])
  (if (not-empty attrs)
    (ret.add (fmtSpecOps fname attrs)))
  (if doc
    (ret.prepend (writeDoc doc)))
  (if (and pub?
           (not dot?)
           (not mtd?))
    (assoc! *externs* fname fname))
  (ret.prepend (writeFuncInfo fname0 ast)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-try

  "The exprs are evaluated and, if no exceptions occur, the value of the last
is returned. If an exception occurs and catch clauses are provided, each is
examined in turn and the first for which the thrown exception is an instance
of the named class is considered a matching catch clause. If there is a
matching catch clause, its exprs are evaluated in a context in which name is
bound to the thrown exception, and the value of the last is the return value
of the function. If there is no matching catch clause, the exception
propagates out of the function. Before returning, normally or abnormally,
any finally exprs will be evaluated for their side effects."

  ^{:opcode ["try"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 2) ast)
  (with-local-vars [stmtQ (stmt? ast)
                    t ? f ? c ?
                    sz (n# ast)
                    ret (node' ast)])
  ;;look for finally
  (set! f (last ast))
  (if (and (array? f)
           (== $(_1 f) :finally))
    (do (pop! ast)
        (set! sz (n# ast))
        (xfi (_1 f) f))
    (nil! f))
  ;;look for catch
  (nil! c)
  (if (> sz 1)
    (set! c (nth ast (-1 sz))))
  (if (and (array? c)
           (== $(_1 c) :catch))
    (do (if (or (< (n# c) 2)
                (not (symbol? (_2 c))))
          (error! :invalid-catch ast))
        (pop! ast)
        (xfi (_1 c) c))
    (nil! c))
  ;;try needs either a catch or finally or both
  (if (and (nil? f)
           (nil? c)) (error! :invalid-try ast))
  (ret.add ["try {\n"
            (txDo (exprHint (xfi ast (rest ast))
                            (not stmtQ)) env) "\n}"])
  (when c
    (set! t (_2 c))
    (ret.add [(str "catch (" (tx* t env) ") {\n")
              (txDo (exprHint (xfi c (slice c 2))
                              (not stmtQ)) env) ";\n}\n"]))
  (when f
    (ret.add ["finally {\n",
              (txDo (exprHint (xfi f (rest f)) #f) env #f) ";\n}\n"]))
  (if-not stmtQ
    (wrap ret "(function(){\n" "}).call(this)")) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-if

  "Evaluates test. If truthy evaluates 'then' otherwise 'else'.

  (if test then else)
  (if test then)"

  ^{:opcode ["if"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 3) ast)
  (with-local-vars
    [stmtQ (stmt? ast)
     ret (node' ast)
     ;test is always an expression
     a1 (exprHint (xfi ast (_2 ast)) #t)
     a2 (exprHint (xfi ast (_3 ast)) (not stmtQ))
     m? (> (n# ast) 3)
     a3 (if m? (xfi ast (.@3 ast)))
     elze (if m? (exprHint a3 (not stmtQ)))])
  (set! a1 (tx* a1 env)
        a2 (tx* a2 env)
        elze (tx* elze env))
  (wrap ret
        nil
        (if stmtQ
          ["if (" a1 ") {\n" a2 ";\n}"
           (if m? [" else { \n" elze ";\n}"] "")]
          ["(" a1 " ?\n" a2 " :\n" (or elze "null") ")"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-get

  "Returns the named property of an object,
  or value at the index of an array.

  (get obj \"age\")
  (aget obj 4)
  (nth obj 3)"

  ^{:opcode ["oget" "nth" "get" "aget"] :tag SourceNode} [ast env]

  (assertArity (= (n# ast) 3) ast)
  (with-local-vars [a0 $(_1 ast)
                    cmd (stripStd (str KBSTDLR ".getProp"))])
  (if (== a0 "get")
    (wrap (node' ast)
          nil [cmd "("
               (tx* (xfi ast (_2 ast)) env)
               "," (tx* (xfi ast (_3 ast)) env) ")"])
    (wrap (node' ast)
          nil [(tx* (xfi ast (_2 ast)) env)
               "[" (tx* (xfi ast (_3 ast)) env) "]"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-array

  "Creates a new vector containing the args.

  (vec \"hello\" \"world\")
  (vec 1 2 3)
  [1 2 3]
  [\"hello\" \"world\"]"

  ^{:opcode ["vec"] :tag SourceNode} [ast env]

  (assertArity true ast)
  (with-local-vars [pos 0
                    ret (node' ast)])
  (if (empty? ast)
    (ret.add "[]")
    (do (if-not (vector? ast) (set! pos 1))
        (ret.add "[ ")
        (for* [e ast :start pos]
          (if (> ____index pos) (ret.add ", "))
          (ret.add (tx* (xfi ast e) env)))
        (ret.add " ]"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-objObj
  "Returns a new object with supplied key-mappings.
  (object \"a\" 1 \"b\" 2)
  {:a 1 :b 2}"
  ^{:opcode ["object"] :tag SourceNode} [ast env]
  (assertArity true ast)
  (with-local-vars [pos 0
                    ret (node' ast)])
  (if-not (obj? ast) (set! pos 1))
  (for* [e ast :start pos :step 2]
    (if (> ____index pos) (ret.add ", "))
    (ret.add [(tx* e env)
              ": " (tx* (xfi ast (nexth ast ____index)) env)]))
  (wrap ret "{" "}"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-mapObj
  ""
  ^{:opcode ["hash-map"] :tag SourceNode} [ast env]
  (assertArity true ast)
  (with-local-vars [pos 0
                    ret (node' ast)])
  (if-not (map? ast) (set! pos 1))
  (for* [e ast :start pos :step 2]
    (if (> ____index pos) (ret.add ","))
    (ret.add ["[" (tx* e env)
              "," (tx* (xfi ast (nexth ast ____index)) env) "]"]))
  (wrap ret "(new Map([" "]))"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-setObj

  "Returns a new Set.
  (set 1 2 3)"

  ^{:opcode ["hash-set"] :tag SourceNode} [ast env]

  (assertArity true ast)
  (with-local-vars [pos 0
                    ret (node' ast)])
  (if-not (set? ast)(set! pos 1))
  (for* [e ast :start pos]
    (if (> ____index pos) (ret.add ", "))
    (ret.add (tx* e env)))
  (wrap ret "(new Set([" "]))"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- require! "" [path]
  ;(println "require path = " path)
  (require path))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-require

  "Loads libs.

  (:require [\"z\" :rename {hello goodbye}])
  (:require [\"a\" :as A])
  (:require [\"b\"]
            [\"c\" :refer [hello world]])"

  ^SourceNode [ast env]

  (assertArity (>= (n# ast) 2) ast)
  (with-local-vars
    [rlib ? as ? rpath ?
     v ? mcs ? nsp ?
     macros_only ?
     info ? libpath ?
     e ? refers ? renames ?
     ret (node' ast)
     fdir (path/dirname ast.source)])
  (for* [e ast :start 1]
    (set! as $(gensym "R__")
          macros_only #f
          refers nil renames nil)
    (if-not (and (array? e)
                 (string? (_1 e))) (error! :invalid-require ast))
    (set! rpath $(_1 e))
    (for* [v e :start 1]
      (cond (== v :as)
            (do (set! as $(nexth e ____index))
                (++ ____index))
            (== v :only)
            (do (if (== $(nexth e ____index) :macros)
                  (true! macros_only))
                (++ ____index))
            (== v :refer)
            (do (set! refers (nexth e ____index))
                (++ ____index))
            (== v :rename)
            (do (set! renames (nexth e ____index))
                (++ ____index))))
    (if (.includes rpath "./")
      (set! libpath (path/resolve fdir rpath))
      (set! libpath rpath))
    (set! libpath (tx* libpath env))
    (if-not macros_only
      (ret.add ["const " (reader/jsid as)
                "= require(" (tx* rpath env) ");\n"]))
    ;load the lib
    (set! rlib (require! (unquote-str libpath))
          info (get rlib EXPKEY))
    (if info
      (set! mcs (get info :macros)
            nsp (loadRLib info env)))
    (.addLib env $(as) rlib)
    (set! mcs (or mcs {}))
    (with-local-vars [t ? r ? rs ? f ? m ? ro ?])
    (for* [r refers ]
      (set! rs $(r)
            v (tx* r env)
            f (get rlib (reader/jsid rs))
            m (get mcs rs))
      (if f (set! t (typeid f)))
      (if m (set! t :marco))
      (if-not (or f m) (raise! "Unknown var " rs))
      (.addVar env
               rs
               {:ns nsp :alias rs :type t})
      (ret.add ["const " v "=" as "[\"" v "\"];\n"]))
    (for* [ro renames :step 2]
      (set! e (tx* ro env)
            r (nexth renames ____index)
            rs $(r)
            v (tx* r env)
            f (get rlib (reader/jsid $(ro)))
            m (get mcs $(ro)))
      (if f (set! t (typeid f)))
      (if m (set! t :marco))
      (if-not (or f m) (raise! "Unknown var " ro))
      (.addVar env
               rs
               {:ns nsp :alias $(ro) :type t})
      (ret.add ["const " v
                "=" as "[\"" e "\"];\n"]))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-ns

  "(ns name doc-string? attr-map? references*)

  Creates a namespace, references can be zero or more of:
  (:require ...)

  (ns ^{:doc \"some doc\"} hello.world.core ...)"

  ^{:opcode ["ns"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 2) ast)
  (with-local-vars [ret [] doc nil e nil
                    mobj nil pos 2
                    [attrs nsp] (meta?? (2nd ast) env)])
  (if-not (symbol? nsp)
    (error! :invalid-namespace ast))
  (when (string? (.@pos ast))
    (set! attrs (or attrs {}))
    (assoc! attrs :doc (.@pos ast)) (++ pos))
  (when (map? (.@pos ast))
    (set! mobj (evalMeta (.@pos ast) env)
          attrs (merge attrs mobj))
    (++ pos)
    (oset! nsp :____meta attrs))
  (std/pushNSP $(nsp) attrs)
  ;;(println (str "Processing namespace: " $(nsp)))
  (set! ast (xfi ast (slice ast pos)))
  (doseq [e ast]
    (when (pairs? e)
      (cond
        (== $(_1 e) :require)
        (conj! ret (sf-require (xfi ast e) env)))))
  ;;force a internal reference to stdlib for user files
  ;;unless processing internal files
  (set! nsp (std/*ns*))
  (cond
    (= nsp (str KBPFX "stdlib"))
    nil
    (starts-with? nsp KBPFX)
    (conj! ret
           (str "const " KBSTDLR "=std;\n"))
    :else
    (->> (-> (xfi ast '(require ["kirby" :as kirbystdlibref]))
             (sf-require env))
         (conj! ret )))
  (conj! ret
         (str "const "
              std/MODULE_NAMESPACE
              "= " (std/quote-str nsp) ";\n")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-comment "" ^{:opcode ["comment"] :tag String} [ast env] "")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-for

  "Generates native (js) for loop.

  (for* [initial-vars :while test :recur update-vars] ...)"

  ^{:opcode ["for*"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 2) ast)
  (with-local-vars [stmtQ (stmt? ast)
                    ret (node' ast)
                    body (exprHint (xfi ast (slice ast 2)) #f)])
  (if (empty? body)
    ret
    (sf-floop ret
              (xfi ast (_2 ast))
              body env stmtQ)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-floop
  "For loop implementation"
  ^SourceNode [ret args body env stmtQ]

  (with-local-vars
    [vars [] recurs [] tst ? nb ? k ? e ?])
  (for* [e args]
    (cond (== e :while)
          (do (set! tst (nexth args ____index)) (++ ____index))
          (== e :recur)
          (do->break! (set! recurs (slice args (+1 ____index))))
          (symbol? e)
          (do (conj! vars e (nexth args ____index)) (++ ____index))))
  (ret.add "for (")
  (for* [e vars :step 2]
    (if (= ____index 0) (ret.add "let "))
    (if (not= ____index 0) (ret.add ","))
    (ret.add [(tx* e env)
              "=" $(tx* (nexth vars ____index) env)]))
  (ret.add (if (empty? vars)
             (str "let " BREAK "=false;")
             (str "," BREAK "=false;")))
  (set! nb '(not ____break))
  (xfi ret nb)
  (if tst
    (set! tst ['and nb tst])
    (set! tst nb))
  (xfi ret tst)
  (ret.add [$(tx* tst env) "; "])
  (set! k 0)
  (for* [e recurs]
    (if (not= ____index 0) (ret.add ","))
    (ret.add [(tx* (nth vars k) env) "=" $(tx* e env)])
    (+= k 2))
  (ret.add ["){\n" (txDo body env #f) "}\n"])
  (if-not stmtQ
    (wrap ret "(function() {\n"  "; return null; }).call(this)")) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-jscode

  "Inject raw native (js) code fragment.

  (raw# \"console.log('hi');\")"

  ^{:opcode ["raw#" "js#"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 2) ast)
  (with-local-vars [s $(_2 ast)
                    name (reader/jsid "sf-jscode")])
  (->>
    (if (and (ends-with? s "\"")
             (starts-with? s "\""))
      (.slice s 1 -1) s) (tnodeEx name) (node' ast)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-macro

  "Like defn, but the resulting function name is declared as a
macro and will be used as a macro by the compiler when it is
called.

  (defmacro macro-name [args] ...)"

  ^{:opcode ["defmacro"] :tag String} [ast env]

  (assertArity (>= (n# ast) 4) ast)
  (with-local-vars [pms []
                    args (_3 ast)
                    body (slice ast 3)
                    mname ? mobj ?
                    doc ? x ? e ? ev ?])
  (when (str? args)
    (set! doc args args (.@3 ast) body (slice ast 4)))
  (set! x (meta?? args env))
  (set! args (last x))
  (set! mobj (_1 x))
  (for* [e args]
    (set! ev $(e))
    (cond (== ev "&")
          (if (array? (nexth args ____index))
            (do (set! e (nexth args ____index))
                (++ ____index)
                (doseq [x e]
                  (if-not (symbol? x)
                    (error! :syntax-error ast))
                  (conj! pms x)))
            (do (conj! pms e (nexth args ____index))
                (++ ____index)))
          (not (symbol? e))
          (error! :syntax-error ast)
          :else
          (conj! pms e)))
  ;ask engine to compile this macro and stores it
  (set! mname (_2 ast)
        ast ['macro* mname pms (_1 body)])
  ;try to register it
  (.addVar env
           mname
           {:ns (std/*ns*) :alias nil :type :macro})
  ;if not private, need to export it
  (if-not (and mobj
               (true? (get mobj :private)))
    (assoc! *macros* mname (std/prn ast #t)))
  ;compile it
  (rt/compute ast env) "")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-unary

  "Special unary operators."

  ^{:opcode ["not" "!"] :tag SourceNode} [ast env]

  (assertArity (= (n# ast) 2) ast)
  (with-local-vars [[a0 a1] ast
                    ret (node' ast)])
  (if (== a0 "not") (set! a0 '!))
  (ret.add ["(" $(tx* a0 env) $(tx* a1 env) ")"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-listc

  "List comprehension. Takes a vector of one or more
 binding-form/collection-expr pairs, each followed by zero or more
 modifiers, and yields a lazy sequence of evaluations of expr.
 Collections are iterated in a nested fashion, rightmost fastest,
 and nested coll-exprs can refer to bindings created in prior
 binding-forms.  Supported modifiers are: :let [binding-form expr ...],
 :while test, :when test.
 (take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)] [x y]))"

  ^{:opcode ["for"] :tag SourceNode} [ast env]

  (with-local-vars
    [stmtQ (stmt? ast)
     ret (node' ast)
     cap (gensym)
     r (sf-doseq (exprHint ast #f) env cap)])
  (ret.add ["(function() {\n"])
  (ret.add ["let " $(cap) "=[];\n"])
  (ret.add r)
  (ret.add ["return " $(cap) ";\n}).call(this)"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-doseq

  "Repeatedly executes body (presumably for side-effects) with
bindings and filtering as provided by \"for\".  Does not retain
the head of the sequence. Returns nil."

  ^{:opcode ["doseq"] :tag SourceNode} [ast env & [capRes]]

  (with-local-vars
    [body (exprHint (xfi ast (slice ast 2)) #f)
     kount (stripStd (str KBSTDLR ".count"))
     args (2nd ast)
     _ (assert (even? (n# args)) "bindings not even")
     stmtQ (stmt? ast)
     inner ""
     ret ?
     fst #t
     while' (gensym)
     [x y] (split-with
             #(not (keyword? %)) args)
     ;reverse the bindings (inside out)
     arr (rseq (partition 2 x))])
  (loop [p1 (1st arr)
         pn (rest arr)]
    (when p1
      (with-local-vars [e' (gensym)
                        n' (gensym)])
      (set! ret (node' ast))
      (ret.add
        ["for(let " $(n') "=0,"
         (if (empty? pn) (str $(while') "=true,") "")
         $(e') "=" (tx* (2nd p1) env) ","
         "____sz=" kount "(" $(e') ")"
         (if fst ",____break=false" "") "; ("
         (if fst "!____break && " "")
         $(while') " && "
         "(" $(n') " < ____sz)"
         "); ++" $(n') "){\n"])
      (ret.add (sf-var (xfi ast ['vars (1st p1) ['nth e' n']]) env))
      (if fst
        (do (false! fst)
            (doseq-binds while' ret y body ast env capRes))
        (ret.add inner))
      (ret.add "}\n")
      (set! inner ret)
      (if (not-empty pn)
        (recur (1st pn) (rest pn)))))
  (if-not stmtQ
    (wrap ret
          "(function() {\n"
          "; return null; }).call(this)")) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- doseq-binds "" [while' ret y body ast env capRes]
  (with-local-vars [patch (node' ast)])
  (each
    (fn [[k expr]]
      (cond
        (== k :let)
        (ret.add (sf-var (xfi ast (cons 'vars expr))))
        (== k :when)
        (do (ret.add ["if (" (tx* expr env) ") {\n"])
            (patch.add "}\n"))
        (== k :while)
        (do (ret.add ["if (!(" (tx* expr env) ")) { " $(while') "=false; ____break=true; } else {\n"])
            (patch.add "}\n"))))
    (partition 2 y))
  (if capRes
    (exprHint body #t))
  (if capRes
    (ret.add [ $(capRes) ".push((function() {\n" (txDo body env #t) "\n}).call(this));\n"])
    (ret.add (txDo body env #f)))
  (ret.add patch))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- getPrePost "" [obj]
  (with-local-vars [ret nil e2 ?])
  (when (map? obj)
    (for* [e obj :step 2]
      (set! e2 (nexth obj ____index))
      (if (and (keyword? e)
               (array? e2))
        (cond (== e :post)
              (set! ret (merge ret {:post e2}))
              (== e :pre)
              (set! ret (merge ret {:pre e2}))))))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- xfi "Transfer source map info" ^Any [from to]
  (cond
    (and from to)
    (let [tline (.-line to)
          fline (.-line from)]
      (if (and (not (number? tline))
               (number? fline))
        (oset! to
               :source (.-source from)
               :line (.-line from)
               :column (.-column from))) to)
    :else to))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- spitMacros "" []
  (if (empty? *macros*)
    ""
    (-> (map (fn [[k v]]
             (str (quote-str (str k))
                  ":" (quote-str v))) (seq *macros*))
        (.join ",\n")
        (std/wrap-str  "const ____macros = {\n" "};\n"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- spitExterns "Write out export info" ^String []
  (with-local-vars
    [mc (if (empty? *macros*) "{}" "____macros")
     s2 ""
     s1 (str EXPKEY
             ": { ns: "
             (quote-str (std/*ns*))
             ", macros: " mc " }")])
  (when (not-empty *externs*)
    (set! s2
          (str ",\n"
               (join ",\n"
                     (map (fn [[k v]]
                            (str k ":" v)) (seq *externs*))))))
  (str "\n\nmodule.exports = {\n" s1 s2 "\n};\n"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- banner "Banner text for the target file" ^String []
  (with-local-vars [{:keys [id meta]} (std/peekNSP)])
  (str "/*" "Auto generated by Kirby v" MOD-VER " - " (new Date) "\n"
       "  " id "\n"
       (if meta (std/prn meta #t) "") "\n"
       "*/\n\n"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- cleanCode "" ^String [code]
  (with-local-vars [tmp nil arr []])
  (each #(let [tmp (.trim %)]
           (if (and (not-empty tmp)
             (not= tmp ";")) (conj! arr %))) (.split code "\n"))
  (join "\n" arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpile*

  "Compiles a source file, returning the translated source and
  possible error object."

  ^Array [source fname options]

  (with-local-vars
    [{:keys [source-map no-format verbose]} options
     ast (reader/parse source fname)
     env (rt/genv)
     ret (txTree ast env)
     fbase (path/basename fname ".ky")
     macros (spitMacros)
     extra (spitExterns)
     fopts {}
     err nil
     cstr
     (if source-map
       (let [fmap (str fbase ".js")
             smap (str fbase ".map")
             sout (ret.toStringWithSourceMap
                    (object :skipValidation #t :file fmap))]
         (fs/writeFileSync smap sout.map)
         (str sout.code
              macros
              extra
              "\n//# sourceMappingURL="
              (path/relative (path/dirname fname) smap)))
       (str ret macros extra))])
  (try
    (if-not no-format
      (set! cstr
            (esfmt/format cstr fopts)))
    (catch e (set! err e)))
  (set! cstr (cleanCode cstr))
  (with-local-vars [mcs (keys *macros*)
                    lbs (keys (get env :libs))
                    vas (keys (get env :vars))])
  ;(println (std/prn (get env :vars) #t))
  (when verbose
    (println "<macros>\n" (std/prn mcs #t))
    (println "<libs>\n" (std/prn lbs #t))
    (println "<vars>\n" (std/prn (difference vas mcs) #t)))
  (vec (if (empty? cstr) "" (str (banner) cstr)) err))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn transpile

  "Compile kirby file to target source"
  ^Array [code file & [options]]

  (set! *externs* {}
        *macros* {} *last-line* 0 *last-col* 0)
  (try
    (transpile* code file (opt?? options (object )))
    (catch e
      (println "Error near line: "
               *last-line* ", col: " *last-col* "\n" (str e)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn dbgAST
  "Dump AST to xml" ^String [source fname]
  (reader/dumpTree (reader/parse source fname) fname))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const version MOD-VER)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

