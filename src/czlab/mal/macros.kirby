
(defmacro values [obj]
  `(Object.values ~obj))

(defmacro keys [obj]
  `(Object.keys ~obj))

(defmacro whatis? [obj]
  `(Object.prototype.toString.call ~obj))

(defmacro typeof? [obj] `(typeof ~obj))

(defmacro regexs [pattern glim] `(new RegExp ~pattern ~glim))
(defmacro regex [pattern] `(new RegExp ~pattern))


(defmacro undef? [obj]
  `(= (typeof? ~obj) "undefined"))
(defmacro boolean? [obj]
  `(= (typeof? ~obj) "boolean"))
(defmacro number? [obj]
  `(= (typeof? ~obj) "number"))
(defmacro string? [obj]
  `(= (typeof? ~obj) "string"))
(defmacro fn? [obj]
  `(= (typeof? ~obj) "function"))

(defmacro date? [obj]
  `(= (whatis? ~obj) "[object Date]"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defmacro regex? [obj]
  `(= (whatis? ~obj) "[object RegExp]"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defmacro array? [obj]
  `(= (whatis? ~obj) "[object Array]"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defmacro object? [obj]
  `(= (whatis? ~obj) "[object Object]"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defmacro null? [obj]
  `(= (whatis? ~obj) "[object Null]"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defmacro isdef? [obj] `(not (undef? ~obj)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defmacro assert [cond msg]
  `(if-not ~cond (throw (new Error ~msg))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defmacro true? [obj] `(= true ~obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defmacro false? [obj] `(= false ~obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defmacro when-not [cond & xs] `(when (not ~cond) ~@xs))
(defmacro unless [cond &xs] `(when-not ~cond ~@xs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defmacro if-not [cond & xs]
  (let* [e1 (nth xs 0)
         e2 (nth xs 1)]
    `(if (not ~cond) ~e1 ~e2)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defmacro when [cond & xs] `(if ~cond (do ~@xs)))

(defmacro cond [& xs]
  (assert (even? (count xs)))
  (if (> (count xs) 0)
    (list 'if
          (nth xs 0)
          (nth xs 1)
          (cons 'cond (rest (rest xs))))))

(defmacro -> [expr form & xs]
  (if (> (count xs) 0)
    `(-> (~(nth form 0) ~expr ~@(rest form)) ~@xs)
    `(~(nth form 0) ~expr ~@(rest form))))

(defmacro ->> [expr form & xs]
  (if (> (count xs) 0)
    `(->> (~@form ~expr) ~@xs)
    `(~@form ~expr)))

(defmacro let [bindings & xs]
  (let* [ps (evens bindings)
         vs (odds bindings)]
    `((fn [~@ps] ~@xs) ~@vs)))

(defmacro XXloop [bindings & more]
  (let*
    [es (evens bindings)
     xs (gensym)
     f (gensym)
     ret (gensym)
     os (odds bindings)]
    `((fn []
         (var recur nil ~xs nil
              ~f (fn [ ~@es  ] ~@more)
              ~ret ~f)
         (set! recur
           (fn []
             (set! ~xs arguments)
             (if (isdef? ~ret)
               (do (set! ~ret undefined)
                   (while (undef? ~ret)
                     (set! ~ret (.apply ~f this ~xs))) ~ret)
               undefined)))
         (recur ~@os)))))

(defmacro loop [bindings & more]
  (let*
    [es (evens bindings)
     xs (gensym)
     f (gensym)
     ret (gensym)
     os (odds bindings)]
    `((fn []
         (var recur nil ~xs nil
              ~f (fn [~@es ] ~@more)
              ~ret ~f)
         (set! recur
           (fn []
             (set! ~xs arguments)
             (if (isdef? ~ret)
               (do (for ((~ret undefined)
                         (= ~ret undefined) nil)
                     (set! ~ret (.apply ~f this ~xs))) ~ret)
               undefined)))
         (recur ~@os)))))

(defmacro or [&xs] `(|| ~@xs))

(defmacro and [&xs] `(&& ~@xs))

(defmacro do-with [binding & xs]
  `(let [~(first binding)
         ~(nth binding 1)]
    (do ~@xs ~(first binding))))

(defmacro do->false [&xs] `(do ~@xs false))
(defmacro do->true [&xs] `(do ~@xs true))
(defmacro do->nil [&xs] `(do ~@xs nil))
(defmacro do->undef [&xs] `(do ~@xs undefined))

(defmacro inc [x] `(+ ~x 1))
(defmacro dec [x] `(- ~x 1))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defmacro dotimes [binding &xs]
  (let* [_times (gensym)]
    `(loop [~(first binding) 0
            ~_times ~(nth binding 1)]
       (when (> ~_times ~(first binding))
         ~@xs
         (recur (inc ~(first binding)) ~_times)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defmacro if-some [binding then otherwise]
  `(let [~(first binding) ~(nth binding 1)]
     (if ~(first binding) ~then ~otherwise)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defmacro when-some [binding &xs]
  `(let [~(first binding) ~(nth binding 1)]
     (when ~(first binding) ~@xs)))

(defmacro doto [target & xs]
  (let* [cvar (gensym)]
    `(let [~cvar ~target] ~@xs ~cvar)))





;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

