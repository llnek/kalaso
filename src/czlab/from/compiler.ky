;; Copyright (c) 2013-2017, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns ^{:doc ""
      :author "Kenneth Leung"}
  czlab.kirby.compiler
  (:require ["source-map" :as smap])
  (:require ["./stdlib"
             :as std
             :refer [lambda-arg? hashmap pairs? into!
                     merge contains? last typeid
                     prn primitive map? vector?
                     opt?? some? primitive?
                     not-empty conj! list?
                     gensym count pop! slice
                     symbol keyword symbol? keyword?]]
            ["./engine" :as eng]
            ["./parser" :as parser :refer [jsid]])
  (:require ["fs" :as fs]
            ["path" :as path]
            ["esformatter" :as esfmt]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- ERRORS-MAP {
  :no-sourcemap-info "Expected source map info"
  :invalid-fargs "Invalid function args"
  :invalid-catch "Invalid catch clause"
  :invalid-try "Invalid try clause"
  :invalid-include "Invalid include clause"
  :invalid-require "Invalid require clause"
  :invalid-namespace "Invalid namespace clause"
  :destruct-args "Bad destructure args"
  :outside-macro "Invalid clause outside of macro"
  :file-access "Failed file access"
  :file-read "Failed file read"
  :file-open "Failed to open file"
  :unknown-keyword "Unknown keyword"
  :invalid-arity "Invalid function arity"
  :invalid-meta "Invalid meta data"
  :syntax-error "Syntax error"
  :empty-form "Invalid form (empty)" })

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- ARRSLICE "Array.prototype.slice.call")
(const- JSARGS "arguments")
(const- LARGS "____args")
(const- BREAK "____break")
(const- MOD-VER "1.0.0")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- *externs* nil
      *ns* nil
      SPEC-OPS {}
      MATH-OP-REGEX #/^[-+][0-9]+$/)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn tnodeEx "Create a node"
  ^SourceNode [name &[chunk]] (tnode nil nil nil chunk name))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn tnode "Create a token
            with source information"
  ^SourceNode [&[source line col chunk name]]
  (new smap/SourceNode
       (opt?? line nil)
       (opt?? col nil)
       (opt?? source nil)
       (opt?? chunk nil) (opt?? name nil)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- doFuncArgs "Deal with possible destructuring
                  of args in function definition"
  ^Array [args env]
  (var~ e ev rval out)
  (var pms []
       [fargs fdefs :as ret] [(node' args) (node' args)])
  (for [i 0 sz (n# args)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i args))
    (cond
      (symbol? e)
      (if (== e "&")
        ;vargs
        (do (set! rval (node' args)
                e (.@+i args))
            (rval.add [ARRSLICE "(" JSARGS "," $(i) ")"])
            (if (symbol? e)
              (fdefs.add ["let "
                          (tx* e env) "=" rval ";\n"])
              (do (set! out (node' args)
                      e (destruct* e out env))
                  (fdefs.add ["let "
                              (tx* e env)
                              "=" rval ";\n" out])))
            (break-out-of-loop!))
        ;ignore _
        (do (if (== e "_")
              (set! e (xfi e (gensym "U__")))) (conj! pms e)))
      (array? e)
      (do (set! rval (node' args)
              out (node' args)
              e (destruct* e out env))
          (rval.add [JSARGS "[" $(i) "]"])
          (conj! pms e)
          (fdefs.add out))
      :else
      (error! :destruct-args args)))
  (each #(fargs.add (tx* % env)) pms)
  (join "," fargs)
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destruct* "Decide on what the
                 rhs should be referred to 'as'"
  ^Symbol [coll out env]
  (var rhs (xfi coll (gensym)) e nil)
  (for [i 0 sz (n# coll)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i coll))
    (when (and (keyword? e)
               (== e "as"))
      (set! rhs (std/keyword->symbol (.@+i coll)))
      (break-out-of-loop!)))
  ;handle a vec or a map destructure only
  (cond
    (map? coll)
    (out.add (destructMap rhs coll env))
    (vector? coll)
    (out.add (destructVec rhs coll env))) rhs)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destructVec "" ^SourceNode [src coll env]
  (var ret (node' coll)
       as (tx* src env))
  (var~ e rval out)
  (for [i 0 sz (n# coll)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i coll))
    (cond
      (symbol? e)
      (cond
        (== e "_") nil
        (== e "&")
        (do (set! rval (node' coll)
                out (node' coll)
                e (.@+i coll))
            (rval.add [ARRSLICE "(" as "," $(i) ")"])
            (if-not (symbol? e)
              (set! e (destruct* e out env)))
            (ret.add ["let "
                      (tx* e env)
                      "=" rval ";\n" out])
            (break-out-of-loop!))
        :else
        (ret.add ["let "
                  (tx* e env)
                  "=" as "[" $(i) "];\n"]))
      (array? e)
      (do (set! rval (node' coll)
              out (node' coll)
              e (destruct* e out env))
          (rval.add [as "[" $(i) "]"])
          (ret.add ["let "
                    (tx* e env)
                    "=" rval ";\n" out]))
      (keyword? e)
      (if (== e "as")
        (++ i)
        (error! :unknown-keyword coll))
      :else (error! :syntax-error coll))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destructMap "" ^SourceNode [src coll env]
  (var ret (node' coll)
       as (tx* src env))
  (var~ e arr)
  (for [i 0 sz (n# coll)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i coll))
    (cond
      (keyword? e)
      (cond
        (or (== e "keys")
            (== e "strs"))
        (do (set! arr (.@+i coll))
            (++ i)
            (for [j 0 sz (n# arr)
                  :while (< j sz) :recur (+1 j)]
              (set! e (.@j arr))
              (ret.add ["let "
                        (tx* e env)
                        "=" as "[\"" $(e) "\"];\n"])))
        :else
        (error! :unknown-keyword coll))
      :else
      (error! :syntax-error coll))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- simple? "" ^Boolean [ast]
  (or (undef? ast) (nil? ast) (str? ast) (num? ast) (bool? ast)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- wrap "" ^SourceNode [ret head tail]
  (if head (ret.prepend head))
  (if tail (ret.add tail)) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- exprHint "" ^Array [ast flag]
  (if (simple? ast) (set! ast (primitive ast))) (assoc! ast :____expr flag) ast)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- stmt? "" ^Boolean [ast]
  (if (simple? ast) (error! :syntax-error ast)) (false? ast.____expr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- error! "" [e & [ast msg]]
  (raise! (get ERRORS-MAP e)
          (if msg (str " : " msg))
          (if (and ast ast.line) (str "\nline: " ast.line))
          (if (and ast ast.source) (str "\nfile: " ast.source))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- testre? "" ^Boolean [re x] (if x (re.test x) false))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- pad "" [n] ^String (.repeat " " n))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- node' "" ^SourceNode [ast & [obj]]
  (set! obj (opt?? obj (tnode)))
  (assoc! obj
          :source ast.source
          :line ast.line
          :column ast.column) obj)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txTree "" ^SourceNode [root env]
  (var ret (node' root))
  (doseq [r root
          :let [t (tx* r env)]
          :when (some? t)] (ret.add [t "\n"])) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txForm "" ^Any [expr env]
  (if (array? expr)
    (each (fn [a i arr]
            (set-in! arr i (tx* a env))) expr)) expr)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txAtom "Returns a SourceNode or String" ^Any [a]
  (var s $(a))
  (cond (lambda-arg? a)
        (str LARGS "[" s "]")
        (keyword? a)
        (node' a (tnodeEx (jsid s) (str "\"" (jsid s) "\"")))
        (symbol? a)
        (node' a (tnodeEx (jsid s) (jsid s)))
        (nil? a)
        "null"
        (primitive? a)
        (do (set! a a.value s $(a))
            (cond (string? a) (std/quote-str a)
                  (nil? a) "null"
                  :else s))
        (string? a)
        (std/quote-str a)
        :else (jsid s)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- tx* "" ^Any [x & [env]]
  (if (array? x) (txPairs x env) (txAtom x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- gcmd "" ^String [ast]
  (cond (map? ast) "hashmap"
        (vector? ast) "vec"
        (list? ast) "list"
        (and (array? ast)
             (not (array? (1st ast)))) $(1st ast) :else ""))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quoteSingle "" ^String [a]
  (cond (keyword? a)
        (str (maybeStripStdlib "kirbystdlibref.keyword")
             "(\":" a "\")")
        (symbol? a)
        (str (maybeStripStdlib "kirbystdlibref.symbol")
             "(\"" a "\")")
        (primitive? a)
        (do (set! a a.value)
            (cond (string? a) (std/quote-str a)
                  (nil? a) "null"
                  :else $(a)))
        (string? a)
        (std/quote-str a)
        :else $(a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quote! "" ^SourceNode [ast env]
  (assertInfo ast)
  (if (array? ast)
    (if (map? ast)
      (quoteMap ast env)
      (quoteBlock ast env))
    (quoteSingle ast)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quoteMap "" ^SourceNode [ast env]
  (var comma ""
       ret (node' ast))
  (for [i 0 sz (n# ast)
        :while (< i sz) :recur (+2 i)]
    (if (> i 0) (ret.add ","))
    (ret.add [(quote! (.@i ast) env)
              " : " (quote! (.@+i ast) env)]))
  (if-not (empty? ast) (set! comma ","))
  (wrap ret ["[" "symbol(\"hashmap\")" comma] "]"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quoteBlock "" ^SourceNode [ast env]
  (var ret (node' ast))
  (for [i 0 sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (if (> i 0) (ret.add ","))
    (ret.add (quote! (.@i ast) env)))
  (wrap ret "[" "]"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- spreadInfo "" ^Any [from to]
  (if (and from
           (not (simple? from))
           (number? from.line)
           (array? to))
    (do (xfi from to)
        (for [i 0 sz (n# to)
              :while (< i sz) :recur (+1 i)]
          (spreadInfo from (.@i to))))
    (xfi from to)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txPairs "" ^SourceNode [ast env]
  (var nsp (.peekNSP (eng/globalEnv))
       stmtQ (stmt? ast)
       ret (node' ast)
       cmd (gcmd ast)
       e1 (1st ast)
       orig ast
       op nil tmp nil
       mc (eng/getMacro cmd))
  (xfi e1 ret)
  (xfi e1 ast)
  ;;handle macro calls
  (when mc
    (set! ast (eng/expand?? ast env mc)
          ast (xfi orig (exprHint ast (not stmtQ))))
    (spreadInfo orig ast)
    (set! cmd (gcmd ast)))
  ;;handle (+1 ) or (-1 ) cases
  (when (parser/REGEX.int.test cmd)
    (if-not (or (starts? cmd "+")
                (starts? cmd "-"))
      (set! cmd (str "+" cmd)))
    (set! ast (xfi ast [(symbol (ch@ cmd 0))
                      (2nd ast)
                      (int (rest cmd))])
        cmd $(1st ast)))
  ;;maybe special form
  (set! op (get SPEC-OPS cmd))
  ;;handle all cases
  (cond
    (== cmd "with-meta")
    (ret.add (tx* (2nd (meta?? ast env)) env))
    (starts? cmd ".-")
    (ret.add [(tx* (2nd ast) env)
              "." (tx* (symbol (cmd.slice 2)) env)])
    (starts? cmd ".@")
    (do (set! tmp (if (starts? cmd ".@+") [3 #t] [2 #f]))
        (ret.add [(tx* (2nd ast) env)
                  "[" (cmd.slice (1st tmp)) (if (2nd tmp) "+1]" "]")]))
    (starts? cmd ".")
    (do (ret.add [(tx* (2nd ast) env) cmd "("])
        (for [n 2 sz (n# ast)
              :while (< n sz) :recur (+1 n)]
          (if (not= n 2) (ret.add ","))
          (ret.add (tx* (.@n ast) env)))
        (ret.add ")"))
    (some? op)
    (set! ret (op ast env))
    (and (or (== cmd "splice-unquote")
             (== cmd "unquote")
             (== cmd "syntax-quote"))
         (not (starts? nsp.id "czlab.kirby.")))
    (error! :outside-macro ast)
    :else
    (do (if (pairs? ast)
          (do (txForm ast env)
              (set! cmd $(1st ast)))
          (set! cmd (tx* ast env)))
        (if-not cmd (error! :empty-form ast))
        (set! cmd (maybeStripStdlib cmd))
        (if (pairs? ast)
          (ret.add
            [(if (testre? parser/REGEX.func cmd)
               (str "(" cmd ")") cmd)
             "(" (join "," (rest ast)) ")"])
          (ret.add cmd))))
  (node' ast ret))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- writeDoc "Convert to jsdoc" ^Array [doc]
  (var out [])
  (if doc
    (->> (.split (std/unquote-str doc) "\n")
         (each #(let [s (.trim (str %))]
                  (if (not-empty s)
                    (conj! out (str "//" s "\n"))))))) out)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txDo "" ^SourceNode [ast env & [return?]]
  (var stmtQ (stmt? ast)
       ret (node' ast)
       e nil end (last-index ast))
  (set! return?
      (if stmtQ false (opt?? return? true)))
  (for [i 0 :while (< i end) :recur (+1 i)]
    (set! e (exprHint (.@i ast) #f))
    (ret.add [(tx* e env) ";\n"]))
  (when (>= end 0)
    (set! e (exprHint (.@end ast)
                    (not stmtQ))
        e (tx* e env))
    (ret.add (if-not return?
               [e ";\n"]
               ["return " e ";\n"]))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- meta?? "" ^Array [obj env]
  (var mobj nil)
  (when (and (array? obj)
             (= 3 (n# obj))
             (== "with-meta"
                 $(1st obj)))
    (set! mobj (evalMeta (.@2 obj) env))
    (assoc! (2nd obj) :____meta mobj)
    (set! obj (2nd obj)))
  [mobj obj])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fmtRegoSpecOps "" ^String [alias fname]
  (str (parser/jsid :SPEC-OPS) "[\"" alias "\"] = " fname))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fmtSpecOps "" ^String [fname attrs]
  (var ks (or (get attrs "opcode") [])
       out (->> (map #(fmtRegoSpecOps
                        (str %) fname) ks) (join ";\n")))
  (if (not-empty ks) (str out ";\n") out))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- writeFuncPre "" [pre env]
  (var ret (node' pre)
       c2 ['if-not (concat ['and] pre)
           ['throw ['Error "Precondition failed"]]])
  (ret.add [(-> (exprHint c2 false) (tx* env)) ";\n"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- writeFuncInfo "" ^String [fname ast]
  (var file (if ast.source
              (ast.source.slice
                (+1 (ast.source.lastIndexOf "/"))) "?")
       s (str "//fn: ["
              fname "] in file: "
              file ",line: " (or ast.line "?") "\n")
       len (alen s))
  (if (< len 80)  (set! len 80))
  (str (.repeat "/" len) "\n" s))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- icache [])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- includeFile ^SourceNode [fname ast]
  (if (contains? icache fname)
    (node' ast)
    (let [src (eng/slurp fname)]
      (conj! icache fname)
      (txTree (parser/parse src fname) (eng/globalEnv )))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- evalMeta "" ^Object [ast env]
  (var x
       (cond (array? ast)
             ast
             (keyword? ast)
             (into! :map [ast #t])
             (symbol? ast)
             (into! :map [(keyword ":tag") ast])
             :else
             (error! :invalid-meta ast))
       v (eng/compute x env))
  ;(console.log (str "meta-obj=" (JSON/stringify v)))
  v)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- maybeStripStdlib "" ^String [cmd]
  (var lib "kirbystdlibref."
       nsp (.peekNSP (eng/globalEnv)))
  (set! cmd $(cmd))
  (if (and (starts? cmd lib)
           (= nsp.id "czlab.kirby.stdlib"))
    (cmd.slice (alen lib)) cmd))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- assertArity "" ^Any [kond ast]
  (if-not kond (error! :invalid-arity ast))
  (assertInfo ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- assertInfo "" ^Any [ast]
  (if (and false
           ast
           (not (simple? ast))
           (not (number? ast.line)))
    (error! :no-sourcemap-info ast)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;special-forms
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn sf-juxt

  "Takes a set of functions and returns a fn that is the juxtaposition
of those fns.  The returned fn takes a variable number of args, and
returns a vector containing the result of applying each fn to the
args (left-to-right).
((juxt a b c) x) => [(a x) (b x) (c x)]"

  ^{:opcode ["juxt"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 2) ast)
  (var ret (node' ast))
  (ret.add ["function () {\n"
            "let ret=[]," LARGS "=" ARRSLICE "(" JSARGS ");\n"])
  (for [i 1 f nil sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (set! f $(gensym "F__"))
    (ret.add ["let " f "=" (tx* (.@i ast) env) ";\n"
              "ret.push(" f ".apply(this," LARGS "));\n"]))
  (ret.add "return ret;\n}"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-deref

  "Returns an atom's current state."

  ^{:opcode ["deref"] :tag SourceNode} [ast env]

  (assertArity (= (n# ast) 2) ast)
  (var ret (node' ast))
  (ret.add [(tx* (2nd ast) env) ".value"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-compose

  "Takes a set of functions and returns a fn that is the composition
of those fns.  The returned fn takes a variable number of args,
applies the rightmost of fns to the args, the next
fn (right-to-left) to the result, etc."

  ^{:opcode ["comp"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 2) ast)
  (var ret (node' ast)
       end (last-index ast))
  (var~ f r prev)
  (ret.add ["function () {\n"])
  (ret.add ["let " LARGS "=" ARRSLICE "(" JSARGS ");\n"])
  (for [i end :while (> i 0) :recur (-1 i)]
    (set! f $(gensym "F__") r $(gensym "R__"))
    (ret.add ["let " f "=" (tx* (.@i ast) env) ";\n"])
    (if (= i end)
      (ret.add ["let " r "=" f ".apply(this," LARGS ");\n"])
      (ret.add ["let " r "=" f "(" prev ");\n"]))
    (set! prev r))
  (ret.add ["return " prev ";\n" "}"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-quote
  "Returns the unevaluated form"
  ^{:opcode ["quote"] :tag SourceNode} [ast env]
  (assertArity (= (n# ast) 2) ast)
  (var ret (node' ast))
  (wrap ret nil (quote! (2nd ast) env)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-deftype
  "Define a JS Class"
  ^{:opcode ["deftype" "deftype-"] :tag SourceNode}
  [ast env]
  (assertArity (>= (n# ast) 4) ast)
  (var ret (node' ast))
  (var~ mtd pos n m)
  (var pub? (not (ends? $(1st ast) "-"))
       czname (tx* (2nd ast) env)
       par (1st (.@2 ast))
       czargs (.@3 ast)
       [doc mtds] (if (str? (.@4 ast))
                    [(.@4 ast) (slice ast 5)]
                    [nil (slice ast 4)]))
  (ret.add ["class " czname])
  (if par (ret.add [" extends " (tx* par env)]))
  (ret.add " {\n")
  (doseq [m mtds]
    ;;maybe doc string?
    (set! mtd 'method
          m1 (1st m)
          pos (if (str? (2nd m)) 3 2))
    ;;pass line info
    (each #(xfi m1 %) [mtd m])
    ;;maybe set member defaults
    (when (and (== $(m1)
                   "constructor")
               (not-empty czargs))
      (for [x 0 sz (n# czargs)
            :while (< x sz) :recur (+2 x)]
        (set-in! czargs x $(.@x czargs)))
      (if (getPrePost (.@pos m)) (++ pos))
      (m.splice pos 0
        (concat ['assoc! 'this] czargs)))
    ;fake a keyword 'method' in front
    (m.unshift mtd)
    ;compiles it like a function
    (ret.add [(sf-func m env #f) "\n"]))
  ;stick doco in front, if any
  (if doc (ret.prepend (writeDoc doc)))
  ;maybe export this type?
  (if (and pub?
           (one? (.countNSPCache (eng/globalEnv))))
    (assoc! *externs* czname czname))
  (ret.add "}\n"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-compOp "Handle comparison operators."

  ^{:opcode ["not=" "!="
             "==" "="
             ">" ">=" "<" "<="]
    :tag SourceNode} [ast env]

  (assertArity (and (>= (n# ast) 3)
                    (odd? (n# ast))) ast)

  (var ret (node' ast)
       a0 (1st ast) cmd $(a0))
  (cond (== cmd "not=") (set-in! ast 0 '!==)
        (== cmd "=") (set-in! ast 0 '===))
  (set! a0 (1st ast))
  (for [i 1 op (tx* a0 env)
        :while (< i (last-index ast)) :recur (+1 i)]
    (if (not= i 1) (ret.add " && "))
    (ret.add [(tx* (.@i ast) env)
              " " op " " (tx* (.@+i ast) env)]))
  (wrap ret "(" ")"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-arithOp
  "Handles math operators"
  ^{:opcode ["bitwise-lshift" "bitwise-rshift" "bitwise-zrshift"
             "+" "-" "*" "/" "div" "mod"
             "or" "and" "exp" "rem"
             "bitwise-and" "bitwise-or" "bitwise-not" "bitwise-xor"]
    :tag SourceNode}
  [ast env]

  (assertArity (>= (n# ast) 2) ast)
  (var e1 (tx* (1st ast) env)
       ret (node' ast)
       cmd (case $(e1)
             "bitwise-zrshift" ">>>"
             "bitwise-rshift" ">>"
             "bitwise-lshift" "<<"
             "bitwise-and" "&"
             "bitwise-or" "|"
             "bitwise-not" "~"
             "bitwise-xor" "^"
             "rem" "%"
             "div" "/"
             "and" "&&"
             "or" "||"
             "exp" "**"
             $(e1)))
  ;handle negative number e.g. (- -2)= -1*-2
  (if (and (== "-" cmd)
           (= 2 (n# ast))) (ret.add "-1 * "))
  (for [i 1 sz (n# ast)
        :while (< i sz) : recur (+1 i)]
    (when (> sz 2)
      (if (> i 1) (ret.add cmd)))
    (ret.add (tx* (.@i ast) env)))
  (wrap ret "(" ")"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-do

  "Evaluates the expressions in order and returns the value of the last. If no
expressions are supplied, returns nil."

  ^{:opcode ["do"] :tag SourceNode} [ast env]

  (assertArity true ast)
  (var ret (node' ast)
       stmtQ (stmt? ast))
  (ret.add (txDo (exprHint (xfi ast (rest ast))
                           (not stmtQ)) env (not stmtQ)))
  (if stmtQ
    (wrap ret nil "")
    (wrap ret
          "(function() {\n" "}).call(this)")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-case

  "Takes an expression, and a set of clauses.
 Each clause can take the form of either:
 test-constant result-expr
 (test-constant1 ... test-constantN)  result-expr
 The test-constants are not evaluated. They must be compile-time
literals, and need not be quoted.  If the expression is equal to a
test-constant, the corresponding result-expr is returned. A single
default expression can follow the clauses, and its value will be
returned if no clause matches."

  ^{:opcode ["case"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 4) ast)
  (var stmtQ (stmt? ast)
       ret (node' ast)
       tst (2nd ast)
       brk ";\nbreak;\n"
       gs $(gensym "C__"))
  (var~ e t c dft)
  ;look for any default clause
  (if (odd? (n# ast))
    (set! dft (1st (pop! ast))))
  (for [i 2 sz (n# ast)
        :while (< i sz) :recur (+2 i)]
    (set! e (.@i ast)
          c (.@+i ast)
          c (tx* c env))
    (if (pairs? e)
      (for [j 0 sz (n# e)
            :while (< j sz) :recur (+1 j)]
        (ret.add ["case " (tx* (.@j e) env) ":\n"])
        (if (= j (last-index e))
          (ret.add [gs "=" c brk])))
      (ret.add ["case " (tx* e env) ":\n" gs "=" c brk])))
  ;maybe add the default clause
  (if dft
    (ret.add ["default:\n"
              gs "=" (tx* dft env) brk]))
  ;wrap the switch construct around it
  (wrap ret ["switch (" (tx* tst env) ") {\n"] "}")
  (if stmtQ
    (wrap ret ["let " gs ";\n"] "")
    (wrap ret
          ["(function() { let " gs ";\n"]
          ["return " gs ";}).call(this)"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-vardefs
  "For JS style var defs with no rvalue, e.g. let x,y;"
  ^{:opcode ["def~-" "def~" "var~"]
    :tag SourceNode} [ast env]
  (assertArity (>= (n# ast) 2) ast)
  (var ret (node' ast)
       cmd $(1st ast)
       keys {}
       pub? (== cmd "def~"))
  (if (starts? cmd "def")
    (set! cmd "var") (set! cmd "let"))
  (for [i 1 s nil sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (set! s (tx* (.@i ast) env))
    (assoc! keys s nil)
    (if (> i 1) (ret.add ","))
    (ret.add s))
  ;;exports
  (if (and pub?
           (one? (.countNSPCache (eng/globalEnv))))
    (each-key (fn [v k] (assoc! *externs* k k)) keys))
  (wrap ret (str cmd " ") ";\n"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-var

  "Creates a variable with an initial value"

  ^{:opcode ["const-" "const" "def-" "def" "var"]
    :tag SourceNode} [ast env]

  (assertArity (odd? (n# ast)) ast)
  (var ret (node' ast)
       cmd $(1st ast)
       keys []
       tmp nil vname nil
       pub? (or (== cmd "def")
                (== cmd "const")))
  (var~ rval rc lhs rhs)
  (set! cmd (if (starts? cmd "const")
            "const"
            (if (== cmd "var") "let" "var")))
  ;deal with 1 level destruction
  (for [i 1 sz (n# ast)
        :while (< i sz) :recur (+2 i)]
    (set! lhs (.@i ast)
          rhs (.@+i ast)
          rval (tx* rhs env))
    (if (symbol? lhs)
      (do (set! lhs (tx* lhs env))
          (conj! keys lhs)
          (ret.add [cmd " " lhs "=" rval ";\n"]))
      (do (set! out (node' ast)
                rhs (destruct* lhs out env))
          (ret.add ["let " (tx* rhs env) "=" rval ";\n" out]))))
  (if (and pub?
           (one? (.countNSPCache (eng/globalEnv))))
    (each #(assoc! *externs* % %) keys)) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-inst?

  "Evaluates x and tests if it is an instance of the class
  c. Returns true or false.
  (inst? c x)"

  ^{:opcode ["inst?"] :tag SourceNode} [ast env]

  (assertArity (= (n# ast) 3) ast)
  (wrap (node' ast) nil ["(" (tx* (3rd ast) env)
                         " instanceof " (tx* (2nd ast) env) ")"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-delete

  "Delete an object or property of an object."

  ^{:opcode ["delete!"] :tag SourceNode} [ast env]

  (assertArity (and (>= (n# ast) 2)
                    (< (n# ast) 4)) ast)
  (var ret (node' ast))
  (ret.add ["delete "
            (tx* (2nd ast) env)])
  (if (> (n# ast) 2)
    (ret.add ["[" (tx* (.@2 ast) env) "]"])) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-new

  "The args, if any, are evaluated from left to right,
  and passed to the constructor of the class
  named by Classname. The constructed object is returned.
  e.g.
  (new Error 'a' 3)"

  ^{:opcode ["new"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 2) ast)
  (wrap (node' ast) "new " (tx* (xfi ast (rest ast)) env)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-throw

  "Throw an exception"

  ^{:opcode ["throw"] :tag SourceNode} [ast env]

  (assertArity (= (n# ast) 2) ast)
  (var ret (node' ast)
       stmtQ (stmt? ast))
  (ret.add ["throw " (tx* (xfi ast (2nd ast)) env)])
  (if-not stmtQ
    (wrap ret
          "(function (){ "
          ";}).call(this)")) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-x-opop

  "Unary operator for increment & decrement"
  ^{:opcode ["++" "--" "++$" "--$"] :tag SourceNode} [ast env]

  (assertArity (= (n# ast) 2) ast)
  (var ret (node' ast)
       cmd $(1st ast)
       a2 (tx* (2nd ast) env))
  (ret.add
    (if (ends? cmd "$")
      [a2 (cmd.slice 0 -1)] [cmd a2])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-x-eq

  "Compound assignment operators"

  ^{:opcode ["+=" "-=" "*="
             "div=" "rem=" "exp="
             "bitwise-and="
             "bitwise-or="
             "bitwise-xor="
             "bitwise-lshift="
             "bitwise-rshift="
             "bitwise-zrshift="]
       :tag SourceNode} [ast env]

  (assertArity (= (n# ast) 3) ast)
  (var cmd
       (case $(1st ast)
         "bitwise-zrshift=" ">>>="
         "bitwise-rshift=" ">>="
         "bitwise-lshift=" "<<="
         "bitwise-xor=" "^="
         "bitwise-or=" "|="
         "bitwise-and=" "&="
         "div=" "/="
         "rem=" "%="
         "exp=" "**="
         $(1st ast)))
  (wrap (node' ast)
        nil
        [(tx* (2nd ast) env)
         " " cmd " " (tx* (3rd ast) env)]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-setin!

  "Object property assignment or array index setter."

  ^{:opcode ["set-in!"
             "assoc!" "=>>"] :tag SourceNode} [ast env]

  (assertArity (even? (n# ast)) ast)
  (var ret (node' ast)
       more #f
       obj (tx* (2nd ast) env))
  (for [i 2 sz (n# ast)
        :while (< i sz) :recur (+2 i)]
    (when (> i 2) (ret.add ",") (true! more))
    (ret.add [obj
              "[" (tx* (xfi ast (.@i ast)) env) "]"
              "=" (tx* (xfi ast (.@+i ast)) env)]))
  (if more (wrap ret "(" ")")) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-set

  "Set value(s) to variable(s).
  e.g. (set! a 2 b 4 ...)"

  ^{:opcode ["set!" "=>"] :tag SourceNode} [ast env]

  (assertArity (odd? (n# ast)) ast)
  (var more #f
       ret (node' ast))
  (for [i 1 sz (n# ast)
        :while (< i sz) :recur (+2 i)]
    (when (> i 1) (ret.add ",") (true! more))
    (ret.add [(tx* (.@i ast) env)
              "=" (tx* (xfi ast (.@+i ast)) env)]))
  (if more (wrap ret "(" ")")) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-fn

  "Defines an anonymous function. See defn.
  (fn attrs? [x y] ...)"

  ^{:opcode ["fn"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 2) ast)
  (var body (xfi ast (slice ast 2))
       [_ args] (meta?? (2nd ast) env))
  (if-not (array? args)
    (error! :invalid-fargs ast))
  (var fargs (doFuncArgs (xfi ast args) env))
  (wrap (node' ast)
        nil
        ["function (" (1st fargs) ") {\n"
         (2nd fargs) (txDo body env #t) "}"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-func

  "Defines a function. Use defn- to indicate privacy (no export).
  (defn name doc-string? attr-map? [params*] ...)"

  ^{:opcode ["defn" "defn-"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 2) ast)
  (var pub? (not (ends? $(1st ast) "-"))
       mtd? (== $(1st ast) "method")
       fname0 $(2nd ast)
       fname $(tx* (2nd ast) env)
       dot? (contains? fname ".")
       ret (node' ast
                  (tnodeEx fname))
       [doc pargs] (if (str? (3rd ast))
                     [(nth ast 2) 3] [nil 2])
       body (xfi ast (slice ast (+1 pargs)))
       b1 (1st body)
       [attrs args] (meta?? (nth ast pargs) env))
  (if-not (array? args)
    (error! :invalid-fargs ast))
  (var fargs (doFuncArgs (xfi ast args) env))
  (var~ pre post)
  (set! attrs (or attrs {}))
  (when (map? b1)
    (for [i 0 e nil e2 nil sz (n# b1)
          :while (< i sz) :recur (+2 i)]
      (set! e (.@i b1) e2 (.@+i b1))
      (when (and (keyword? e)
                 (array? e2))
        (cond (== e "post") (set! post e2)
              (== e "pre") (set! pre e2)))))
  (cond mtd?
        (do (if (.-static attrs)
              (ret.add "static "))
            (ret.add [fname " ("])
            (if (== fname "constructor")
              (conj! body 'this)))
        dot?
        (ret.add [fname " = function ("])
        :else
        (ret.add ["const " fname " = function ("]))
  (ret.add [(1st fargs) ") {\n" (2nd fargs)])
  (when (or pre post)
    (set! body (rest body))
    (ret.add (writeFuncPre (xfi ast pre) env)))
  (ret.add [(txDo body env #t) "};\n"])
  (if (not-empty attrs)
    (ret.add (fmtSpecOps fname attrs)))
  (if doc
    (ret.prepend (writeDoc doc)))
  (if (and pub?
           (not dot?)
           (not mtd?)
           (one? (.countNSPCache (eng/globalEnv))))
    (assoc! *externs* fname fname))
  (ret.prepend (writeFuncInfo fname0 ast)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-try

  "The exprs are evaluated and, if no exceptions occur, the value of the last
is returned. If an exception occurs and catch clauses are provided, each is
examined in turn and the first for which the thrown exception is an instance
of the named class is considered a matching catch clause. If there is a
matching catch clause, its exprs are evaluated in a context in which name is
bound to the thrown exception, and the value of the last is the return value
of the function. If there is no matching catch clause, the exception
propagates out of the function. Before returning, normally or abnormally,
any finally exprs will be evaluated for their side effects."

  ^{:opcode ["try"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 2) ast)

  (var stmtQ (stmt? ast)
       sz (n# ast)
       ret (node' ast))
  (var~ t f c)
  ;;look for finally
  (set! f (last ast))
  (if (and (array? f)
           (== "finally" $(1st f)))
    (do (pop! ast)
        (set! sz (n# ast))
        (xfi (1st f) f))
    (nil! f))
  ;;look for catch
  (nil! c)
  (if (> sz 1)
    (set! c (nth ast (-1 sz))))
  (if (and (array? c)
           (== "catch" $(1st c)))
    (do (if (or (< (n# c) 2)
                (not (symbol? (2nd c))))
          (error! :invalid-catch ast))
        (pop! ast)
        (xfi (1st c) c))
    (nil! c))
  ;;try needs either a catch or finally or both
  (if (and (nil? f)
           (nil? c)) (error! :invalid-try ast))
  (ret.add ["try {\n"
            (txDo (exprHint (xfi ast (rest ast))
                            (not stmtQ)) env) "\n}"])
  (when c
    (set! t (2nd c))
    (ret.add [(str "catch (" (tx* t env) ") {\n")
              (txDo (exprHint (xfi c (slice c 2))
                              (not stmtQ)) env) ";\n}\n"]))
  (when f
    (ret.add ["finally {\n",
              (txDo (exprHint (xfi f (rest f)) #f) env #f) ";\n}\n"]))
  (if-not stmtQ
    (wrap ret "(function(){\n" "}).call(this)")) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-if

  "Evaluates test. If truthy evaluates 'then' otherwise 'else'.

  (if test then else)
  (if test then)"

  ^{:opcode ["if"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 3) ast)
  (var stmtQ (stmt? ast)
       ret (node' ast)
       ;test is always an expression
       a1 (exprHint (xfi ast (2nd ast)) true)
       a2 (exprHint (xfi ast (3rd ast)) (not stmtQ))
       m? (> (n# ast) 3)
       a3 (if m? (xfi ast (.@3 ast)))
       elze (if m? (exprHint a3 (not stmtQ))))
  (set! a1 (tx* a1 env)
        a2 (tx* a2 env)
        elze (tx* elze env))
  (wrap ret
        nil
        (if stmtQ
          ["if (" a1 ") {\n" a2 ";\n}"
           (if m? [" else { \n" elze ";\n}"] "")]
          ["(" a1 " ?\n" a2 " :\n" (or elze "null") ")"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-get

  "Returns the named property of an object,
  or value at the index of an array.

  (get obj \"age\")
  (nth obj 3)"

  ^{:opcode ["nth" "get"] :tag SourceNode} [ast env]

  (assertArity (= (n# ast) 3) ast)
  (var cmd
       (maybeStripStdlib "kirbystdlibref.getProp"))
  (wrap (node' ast)
        nil [cmd "("
             (tx* (xfi ast (2nd ast)) env)
             "," (tx* (xfi ast (3rd ast)) env) ")"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-array

  "Creates a new vector containing the args.

  (vec \"hello\" \"world\")
  (vec 1 2 3)
  [1 2 3]
  [\"hello\" \"world\"]"

  ^{:opcode ["vec"] :tag SourceNode} [ast env]

  (assertArity true ast)
  (var pos 0
       ret (node' ast))
  (if (empty? ast)
    (ret.add "[]")
    (do (if-not (vector? ast) (set! pos 1))
        (ret.add "[\n")
        (for [i pos sz (n# ast)
              :while (< i sz) :recur (+1 i)]
          (if (> i pos) (ret.add ",\n"))
          (ret.add (tx* (xfi ast (.@i ast)) env)))
        (ret.add "\n]"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-object

  "Returns a new object with supplied key-mappings.

  (hashmap \"a\" 1 \"b\" 2)
  {:a 1 :b 2}"

  ^{:opcode ["hash-map" "hashmap"] :tag SourceNode} [ast env]

  (assertArity true ast)
  (var pos 0
       ret (node' ast))
  (if (empty? ast)
    (ret.add "{}")
    (do (if-not (map? ast) (set! pos 1))
        (ret.add "{\n")
        (for [i pos sz (n# ast)
              :while (< i sz) :recur (+2 i)]
          (if (> i pos) (ret.add ",\n"))
          (ret.add [(tx* (.@i ast) env)
                    ": " (tx* (xfi ast (.@+i ast)) env)]))
        (ret.add "\n}"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-include

  "Include another kirby file.

  (:include [\"./common.ky\"])
  (:include [\"./common.ky\"]
            [\"./other.ky\"])"

  ^Array [ast env]

  (assertArity (>= (n# ast) 2) ast)
  (var genv (eng/globalEnv)
       ret []
       dir (path/dirname ast.source))
  (var~ fpath e)
  (for [i 1 sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i ast))
    (if (or (not (array? e))
            (not= 1 (n# e)))
      (error! :invalid-include ast))
    (set! fpath $(1st e))
    (if fpath
      (set! fpath (fpath.replace #/[\"]/g "")))
    (try
      (set! fpath (fs/realpathSync
                    (str dir "/" fpath)))
      (catch e
        (error! :file-access ast)))
    (try
      (conj! ret (includeFile fpath ast))
      (catch e
        (error! :file-read ast))
      (finally
        ;TODO: check if pop is always true
        (.popNSP genv)
        (set! *ns* (.-id (.peekNSP genv))))))
  (if (empty? ret) "" ret))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-require

  "Loads libs.

  (:require [\"z\" :rename {hello goodbye}])
  (:require [\"a\" :as A])
  (:require [\"b\"]
            [\"c\" :refer [hello world]])"

  ^SourceNode [ast env]

  (assertArity (>= (n# ast) 2) ast)
  (var~ as path v e refers renames)
  (var ret (node' ast))
  (for [i 1 sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i ast)
          as $(gensym "R__")
          refers nil renames nil)
    (if (or (not (array? e))
            (< (n# e) 3)) (error! :invalid-require ast))
    (set! path $(1st e))
    (for [j 1 sz (n# e)
          :while (< j sz) :recur (+1 j)]
      (set! v (.@j e))
      (cond (== v "as")
            (do (set! as $(.@+j e))
                (++ j))
            (== v "refer")
            (do (set! refers (.@+j e))
                (++ j))
            (== v "rename")
            (do (set! renames (.@+j e))
                (++ j))))
    (ret.add ["const " (parser/jsid as)
              "= require(" (tx* path env) ");\n"])
    (for [i 0 sz (n# refers)
          :while (< i sz) :recur (+1 i)]
      (set! v (tx* (.@i refers) env))
      (ret.add ["const " v "=" as "[\"" v "\"];\n"]))
    (for [i 0 sz (n# renames)
          :while (< i sz) :recur (+2 i)]
      (set! e (tx* (.@i renames) env)
            v (tx* (.@+i renames) env))
      (ret.add ["const " v
                "=" as "[\"" e "\"];\n"]))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-ns

  "(ns name doc-string? attr-map? references*)

  Creates a namespace, references can be zero or more of:
  (:require ...)

  (ns ^{:doc \"some doc\"} hello.world.core ...)"

  ^{:opcode ["ns"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 2) ast)
  (var ret [] doc nil e nil
       mobj nil pos 2
       [attrs nsp] (meta?? (2nd ast) env))
  (if-not (symbol? nsp)
    (error! :invalid-namespace ast))
  (when (string? (.@pos ast))
    (set! attrs (or attrs {}))
    (set-in! attrs :doc (.@pos ast)) (++ pos))
  (when (map? (.@pos ast))
    (set! mobj (evalMeta (.@pos ast) env)
          attrs (merge attrs mobj))
    (++ pos)
    (assoc! nsp :____meta attrs))
  (.pushNSP (eng/globalEnv) $(nsp) attrs)
  (set! *ns* $(nsp))
  (println (str "Processing namespace: " *ns*))
  (set! ast (xfi ast (slice ast pos)))
  (for [i 0 sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i ast))
    (cond (and (pairs? e)
               (== "include" $(1st e)))
          (conj! ret (sf-include (xfi ast e)))
          (and (pairs? e)
               (== "require" $(1st e)))
          (conj! ret (sf-require (xfi ast e)))))
  ;;force a internal reference to stdlib for user files
  ;;unless processing internal files
  (set! nsp (.peekNSP (eng/globalEnv)))
  (cond
    (or (= nsp.id "czlab.kirby.macros")
        (= nsp.id "czlab.kirby.stdlib"))
    nil
    (starts? nsp.id "czlab.kirby.")
    (conj! ret "const kirbystdlibref=std;\n")
    :else
    (->> (xfi ast '(require ["kirby" :as kirbystdlibref]))
         (sf-require )
         (conj! ret ))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-comment "" ^{:opcode ["comment"] :tag String} [ast env] "")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-for

  "Generates native (js) for loop.

  (for [initial-vars :while test :recur update-vars] ...)"

  ^{:opcode ["for"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 2) ast)

  (var stmtQ (stmt? ast)
       ret (node' ast)
       body (exprHint (xfi ast (slice ast 2)) #f))
  (if (empty? body)
    ret
    (sf-floop ret
              (xfi ast (2nd ast))
              body env stmtQ)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-floop
  "For loop implementation"
  ^SourceNode [ret args body env stmtQ]

  (var vars [] recurs [])
  (var~ tst nb e)
  (for [i 0 sz (n# args)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i args))
    (cond (== e "while")
          (do (set! tst (.@+i args)) (++ i))
          (== e "recur")
          (do (set! recurs (slice args (+1 i)))
              (break-out-of-loop!))
          (symbol? e)
          (do (conj! vars e (.@+i args))
              (++ i))))
  (ret.add "for (")
  (for [i 0 sz (n# vars)
        :while (< i sz) :recur (+2 i)]
    (if (= i 0) (ret.add "let "))
    (if (not= i 0) (ret.add ","))
    (ret.add [(tx* (.@i vars) env)
              "=" $(tx* (.@+i vars) env)]))
  (ret.add (if (empty? vars)
             (str "let " BREAK "=false;")
             (str "," BREAK "=false;")))
  (set! nb '(not ____break))
  (xfi ret nb)
  (if tst
    (set! tst ['and nb tst])
    (set! tst nb))
  (xfi ret tst)
  (ret.add [$(tx* tst env) "; "])
  (for [i 0 k 0 sz (n# recurs)
        :while (< i sz) :recur (+1 i)(+2 k)]
    (if (not= i 0) (ret.add ","))
    (ret.add [(tx* (.@k vars) env)
              "=" $(tx* (.@i recurs) env)]))
  (ret.add ["){\n" (txDo body env #f) "}\n"])
  (if-not stmtQ
    (wrap ret "(function() {\n"  "}).call(this)")) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-jscode

  "Inject raw native (js) code fragment.

  (js# \"console.log('hi');\")"

  ^{:opcode ["js#"] :tag SourceNode} [ast env]

  (assertArity (>= (n# ast) 2) ast)
  (var s $(2nd ast)
       name (parser/jsid "sf-jscode"))
  (->>
    (if (and (ends? s "\"")
             (starts? s "\""))
      (s.slice 1 -1) s) (tnodeEx name) (node' ast)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-macro

  "Like defn, but the resulting function name is declared as a
macro and will be used as a macro by the compiler when it is
called.

  (defmacro macro-name [args] ...)"

  ^{:opcode ["defmacro"] :tag String} [ast env]

  (assertArity (>= (n# ast) 4) ast)
  (var pms [] args (3rd ast) body (slice ast 3))
  (var~ doc x e ev)
  (when (str? args)
    (set! doc args args (.@3 ast) body (slice ast 4)))
  (for [i 0 sz (n# args)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i args) ev $(e))
    (cond (= ev "&")
          (if (array? (.@+i args))
            (do (set! e (.@+i args))
                (++ i)
                (for [j 0 sz (n# e)
                      :while (< j sz) :recur (+1 j)]
                  (set! x (.@j e))
                  (if-not (symbol? x)
                    (error! :syntax-error ast))
                  (conj! pms x)))
            (do (conj! pms e (.@+i args))
                (++ i)))
          (not (symbol? e))
          (error! :syntax-error ast)
          :else
          (conj! pms e)))
  ;ask engine to compile this macro and stores it
  (eng/compute ['macro*
                (2nd ast) pms (1st body)] env) "")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-unary

  "Special unary operators."

  ^{:opcode ["not" "~" "!"] :tag SourceNode} [ast env]

  (assertArity (= (n# ast) 2) ast)
  (var [a0 a1] ast
       ret (node' ast))
  (if (== a0 "not") (set! a0 '!))
  (ret.add ["(" $(tx* a0 env) $(tx* a1 env) ")"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- getPrePost "" [obj]
  (var ret nil)
  (when (map? obj)
    (for [i 0 e nil e2 nil sz (n# obj)
          :while (< i sz) :recur (+2 i)]
      (set! e (.@i obj)
            e2 (.@+i obj))
      (if (and (keyword? e)
               (array? e2))
        (cond (== "post" e)
              (set! ret (merge ret {:post e2}))
              (== "pre" e)
              (set! ret (merge ret {:pre e2}))))))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- xfi "Transfer source map info" ^Any [from to]
  (cond
    (and from to)
    (let [tline (.-line to)
          fline (.-line from)]
      (if (and (not (number? tline))
               (number? fline))
        (assoc! to
             :source (.-source from)
             :line (.-line from)
             :column (.-column from))) to)
    :else to))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- spitExterns "Write out export info" ^String []
  (var s "" ks (keys *externs*)
       z (str "____namespaceid: " "\"" *ns* "\""))
  (if (not-empty ks)
    (set! s (join ",\n" (map #(str % ": " %) ks))
          s (str z ",\n" s))
    (set! s (str z "\n")))
  (str "\n\nmodule.exports = {\n" s "\n};\n\n"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- banner "Banner text for the target file" ^String []
  (var {:keys [id meta]}
       (.firstNSP (eng/globalEnv)))
  (str "/*" "Auto generated by Kirby v" MOD-VER " - " (new Date) "\n"
       "  " id "\n"
       (if meta (std/prn meta true) "") "\n"
       "*/\n\n"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- cleanCode "" ^String [code]
  (var tmp nil arr [])
  (doseq [s (code.split "\n")
          :let [tmp (s.trim)]]
    (if (and (not-empty tmp)
             (not= tmp ";")) (conj! arr s)))
  (join "\n" arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpile*

  "Compiles a source file, returning the translated source and
  possible error object."

  ^Array [source fname options]

  (.resetNSPCache (eng/globalEnv))
  (set! *externs* {}
        *ns* nil)
  (var ret (txTree (parser/parse source fname)
                   (eng/globalEnv))
       {:keys [source-map format]} options
       fbase (path/basename fname ".ky")
       extra (spitExterns)
       fopts {}
       err nil
       cstr
       (if source-map
         (let [fmap (str fbase ".js")
               smap (str fbase ".map")
               sout (ret.toStringWithSourceMap
                      {:skipValidation true :file fmap})]
           (fs/writeFileSync smap sout.map)
           (str sout.code
                extra
                "\n//# sourceMappingURL="
                (path/relative (path/dirname fname) smap)))
         (str ret extra)))
  (try
    (if format (set! cstr
                   (esfmt/format cstr fopts)))
    (catch e (set! err e)))
  (set! cstr (cleanCode cstr))
  (vec (if (empty? cstr) "" (str (banner) cstr)) err))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn transpile

  "Compile kirby file to target source"
  ^Array [code file & [options]]

  (try (transpile* code file (opt?? options {}))
       (catch e
         (println (.-stack e)) (throw e))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn dbgAST
  "Dump AST to xml" ^String [source fname]
  (parser/dumpTree (parser/parse source fname) fname))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const version MOD-VER)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

