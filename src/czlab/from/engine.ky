;; Copyright (c) 2013-2017, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns ^{:doc ""
      :author "Kenneth Leung"}
  czlab.kirby.engine
  (:require ["readline" :as readline])
  (:require ["fs" :as fs])
  (:require ["./parser" :as parser]
            ["./stdlib"
             :as std
             :refer [pairs? stringify contains?
                     atom? list? map? some?
                     LambdaArg Keyword println
                     nichts? not-empty object?
                     Symbol into! prn
                     Atom symbol swap!
                     atom vector vector?
                     typeid sequential?
                     conj! count truthy? falsy?
                     last pop! opt??
                     keyword? symbol? seq]]))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const EXPKEY "da57bc0172fb42438a11e6e8778f36fb")
(const KBSTDLR "kirbystdlibref")
(const KBPFX "czlab.kirby.")
(const KBSTDLIB (str KBPFX "stdlib"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- macro_assert ```
  (macro* assert* [c msg] `(if* ~c true (throw* ~msg))) ```)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- macro_cond ```
  (macro* cond* [&xs]
    (if* (> (count* xs) 0)
      (list* 'if*
            (first* xs)
            (nth* xs 1)
            (cons* 'cond* (rest* (rest* xs)))))) ```)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- macro_andp ```
  (macro* _andp_* [&xs]
    (if* (= 1 ~(count* xs)) `~(first* xs) `(and ~@xs))) ```)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- GLOBAL (if (undef? window) undefined  window))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- STD-MACROS "czlab.kirby.stdlib")
(const- prefix "kirby> ")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- expect! "" [k]
  (if-not (inst? Symbol k)
    (raise! "expecting symbol")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deftype LEXEnv [][nsp nil parent nil
                   data {} libs {} vars {}]
  "Lexical Environment"
  (constructor "Create and initialize
               a new env with these symbols,
               and optionally a parent env"
    [parent vars vals]
    (if parent (assoc! this :parent parent))
    (for [i 0 e nil ev nil sz (n# vars)
          :while (< i sz) :recur (+1 i)]
      (set! e (.@i vars)
            ev (.-value e))
      (cond
        (= ev "&")
        (do (assoc! this.data
                     $(.@+i vars) (slice vals i))
            (break-out-of-loop!))
        (starts? ev "&")
        (do (assoc! this.data
                     (rest ev) (slice vals i))
            (break-out-of-loop!))
        :else
        (assoc! this.data ev (.@i vals)))))
  (find "Find the env
        containing this symbol"
    ^LEXEnv [k]
    (expect! k)
    (cond
      (contains? this.data k.value) this
      (some? this.parent) (.find this.parent k)))
  (set "Bind this symbol,
       value to this env"
    ^Any [k v]
    (expect! k)
    (assoc! this.data k.value v) v)
  (get "Get value of
       this symbol"
    ^Any [k]
    (expect! k)
    (var env (.find this k))
    (if env (get env.data k.value) k.value))
  (select ""
    ^Map [what]
    (reduce (fn [acc [k v]]
              (if (case what
                    :fn (fn? v)
                    :var (not (fn? v)) true)
                (assoc! acc $(k) v)) acc) {} (seq this.data)))
  (prn "Print set of vars"
    ^String []
    (std/prn this.data))
  (setNSP "Set current namespace"
    [nsp & info]
    (do->nil (set! this.nsp
                    {:id $(nsp) :meta info})))
  (curNSP "Returns the
           current namespace" [] this.nsp)
  (getLib "" [alias] (get this.libs alias))
  (addVar "" [sym info]
    (do->nil (var s (str sym)
                  m (get this.vars s))
             (if m
               (raise! "var: " s " already added"))
             (assoc! this.vars s info)))
  (getVar "" [sym]
    (get this.vars (str sym)))
  (hasVar? "" [sym]
    (contains? this.vars (str sym)))
  (addLib "" [alias lib]
    (do->nil
      (if (contains? this.libs alias)
        (raise! "Library alias already added: " alias))
      (assoc! this.libs alias lib))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro prnArr "" [arr] `(map #(prn %) ~arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn Function.prototype.clone "" ^Function []
  ;;run the old function with the new 'this'
  (var orig this
       cloned #(apply orig this ____args))
  (each-key
    (fn [v k] (=>> cloned k v)) orig) cloned)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- prnStr "" ^String [&xs] (join " " (prnArr xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- prnLn "" [&xs] (each #(println %) (prnArr xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn slurp "" ^String [f] (fs/readFileSync f "utf-8"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn spit "" [f s] (fs/writeFileSync f s "utf-8") nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- clone "" ^Any [obj]
  (var oid (typeid obj))
  (case oid
    (:vector :map :list)
    (into! oid (slice obj))
    :array
    (slice obj)
    :object
    (reduce
      (fn [acc [k v]]
        (assoc! acc k v) acc) {} (seq obj))
    :function
    (obj.clone)
    ;;else
    (raise! "clone of non-collection: " oid)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- cons "" ^Array [a b] (concat [a] b))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- conj "" ^Array [arr & xs]
  (cond
    (list? arr)
    (into! :list
           (-> (xs.reverse)
               (concat arr)))
    (some? arr)
    (into! :vector
           (concat arr xs))
    :else arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fapply "" ^Any [f & xs] (f.apply this xs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fmap "" ^Array [f arr] (map f arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- resolveJS "" ^Array [s]
  [(if (contains? s ".")
     (-> (.exec #/^(.*)\.[^\.]*$/g s)
         (nth 1) (eval))
     GLOBAL)
   (eval s)])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- filterJS "" ^Any [obj]
  (var s (stringify obj))
  (if (not-empty s) (JSON/parse s)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- withMeta "" ^Object [obj m]
  (var ret (clone obj))
  (assoc! ret :____meta m) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- meta "" ^Map [obj]
  (if-not (or (array? obj)
              (object? obj)
              (fn? obj))
    (raise! "can't get meta from: " (typeid obj)))
  (get obj :____meta))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- evalJS "" ^Any [s]
  (filterJS (eval (s.toString))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- invokeJS "" ^Any [method & xs]
  (var [obj f] (resolveJS method))
  (filterJS (apply f obj xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- *runtime-funcs* {
  "macroexpand*" (fn [code & [env]]
                    (println
                      (std/prn (expand??
                                 code (or env g_env)))))
  "assert*" (fn [k msg]
                (if-not k (raise! msg)))

  "macros*" (fn [&[fout]]
               (var s (std/prn CACHE))
               (if fout
                 (spit fout s)
                 (println s)))
  "env*" (fn [what & [env fout]]
               (var s (std/prn (.select (or env g_env) what)))
               (if fout
                 (spit fout s)
                 (println s)))
  "is-same?"  (fn [a b] (== a b))
  "is-nil?"  #(nil? %)
  "obj-type*"  std/typeid
  "gensym*"  std/gensym
  "is-eq?"  std/eq?
  "is-some?"  std/some?
  "str*" (fn [&xs] (join "" xs))
  "slice*"  (fn [arr & xs]
              (Array.prototype.slice.apply arr xs))
  "throw*"  (fn [&xs]
              (throw (new Error (.join xs ""))))
  "#f?"  #(false? %)
  "#t?"  #(true? %)
  "is-str?"  #(string? %)
  "is-keyword?"  std/keyword?
  "is-symbol?"  std/symbol?
  "keyword*"  std/keyword
  "symbol*"  std/symbol
  "println*"  prnLn
  "prn*"  prnStr
  "slurp*"  slurp
  "spit*" spit
  "<"   (fn [a b] (< a b))
  "<="  (fn [a b] (<= a b))
  ">"   (fn [a b] (> a b))
  ">="  (fn [a b] (>= a b))
  "/"   (fn [a &xs] (reduce (fn [acc n] (div acc n)) a xs))
  "+"   (fn [&xs] (reduce (fn [acc n] (+ acc n)) 0 xs))
  "-"   (fn [a &xs] (reduce (fn [acc n] (- acc n)) a xs))
  "*"   (fn [&xs] (reduce (fn [acc n] (* acc n)) 1 xs))
  "not=" (fn [a b] (not= a b))
  "=" (fn [a b] (= a b))
  "is-contains?" std/contains?
  "is-vector?"  std/vector?
  "is-list?"  std/list?
  "is-map?"  std/map?
  "is-array?"  (fn [x] (Array/isArray x))
  "object*"  std/object
  "vector*"  std/vector
  "list*"  std/list
  "hashmap*"  std/hashmap
  "values*"  #(Object.values %)
  "keys*"  #(Object.keys %)
  "get*"  #(get %1 %2)
  "not*"  #(if % #f #t)
  "dec*"  #(-1 %)
  "inc*"  #(+1 %)
  "is-even?"  #(= 0 (std/modulo % 2))
  "is-odd?"  #(= 1 (std/modulo % 2))
  "is-sequential?"  std/sequential?
  "concat*"  std/concat*
  "count*"  std/count
  "cons*"  cons
  "rest*"  #(if % (slice % 1) [])
  "nth*"  #(get %1 %2)
  "first*"  #(get % 0)
  "is-empty?" #(= 0 (std/count %))
  "not-empty*" std/not-empty
  "apply*"  fapply
  "map*"  fmap
  "evens*" std/evens
  "odds*" std/odds
  "meta*"  meta
  "conj*"  conj
  "seq*"  std/seq
  "is-atom?"  std/atom?
  "atom*"  std/atom
  "deref*"  std/deref
  "reset*"  std/reset!
  "swap*"  std/swap!
  "with-meta*"  withMeta
  "js-eval*"  evalJS
  "js*"  invokeJS
  "type*" #(typeof %) })

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- loadedMacros? false)
(const- CACHE {})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- loadMacros "" []
  (when-not loadedMacros?
    (true! loadedMacros?)
    (require "./macros.ky")) loadedMacros?)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn setMacro "Register a new macro"
  [cmd func]
  (do->nil
    (when (and cmd
               (fn? func))
      (set! cmd $(cmd))
      (when-not (contains? cmd "/")
        (var c (.curNSP g_env))
        (if-not c (raise! "missing namespace"))
        (set! cmd (str c.id "/" cmd)))
      ;;(println "adding macro ==== " cmd)
      (assoc! CACHE cmd func))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getMacro "Get macro" ^Function [cmd]
  (var~ skip nsp mname)
  (set! cmd $(cmd))
  (cond
    (contains? cmd "/")
    (let [[p c](cmd.split "/")
          tmp nil
          lib (.getLib (genv) p)]
      (set! mname c)
      (cond
        (= KBSTDLR p)
        (set! nsp KBSTDLIB)
        (nichts? lib)
        (set! skip true)
        :else
        (if-not (get lib EXPKEY)
          (set! skip true)
          (set! nsp (get (get lib EXPKEY) :ns)))))
    :else
    (let [m (.getVar (genv) cmd)]
      (set! mname cmd
            nsp (if m (get m :ns) KBSTDLIB))))
  (if-not skip
    (get CACHE (str nsp "/" mname))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- dbg "" [x] (do->nil (println "DBG: " (prn x))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn readAST "" ^Array [s]
  (var ret (parser/parse s))
  (if (single? ret)
    (set! ret (1st ret))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- backtick "" ^Array [ast]
  (var lst? #(and (sequential? %)
                  (not-empty %)))
  (cond
    (not (lst? ast))
    ['quote ast]
    ;;
    (and (symbol? (1st ast))
         (== (1st ast) "unquote"))
    (2nd ast)
    ;;
    (and (lst? (1st ast))
         (symbol? (1st (1st ast)))
         (== (1st (1st ast)) "splice-unquote"))
    ['concat* (2nd (1st ast)) (backtick (rest ast))]
    ;;
    :else
    ['cons* (backtick (1st ast))
            (backtick (rest ast))]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- isMacroCall? "" ^Boolean [ast env]
  (and (pairs? ast)
       (symbol? (1st ast))
       (getMacro $(1st ast))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn expand?? "" ^Any [ast env]
  (var~ cmd mac)
  (while (isMacroCall? ast env)
    (set! cmd $(1st ast)
          mac (getMacro cmd)
          ast (apply mac this (rest ast)))) ast)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- eval* "" ^Any [ast env]
  (cond
    (string? ast) (std/unquote-str ast)
    (keyword? ast) (.-value ast)
    (symbol? ast) (env.get ast)
    ;complex data
    (pairs? ast)
    (map #(compute %1 env) ast)
    (list? ast)
    (into! :list (map #(compute %1 env) ast))
    (vector? ast)
    (into! :vector (map #(compute %1 env) ast))
    (map? ast)
    (do-with [m {}]
      (for [i 0 sz (n# ast)
            :while (< i sz) :recur (+2 i)]
        (assoc! m
                 (compute (.@i ast) env)
                 (compute (.@+i ast) env))))
    :else ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- doAND "" ^Boolean [ast env]
  (var ret #t)
  (for [i 1 sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (set! ret (compute (.@i ast) env))
    (if-not ret (break-out-of-loop!))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- doOR "" ^Boolean [ast env]
  (var ret nil)
  (for [i 1 sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (set! ret (compute (.@i ast) env))
    (if ret (break-out-of-loop!))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- doLET "" ^Array [ast env]
  (var e (new LEXEnv env)
       binds (2nd ast))
  (for [i 0 sz (n# binds)
        :while (< i sz) :recur (+2 i)]
    (e.set (.@i binds)
           (compute (.@+i binds) e)))
  [(3rd ast) e])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;(macro* name args body)
(defn- doMACRO "" [ast env]
  (var name $(2nd ast)
       nsp (.curNSP g_env))
  (set! nsp (if nsp nsp.id STD-MACROS))
  (if-not (contains? name "/")
    (set! name (str nsp "/" name)))
  (do->nil (setMacro name
                     (fn->raw (3rd ast)
                              (.@3 ast) env))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- doTRY "" ^Any [ast env]
  (var a3 (3rd ast))
  (try
    (compute (2nd ast) env)
    (catch e
      (if (and a3 (== "catch*"
                      (1st a3)))
        (do (if (inst? Error e)
              (set! e (.-message e)))
            (compute (3rd a3)
                     (new LEXEnv
                          env [(2nd a3)] [e])))
        (throw e)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- doIF "" ^Any [ast env]
  (var kond (compute (.@1 ast) env)
       a2 (.@2 ast)
       a3 (.@3 ast))
  (if (falsy? kond)
    (if-not (undef? a3) a3) a2))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- form* "" ^Any [ast env]
  (var el (eval* ast env))
  (cond
    (or (vector? ast)
        (map? ast) (list? ast)) (atom el)
    (array? el)
    (let [f (1st el)
          c (if (fn? f) f.____code)]
      (cond
        (array? c)
        [(2nd c)
         (new LEXEnv (3rd c) (1st c) (rest el))]
        (fn? f)
        (atom (apply f this (rest el)))
        :else (atom el)))
    :else (atom el)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fn->raw "Wrap the function body and args inside
               a native js function"
  ^Function [fargs fbody env]
  (doto #(compute fbody (new LEXEnv env fargs ____args))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- *spec-forms* {
  "def*" (fn [a e] (atom (e.set (.@1 a)
                                (compute (.@2 a) e))))
  "and*" #(atom (doAND %1 %2))
  "or*" #(atom (doOR %1 %2))
  "let*" #(doLET %1 %2)
  "quote" #(atom (2nd %1))
  "syntax-quote" #([(backtick (2nd %1)) %2])
  "macro*" #(atom (doMACRO %1 %2))
  "try*" #(atom (doTRY %1 %2))
  "do*" (fn [a e]
          (eval* (a.slice 1 -1) e)
          [(nth a (last-index a)) e])
  "if*" #([(doIF %1 %2) %2])
  "lambda*" #(atom (fn->raw (.@1 %1) (.@2 %1) %2)) })

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn compute "Interpret a expression" ^Any [expr cenv]
  (var g1 #(if (pairs? %) (1st %) "")
       env (or cenv g_env)
       ret (loop [ast (expand?? expr env)]
             (var cmd $(g1 ast)
                  fc (get *spec-forms* cmd)
                  res (cond
                        (not (arr? ast))
                        (atom (eval* ast env))
                        (empty? ast)
                        (atom ast)
                        (fn? fc)
                        (fc ast env)
                        :else
                        (form* ast env)))
             (if (atom? res)
               res
               (do (set! env (2nd res))
                   (recur (expand?? (1st res) env))))))
  (if (undef? @ret) nil @ret))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn newEnv "Create a new interpreter environment" ^LEXEnv []
  (do-with [ret (new LEXEnv)]
    (each-key (fn [v k]
                (ret.set (symbol k) v)) *runtime-funcs*)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn runRepl "Start a interactive session" []
  (var ss (readline/createInterface process.stdin
                                    process.stdout)
       z (alen prefix)
       pt #(do (ss.setPrompt prefix z)
               (ss.prompt ))
       rl (fn [line]
            (try (if line (println (reval line)))
                 (catch e (println e))) (pt))
       cl #(do (println "Bye!") (process.exit 0)))
  (ss.on :close cl)
  (ss.on :line rl)
  (init)
  (println prefix "Kirby REPL v" *version*) (pt))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- reval "Eval one or more expressions" ^Any [expr & xs]
  (var f (comp prn
               compute readAST) ret (f expr))
  (doseq [e xs] (set! ret (f e))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- inited? false
      *version* "" g_env nil)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn init "Set up the runtime environment" ^Boolean [ver]
  (when-not inited?
    (set! *version* ver g_env (newEnv))
    (reval macro_cond macro_andp)
    ;;(loadMacros)
    (true! inited?)) inited?)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn genv "Returns the runtime environment" [] g_env)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

