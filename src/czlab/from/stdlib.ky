;; Copyright (c) 2013-2017, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns ^{:doc "Kirby's standard core library."
      :author "Kenneth Leung"}
  czlab.kirby.stdlib)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro empty? "" [coll] `(= 0 (kirbystdlibref/count ~coll)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro starts? "" [s arg] `(.startsWith ~s ~arg))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro ends? "" [s arg] `(.endsWith ~s ~arg))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro n# "" [coll] `(kirbystdlibref/count ~coll))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro 1st "" [x] `(first ~x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro 2nd "" [x] `(second ~x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro 3rd "" [x] `(nth ~x 2))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro trap! "" [&msgs]
  (let* [sz (count* msgs)]
    (if* (> sz 1)
      `(throw (join "" (vec ~@msgs)))
      (if* (> sz 0)
        `(throw ~(nth* msgs 0)) `(throw "error!")))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro merror "" [e] `(new Error ~e))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro raise! "" [&msgs]
  (let* [sz (count* msgs)]
    (if* (> sz 1)
      `(throw (merror (join "" (vec ~@msgs))))
      (if* (> sz 0)
        `(throw (merror ~(nth* msgs 0))) `(throw (merror "error!"))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro slice "" [arr &[start end]]
  (if* end
       `(Array.prototype.slice.call ~arr ~start ~end)
       (if* start
            `(Array.prototype.slice.call ~arr ~start)
            `(Array.prototype.slice.call ~arr))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro float "" [x] `(parseFloat ~x))
(defmacro int "" [x] `(parseInt ~x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro println "" [&msgs]
  `(if console
     (console.log (join "" (vec ~@msgs)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro delay "" [f t] `(setTimeout ~f ~t))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro break-out-of-loop! "" [] `(set! ____break true))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro undef! "" [x] `(set! ~x undefined))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro nil! "" [x] `(set! ~x nil))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro last-index "" [coll] `(-1 (alen ~coll)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro rest "" [coll] `(.slice ~coll 1))
(defmacro cdr "" [coll] `(.slice ~coll 1))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro second "" [coll] `(nth ~coll 1))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro first "" [coll] `(nth ~coll 0))
(defmacro car "" [coll] `(nth ~coll 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro nexth "" [coll i] `(nth ~coll (+1 ~i)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro nth "" [coll i] `(get ~coll ~i))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro even? "" [&xs]
  `(_andp_* ~@(map* (lambda* [x] `(= 0 (kirbystdlibref/modulo ~x 2))) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro odd? "" [&xs]
  `(_andp_* ~@(map* (lambda* [x] `(not (even? ~x))) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro alen "" [coll] `(.-length ~coll))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro nzlen? "" [coll] `(> (alen ~coll) 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro zlen? "" [coll] `(= 0 (alen ~coll)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro type "" [obj] `(typeof ~obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro whatis? "" [obj] `(Object.prototype.toString.call ~obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro regex? "" [&xs]
  `(_andp_* ~@(map* (lambda* [x] `(= (whatis? ~x) "[object RegExp]")) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro array? "" [&xs]
  `(_andp_* ~@(map* (lambda* [x] `(Array.isArray ~x)) xs)))
(defmacro arr? "" [&xs] `(array? ~@xs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro date? "" [&xs]
  `(_andp_* ~@(map* (lambda* [x] `(= (whatis? ~x) "[object Date]")) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro bool? "" [&xs] `(boolean? ~@xs))
(defmacro boolean? "" [&xs]
  `(_andp_* ~@(map* (lambda* [x] `(= (typeof ~x) "boolean")) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro num? "" [&xs] `(number? ~@xs))
(defmacro number? "" [&xs]
  `(_andp_* ~@(map* (lambda* [x] `(= (typeof ~x) "number")) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro str? "" [&xs] `(string? ~@xs))
(defmacro string? "" [&xs]
  `(_andp_* ~@(map* (lambda* [x] `(= (typeof ~x) "string")) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro fn? "" [&xs]
  `(_andp_* ~@(map* (lambda* [x] `(= (typeof ~x) "function")) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro undef? "" [&xs]
  `(_andp_* ~@(map* (lambda* [x] `(= (typeof ~x) "undefined")) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro def? "" [&xs]
  `(_andp_* ~@(map* (lambda* [x] `(not= (typeof ~x) "undefined")) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro nil? "" [&xs]
  `(_andp_* ~@(map* (lambda* [x] `(= ~x null)) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro zero? "" [&xs]
  `(_andp_* ~@(map* (lambda* [x] `(= ~x 0)) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro one? "" [&xs]
  `(_andp_* ~@(map* (lambda* [x] `(= ~x 1)) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro neg? "" [&xs]
  `(_andp_* ~@(map* (lambda* [x] `(< ~x 0)) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro pos? "" [&xs]
  `(_andp_* ~@(map* (lambda* [x] `(> ~x 0)) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro values "" [obj] `(Object.values ~obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro keys "" [obj] `(Object.keys ~obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro assert "" [tst & msgs] `(if ~tst true (raise! ~@msgs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro false? "" [&xs]
  `(_andp_* ~@(map* (lambda* [x] `(= ~x false)) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro true? "" [&xs]
  `(_andp_* ~@(map* (lambda* [x] `(= ~x true)) xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro when-not "" [tst & xs] `(when (not ~tst) ~@xs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro unless "" [tst & xs] `(when-not ~tst ~@xs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro if-not
  "" [tst then & [else]] `(if (not ~tst) ~then ~else))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro while "" [tst & xs] `(for [:while ~tst] ~@xs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro when "" [tst & xs] `(if ~tst (do ~@xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro cond "" [&xs]
  (let* [len (count* xs)]
    (do* (assert* (is-even? len) "cond expects even args")
         (if* (> len 0)
           (let* [c (nth* xs 0)
                  e (nth* xs 1)
                  r (rest* (rest* xs))]
             (if* (is-same? c "else")
               `(if true ~e)
               `(if ~c ~e (cond ~@r))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro -> "" [expr form & xs]
  (let* [x `(~(nth* form 0)
                    ~expr ~@(rest* form))]
    (if* (> (count* xs) 0) `(-> ~x ~@xs) `~x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro ->> "" [expr form & xs]
  (let* [x `(~@form ~expr)]
    (if* (> (count* xs) 0) `(->> ~x ~@xs) `~x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro let "" [bindings & xs] `(do (var ~@bindings) ~@xs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro single? "" [coll] `(= 1 (n# ~coll)))
(defmacro dual? "" [coll] `(= 2 (n# ~coll)))
(defmacro triple? "" [coll] `(= 3 (n# ~coll)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defmacro loop "" [bindings & more]
  (let*
    [es (evens* bindings)
     os (odds* bindings)]
    `((fn []
        (var _x_ nil recur nil
             _f_ (fn [~@es] ~@more) _r_ _f_)
        (set! recur
              (fn []
                (set! _x_ arguments)
                (raw# "if (_r_) {for(_r_=undefined;_r_===undefined;){_r_=_f_.apply(this,_x_);} return _r_;}")
                undefined))
        (recur ~@os)) this)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro concat "" [coll x] `(.concat ~coll ~x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro join "" [sep coll] `(.join ~coll ~sep))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro do-with "" [binding & xs]
  (let* [f (nth* binding 0)]
    `(let [~f ~(nth* binding 1)] ~@xs ~f)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro do->false "" [&xs]
  (let* [a (gensym*)] `(let [~a false] ~@xs ~a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro do->true "" [&xs]
  (let* [a (gensym*)] `(let [~a true] ~@xs ~a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro do->nil "" [&xs]
  (let* [a (gensym*)] `(let [~a nil] ~@xs ~a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro do->undef "" [&xs]
  (let* [a (gensym*)] `(let [~a undefined] ~@xs ~a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro inc "" [x] `(+1 ~x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro dec "" [x] `(-1 ~x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro dotimes "" [binding &xs]
  (let* [_t (gensym*)
         b1 (first* binding)]
    `(for [~b1 0 ~_t ~(nth* binding 1)
           :while (< ~b1 ~_t) :recur (+1 ~b1)] ~@xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro range "" [a & [b c]]
  (let* [start (if* b a 0)
         end (if* b b a)
         step (if* c c 1)]
    `(do-with [ret []]
       (for [i ~start
             :while (< i ~end) :recur (+ i ~step)]
         (ret.push i)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro apply
  "" [f this args] `(.apply ~f ~this ~args))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro apply*
  "" [f this & args]
  `(.apply ~f ~this (vec ~@args)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro ch@ "" [s pos] `(.charAt ~s ~pos))
(defmacro false! "" [x] `(set! ~x false))
(defmacro true! "" [x] `(set! ~x true))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro repeat "" [n x]
  `(do-with [ret []]
     (for [i 0
           :while (< i ~n)
           :recur (+1 i)] (ret.push ~x))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro doseq "" [bindings & xs]
  (let*
    [loopExpr (gensym*)
     escvar (gensym*)
     idxvar (gensym*)
     _let (if* (is-eq? (nth* bindings 2) ':let)
               (nth* bindings 3))
     _while (if* (is-eq? (nth* bindings 2) ':while)
                 (nth* bindings 3)
                 (if* (is-eq? (nth* bindings 4) ':while)
                      (nth* bindings 5)
                      (if* (is-eq? (nth* bindings 6) ':while)
                           (nth* bindings 7)
                           true)))
     _when (if* (is-eq? (nth* bindings 2) ':when)
                (nth* bindings 3)
                (if* (is-eq? (nth* bindings 4) ':when)
                     (nth* bindings 5)
                     (if* (is-eq? (nth* bindings 6) ':when)
                          (nth* bindings 7)
                          true)))]
    `(let [~loopExpr ~(nth* bindings 1)]
       (for [~idxvar 0
             ~escvar false
             :while (and (not ~escvar)
                         (< ~idxvar (alen ~loopExpr))) :recur (+1 ~idxvar)]
         (var ~(nth* bindings 0)
              (nth ~loopExpr ~idxvar))
         ~(if* _let `(var ~@_let))
         (if-not ~_while (set! ~escvar true))
         (when (and (not ~escvar) ~_when) ~@xs)) nil)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro if-some+ "" [binding then & [else]]
  (let* [tst (gensym*)]
    `(let [~tst ~(nth* binding 1)
           ~(first* binding) ~tst]
       (if (> (n# ~tst) 0) ~then ~else))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro if-some "" [binding then & [else]]
  (let* [tst (gensym*)]
    `(let [~tst ~(nth* binding 1)
           ~(first* binding) ~tst]
       (if (or (undef? ~tst)
               (nil? ~tst)) ~else ~then))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro if-let "" [binding then & [else]]
  (let* [tst (gensym*)]
    `(let [~tst ~(nth* binding 1)
           ~(first* binding) ~tst] (if ~tst ~then ~else))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro when-some+ "" [binding &xs]
  (let* [tst (gensym*)]
    `(let [~tst ~(nth* binding 1)
           ~(first* binding) ~tst]
       (when (> (n# ~tst) 0) ~@xs))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro when-some "" [binding &xs]
  (let* [tst (gensym*)]
    `(let [~tst ~(nth* binding 1)
           ~(first* binding) ~tst]
       (when-not (or (undef? ~tst)
                     (nil? ~tst)) ~@xs))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro when-let "" [binding &xs]
  (let* [tst (gensym*)]
    `(let [~tst ~(nth* binding 1)
           ~(first* binding) ~tst] (when ~tst ~@xs))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro doto "" [target & xs]
  (let* [v (gensym*)]
    `(let [~v ~target]
       ~@(map* (lambda* [e]
                    `(~(first* e) ~v ~@(rest* e))) xs) ~v)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro map "" [f coll] `(.map ~coll ~f))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro filter "" [p coll] `(.filter ~coll ~p))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro some "" [p coll] `(.some ~coll ~p))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro take "" [coll cnt] `(slice ~coll 0 ~cnt))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro constantly "" [x] `(fn [&xs] ~x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro drop "" [coll cnt] `(slice ~coll ~cnt))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro reduce2 "" [f coll] `(.reduce ~coll ~f))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro reduce
  "" [f start coll] `(.reduce ~coll ~f ~start))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro str [&xs] `(.join (vec ~@xs) ""))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro lambda "" [code]
  (let* [sz (count* code)
         body (if* (> sz 1)
                   code
                   (if* (> sz 0) (nth* code 0)))]
    `(fn [] (var ____args (slice arguments)) ~body)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro each "" [func coll] `(.forEach ~coll ~func))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro each-key "" [func obj]
  (let* [t (gensym*)]
    `(let [~t ~obj]
       (each (fn [e]
               (~func (nth e 1) (nth e 0)))
             (Object.entries ~t)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro do-monad "" [monad bindings & body]
  `((fn [mo]
      (var res
           (fn [&xs]
             (if (and (or (nil? xs)
                          (zlen? xs))
                      (def? mo.zero))
               mo.zero
               (mo.result.apply mo xs))))
      (do-bind mo.bind
               ~bindings
               (res.apply this ~@body))) ~monad))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro do-bind "" [bindfunc bindings & body]
  (let* [a2 (nth* bindings 1)
         a1 (nth* bindings 0)
         more (rest* (rest* bindings))]
    `(~bindfunc ~a2
                (fn [~a1]
                  ~(if* (not-empty* more)
                        `(do-bind ~bindfunc
                                  ~more
                                  ~@body)
                        `(do ~@body))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro monad-identity "" [monads bindings & body]
  `(do-monad (.-identity monads) ~bindings ~@body))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro monad-maybe "" [monads bindings & body]
  `(do-monad (.-maybe monads) ~bindings ~@body))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro monad-array "" [monads bindings & body]
  `(do-monad (.-array monads) ~bindings ~@body))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro monad-state "" [monads bindings & body]
  `(do-monad (.-state monads) ~bindings ~@body))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro monad-continuation "" [monads bindings & body]
  `(do-monad (.-continuation monads) ~bindings ~@body))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;MACROS-EOF


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn not-empty

  "If coll is empty, returns nil, else coll"
  [coll]

  (if (empty? coll) nil coll))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- noCRef
  "Use a cache to store already referenced objects
  to prevent circular references" []
  (var cache [])
  (fn [k v]
    (cond (fn? v)
          (set! v "native-fn")
          (object? v)
          (if (contains? cache v)
            (undef! v)
            (conj! cache v))) v))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn stringify

  "JSON stringify (no cyclical obj-ref)"
  ^String [obj]

  (if obj (JSON/stringify obj (noCRef))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn opt??

  "If cur is not defined, returns other else cur"
  ^Any [cur other]

  (if (def? cur) cur other))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn conj!

  "conj[oin]. Returns coll with the xs
  'added'. (conj! nil item) returns [item].
  If coll is a list, prepends else appends to coll."

  ^Array [coll & xs]
  (var c (or coll []))
  (if (list? c)
    (->> (xs.reverse)
         (c.unshift.apply c)) (c.push.apply c xs)) c)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn conj "Like conj! but
           returns a new collection"
  ^Array [coll & xs]
  (var c
       (cond (vector? coll)
             (into :vector coll)
             (list? coll)
             (into :list coll)
             (map? coll)
             (into :map coll)
             (nichts? coll)
             []
             :else (slice coll)))
  (apply conj! this (concat [c] xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn pop!

  "Removes the first element if list,
  else removes the last element,
  returning the element
  and the altered collection"

  ^Array [coll]
  (var r (if (list? coll)
           (coll.shift) (coll.pop))) [r coll])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn pop "Like pop! but returns a new collection"
  ^Array [coll]
  (var r (if (list? coll)
           (1st coll) (last coll)))
  [r (if (list? coll)
       (coll.slice 1) (coll.slice 0 -1))])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn wrap-str
  "Prepend and append
  strings to the object." [obj start end] (str start obj end))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getProp

  "If prop is a string, returns the value of
  this object property, obeying the own? flag.
  Otherwise, return the value at the index of
  the array"

  ^Any
  [obj prop & [own?]]
  (set! own? (opt?? own? true))
  (if (or (string? prop)
          (number? prop))
    (if (and own?
             (string? prop)
             (not (obj.hasOwnProperty prop)))
      undefined
      (raw# "obj[prop]"))
    undefined))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn prn

  "Print data as string - use to dump an AST node"
  ^String [obj & [r?]]

  (var f (noCRef))
  (if (complex? obj)
    (set! obj (f nil obj)))
  (if obj (prn* obj r? f) ""))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- prnArr* "Print an array" [obj r? f]
  (join " "
        (map (fn [v i]
               (var x (f i v))
               (-> (opt?? x null)
                   (prn* r? f))) obj)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- prn*

  "" [obj r? func]

  (var pfx #(prn* % r? func)
       parr (if (arr? obj)
              #(wrap-str
                 (prnArr* obj
                          r? func) %1 %2)))
  (case (typeid obj)
    :atom
    (wrap-str (func nil obj.value) "(atom" ")")
    :lambda-arg
    (str "%" (+1 (int obj.value)))
    :keyword
    (str ":" obj.value)
    :symbol
    obj.value
    :object
    (-> (reduce (fn [acc [k v]]
                  (var x (func k v))
                  (if-not (undef? x)
                    (conj! acc
                           (str (pfx k)
                                ":" (pfx x)))) acc)
                [] (seq obj))
        (.join  ",")
        (wrap-str "{" "}"))
    :vector
    (parr "[" "]")
    :map
    (parr "{" "}")
    :list
    (parr "'(" ")")
    :string
    (if r? (quote-str obj) obj)
    (:null :nil)
    "null"
    (if (array? obj)
      (parr "(" ")") (obj.toString))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deftype LambdaArg [][value ""]
  "Defining a lambda positional argument"
  (constructor "" [arg]
    (var name (if (= arg "%")
                "1" (rest arg))
         v (int name))
    (if-not (> v 0)
      (raise! "invalid lambda-arg " arg))
    ;;zero based arg so minus 1
    (-- v)
    (set! this.value $(v)))
  (toString "" [] this.value))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deftype Primitive [][value nil]
  "Defining a primitive data type"
  (constructor "" [v]
    (set! this.value v))
  (toString "" [] this.value))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deftype Keyword [][value ""]
  "Defining a keyword"
  (constructor "" [name]
    (set! this.value (rest name)))
  (toString "" [] this.value))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deftype Symbol [][value ""]
  "Defining a symbol"
  (constructor "" [name]
    (set! this.value name))
  (toString "" [] this.value))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn primitive?
  "Returns true if primitive" [obj] (inst? Primitive obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn primitive
  "Create a Primitive" ^Primitive [v] (new Primitive v))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn symbol?
  "Returns true if a symbol" [obj] (inst? Symbol obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn symbol
  "Create a new Symbol" ^Symbol [name] (new Symbol name))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn keyword?
  "Returns true if a keyword" [obj] (inst? Keyword obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn keyword
  "Create a new Keyword" ^Keyword [name] (new Keyword name))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn keyword->symbol
  "Convert a Keyword to Symbol" ^Symbol [k]
  (var s (new Symbol k.value))
  (assoc! s
          :source k.source
          :line  k.line
          :column k.column) s)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn lambda-arg?
  "Returns true if a Lambda Arg" [obj] (inst? LambdaArg obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn lambda-arg
  "Create a new Lambda Arg" ^LambdaArg [name] (new LambdaArg name))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deftype Atom [][value nil]
  "Defining a clojure-like Atom"
  (constructor "" [val] (set! this.value val)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn atom?
  "Returns true if an Atom" [atm] (inst? Atom atm))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn atom
  "Create a new Atom" ^Atom [val] (new Atom val))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn reset!
  "Set a new value to the Atom" [a v] (do->nil (set! a.value v)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn deref
  "Get value inside the Atom" ^Any [a] (.-value a))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn swap! "Change value inside the Atom,
            returning the new value"
  ^Any [a f & xs]
  (->> (concat [a.value] xs)
       (apply f this)
       (set! a.value )) (get a :value))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn typeid "Returns the type-id
             of this object"
  [obj]
  (cond
    (lambda-arg? obj) :lambda-arg
    (keyword? obj) :keyword
    (symbol? obj) :symbol
    (vector? obj) :vector
    (atom? obj) :atom
    (list? obj) :list
    (map? obj) :map
    (nil? obj) :null
    (true? obj) :true
    (false? obj) :false
    (fn? obj) :function
    (string? obj) :string
    (number? obj) :number
    (array? obj) :array
    (object? obj) :object
    :else
    (raise! "Unknown type [" (type obj) "]")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn complex?
  "True if x is an array
  or js object." [x] (or (array? x) (object? x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn simple? "True if x is a
              primitive value type" [obj]
  (or (undef? obj)
      (nil? obj) (false? obj) (true? obj) (string? obj) (number? obj)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn value? "Returns true
             if a simple LISP value"
  [obj]
  (or (nil? obj)
      (vector? obj)
      (list? obj)
      (map? obj)
      (false? obj)
      (true? obj)
      (string? obj)
      (number? obj)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn sequential? "True if coll
                  implements Sequential"
  [arr] (and (array? arr) (not (map? arr))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- map2Obj "" [m]
  (var ret {})
  (var~ k v)
  (for [i 0 sz (n# m)
        :while (< i sz) :recur (+2 i)]
    (set! k (.@i m)
          v (.@+i m))
    (assoc! ret (str k) v)) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn eq? "True if both are equal" [a b]
  (var k nil ok? true)
  (cond
    (and (map? a) (map? b)
         (= (alen a) (alen b)))
    (eq? (map2Obj a) (map2Obj b))
    (and (array? a) (array? b)
         (= (alen a) (alen b)))
    (do (for [i 0 sz (alen a)
              :while (and ok? (< i sz)) :recur (+1 i)]
          (when-not (eq? (.@i a)
                         (.@i b)) (false! ok?))) ok?)
    (and (inst? LambdaArg a)
         (inst? LambdaArg b))
    (= a.value b.value)
    (and (inst? Symbol a)
         (inst? Symbol b))
    (= a.value b.value)
    (and (inst? Keyword a)
         (inst? Keyword b))
    (= a.value b.value)
    (and (object? a)
         (object? b)
         (= (n# a) (n# b)))
    (do (for [i 0 ks (keys a) sz (n# ks)
              :while (and ok? (< i sz)) :recur (+1 i)]
          (set! k (.@i ks))
          (when-not (eq? (get a k)
                         (get b k)) (false! ok?))) ok?)
    :else
    (= a b)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn object? "Returns true
              if a js object" [obj]
  (if-not (or (nil? obj)
              (array? obj)) (= (type obj) "object")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn last "Returns the last element"
  ^Any [coll]
  (if (and (array? coll)
           (nzlen? coll)) (nth coll (last-index coll))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn into! "Assign a type to this collection"
  ^Array [type coll]
  (case type
    :vector
    (assoc! coll :____vec #t)
    :list
    (assoc! coll :____list #t)
    :map
    (assoc! coll :____map #t)) coll)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn into "Like into! but
           returning a new collection"
  ^Array [type coll]
  (into! type (coll.slice 0)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn pairs? "Returns true if
             a LISP list, not data" [obj]
  (and (array? obj)
       (not (vector? obj)) (not (map? obj)) (not (list? obj))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn list? "Returns true if a List"
  [obj] (and (array? obj) obj.____list))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn list
  "Create a List" ^Array [&xs] (assoc! xs :____list #t) xs)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn vector? "Returns true if a Vector"
  [obj] (and (array? obj) obj.____vec))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn vector
  "Create a Vector" ^Array [&xs] (assoc! xs :____vec #t) xs)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn map? "Returns true if a Hashmap"
  [obj] (and (array? obj) obj.____map))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn hashmap "Create a new Hashmap"
  ^Array [&xs]
  (if (odd? (alen xs))
    (raise! "Invalid arity for hashmap")) (assoc! xs :____map #t) xs)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn seq "Returns a sequence"
  ^Array [obj]
  (cond
    (string? obj) (obj.split "")
    (array? obj) (obj.slice 0)
    (object? obj) (Object.entries obj)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn contains? "True if item is inside" [coll x]
  (cond
    (or (array? coll)
        (string? coll)) (coll.includes x)
    (object? coll) (coll.hasOwnProperty x) :else false))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn nichts? "True if object is
              either null of undefined" [obj] (or (undef? obj) (nil? obj)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn some? "True if object is
            defined and not null" [obj] (not (nichts? obj)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn count "Count the number of elements inside"
  ^Integer [coll]
  (if coll
    (alen (if (or (string? coll)
                  (array? coll)) coll (keys coll))) 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn concat* "Add many to this collection"
  ^Array [coll & xs]
  (if coll (coll.concat.apply coll xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- every "" ^Array [coll start step]
  (var ret [])
  (for [i start sz (n# coll)
        :while (< i sz) :recur (+ i step)] (conj! ret (.@i coll))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn evens "Collect every
            2nd item starting at 0" ^Array [coll] (every coll 0 2))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn odds "Collect every
           2nd item starting at 1" ^Array [coll] (every coll 1 2))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn modulo "Modulo"
  ^Integer [x N]
  (if (< x 0)
    (- x (* -1
            (+ N (* (Math.floor (div (- x) N)) N))))
    (rem x N)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn interleave "Returns a seq of the first item
                 in each coll, then the second, etc"
  ^Array [c1 c2]
  (var cz (if (< (alen c2)
                 (alen c1))
            (alen c2) (alen c1))
       ret [])
  (for [i 0
        :while (< i cz) :recur (+1 i)] (conj! ret (.@i c1) (.@i c2))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn zipmap "Returns an object with the
             keys mapped to the corresponding vals"
  ^Object [keys vals]
  (var cz (if (< (alen keys)
                 (alen vals))
            (alen keys) (alen vals))
       ret {})
  (for [i 0
        :while (< i cz) :recur (+1 i)]
    (assoc! ret $(.@i keys) (.@i vals))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn extendAttr "" ^Object [obj attr & [flags]]
  (set! flags (opt?? flags
                   {:enumerable #f :writable #t}))
  (Object.defineProperty obj attr flags) obj)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn cons
  "Returns a new seq where x is the first element and seq is
  the rest." [x coll] (.concat [x] coll))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- gensym-counter (atom 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn gensym "Generates next random symbol"
  ^Symbol [& [pfx]]
  (symbol (str (opt?? pfx "GS__")
               (swap! gensym-counter
                      (fn [x] (+1 x))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn carve "" ^Array [coll & [start end]]
  (if (def? end)
    (Array.prototype.slice.call coll start end)
    (if (def? start)
      (Array.prototype.slice.call coll start)
      (Array.prototype.slice.call coll))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn assoc! "" ^Object [mmap & xs]
  (when mmap
    (for [i 0 sz (n# xs)
          :while (< i sz) :recur (+2 i)]
      ;the following assoc!
      ;will be compiled out
      (assoc! mmap (.@i xs) (.@+i xs)))) mmap)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn dissoc! "" ^Object [mmap & xs]
  (when mmap
    (doseq [n xs]
      (delete! mmap n))) mmap)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn truthy? "LISP truthy" [a] (not (falsy? a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn falsy? "LISP falsy" [a] (or (nil? a)(false? a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;monads
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def m-identity
  {:bind (fn [mv mf] (mf mv))
   :result #(%1)})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def m-maybe
  {:bind (fn [mv mf]
           (if-not (nil? mv) (mf mv)))
   :result #(%1)
   :zero nil})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def m-array
  {:bind (fn [mv mf]
           (reduce
             (fn [acc v]
               (concat acc v)) [] (map mf mv)))
   :result #(concat [] %)
   :zero []
   :plus #(reduce
            (fn [acc v]
              (concat acc v)) [] ____args)})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def m-state
  {:bind (fn [mv mf]
           (fn [s]
             (var x (mv s))
             ((mf (1st x)) (2nd x))))
   :result (fn [v]
             (fn [s]
               (concat [] [v s])))})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def m-continuation
  {:bind (fn [mv mf]
           (fn [c]
             (mv (fn [v] ((mf v) c)))))
   :result (fn [v] (fn [c] (c v)))})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn quote-str "Add quotes around a string" ^String [s]
  (var out "\"")
  (for [i 0 ch "" sz (count s)
        :while (< i sz) :recur (+1 i)]
    (set! ch (ch@ s i))
    (cond
      (= ch "\"") (+= out "\\\"")
      (= ch "\n") (+= out "\\n")
      (= ch "\t") (+= out "\\t")
      (= ch "\f") (+= out "\\f")
      (= ch "\r") (+= out "\\r")
      (= ch "\v") (+= out "\\v")
      (= ch "\\") (+= out (if (= "u" (ch@ s (+1 i))) ch "\\\\"))
      :else (+= out ch)))
  (+= out "\""))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn unquote-str "Removes quotes around a string" ^String [s]
  (if (and (starts? s "\"")
           (ends? s "\""))
    (do-with [out ""]
      (set! s (s.slice 1 -1))
      (for [i 0 nx "" ch "" sz (count s)
            :while (< i sz) :recur (+1 i)]
        (set! ch (ch@ s i))
        (if (= ch "\\")
          (do (++ i)
              (set! nx (ch@ s i))
              (cond
                (= nx "\"") (+= out "\"")
                (= nx "\\") (+= out "\\")
                (= nx "n") (+= out "\n")
                (= nx "t") (+= out "\t")
                (= nx "f") (+= out "\f")
                (= nx "v") (+= out "\v")
                (= nx "r") (+= out "\r")
                :else (do (+= out ch) (-- i))))
          (+= out ch))))
    s))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn escXml "Escape XML special chars" ^String [s]
  (var out "")
  (for [i 0 c nil sz (n# s)
        :while (< i sz) :recur (+1 i)]
    (set! c (.@i s))
    (cond
      (= c "&") (set! c "&amp;")
      (= c ">") (set! c "&gt;")
      (= c "<") (set! c "&lt;")
      (= c "\"") (set! c "&quot;")
      (= c "'") (set! c "&apos;"))
    (+= out c))
  out)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn split-seq "Split a collection into 2 parts" ^Array [coll cnt]
  (if (< cnt (count coll))
    [(take coll cnt) (drop coll cnt)]
    [(slice coll 0) []]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn select-keys "Get a subset of keys" ^Object [coll keys]
  (reduce
    (fn [acc n]
      (assoc! acc
           (str n)
           (get coll (str n))) acc) {} (seq keys)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- doUpdateIn! "" [coll n func args err]
  (var cur (cond
             (number? n)
             (if (and (array? coll)
                      (< n (alen coll))) (nth coll n) (err n))
             :else (get coll n))
       v (apply func this (cons cur args)))
  (assoc! coll n v))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn update-in!

  "'Updates' a value in a nested associative structure, where ks is a
sequence of keys and f is a function that will take the old value
and any supplied args and return the new value, and returns a new
nested structure.  If any levels do not exist, hash-maps will be
created."

  ^Any [coll keys func & xs]

  (var err #(raise! "update-in! failed, bad nested keys: " %))
  (var root coll
       end (last-index keys))
  (var~ m n)
  (for [i 0 :while (<= i end) :recur (+1 i)]
    (set! n (.@i keys))
    (cond
      (= i end)
      (doUpdateIn! root n func xs err)
      (number? n)
      (if-not (and (array? root)
                   (< n (alen root)))
        (err n)
        (set! root (nth root n)))
      :else
      (do (set! m (get root n))
          (when (undef? m) (set! m {}) (assoc! root n m))
          (if-not (object? m) (err n))
          (set! root m))))
  coll)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- merge! "" [base m]
  (var ret (or base {})
       src (or m {}))
  (each-key (fn [v k]
              (set-in! ret k v)) src) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn merge

  "Returns a map that consists of the rest of the maps conj-ed onto
the first.  If a key occurs in more than one map, the mapping from
the latter (left-to-right) will be the mapping in the result."

  [&maps] (reduce (fn [acc n] (merge! acc n)) {} maps))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn difference
  "Return a set that is the first set
  without elements of the other set."
  [a b]

  (var ret [] z nil)
  (for [i 0 sz (n# a)
        :while (< i sz) :recur (+1 i)]
    (set! z (.@i a))
    (if-not (contains? b z) (conj! ret z)))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn percent "" ^Number [numerator denominator]
  (* 100 (div numerator denominator)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn toFixed "" ^String [num digits]
  (set! digits (opt?? digits 2))
  (.toFixed (Number num) digits))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;testing stuff
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro deftest
  "" [name & body] `(const ~name #(vec ~@body)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn ensureTest "" [cnd msg]
  (set! msg (or msg "test"))
  (try (str (if cnd "passed:" "FAILED:") " " msg)
       (catch e (str "FAILED: " msg))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro ensure "" [form & [msg]]
  `(kirbystdlibref/ensureTest ~form ~msg))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn ensureTestThrown "" [expected error msg]
  (set! msg (or msg "test"))
  (if (nil? error)
    (str "FAILED: " msg)
    (if (= expected (type error))
      (str "passed: " msg)
      (str "FAILED: " msg))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro ensureThrown "" [expected form & [msg]]
  `(try ~form
        (kirbystdlibref/ensureTestThrown ~expected nil ~msg)
        (catch e
          (kirbystdlibref/ensureTestThrown ~expected e ~msg))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn runtest "" [test & [title]]
  (set! title (opt?? title "test"))
  (var now (new Date)
       results (test)
       sum (n# results)
       ok (n# (filter #(starts? % "p") results))
       ps (toFixed (percent ok sum)))
  (->> [(.repeat "+" 78)
        title now
        (.repeat "+" 78)
        (join "\n" results)
        (.repeat "=" 78)
        (str "Passed: " ok "/" sum " [" ps "%]")
        (str "Failed: " (- sum ok))
        (str "CPU Time: " (- (new Date) now) "ms")]
       (join "\n")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

