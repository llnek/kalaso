/*Auto generated by Kirby - v1.0.0 czlab.kirby.main - Sun Dec 03 2017 23:52:01 GMT-0800 (PST)*/

const gopt = require("node-getopt");
const watcher = require("watch");
const path = require("path");
const fs = require("fs");
const tx = require("./compiler");
const std = require("./stdlib");
const rt = require("./engine");
const kirbystdlibref = std;
var validFlag_QUERY = /-h\b|-r\b|-v\b|-b\b|-s\b|-t\b/;
var error_BANG = function() {
  let ____args = Array.prototype.slice.call(arguments);
  return (function() {
    if (console) {
      console.log([
        ____args[0]
      ].join(""));
    }
    return process.exit(1);
  }).call(this);
};
var opt = gopt.create([
  [
    "h",
    "help",
    "display this help"
  ],
  [
    "v",
    "version",
    "show version"
  ],
  [
    "r",
    "run",
    "run .ky files"
  ],
  [
    "w",
    "watch",
    "auto-compile changed files"
  ],
  [
    "b",
    "browser-bundle",
    "bundle for browser"
  ],
  [
    "m",
    "source-map",
    "generate source maps"
  ],
  [
    "f",
    "format",
    "format source code"
  ],
  [
    "t",
    "show-ast",
    "show AST"
  ]
]).setHelp([
  "kirby [OPTION] [<infile>] [<outfile>]\n\n",
  "<outfile> default to <infile> with \".js\" extension\n\n",
  "Also compile stdin to stdout\n",
  "eg. $ echo '(console.log \"hello\")' | kirby\n\n",
  "[[OPTIONS]]\n\n"
].join("")).bindHelp().parseSystem();
////////////////////////////////////////////////////////////////////////////////
//fn: [handleNoArgs] in file: main.ky,line: 46
//when no args do stdin -> stdout compile or run repl and return null to
//halt operations.
const handleNoArgs = function() {
  let pout = process.stdout;
  let source = "";
  let pin = process.stdin;
  pout.on("error", error_BANG);
  let GS__8 = pin;
  GS__8.setEncoding("utf8");
  GS__8.resume();
  GS__8.on("data", function() {
    let ____args = Array.prototype.slice.call(arguments);
    return source += ____args[0].toString();
  });
  GS__8.on("end", function() {
    let ____args = Array.prototype.slice.call(arguments);
    return (function() {
      try {
        return pout.write(tx.transpile(source, process.cwd()));
      } catch (e) {
        return error_BANG(e);
      }
    }).call(this);
  });
  GS__8.on("error", error_BANG);
  GS__8;
  return setTimeout(function() {
    let ____args = Array.prototype.slice.call(arguments);
    return ((0 === pin.bytesRead) ?
      (function() {
        pin.removeAllListeners("data");
        return runrepl();
      }).call(this) :
      null);
  }, 20);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [compileFiles] in file: main.ky,line: 67
const compileFiles = function() {
  let fin = (opt.argv[0] ?
    opt.argv[0] :
    error_BANG("No Input file"));
  let fout = opt.argv[1];
  if ( (!fout) ) {
    fout = fin.replace(/\.ky$/, ".js");
    if ( (fout === fin) ) {
      error_BANG("Input file must have extension \".ky\"");
    }
  }
  return (function() {
    try {
      let options = opt.options;
      let GS__9 = options;
      let source_DASH_map = GS__9["source-map"];
      let show_DASH_ast = GS__9["show-ast"];
      let source = null;
      if ( (!show_DASH_ast) ) {
        if (console) {
          console.log([
            [
              "kirby v",
              tx.version
            ].join(""),
            ": compiling: ",
            fin,
            " -> ",
            fout
          ].join(""));
        }
      } else {
        null;
      }
      source = fs.readFileSync(fin, "utf8");
      return (show_DASH_ast ?
        tx.dbgAST(source, fin, dirs) :
        (function() {
          let out = (source_DASH_map ?
            tx.transpileWithSrcMap(source, fin, options) :
            tx.transpile(source, fin, options));
          return fs.writeFileSync(fout, out, "utf8");
        }).call(this));
    } catch (e) {
      return error_BANG(e);
    }
  }).call(this);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [init] in file: main.ky,line: 97
const init = function() {
  require.extensions[".ky"] = function(module, fname) {
    let code = require("./compiler").transpile(fs.readFileSync(fname, "utf8"), path.relative(process.cwd(), fname));
    return module._compile(code, fname);
  };
  return rt.init();
};
////////////////////////////////////////////////////////////////////////////////
//fn: [main] in file: main.ky,line: 110
const main = function() {
  init();
  return compileFiles();
};
main()
module.exports = {
  main: main
};