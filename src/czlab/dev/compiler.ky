;; Copyright (c) 2013-2017, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns ^{:doc ""
      :author "Kenneth Leung"}
  czlab.kirby.compiler
  (:require ["./stdlib"
             :as std
             :refer [lambda-arg? hashmap pairs?
                     contains? last typeid
                     prn primitive map? vector?
                     opt?? some? primitive?
                     not-empty conj! list?
                     gensym count pop! slice
                     symbol keyword symbol? keyword?]]
            ["./engine" :as eng]
            ["./parser" :as parser :refer [tnode tnodeEx]])
  (:require ["fs" :as fs]
            ["path" :as path]
            ["esformatter" :as esfmt]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- ERRORS-MAP {
  :invalid-fargs ""
  :invalid-catch ""
  :invalid-try ""
  :invalid-include ""
  :invalid-require ""
  :invalid-namespace ""
  :destruct-args ""
  :file-access ""
  :file-read ""
  :file-open ""
  :unknown-keyword ""
  :invalid-arity ""
  :invalid-meta ""
  :syntax-error ""
  :empty-form "" })

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- XERRORS-MAP {
  :e0 "Syntax Error"
  :e1 "Empty statement"
  :e2 "Invalid characters in function name"
  :e3 "End of File encountered, unterminated string"
  :e4 "Closing square bracket, without an opening square bracket"
  :e5 "End of File encountered, unterminated array"
  :e6 "Closing curly brace, without an opening curly brace"
  :e7 "End of File encountered, unterminated javascript object '}'"
  :e8 "End of File encountered, unterminated parenthesis"
  :e9 "Invalid character in var name"
  :e10 "Extra chars at end of file. Maybe an extra ')'."
  :e11 "Cannot Open include File"
  :e12 "Invalid no of arguments to "
  :e13 "Invalid Argument type to "
  :e14 "End of File encountered, unterminated regular expression"
  :e15 "Invalid vararg position, must be last argument."
  :e16 "Invalid arity (args > expected) to "
  :e17 "Invalid arity (args < expected) to "})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- MODULE-VERSION "1.0.0")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- EXTERNS nil
      SPEC-OPS {}
      MATH-OP-REGEX /^[-+][0-9]+$/)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- doFuncArgs "Deal with possible destructuring
                  of args in function definition"
  [args ast env]
  (var~ e ev rval out)
  (var pms []
       [fargs fdefs :as ret] [(tnode) (tnode)])
  (for [i 0 sz (n# args)
        :while (< i sz) :recur (+1 i)]
    (=> e (.@i args))
    (cond
      (symbol? e)
      (if (== e "&")
        ;vargs
        (do (=> rval (tnode)
                e (.@+i args))
            (rval.add ["Array.prototype.slice.call(arguments," $(i) ")"])
            (if (symbol? e)
              (fdefs.add ["let "
                          (tx* e env) "=" rval ";\n"])
              (do (=> out (tnode)
                      e (destruct* e out env ast))
                  (fdefs.add ["let "
                              (tx* e env)
                              "=" rval ";\n" out])))
            (break-out-of-loop!))
        ;ignore _
        (do (if (== e "_")
              (=> e (gensym "U__"))) (conj! pms e)))
      (array? e)
      (do (=> rval (tnode)
              out (tnode)
              e (destruct* e out env ast))
          (rval.add ["arguments[" $(i) "]"])
          (conj! pms e)
          (fdefs.add ["let "
                      (tx* e env)
                      "=" rval ";\n" out]))
      :else
      (error! :destruct-args ast)))
  (each #(fargs.add (tx* % env)) pms)
  (join "," fargs)
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destruct* "" [coll out env ast]
  ;decide on what the rhs should be referred to "as"
  (var rhs (gensym) e nil)
  (for [i 0 sz (n# coll)
        :while (< i sz) :recur (+1 i)]
    (=> e (.@i coll))
    (when (and (keyword? e)
               (== e "as"))
      (=> rhs (.@+i coll))
      (break-out-of-loop!)))
  ;handle a vec or a map destructure only
  (cond
    (map? coll)
    (out.add (destructMap rhs coll env ast))
    (vector? coll)
    (out.add (destructVec rhs coll env ast)))
  rhs)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destructVec "" [src coll env ast]
  (=> src (tx* src env))
  (var~ e rval out)
  (var ret (tnode))
  (for [i 0 sz (n# coll)
        :while (< i sz) :recur (+1 i)]
    (=> e (.@i coll))
    (cond
      (symbol? e)
      (cond
        (== e "_") nil
        (== e "&")
        (do (=> rval (tnode)
                out (tnode)
                e (.@+i coll))
            (rval.add ["Array.prototype.slice.call(" src "," $(i) ")"])
            (if-not (symbol? e)
              (=> e (destruct* e out env ast)))
            (ret.add ["let "
                      (tx* e env)
                      "=" rval ";\n" out])
            (break-out-of-loop!))
        :else
        (ret.add ["let "
                  (tx* e env)
                  "=" src "[" $(i) "];\n"]))
      (array? e)
      (do (=> rval (tnode)
              out (tnode)
              e (destruct* e out env ast))
          (rval.add [src "[" $(i) "]"])
          (ret.add ["let "
                    (tx* e env)
                    "=" rval ";\n" out]))
      (keyword? e)
      (if (== e "as")
        (++ i)
        (error! :unknown-keyword ast))
      :else (error! :syntax-error ast))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- destructMap "" [src coll env ast]
  (=> src (tx* src env))
  (var ret (tnode))
  (var~ e arr)
  (for [i 0 sz (n# coll)
        :while (< i sz) :recur (+1 i)]
    (=> e (.@i coll))
    (cond
      (keyword? e)
      (cond
        (or (== e "keys")
            (== e "strs"))
        (do (=> arr (.@+i coll))
            (++ i)
            (for [j 0 sz (n# arr)
                  :while (< j sz) :recur (+1 j)]
              (=> e (.@j arr))
              (ret.add ["let "
                        (tx* e env)
                        "=" src "[\"" $(e) "\"];\n"])))
        :else
        (error! :unknown-keyword ast))
      :else
      (error! :syntax-error ast))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- simple? "" [ast]
  (or (undef? ast) (nil? ast) (str? ast) (num? ast) (bool? ast)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- wrap "" [ret head tail]
  (if head (ret.prepend head))
  (if tail (ret.add tail))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- exprHint "" [ast flag]
  (if (simple? ast) (=> ast (primitive ast))) (=>> ast :____expr flag) ast)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- stmt? "" [ast]
  (if (simple? ast) (error! :syntax-error ast)) (false? ast.____expr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- error! "" [e & [ast msg]]
  (raise! (get ERRORS-MAP e)
          (if msg (str " : " msg))
          (if (and ast ast.line) (str "\nline: " ast.line))
          (if (and ast ast.source) (str "\nfile: " ast.source))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- testre? "" [re x] (if x (re.test x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- pad "" [n] (.repeat " " n))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- node' "" [ast & [obj]]
  (=> obj (opt?? obj (tnode)))
  (=>> obj :source ast.source
           :line ast.line
           :column ast.column) obj)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txTree "" [root env]
  (var ret (node' root))
  (doseq [r root
          :let [t (tx* r env)]
          :when (some? t)] (ret.add [t "\n"])) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txForm "" [expr env]
  (if (array? expr)
    (each (fn [a i arr]
            (=>> arr i (tx* a env))) expr)) expr)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txAtom "" [a]
  (var s $(a))
  (cond (lambda-arg? a)
        (str "____args[" s "]")
        (keyword? a)
        (str "\"" s "\"")
        (symbol? a)
        (parser/jsid s)
        (nil? a)
        "null"
        (primitive? a)
        (do (=> a a.value)
            (cond (string? a) a
                  (nil? a) "null"
                  :else $(a)))
        :else s))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- tx* "" [x & [env]] (if (array? x) (txPairs x env) (txAtom x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- gcmd "" [ast]
  (cond (map? ast) "hashmap"
        (vector? ast) "vec"
        (list? ast) "list"
        (and (array? ast)
             (not (array? (1st ast)))) $(1st ast) :else ""))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quoteSingle "" [a]
  (cond (keyword? a)
        (str "keyword(\":" a "\")")
        (symbol? a)
        (str "symbol(\"" a "\")")
        (primitive? a)
        (do (set! a a.value)
            (cond (string? a) a
                  (nil? a) "null"
                  :else $(a)))
        :else $(a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quote! "" [ast env]
  (if (array? ast)
    (if (map? ast)
      (quoteMap ast env)
      (quoteBlock ast env))
    (quoteSingle ast)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quoteMap "" [ast env]
  (var comma ""
       ret (node' ast))
  (for [i 0 sz (n# ast)
        :while (< i sz) :recur (+2 i)]
    (if (> i 0) (ret.add ","))
    (ret.add [(quote! (.@i ast) env)
              " : " (quote! (.@+i ast) env)]))
  (if-not (empty? ast) (=> comma ","))
  (wrap ret ["[" "symbol(\"hashmap\")" comma] "]"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- quoteBlock "" [ast env]
  (var ret (node' ast))
  (for [i 0 sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (if (> i 0) (ret.add ","))
    (ret.add (quote! (.@i ast) env)))
  (wrap ret "[" "]"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txPairs "" [ast env]
  (var stmtQ (stmt? ast)
       ret (node' ast)
       cmd (gcmd ast)
       op nil tmp nil
       mc (eng/getMacro cmd))
  ;;handle macro calls
  (when mc
    (=> ast (eng/expandMacro ast env mc)
        ast (exprHint ast (not stmtQ))
        cmd (gcmd ast)))
  ;;handle (+1 ) or (-1 ) cases
  (when (parser/REGEX.int.test cmd)
    (if-not (or (starts? cmd "+")
                (starts? cmd "-"))
      (=> cmd (str "+" cmd)))
    (=> ast [(symbol (ch@ cmd 0))
             (2nd ast) (int (rest cmd))]
        cmd $(1st ast)))
  ;;maybe special form
  (=> op (get SPEC-OPS cmd))
  ;;handle all cases
  (cond
    (== cmd "with-meta")
    (ret.add (tx* (2nd (meta?? ast env)) env))
    (starts? cmd ".-")
    (ret.add [(tx* (2nd ast) env)
              "." (tx* (symbol (cmd.slice 2)) env)])
    (starts? cmd ".@")
    (do (=> tmp (if (starts? cmd ".@+") [3 #t] [2 #f]))
        (ret.add [(tx* (2nd ast) env)
                  "[" (cmd.slice (1st tmp)) (if (2nd tmp) "+1]" "]")]))
    (starts? cmd ".")
    (do (ret.add [(tx* (2nd ast) env) cmd "("])
        (for [n 2 sz (n# ast)
              :while (< n sz) :recur (+1 n)]
          (if (not= n 2) (ret.add ","))
          (ret.add (tx* (.@n ast) env)))
        (ret.add ")"))
    (some? op)
    (=> ret (op ast env))
    :else
    (do (if (pairs? ast)
          (do (txForm ast env)
              (=> cmd $(1st ast)))
          (=> cmd (tx* ast env)))
        (if-not cmd (error! :empty-form ast))
        (=> cmd (maybeStripStdlib cmd))
        (if (pairs? ast)
          (ret.add
            [(if (testre? parser/REGEX.func cmd)
               (tnodeEx ["(" cmd ")"]) cmd)
             "(" (join "," (tnodeEx (rest ast))) ")"])
          (ret.add cmd))))
  (node' ast ret))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- writeDoc "Convert to jsdoc"
  [doc]
  (var out [])
  (if doc
    (->> (.split (eng/unwrap-str doc) "\n")
         (each #(let [s (.trim (str %))]
                  (if (not-empty s)
                    (conj! out (str "//" s "\n"))))))) out)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- txDo "" [ast env & [return?]]
  (var stmtQ (stmt? ast)
       ret (node' ast)
       e nil end (last-index ast))
  (=> return?
      (if stmtQ false (opt?? return? true)))
  (for [i 0 :while (< i end) :recur (+1 i)]
    (=> e (exprHint (.@i ast) #f))
    (ret.add [(tx* e env) ";\n"]))
  (when (>= end 0)
    (=> e (exprHint (.@end ast)
                    (not stmtQ))
        e (tx* e env))
    (ret.add (if-not return?
               [e ";\n"]
               ["return " e ";\n"]))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- meta?? "" [obj env]
  (var mobj nil)
  (when (and (array? obj)
             (= 3 (n# obj))
             (== "with-meta"
                 $(1st obj)))
    (=> mobj (evalMeta (.@2 obj) env))
    (=>> (2nd obj) :____meta mobj)
    (=> obj (2nd obj)))
  [mobj obj])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fmtRegoSpecOps "" [alias fname]
  (str (parser/jsid :SPEC-OPS) "[\"" alias "\"] = " fname))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fmtSpecOps "" [fname attrs]
  (var ks (or (get attrs "opcode") [])
       out (->> (map #(fmtRegoSpecOps
                        (str %) fname) ks) (join ";\n")))
  (if (not-empty ks) (str out ";\n") out))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- writeFuncInfo "" [fname ast]
  (var file (if ast.source
              (ast.source.slice
                (+1 (ast.source.lastIndexOf "/"))) "?")
       s (str "//fn: ["
              fname "] in file: "
              file ",line: " (or ast.line "?") "\n")
       len (alen s))
  (if (< len 80)  (=> len 80))
  (doto (tnodeEx (str (.repeat "/" len) "\n")) (.add s)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- icache [])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- includeFile [fname]
  (if (contains? icache fname)
    (tnode)
    (let [src (fs/readFileSync fname "utf-8")]
      (conj! icache fname)
      (txTree (parser/parser src fname) (eng/globalEnv )))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- evalMeta "" [ast env]
  (cond
    (array? ast)
    (JSON/parse $(tx* ast env))
    (keyword? ast)
    (->> (tx* [ast #t] env)
         (str )
         (JSON/parse ))
    (symbol? ast)
    (->> (tx* [(symbol "tag") ast] env)
         (str )
         (JSON/parse ))
    :else
    (error! :invalid-meta ast)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- maybeStripStdlib "" [cmd]
  (var lib "kirbystdlibref."
       nsp (.peekNSP (eng/globalEnv)))
  (=> cmd $(cmd))
  (if (and (starts? cmd lib)
           (= nsp "czlab.kirby.stdlib"))
    (cmd.slice (alen lib)) cmd))

;;kenl
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-quote "" ^{:opcode ["quote"]} [ast env]
  (if-not (= (n# ast) 2) (error! :invalid-arity ast))
  (var ret (node' ast))
  (wrap ret nil (quote! (2nd ast) env)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-deftype
  "Define a JS Class"
  ^{:opcode ["deftype" "deftype-"]}
  [ast env]
  (if-not (>= (n# ast) 4) (error! :invalid-arity ast))
  (var~ n m)
  (var private? (ends? $(1st ast) "-")
       czname (tx* (2nd ast) env)
       par (1st (.@2 ast))
       czargs (.@3 ast)
       ret (node' ast)
       [doc mtds] (if (str? (.@4 ast))
                    [(.@4 ast) (slice ast 5)]
                    [nil (slice ast 4)]))
  (ret.add ["class " czname])
  (if par (ret.add [" extends " (tx* par env)]))
  (ret.add " {\n")
  (for [i 0 pos 0 sz (n# mtds)
        :while (< i sz) :recur (+1 i)]
    (=> m (.@i mtds)
        pos (if (str? (2nd m)) 3 2))
    (when (and (== $(1st m)
                   "constructor")
               (not-empty czargs))
      (for [x 0 sz (n# czargs)
            :while (< x sz) :recur (+2 x)]
        (=>> czargs
             x
             (str "\"" (.@x czargs) "\"")))
      (m.splice pos 0
        (concat [(symbol "set-in!")
                 (symbol "this")] czargs)))
    (m.unshift (symbol "method"))
    (ret.add [(sf-func m env #f) "\n"]))
  (ret.add "}\n")
  (if doc (ret.prepend (writeDoc doc)))
  (if (and (not private?)
           (= 1 (.countNSPCache
                  (eng/globalEnv))))
      (=>> EXTERNS czname czname)) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-compOp "" ^{:opcode ["not=" "!="
                               "==" "="
                               ">" ">=" "<" "<="]} [ast env]
  (if-not (and (>= (n# ast) 3)
               (odd? (n# ast))) (error! :invalid-arity ast))
  (var ret (node' ast)
       cmd $(1st ast))
  (cond (== cmd "not=") (=>> ast 0 (symbol "!=="))
        (== cmd "=") (=>> ast 0 (symbol "===")))
  (for [i 0 op (tx* (ast.shift) env)
        :while (< i (last-index ast)) :recur (+1 i)]
    (ret.add (tnodeEx [(tx* (.@i ast) env)
                       " " op " "
                       (tx* (.@+i ast) env)])))
  (join " && " ret)
  (wrap ret "(" ")"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-arithOp
  ""
  ^{:opcode ["bitwise-lshift" "bitwise-rshift" "bitwise-zrshift"
             "+" "-" "*" "div" "mod"
             "or" "and" "exp" "rem"
             "bitwise-and" "bitwise-or" "bitwise-not" "bitwise-xor"]}
  [ast env]
  (var e1 (tx* (ast.shift) env)
       op "" cmd $(e1) ret (node' ast))
  (cond (== cmd "bitwise-zrshift") (=> cmd ">>>")
        (== cmd "bitwise-rshift") (=> cmd ">>")
        (== cmd "bitwise-lshift") (=> cmd "<<")
        (== cmd "bitwise-and") (=> cmd "&")
        (== cmd "bitwise-or") (=> cmd "|")
        (== cmd "bitwise-not") (=> cmd "~")
        (== cmd "bitwise-xor") (=> cmd "^")
        (== cmd "rem") (=> cmd "%")
        (== cmd "div") (=> cmd "/")
        (== cmd "and") (=> cmd "&&")
        (== cmd "or") (=> cmd "||")
        (== cmd "exp") (=> cmd "**"))
  (if (= 1 (n# ast))
    (if (== "-" cmd) (ret.add "-"))
    (=> op cmd))
  (txForm ast env)
  (ret.add ast)
  (if (> (n# ast) 1) (join op ret))
  (wrap ret "(" ")"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-do
  "" ^{:opcode ["do"]} [ast env]
  (var ret (node' ast)
       stmtQ (stmt? ast))
  (ret.add (txDo (exprHint (rest ast)
                           (not stmtQ)) env (not stmtQ)))
  (if stmtQ
    (wrap ret nil "")
    (wrap ret
          "(function() {\n" "}).call(this)")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-case
  "" ^{:opcode ["case"]} [ast env]
  (var stmtQ (stmt? ast)
       ret (node' ast)
       tst (2nd ast)
       brk ";\nbreak;\n"
       gs $(gensym "C__"))
  (var~ e t c dft)
  (if (odd? (n# ast))
    (=> dft (1st (pop! ast))))
  (for [i 2 sz (n# ast)
        :while (< i sz) :recur (+2 i)]
    (=> e (.@i ast)
        c (.@+i ast))
    (if (pairs? e)
      (for [j 0 sz (n# e)
            :while (< j sz) :recur (+1 j)]
        (ret.add ["case "
                  (tx* (.@j e) env) ":\n"])
        (if (= j (last-index e))
          (ret.add [gs "="
                    (tx* c env) brk])))
      (ret.add ["case " (tx* e env) ":\n"
                gs "=" (tx* c env) brk])))
  (if dft
    (ret.add ["default:\n"
              gs "=" (tx* dft env) brk]))
  (wrap ret ["switch ("
             (tx* tst env) ") {\n"] "}")
  (if stmtQ
    (wrap ret ["let " gs ";\n"] "")
    (wrap ret
          ["(function() { let " gs ";\n"]
          ["return " gs ";}).call(this)"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-vardefs "" ^{:opcode ["def~-"
                                "def~" "var~"]} [ast env]
  (var ret (node' ast)
       cmd $(1st ast)
       keys {}
       private? (not= cmd "def~"))
  (if (starts? cmd "def")
    (=> cmd "var") (=> cmd "let"))
  (for [i 1 s nil sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (=> s (tx* (.@i ast) env))
    (=>> keys s nil)
    (ret.add s))
  (join "," ret)
  (wrap ret (str cmd " ") ";\n")
  (if (and (not private?)
           (= 1 (.countNSPCache
                  (eng/globalEnv))))
    (each-key (fn [v k] (=>> EXTERNS k k)) keys)) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-var "" ^{:opcode ["const-"
                            "const"
                            "def-"
                            "def"
                            "var"]} [ast env]
  (if-not (odd? (n# ast)) (error! :invalid-arity ast))
  (var ret (node' ast)
       cmd $(1st ast)
       keys []
       tmp nil vname nil
       private? (and (not= cmd "const")
                     (not= cmd "def")))
  (var~ rval rc lhs rhs)
  (=> ast (rest ast)
      cmd (if (starts? cmd "const")
            "const"
            (if (== cmd "var") "let" "var")))
  (for [i 0 sz (n# ast)
        :while (< i sz) :recur (+2 i)]
    (=> lhs (.@i ast)
        rhs (.@+i ast)
        rval (tx* rhs env))
    (if (symbol? lhs)
      (do (=> lhs (tx* lhs env)
              tmp [cmd " " lhs "=" rval ";\n"])
          (conj! keys lhs)
          (ret.add tmp))
      (do (=> out (tnode)
              rhs (destruct* lhs out env ast))
          (ret.add ["let "
                    (tx* rhs env)
                    "=" rval ";\n" out]))))
  (when (and (not private?)
             (= 1 (.countNSPCache
                    (eng/globalEnv))))
    (each (fn [k] (=>> EXTERNS k k)) keys)) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-inst?
  "" ^{:opcode ["inst?"]} [ast env]
  (if-not (= (n# ast) 3) (error! :invalid-arity ast))
  (var ret (node' ast))
  (wrap ret nil ["(" (tx* (.@2 ast) env)
                 " instanceof " (tx* (2nd ast) env) ")"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-delete
  "" ^{:opcode ["delete!"]} [ast env]
  (if-not (and (>= (n# ast) 2)
               (< (n# ast) 4)) (error! :invalid-arity ast))
  (var ret (node' ast))
  (ret.add ["delete "
            (tx* (2nd ast) env)])
  (if (> (n# ast) 2)
    (ret.add ["[" (tx* (.@2 ast) env) "]"])) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-new
  "" ^{:opcode ["new"]} [ast env]
  (var ret (node' ast))
  (wrap ret "new " (tx* (rest ast) env)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-throw
  "" ^{:opcode ["throw"]} [ast env]
  (var ret (node' ast)
       stmtQ (stmt? ast))
  (ret.add ["throw " (tx* (2nd ast) env)])
  (if-not stmtQ
    (wrap ret
          "(function (){ "
          ";}).call(this)")) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-x-opop
  "" ^{:opcode ["++" "--" "++$" "--$"]} [ast env]
  (if-not (= (n# ast) 2) (error! :invalid-arity ast))
  (var ret (node' ast)
       cmd $(1st ast)
       a2 (tx* (2nd ast) env))
  (if (ends? cmd "$")
    (ret.add [a2 (cmd.slice 0 -1)])
    (ret.add [cmd a2])) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-x-eq
  "" ^{:opcode ["+="
                "-="
                "*="
                "div="
                "rem="
                "exp="
                "bitwise-and="
                "bitwise-or="
                "bitwise-xor="
                "bitwise-lshift="
                "bitwise-rshift="
                "bitwise-zrshift="]} [ast env]
  (if-not (= (n# ast) 3) (error! :invalid-arity ast))
  (var cmd $(1st ast)
       ret (node' ast))
  (cond
    (== cmd "bitwise-zrshift=") (=> cmd ">>>=")
    (== cmd "bitwise-rshift=") (=> cmd ">>=")
    (== cmd "bitwise-lshift=") (=> cmd "<<=")
    (== cmd "bitwise-xor=") (=> cmd "^=")
    (== cmd "bitwise-or=") (=> cmd "|=")
    (== cmd "bitwise-and=") (=> cmd "&=")
    (== cmd "div=") (=> cmd "/=")
    (== cmd "rem=") (=> cmd "%=")
    (== cmd "exp=") (=> cmd "**="))
  (wrap ret nil [(tx* (2nd ast) env)
                 " " cmd " " (tx* (.@2 ast) env)]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-set-in
  "" ^{:opcode ["set-in!" "=>>"]} [ast env]
  (if-not (even? (n# ast))
          (error! :invalid-arity ast))
  (var ret (node' ast)
       more #f
       obj (tx* (2nd ast) env))
  (for [i 2 sz (n# ast)
        :while (< i sz) :recur (+2 i)]
    (when (> i 2)
      (ret.add ",")
      (true! more))
    (ret.add [obj
              "[" (tx* (.@i ast) env) "]"
              "=" (tx* (.@+i ast) env)]))
  (if more (wrap ret "(" ")")) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-set
  "" ^{:opcode ["set!" "=>"]} [ast env]
  (if-not (odd? (n# ast))
          (error! :invalid-arity ast))
  (var more #f
       ret (node' ast))
  (for [i 1 sz (n# ast)
        :while (< i sz) :recur (+2 i)]
    (when (> i 1)
      (ret.add ",")
      (true! more))
    (ret.add [(tx* (.@i ast) env)
              "=" (tx* (.@+i ast) env)]))
  (if more (wrap ret "(" ")")) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-fn
  "(fn [x y] ...)" ^{:opcode ["fn"]} [ast env]
  (var ret (node' ast)
       fargs nil
       body (slice ast 2)
       [_ args] (meta?? (2nd ast) env))
  (if-not (array? args)
    (error! :invalid-fargs ast))
  (=> fargs (doFuncArgs args ast env))
  (wrap ret nil ["function ("
                 (1st fargs)
                 ") {\n"
                 (2nd fargs)
                 (txDo body env #t) "}"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-func "" ^{:opcode ["defn" "defn-"]} [ast env]
  (var private? (ends? $(1st ast) "-")
       mtd? (== $(1st ast) "method")
       fname0 $(2nd ast)
       fname (tx* (2nd ast) env)
       dot? (contains? fname ".")
       fargs nil ret (node' ast)
       [doc pargs] (if (str? (.@2 ast))
                     [(nth ast 2) 3] [nil 2])
       body (slice ast (+1 pargs))
       [hints args] (meta?? (nth ast pargs) env))
  (if-not (array? args)
    (error! :invalid-fargs ast))
  (=> fargs (doFuncArgs args ast env))
  (=> hints (or hints {}))
  (cond mtd?
        (do (if (.-static hints)
              (ret.add "static "))
            (ret.add [fname " ("])
            (if (== fname "constructor")
              (conj! body (symbol "this"))))
        dot?
        (ret.add [fname " = function ("])
        :else
        (ret.add ["const " fname " = function ("]))
  (ret.add [(1st fargs)
            ") {\n"
            (2nd fargs)
            (txDo body env #t) "};\n"])
  (if (not-empty hints)
    (ret.add (fmtSpecOps fname hints)))
  (if doc
    (ret.prepend (writeDoc doc)))
  (ret.prepend (writeFuncInfo fname0 ast))
  (if (and (not private?)
           (not dot?)
           (not mtd?)
           (= 1 (.countNSPCache
                  (eng/globalEnv)))) (=>> EXTERNS fname fname)) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-try "" ^{:opcode ["try"]} [ast env]
  (var stmtQ (stmt? ast)
       sz (n# ast)
       ret (node' ast))
  (var~ t f c)
  ;;look for finally
  (=> f (last ast))
  (if (and (array? f)
           (== "finally" $(1st f)))
    (=> f (1st (pop! ast))
        sz (n# ast))
    (nil! f))
  ;;look for catch
  (nil! c)
  (if (> sz 1)
    (=> c (nth ast (-1 sz))))
  (if (and (array? c)
           (== "catch" $(1st c)))
    (do (if (or (< (n# c) 2)
                (not (symbol? (2nd c))))
          (error! :invalid-catch ast))
        (=> c (1st (pop! ast))))
    (nil! c))
  ;;try needs either a catch or finally or both
  (if (and (nil? f)
           (nil? c)) (error! :invalid-try ast))
  (ret.add ["try {\n"
            (txDo (exprHint (rest ast)
                            (not stmtQ)) env) "\n}"])
  (when c
    (=> t (2nd c))
    (ret.add [(str "catch (" t ") {\n")
              (txDo (exprHint (slice c 2)
                              (not stmtQ)) env) ";\n}\n"]))
  (when f
    (ret.add ["finally {\n",
              (txDo (exprHint (rest f) #f) env #f) ";\n}\n"]))
  (if-not stmtQ
    (wrap ret "(function(){\n" "}).call(this)")) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-if "" ^{:opcode ["if"]} [ast env]
  (var stmtQ (stmt? ast)
       ret (node' ast)
       a1 (exprHint (2nd ast) (not stmtQ))
       a2 (exprHint (.@2 ast) (not stmtQ))
       m? (> (n# ast) 3)
       a3 (if m? (.@3 ast))
       elze (if m? (exprHint a3 (not stmtQ))))
  (=> a1 (tx* a1 env)
      a2 (tx* a2 env)
      elze (tx* elze env))
  (wrap ret
        nil
        (if stmtQ
          ["if (" a1 ") {\n" a2 ";\n}"
           (if m? (tnodeEx [" else { \n"
                            elze ";\n}"]) "")]
          ["(" a1 " ?\n" a2 " :\n" (or elze "null") ")"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-get "" ^{:opcode ["nth" "get"]} [ast env]
  (if-not (= (n# ast) 3) (error! :invalid-arity ast))
  (var ret (node' ast))
  (wrap ret nil [(tx* (2nd ast) env) "[" (tx* (.@2 ast) env) "]"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-array "" ^{:opcode ["vec"]} [ast env]
  (var ret (node' ast))
  (if (empty? ast)
    (ret.add "[]")
    (do (if-not (vector? ast)
          (ast.splice 0 1))
        (ret.add "[\n")
        (for [i 0 sz (n# ast)
              :while (< i sz) :recur (+1 i)]
          (if (> i 0) (ret.add ",\n"))
          (ret.add (tx* (.@i ast) env)))
        (ret.add "\n]"))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-object "" ^{:opcode ["hashmap"]} [ast env]
  (var ret (node' ast))
  (if (empty? ast)
    (ret.add "{}")
    (do (if-not (map? ast)
          (ast.splice 0 1))
        (ret.add "{\n")
        (for [i 0 sz (n# ast)
              :while (< i sz) :recur (+2 i)]
          (if (> i 0) (ret.add ",\n"))
          (ret.add [(tx* (.@i ast) env)
                    ": " (tx* (.@+i ast) env)]))
        (ret.add "\n}"))) ret)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-include "" [ast env]
  (var ret []
       dir (path/dirname ast.source))
  (var~ fname e)
  (for [i 1 sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (=> e (.@i ast))
    (if (or (not (array? e))
            (not= 1 (n# e)))
      (error! :invalid-include ast))
    (=> fname $(1st e))
    (if fname
      (=> fname (fname.replace /[\"]/g "")))
    (try
      (=> fname (fs/realpathSync
                  (str dir "/" fname)))
      (catch e
        (error! :file-access ast)))
    (try
      (conj! ret (includeFile fname))
      (catch e
        (error! :file-read ast))
      (finally
        (.popNSP (eng/globalEnv)))))
  (if (empty? ret) (node' ast) ret))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-require "" [ast env]
  (var~ as path v e refers renames)
  (var ret (node' ast))
  (for [i 1 sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (=> e (.@i ast)
        as $(gensym "R__")
        refers nil renames nil)
    (if (or (not (array? e))
            (< (n# e) 3)) (error! :invalid-require ast))
    (=> path $(1st e))
    (for [j 1 sz (n# e)
          :while (< j sz) :recur (+1 j)]
      (=> v (.@j e))
      (cond (== v "as")
            (do (=> as $(.@+j e))
                (++ j))
            (== v "refer")
            (do (=> refers (.@+j e))
                (++ j))
            (== v "rename")
            (do (=> renames (.@+j e))
                (++ j))))
    (ret.add ["const " (parser/jsid as)
              "= require(" (tx* path env) ");\n"])
    (for [i 0 sz (n# refers)
          :while (< i sz) :recur (+1 i)]
      (=> v (tx* (.@i refers) env))
      (ret.add ["const " v "=" as "[\"" v "\"];\n"]))
    (for [i 0 sz (n# renames)
          :while (< i sz) :recur (+2 i)]
      (=> e (tx* (.@i renames) env)
          v (tx* (.@+i renames) env))
      (ret.add ["const " v
                "=" as "[\"" e "\"];\n"]))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-ns "" ^{:opcode ["ns"]} [ast env]
  (if-not (>= (n# ast) 2) (error! :invalid-arity ast))
  (var ret [] e nil
       [hints nsp] (meta?? (2nd ast) env))
  (if-not (symbol? nsp)
    (error! :invalid-namespace ast))
  (.pushNSP (eng/globalEnv) $(nsp))
  (=> ast (slice ast 2))
  (for [i 0 sz (n# ast)
        :while (< i sz) :recur (+1 i)]
    (=> e (.@i ast))
    (cond (and (pairs? e)
               (== "include" $(1st e)))
          (conj! ret (sf-include e))
          (and (pairs? e)
               (== "require" $(1st e)))
          (conj! ret (sf-require e))))
  ;;force a internal reference to stdlib for user files
  (=> nsp (.peekNSP (eng/globalEnv)))
  (cond
    (or (= nsp "czlab.kirby.macros")
        (= nsp "czlab.kirby.stdlib"))
    nil
    (starts? nsp "czlab.kirby.")
    (conj! ret (tnodeEx "const kirbystdlibref=std;\n"))
    :else
    (->> '(require ["kirby" :as kirbystdlibref])
         (sf-require )
         (conj! ret ))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-comment "" ^{:opcode ["comment"]} [ast env] (node' ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-for "" ^{:opcode ["for"]} [ast env]
  (var stmtQ (stmt? ast)
       ret (node' ast)
       body (exprHint (slice ast 2) #f))
  (if (empty? body)
    (node' ast)
    (sf-floop ret (2nd ast) body env stmtQ)) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-floop "" [ret args body env stmtQ]
  (var vars [] recurs [])
  (var~ tst nb e)
  (for [i 0 sz (n# args)
        :while (< i sz) :recur (+1 i)]
    (=> e (.@i args))
    (cond (== e "while")
          (do (=> tst (.@+i args)) (++ i))
          (== e "recur")
          (do (=> recurs (slice args (+1 i)))
              (break-out-of-loop!))
          (symbol? e)
          (do (conj! vars e (.@+i args))
              (++ i))))
  (ret.add "for (")
  (for [i 0 sz (n# vars)
        :while (< i sz) :recur (+2 i)]
    (if (= i 0) (ret.add "let "))
    (if (not= i 0) (ret.add ","))
    (ret.add [(tx* (.@i vars) env)
              "=" (tx* (.@+i vars) env)]))
  (ret.add (if (empty? vars)
             "let ____break=false;" ",____break=false;"))
  (=> nb '(not ____break))
  (if tst
    (=> tst [(symbol "and") nb tst])
    (=> tst nb))
  (ret.add [(tx* tst env) "; "])
  (for [i 0 k 0 sz (n# recurs)
        :while (< i sz) :recur (+1 i)(+2 k)]
    (if (not= i 0) (ret.add ","))
    (ret.add [(tx* (.@k vars) env)
              "=" (tx* (.@i recurs) env)]))
  (ret.add ["){\n" (txDo body env #f) "}\n"])
  (if-not stmtQ
    (wrap ret "(function() {\n"  "}).call(this)")) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-jscode "" ^{:opcode ["js#"]} [ast env]
  (node' ast
         (tnodeEx (-> $(2nd ast)
                      (.replace parser/REGEX.dquoteHat "")
                      (.replace parser/REGEX.dquoteEnd "")))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-macro "" ^{:opcode ["defmacro"]} [ast env]
  (var pms []
       args (.@2 ast)
       body (slice ast 3))
  (var~ doc x e ev)
  (when (string? args)
    (=> doc args
        args (.@3 ast)
        body (slice ast 4)))
  (for [i 0 sz (n# args)
        :while (< i sz) :recur (+1 i)]
    (=> e (.@i args) ev $(e))
    (cond (= ev "&")
          (if (array? (.@+i args))
            (do (=> e (.@+i args))
                (++ i)
                (for [j 0 sz (n# e)
                      :while (< j sz) :recur (+1 j)]
                  (=> x (.@j e))
                  (if-not (symbol? x)
                    (error! :syntax-error ast))
                  (conj! pms x)))
            (do (conj! pms e (.@+i args))
                (++ i)))
          (not (symbol? e))
          (error! :syntax-error ast)
          :else
          (conj! pms e)))
  (=> ast
      [(1st ast)
       (2nd ast)
       (concat [(symbol "fn*") pms] body)])
  (var a1 $(2nd ast)
       a2 (.@2 ast)
       func (eng/compute a2 env))
  (=>> func
       :____macro #t
       :____doc doc)
  (eng/setMacro a1 func) (node' ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-unary "" ^{:opcode ["not" "~" "!"]} [ast env]
  (if-not (= (n# ast) 2) (error! :invalid-arity ast))
  (var [a0 a1] ast
       ret (node' ast))
  (if (== a0 "not") (=> a0 (symbol "!")))
  (ret.add ["(" (tx* a0 env) (tx* a1 env) ")"]) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- spitExterns "" []
  (var s "" ks (keys EXTERNS))
  (when (not-empty ks)
    (=> s (join ",\n" (map #(str % ": " %) ks))
        s (str "\n\nmodule.exports = {\n" s "\n};\n\n"))) s)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- banner "" []
  (str "/*"
       "Auto generated by Kirby - v"
       MODULE-VERSION " "
       (.firstNSP (eng/globalEnv)) " - " (new Date) "*/\n\n"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- cleanCode "" [code]
  (var tmp nil arr [])
  (doseq [s (code.split "\n")
          :let [tmp (s.trim)]]
    (if (and (not-empty tmp)
             (not= tmp ";")) (conj! arr s)))
  (join "\n" arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileCode "" [codeStr fname options]
  (.resetNSPCache (eng/globalEnv))
  (=> EXTERNS {})
  (var outNode (txTree (parser/parser codeStr fname)
                       (eng/globalEnv))
       {:keys [source-map format]} options
       cstr ""
       fopts {}
       extra (spitExterns))
  (=> cstr
      (if source-map
        (let [outFile (str (path/basename fname ".ky") ".js")
              srcMap (str outFile ".map")
              output (outNode.toStringWithSourceMap {:file outFile})]
          (fs/writeFileSync srcMap output.map)
          (str output.code
               extra
               "\n//# sourceMappingURL="
               (path/relative (path/dirname fname) srcMap)))
        (str outNode extra)))
  (if format
    (=> cstr (esfmt/format cstr fopts)))
  (=> cstr (cleanCode cstr))
  ;;(if format (set! cstr (esfmt/format cstr fopts)))
  (if (empty? cstr) "" (str (banner) cstr)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileXXX "" [code file options]
  (try (transpileCode code file options)
       (catch e
         (println (.-stack e)) (throw e))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn transpileWithSrcMap
  "" [code file & [options]]
  (transpileXXX code file (opt?? options {})))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn transpile
  "" [code file & [options]]
  (transpileXXX code file (opt?? options {})))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn parseWithSourceMap "" [codeStr fname]
  (var outNode (txTree (parser/parser codeStr fname)))
  (outNode.prepend (banner))
  (outNode.toStringWithSourceMap ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn dbgAST
  "" [source fname]
  (parser/dumpTree (parser/parser source fname)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(def version MODULE-VERSION)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

