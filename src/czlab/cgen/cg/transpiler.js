/*Auto generated by Kirby - v1.0.0 czlab.kirby.transpiler Sun Oct 15 2017 00:25:07 GMT-0700 (PDT)*/

var macros= require("../bl/macros");
var types= require("../bl/types");
var std= require("../bl/stdlib");
var tn= require("../bl/tnode");
var rdr= require("../bl/lexer");
var psr= require("../bl/parser");
var rt= require("../rt/runtime");
;
var tnodeEx = tn.tnodeEx;
var tnode = tn.tnode;
var ERRORS_MAP = {
  "e0": "Syntax Error",
  "e1": "Empty statement",
  "e2": "Invalid characters in function name",
  "e3": "End of File encountered, unterminated string",
  "e4": "Closing square bracket, without an opening square bracket",
  "e5": "End of File encountered, unterminated array",
  "e6": "Closing curly brace, without an opening curly brace",
  "e7": "End of File encountered, unterminated javascript object '}'",
  "e8": "End of File encountered, unterminated parenthesis",
  "e9": "Invalid character in var name",
  "e10": "Extra chars at end of file. Maybe an extra ')'.",
  "e11": "Cannot Open include File",
  "e12": "Invalid no of arguments to ",
  "e13": "Invalid Argument type to ",
  "e14": "End of File encountered, unterminated regular expression",
  "e15": "Invalid vararg position, must be last argument.",
  "e16": "Invalid arity (args > expected) to ",
  "e17": "Invalid arity (args < expected) to "
};
var RESERVED = {
  "compare": [
    "not=",
    "!=",
    "==",
    "=",
    ">",
    ">=",
    "<",
    "<="
  ],
  "arith": [
    "+",
    "-",
    "*",
    "/",
    "%",
    "mod"
  ],
  "logic": [
    "||",
    "&&"
  ],
  "bitwise": [
    "^",
    "&",
    "|",
    "<<",
    ">>",
    ">>>"
  ],
  "incdec": [
    "++",
    "--"
  ],
  "unary": [
    "not",
    "~",
    "!"
  ],
  "assign": [
    "+=",
    "-=",
    "*=",
    "/=",
    "%=",
    "<<=",
    ">>=",
    ">>>=",
    "&=",
    "|=",
    "^="
  ],
  "builtin": [
    "quote",
    "syntax-quote",
    "quasi-quote",
    "backtick",
    "unquote",
    "unquote-splice",
    "repeat-n",
    "do",
    "doto",
    "case",
    "apply",
    "range",
    "def-",
    "def",
    "var",
    "forlet",
    "new",
    "throw",
    "while",
    "lambda",
    "inst?",
    "delete!",
    "aset",
    "set!",
    "fn",
    "def!",
    "defn-",
    "defn",
    "try",
    "if",
    "get",
    "aget",
    "str",
    "list",
    "[",
    "vec",
    "{",
    "hash-map",
    "ns",
    "comment",
    "for",
    "cons",
    "js#",
    "macro",
    "defmacro"
  ]
};
var MODULE_VERSION = "1.0.0",
  nosemi_QUERY = false,
  tabspace = 2,
  indent = (-tabspace),
  EXTERNS = null,
  NSPACES = null,
  SPEC_OPS = {};
//
function regoBuiltins(f,group) {
return RESERVED[group].forEach(function (k) {
return SPEC_OPS[k] = f;
});
}

//
function error_BANG(e,line,file,msg) {
return std.raise_BANG(ERRORS_MAP[e],(msg ?
  [" : ",msg].join("") :
  ""),(line ?
  ["\nLine no ",line].join("") :
  ""),(file ?
  ["\nFile ",file].join("") :
  ""));
}

//
function syntax_BANG(ecode,ast,cmd) {
return error_BANG(ecode,(ast ?
  ast.line :
  0),(ast ?
  ast.source :
  0),cmd);
}

//
function pad(z) {
return " ".repeat(z);
}

//
function testre_QUERY(re,x) {
return (x ?
  re.test(x) :
  false);
}

//
function nodeTag(obj,src) {
((obj&&src&&(typeof(obj) !== "boolean")&&(typeof(obj) !== "number")) ?
    (function() {
  obj.source = src.source;
  obj.column = src.column;
  return obj.line = src.line;
  }).call(this) :
  null);
return obj;
}

//
function transpileTree(root,env) {
return (function (ret) {
let pstr = "",
  endx = (root.length-1),
  treeSize = root.length;
indent += tabspace;
pstr = pad(indent);
root.forEach(function (ast) {
let tmp = ast;
(std.array_QUERY(ast) ?
  tmp = transpileList(ast,env) :
  null);
return (tmp ?
    (function() {
  ret.add([
    pstr,
    tmp,
    (nosemi_QUERY ?
      "" :
      ";"),
    "\n"
  ]);
  return nosemi_QUERY = false;
  }).call(this) :
  null);
});
indent -= tabspace;
return ret;
})(nodeTag(tnode(),root));
}

//
function transpileAtoms(atoms,env) {
return atoms.forEach(function (a,i,arr) {
return arr[i] = (std.array_QUERY(a) ?
  transpileList(a,env) :
  transpileSingle(a));
});
}

//
function transpileSingle(a) {
return (types.symbol_QUERY(a) ?
  rdr.jsid(types.symbol_s(a)) :
  (types.keyword_QUERY(a) ?
    ["\"",types.keyword_s(a),"\""].join("") :
    (std.string_QUERY(a) ?
      a :
      ((a === null) ?
        "null" :
        (true ?
          ["",a].join("") :
          null)))));
}

//
function transpile_STAR(x,env) {
return (std.array_QUERY(x) ?
  transpileList(x,env) :
  transpileSingle(x));
}

//
function findCmd(ast) {
return (function (cmd) {
(types.vector_QUERY(ast) ?
  cmd = "[" :
  (types.map_QUERY(ast) ?
    cmd = "{" :
    (types.list_QUERY(ast) ?
      cmd = types.symbol_s(first(ast)) :
      null)));
return cmd;
})("");
}

//
function transpileList(ast,env) {
let cmd = findCmd(ast),
  mc = macros.get(cmd),
  tmp = null;
return (function (ret) {
(mc ?
    (function() {
  ast = rt.expandMacro(ast,env,mc);
  return cmd = findCmd(ast);
  }).call(this) :
  null);
(cmd.startsWith(".-") ?
  ret.add([
    transpile_STAR(second(ast),env),
    ".",
    transpileSingle(types.symbol(cmd.slice(2)))
  ]) :
  (("." === cmd.charAt(0)) ?
        (function() {
    ret.add(transpile_STAR(second(ast),env));
    ret.add([
      cmd,
      "("
    ]);
    (function () {
for (var n = 2; (n < ast.length); n = (n+1)) {
            ((n !== 2) ?
        ret.add(",") :
        null);
      ret.add(transpile_STAR(ast[n],env));
;
    }
}).call(this);
    return ret.add(")");
    }).call(this) :
    (SPEC_OPS.hasOwnProperty(cmd) ?
      ret = SPEC_OPS[cmd](ast,env) :
      (true ?
                (function() {
        (types.list_QUERY(ast) ?
                    (function() {
          transpileAtoms(ast,env);
          return cmd = first(ast);
          }).call(this) :
          cmd = transpileSingle(ast));
        (cmd ?
          null :
          syntax_BANG("e1",ast));
        return (types.list_QUERY(ast) ?
                    (function() {
          (testre_QUERY(rdr.REGEX.func(cmd)) ?
            cmd = tnodeEx([
              "(",
              cmd,
              ")"
            ]) :
            null);
          return ret.add([
            cmd,
            "(",
            tnodeEx(ast.slice(1)).join(","),
            ")"
          ]);
          }).call(this) :
          ret.add(cmd));
        }).call(this) :
        null))));
ret = nodeTag(ret,ast);
return ret;
})(tnode());
}

//
function sf_apply(ast,env) {
let args = ast.slice(2),
  f = second(ast),
  ret = nodeTag(tnode(),ast);
(function () {
for (var i = 0; (i < args.length); i = (i+1)) {
    ret.add(transpile_STAR(args[i],env));
;
}
}).call(this);
((args.length > 1) ?
  ret.join(",") :
  null);
return (function (G__1) {
G__1.prepend("[");
G__1.add("]");
G__1.prepend([
  transpile_STAR(f,env),
  ".apply(this,"
]);
G__1.add(ret,")");
return G__1;
})(ret);
}

SPEC_OPS["apply"] = sf_apply;
//
function sf_compOp(ast,env) {
let cmd = first(ast);
(((cmd === "not=")||(cmd === "!=")) ?
  ast[0] = types.symbol("!==") :
  null);
((cmd === "=") ?
  ast[0] = types.symbol("===") :
  null);
return (function (ret) {
transpileAtoms(ast,env);
(function () {
for (var i = 0,op = ast.shift(); (i < (ast.length-1)); i = (i+1)) {
    ret.add(tnodeEx([
    ast[i],
    " ",
    op,
    " ",
    ast[(i+1)]
  ]));
;
}
}).call(this);
ret.join(" && ");
ret.prepend("(");
ret.add(")");
return ret;
})(nodeTag(tnode(),ast));
}

regoBuiltins(sf_compOp,"compare");
//
function sf_arithOp(ast,env) {
return (function (ret) {
transpileAtoms(ast,env);
let op = tnode(),
  e1 = ast.shift(),
  cmd = types.symbol_s(e1);
((cmd === "mod") ?
  cmd = "%" :
  null);
((1 === ast.length) ?
  (("-" === cmd) ?
    ret.add("-") :
    null) :
  op.add([
    "",
    cmd,
    ""
  ]));
ret.add(ast);
((ast.length > 1) ?
  ret.join(op) :
  null);
ret.prepend("(");
ret.add(")");
return ret;
})(nodeTag(tnode(),ast));
}

regoBuiltins(sf_arithOp,"bitwise");
regoBuiltins(sf_arithOp,"logic");
regoBuiltins(sf_arithOp,"arith");
//
function sf_repeat(ast,env) {
return (function (ret) {
transpileAtoms(ast,env);
(function () {
for (var i = 0,end = parseInt(second(ast)); (i < end); i = (i+1)) {
    ((i !== 0) ?
    ret.add(",") :
    null);
  ret.add(ast[2]);
;
}
}).call(this);
ret.prepend("[");
ret.add("]");
return ret;
})(nodeTag(tnode(),ast));
}

SPEC_OPS["repeat-n"] = sf_repeat;
//
function transpileDo(ast,env,return_QUERY) {
return (function (ret) {
let p = pad(indent),
  e = null,
  end = (ast.length-1);
(function () {
for (var i = 0; (i < end); i = (i+1)) {
    e = ast[i];
  ret.add([
    p,
    transpileList(e,env),
    ";\n"
  ]);
;
}
}).call(this);
((end >= 0) ?
    (function() {
  e = transpile_STAR(ast[end],env);
  return (return_QUERY ?
    ret.add([
      p,
      "return ",
      e,
      ";\n"
    ]) :
    ret.add([
      p,
      e,
      ";\n"
    ]));
  }).call(this) :
  null);
return ret;
})(nodeTag(tnode(),ast));
}

//
function sf_do(ast,env) {
return (function (ret) {
let p = pad(indent);
ret.add([p,"(function() {\n"].join(""));
ret.add(transpileDo(ast.slice(1),env));
ret.add([p,"}).call(this)"].join(""));
return ret;
})(nodeTag(tnode(),ast));
}

SPEC_OPS["do"] = sf_do;
//
function sf_case(ast,env) {
return (function (ret) {
let tst = second(ast),
  e = null,
  t = null,
  c = null,
  dft = null;
(std.odd_QUERY(ast.length) ?
  dft = ast.pop() :
  null);
(function () {
for (var i = 2; (i < ast.length); i = (i+2)) {
    c = ast[(i+1)];
  e = ast[i];
  (types.list_QUERY(e) ?
    (function () {
for (var j = 0; (j < e.length); i = (null+1)) {
            ret.add([
        "case ",
        e[j],
        ":\n"
      ]);
      ((j === (e.length-1)) ?
        ret.add([
          "____x= ",
          transpile_STAR(c,env),
          ";\nbreak;\n"
        ]) :
        null);
;
    }
}).call(this) :
        (function() {
    ret.add([
      "case ",
      e,
      ":\n"
    ]);
    return ret.add([
      "____x= ",
      transpile_STAR(c,env),
      ";\nbreak;\n"
    ]);
    }).call(this));
;
}
}).call(this);
(dft ?
    (function() {
  ret.add("default:\n");
  return ret.add([
    "____x= ",
    transpile_STAR(dft,env),
    ";\nbreak;\n"
  ]);
  }).call(this) :
  null);
ret.prepend([
  "switch (",
  transpile_STAR(tst,env),
  ") {\n"
]);
ret.add("}\n");
ret.prepend("(function() { let ____x;\n");
ret.add("return ____x;}).call(this)");
return ret;
})(nodeTag(tnode(),ast));
}

SPEC_OPS["case"] = sf_case;
//
function sf_range(ast,env) {
return (function (ret) {
let len = 0,
  start = 0,
  step = 1,
  end = 0;
transpileAtoms(ast,env);
len = ast.length;
end = parseInt(second(ast));
((len > 2) ?
    (function() {
  start = parseInt(second(ast));
  return end = parseInt(ast[2]);
  }).call(this) :
  null);
((len > 3) ?
  step = parseInt(ast[3]) :
  null);
(function () {
for (var i = start; (i < end); i = i(+,step)) {
    ((i !== start) ?
    ret.add(",") :
    null);
  ret.add(i);
;
}
}).call(this);
ret.prepend("[");
ret.add("]");
return ret;
})(nodeTag(tnode(),ast));
}

SPEC_OPS["range"] = sf_range;
//
function sf_var(ast,env,cmd) {
(((ast.length < 3)||(0 === (ast.length%2))) ?
  syntax_BANG("e0",ast) :
  null);
return (function (ret) {
let vname = null,
  public_QUERY = ("global" == cmd);
((ast.length > 3) ?
  indent += tabspace :
  null);
((public_QUERY||("local" == cmd)) ?
  cmd = "var" :
  null);
transpileAtoms(ast,env);
(function () {
for (var i = 1; (i < ast.length); i = (i+2)) {
    ((i > 1) ?
    ret.add([",\n",pad(indent)].join("")) :
    null);
  (rdr.testid_QUERY(ast[i]) ?
    null :
    syntax_BANG("e9",ast));
  vname = types.symbol_s(ast[i]);
  ((public_QUERY&&(1 === NSPACES.length)) ?
    EXTERNS[vname] = vname :
    null);
  ret.add([
    vname,
    " = ",
    ast[(i+1)]
  ]);
;
}
}).call(this);
ret.prepend(" ");
ret.prepend(cmd);
((ast.length > 3) ?
  indent -= tabspace :
  null);
return ret;
})(nodeTag(tnode(),ast));
}

//
function sf_var_local(ast,env) {
return sf_var(ast,env,"local");
}

SPEC_OPS["def-"] = sf_var_local;
//
function sf_var_global(ast,env) {
return sf_var(ast,env,"global");
}

SPEC_OPS["def"] = sf_var_global;
//
function sf_var_let(ast,env) {
return sf_var(ast,env,"let");
}

SPEC_OPS["var"] = sf_var_let;
//
function sf_inst_QUERY(ast,env) {
return (function (ret) {
ret.add([
  "(",
  transpile_STAR(ast[2],env),
  " instanceof ",
  transpile_STAR(ast[1],env),
  ")"
]);
return ret;
})(nodeTag(tnode(),ast));
}

SPEC_OPS["inst?"] = sf_inst_QUERY;
//
function sf_delete(ast,env) {
return (function (ret) {
ret.add([
  "delete ",
  transpile_STAR(st[1],env)
]);
return ret;
})(nodeTag(tnode(),ast));
}

SPEC_OPS["delete!"] = sf_delete;
//
function sf_new(ast,env) {
return (function (ret) {
ret.add(transpileList(ast.slice(1),env));
ret.prepend("new ");
return ret;
})(nodeTag(tnode(),ast));
}

SPEC_OPS["new"] = sf_new;
//
function sf_throw(ast,env) {
return (function (ret) {
ret.add([
  "throw ",
  transpile_STAR(ast[1],env),
  ";"
]);
ret.prepend("(function (){ ");
ret.add(" }).call(this)");
return ret;
})(nodeTag(tnode(),ast));
}

SPEC_OPS["throw"] = sf_throw;
//
function sf_x_opop(ast,env) {
transpileAtoms(ast,env);
return nodeTag(tnodeEx([
  first(ast),
  second(ast)
]),ast);
}

regoBuiltins(sf_x_opop,"incdec");
//
function sf_x_eq(ast,env) {
transpileAtoms(ast,env);
return nodeTag(tnodeEx([
  second(ast),
  " ",
  first(ast),
  " ",
  ast[2]
]));
}

regoBuiltins(sf_x_eq,"assign");
//
function sf_set(ast,env) {
return (function (ret) {
let e1 = transpile_STAR(ast[1],env);
((4 === ast.length) ?
  (function (G__2) {
  G__2.add(e1);
  G__2.add("[");
  G__2.add(transpile_STAR(ast[2],env));
  G__2.add("]");
  return G__2;
  })(ret) :
  ret.add(e1));
ret.add([
  " = ",
  transpile_STAR(ast[(ast.length-1)],env)
]);
return ret;
})(nodeTag(tnode(),ast));
}

SPEC_OPS["aset"] = sf_set;
SPEC_OPS["set!"] = sf_set;
SPEC_OPS["def!"] = sf_set;
//
function sf_lambda(ast,env) {
return (function (ret) {
let args = ast[1],
  varg = "",
  body = ast.slice(2);
args = ret.add([
  ") {\n",
  varg,
  transpileDo(body,env),
  pad(indent),
  "}"
]);
return ret;
})(nodeTag(tnode(),ast));
}

SPEC_OPS["fn"] = sf_lambda;
//
function handleArgs(args) {
let skip = -1,
  varg = "",
  ret = [],
  ____break = false;
(function () {
for (var i = 0,e = null; ((!____break)&&(i < args.length)); i = (i+1)) {
    e = args[i];
  ((e == "&") ?
        (function() {
    varg = args[(i+1)];
    skip = i;
    return ____break = true;
    }).call(this) :
    (""(+e).startsWith("&") ?
            (function() {
      varg = ""(+,e).slice(1);
      skip = i;
      return ____break = true;
      }).call(this) :
      (true ?
        ret.push(e) :
        null)));
;
}
}).call(this);
return [
  ret,
  skip,
  varg
];
}

//
function sf_func(ast,env,public_QUERY) {
return (function (ret) {
let fname = transpileSingle(ast[1],env),
  dot_QUERY = fname.includes("."),
  vargs = "",
  e3 = ast[3],
  e2 = ast[2],
  doc = null,
  attrs = null,
  args = 2,
  body = 3;
(types.list_QUERY(e2) ?
  null :
  (std.string_QUERY(e2) ?
        (function() {
    doc = 2;
    args = 3;
    return (types.map_QUERY(e3) ?
            (function() {
      attrs = 3;
      return args = 4;
      }).call(this) :
      null);
    }).call(this) :
    (types.map_QUERY(e2) ?
            (function() {
      attrs = 2;
      return args = 3;
      }).call(this) :
      null)));
body = (args+1);
(doc ?
  doc = ast[doc] :
  null);
(attrs ?
  attrs = ast[attrs] :
  null);
args = ast[args];
args = args.map(function (a) {
return a;
});
transpileAtoms(args,env);
args = handleArgs(args);
body = ast.slice(body);
ret.add(args[0]);
ret.join(",");
(dot_QUERY ?
  ret.prepend([
    fname,
    " = function ("
  ]) :
  ret.prepend(["function ",fname,"("].join("")));
((args[1] >= 0) ?
  vargs = ["let ",args[2],"=Array.prototype.slice.call(arguments,",args[1],");\n"].join("") :
  null);
ret.add([
  ") {\n",
  vargs,
  transpileDo(body,env),
  pad(indent),
  "}\n"
]);
((false&&attrs) ?
    (function() {
  ret.add(fmtSpecOps(fname,attrs));
  return ret.add(";");
  }).call(this) :
  null);
(doc ?
    (function() {
  doc = doc.replace(rdr.REGEX.dquoteHat,"");
  doc = doc.replace(rdr.REGEX.dquoteEnd,"");
  return ret.prepend(doc.split("\\n").map(function (s) {
  return ["//",s,"\n"].join("");
  }));
  }).call(this) :
  null);
((public_QUERY&&(!dot_QUERY)&&(1 === NSPACES.length)) ?
  EXTERNS[fname] = fname :
  null);
nosemi_QUERY = true;
return ret;
})(nodeTag(tnode(),ast));
}

//
function sf_func_private(ast,env) {
return sf_func(ast,env,false);
}

SPEC_OPS["defn-"] = sf_func_private;
//
function sf_func_public(ast,env) {
return sf_func(ast,env,true);
}

SPEC_OPS["defn"] = sf_func_public;
//
function sf_try(ast,env) {
return (function (ret) {
let sz = ast.length,
  t = null,
  f = null,
  c = null,
  ind = pad(indent);
f = std.last(ast);
((std.array_QUERY(f)&&("finally" == first(f))) ?
    (function() {
  f = ast.pop();
  return sz = ast.length;
  }).call(this) :
  f = null);
c = null;
((sz > 1) ?
  c = ast[(sz-1)] :
  null);
((std.array_QUERY(c)&&("catch" == first(c))) ?
    (function() {
  (((c.length < 2)||(!types.symbol_QUERY(second(c)))) ?
    syntax_BANG("e0",ast) :
    null);
  return c = ast.pop();
  }).call(this) :
  c = null);
(((f === null)&&(c === null)) ?
  syntax_BANG("e0",ast) :
  null);
ret.add([
  ["(function() {\n",ind,"try {\n"].join(""),
  transpileDo(ast.slice(1),env),
  ["\n",ind,"} "].join("")
]);
(c ?
    (function() {
  t = second(c);
  return ret.add([
    ["catch (",t,") {\n"].join(""),
    transpileDo(c.slice(2),env),
    [";\n",ind,"}\n"].join("")
  ]);
  }).call(this) :
  null);
(f ?
    (function() {
  return ret.add([
    "finally {\n",
    transpileDo(f.slice(1),env),
    [";\n",ind,"}\n"].join("")
  ]);
  }).call(this) :
  null);
ret.add([ind,"}).call(this)"].join(""));
return ret;
})(nodeTag(tnode(),ast));
}

SPEC_OPS["try"] = sf_try;
//
function sf_if(ast,env) {
return (function (ret) {
let a1 = ast[1],
  a2 = ast[2],
  a3 = ((ast.length > 3) ?
    ast[3] :
    null);
indent += tabspace;
ret.add([
  "(",
  transpile_STAR(a1,env),
  [" ?\n",pad(indent)].join(""),
  transpile_STAR(a2,env),
  [" :\n",pad(indent)].join(""),
  (transpile_STAR(a3,env)||"null"),
  ")"
]);
indent -= tabspace;
return ret;
})(nodeTag(tnode(),ast));
}

SPEC_OPS["if"] = sf_if;
//
function sf_nth(ast,env) {
return (function (ret) {
transpileAtoms(ast,env);
ret.add([
  ast[1],
  "[",
  ast[2],
  "]"
]);
return ret;
})(nodeTag(tnode(),ast));
}

SPEC_OPS["nth"] = sf_nth;
//
function sf_get(ast,env) {
return (function (ret) {
transpileAtoms(ast,env);
ret.add([
  ast[1],
  "[",
  ast[2],
  "]"
]);
return ret;
})(nodeTag(tnode(),ast));
}

SPEC_OPS["aget"] = sf_get;
SPEC_OPS["get"] = sf_get;
//
function sf_str(ast,env) {
return (function (ret) {
let args = ast.slice(1);
transpileAtoms(args,env);
((args.length > 1) ?
  (function (G__3) {
  G__3.add(args);
  G__3.join(",");
  G__3.prepend("[");
  G__3.add("].join(\"\")");
  return G__3;
  })(ret) :
  ((args.length > 0) ?
    ret.add(first(args).toString()) :
    null));
return ret;
})(nodeTag(tnode(),ast));
}

SPEC_OPS["str"] = sf_str;
//
function sf_array(ast,env) {
return (function (ret) {
let p = pad(indent),
  epilog = ["\n",p,"]"].join("");
(std.empty_QUERY(ast) ?
  ret.add("[]") :
    (function() {
  (types.vector_QUERY(ast) ?
    null :
    ast.splice(0,1));
  indent += tabspace;
  transpileAtoms(ast,env);
  p = pad(indent);
  ret.add(["[\n",+,p].join(""));
  (function () {
for (var i = 0; (i < ast.length); i = (i+1)) {
        ((i > 0) ?
      ret.add([",\n",p].join("")) :
      null);
    ret.add(ast[i]);
;
  }
}).call(this);
  ret.add(epilog);
  return indent -= tabspace;
  }).call(this));
return ret;
})(nodeTag(tnode(),ast));
}

SPEC_OPS["vec"] = sf_array;
SPEC_OPS["["] = sf_array;
//
function sf_object(ast,env) {
return (function (ret) {
let p = pad(indent),
  epilog = ["\n",p,"}"].join("");
(std.empty_QUERY(ast) ?
  ret.add("{}") :
    (function() {
  (types.map_QUERY(ast) ?
    null :
    ast.splice(0,1));
  indent += tabspace;
  transpileAtoms(ast,env);
  p = pad(indent);
  ret.add(["{\n",p].join(""));
  (function () {
for (var i = 0; (i < ast.length); i = (i+2)) {
        ((i > 0) ?
      ret.add([",\n",p].join("")) :
      null);
    ret.add([
      ast[i],
      ": ",
      ast[(i+1)]
    ]);
;
  }
}).call(this);
  ret.add(epilog);
  return indent -= tabspace;
  }).call(this));
return ret;
})(nodeTag(tnode(),ast));
}

SPEC_OPS["hash-map"] = sf_object;
SPEC_OPS["{"] = sf_object;
var includeFile = (function () {
let icache = [];
return function (fname) {
return (std.contains_QUERY(icache,fname) ?
  tnode() :
  (function (src) {
  icache.push(fname);
  return transpileTree(psr.parser(src,fname),rt.globalEnv());
  })(fs.readFileSync(fname,"utf-8")));
};
})();
//
function sf_include(ast,env) {
let ret = [],
  fname = null,
  dir = path.dirname(ast.source);
(function () {
for (var i = 1,e = null; (i < ast.length); i = (i+1)) {
    e = ast[i];
  (((!std.array_QUERY(e))||(1 !== e.length)) ?
    syntax_BANG("e0",ast) :
    null);
  fname = first(e);
  (fname ?
    fname = fname.replace(new RegExp("[\"]","g"),"") :
    null);
  (function() {
  try {
  return fname = fs.realpathSync([dir,"/",fname].join(""));

  } catch (e) {
  return syntax_BANG("e11",ast);
;
  }
  }).call(this);
  (function() {
  try {
  indent -= tabspace;
  return ret.push(includeFile(fname));

  } finally {
  NSPACES.pop();
  return indent += tabspace;
;
  }
  }).call(this);
;
}
}).call(this);
return (std.empty_QUERY(ret) ?
  tnode() :
  ret);
}

//
function sf_require(ast,env) {
return (function (ret) {
let path = null,
  v = null,
  e = null;
(function () {
for (var i = 1; (i < ast.length); i = (i+1)) {
    e = ast[i];
  (((!std.array_QUERY(e))||(3 !== e.length)) ?
    syntax_BANG("e0",ast) :
    null);
  path = first(e);
  v = e[2];
  ret.add([
    "var ",
    transpileSingle(v,env),
    "= require(",
    transpileSingle(path,env),
    ");\n"
  ]);
;
}
}).call(this);
return ret;
})(nodeTag(tnode(),ast));
}

//
function sf_ns(ast,env) {
return (function (ret) {
(function () {
for (var i = 1,e = null,nsp = null; (i < ast.length); i = (i+1)) {
    e = ast[i];
  (types.symbol_QUERY(e) ?
    (nsp ?
      syntax_BANG("e0",ast) :
      NSPACES.push(e.toString())) :
    ((types.list_QUERY(e)&&("with-meta" == e[0])&&types.symbol_QUERY(e[1])) ?
      (nsp ?
        syntax_BANG("e0",ast) :
        NSPACES.push(second(e).toString())) :
      ((types.list_QUERY(e)&&("include" == first(e))) ?
        ret.push(sf_include(e)) :
        ((types.list_QUERY(e)&&("require" == first(e))) ?
          ret.push(sf_require(e)) :
          null))));
;
}
}).call(this);
return ret;
})([]);
}

SPEC_OPS["ns"] = sf_ns;
//
function sf_comment(ast,env) {
return nodeTag(tnode(),ast);
}

SPEC_OPS["comment"] = sf_comment;
//
function sf_floop(ast,env,hint) {
return (function (ret) {
let c1 = null,
  c2 = null,
  c3 = null,
  c = ast[1],
  ind = pad(indent);
(((!std.array_QUERY(c))||(3 !== c.length)) ?
  syntax_BANG("e0",ast) :
  null);
c1 = first(c);
c2 = second(c);
c3 = c[2];
indent += tabspace;
(std.array_QUERY(c1) ?
  (function () {
for (var i = 0; (i < c1.length); i = (i+2)) {
        ((i === 0) ?
      ret.add([hint," "].join("")) :
      null);
    ((i > 0) ?
      ret.add(",") :
      null);
    ret.add([
      transpileSingle(c1[i],env),
      " = ",
      transpile_STAR(c1[(i+1)],env)
    ]);
;
  }
}).call(this) :
  null);
ret.add("; ");
(std.array_QUERY(c2) ?
  ret.add(transpileList(c2,env)) :
  null);
ret.add("; ");
(std.array_QUERY(c3) ?
  (function () {
for (var i = 0; (i < c3.length); i = (i+2)) {
        ((i > 0) ?
      ret.add(",") :
      null);
    ret.add([
      transpileSingle(c3[i],env),
      " = ",
      transpile_STAR(c3[(i+1)],env)
    ]);
;
  }
}).call(this) :
  null);
ret.add(") {\n");
((ast.length > 2) ?
  ret.add([
    ind,
    pad(tabspace),
    transpileDo(ast.slice(2),env,false),
    ";"
  ]) :
  null);
ret.add(["\n",ind,"}\n"].join(""));
ret.prepend("(function () {\n");
ret.add("}).call(this)");
indent -= tabspace;
return ret;
})(nodeTag(tnodeEx("for ("),ast));
}

SPEC_OPS["forlet"] = function (ast,env) {
return sf_floop(ast,env,"var");
};
SPEC_OPS["for"] = function (ast,env) {
return sf_floop(ast,env,"");
};
//
function sf_wloop(ast,env) {
return (function (ret) {
let cond = second(ast),
  ind = pad(indent);
ret.add(transpile_STAR(cond,env));
ret.add(";) {\n");
indent += tabspace;
((ast.length > 2) ?
  ret.add([
    ind,
    pad(tabspace),
    transpileDo(ast.slice(2),env,false),
    ";"
  ]) :
  null);
ret.add(["\n",ind,"}\n"].join(""));
ret.prepend("(function () {\n");
ret.add("}).call(this)");
indent -= tabspace;
return ret;
})(nodeTag(tnodeEx("for (;"),ast));
}

SPEC_OPS["while"] = sf_wloop;
//
function sf_jscode(ast,env) {
nosemi_QUERY = true;
return nodeTag(tnodeEx(second(ast).toString().replace(rdr.REGEX.dquoteHat,"").replace(rdr.REGEX.dquoteEnd,"")),ast);
}

SPEC_OPS["js#"] = sf_jscode;
//
function sf_macro(ast,env) {
return (function (ret) {
let a2 = null,
  a1 = null,
  func = null,
  p2 = ast[2],
  p3 = ast.slice(3);
ast = [
  first(ast),
  second(ast),
  std.concat([
    types.symbol("fn*"),
    p2
  ],p3)
];
a2 = ast[2];
a1 = ast[1].toString();
func = rt.eval(a2,env);
func["_ismacro_"] = true;
macros.set(a1func);
return ret;
})(nodeTag(tnode(),ast));
}

SPEC_OPS["defmacro"] = sf_macro;
//
function sf_unary(ast,env) {
return (function (ret) {
let a0 = first(ast),
  a1 = second(ast);
((a0 == "not") ?
  a0 = types.symbol("!") :
  null);
ret.add([
  "(",
  transpile_STAR(a0,env),
  transpile_STAR(a1,env),
  ")"
]);
return ret;
})(nodeTag(tnode(),ast));
}

regoBuiltins(sf_unary,"unary");
//
function spitExterns() {
return (function (s) {
let ks = std.keys(EXTERNS),
  p = pad(tabspace);
((ks.length > 0) ?
    (function() {
  s = ks.map(function (k) {
  return [p,k,": ",k].join("");
  }).join(",\n");
  return s = ["\n\nmodule.exports = {\n",s,"\n};\n\n"].join("");
  }).call(this) :
  null);
return s;
})("");
}

//
function banner() {
return ["/*","Auto generated by Kirby - v",MODULE_VERSION," ",std.first(NSPACES)," - ",new Date(),"*/\n\n"].join("");
}

//
function transpileCode(codeStr,fname,srcMap_QUERY) {
let indent = (-tabspace),
  EXTERNS = {},
  NSPACES = [],
  outNode = transpileTree(psr.parser(codeStr,fname),rt.globalEnv()),
  extra = spitExterns();
outNode.prepend(banner());
return (srcMap_QUERY ?
  (function (outFile,srcMap,output) {
  fs.writeFileSync(srcMap,output.map);
  return [output.code,extra,"\n//# sourceMappingURL=",path.relative(path.dirname(fname),srcMap)].join("");
  })([path.basename(fname,".ky"),".js"].join(""),[outFile,".map"].join(""),outNode.toStringWithSourceMap({
    "file": outFile
  })) :
  [outNode,extra].join(""));
}

//
function transpileXXX(code,file,smap_QUERY) {
return (function() {
try {
return transpileCode(code,file,smap_QUERY);

} catch (e) {
std.println(e.stack);
return (function (){ throw e; }).call(this);
;
}
}).call(this);
}

//
function transpileWithSrcMap(code,file) {
return transpileXXX(code,file,true);
}

//
function transpile(code,file) {
return transpileXXX(code,file,false);
}

//
function parseWithSourceMap(codeStr,fname) {
let outNode = transpileTree(psr.parser(codeStr,fname));
outNode.prepend(banner());
return outNode.toStringWithSourceMap();
}

var version = MODULE_VERSION;


module.exports = {
  transpileWithSrcMap: transpileWithSrcMap,
  transpile: transpile,
  parseWithSourceMap: parseWithSourceMap,
  version: version
};

