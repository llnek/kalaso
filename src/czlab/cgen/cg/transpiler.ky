;; Copyright (c) 2013-2017, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author ""}
  czlab.kirby.transpiler
  (require ["../bl/macros" :as macros]
           ["../bl/types" :as types]
           ["../bl/stdlib" :as std]
           ["../bl/tnode" :as tn]
           ["../bl/lexer" :as rdr]
           ["../bl/parser" :as psr]
           ["../rt/runtime" :as rt]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- tnodeEx tn.tnodeEx)
(def- tnode tn.tnode)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- ERRORS_MAP {
  :e0 "Syntax Error"
  :e1 "Empty statement"
  :e2 "Invalid characters in function name"
  :e3 "End of File encountered, unterminated string"
  :e4 "Closing square bracket, without an opening square bracket"
  :e5 "End of File encountered, unterminated array"
  :e6 "Closing curly brace, without an opening curly brace"
  :e7 "End of File encountered, unterminated javascript object '}'"
  :e8 "End of File encountered, unterminated parenthesis"
  :e9 "Invalid character in var name"
  :e10 "Extra chars at end of file. Maybe an extra ')'."
  :e11 "Cannot Open include File"
  :e12 "Invalid no of arguments to "
  :e13 "Invalid Argument type to "
  :e14 "End of File encountered, unterminated regular expression"
  :e15 "Invalid vararg position, must be last argument."
  :e16 "Invalid arity (args > expected) to "
  :e17 "Invalid arity (args < expected) to "})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- RESERVED {
  :compare ["not=" "!=" "==" "=" ">" ">=" "<" "<="]
  :arith ["+" "-" "*" "/" "%"  "mod"]
  :logic ["||" "&&"]
  :bitwise ["^" "&" "|" "<<" ">>" ">>>"]
  :incdec ["++" "--"]
  :unary ["not"  "~" "!"]
  :assign ["+=" "-=" "*="
         "/=" "%=" "<<="
         ">>=" ">>>=" "&=" "|=" "^="]
  :builtin
  ["quote" "syntax-quote" "quasi-quote"
  "backtick"  "unquote" "unquote-splice"
  "repeat-n"  "do"  "doto"  "case" "apply"
  "range"  "def-"  "def"  "var"  "forlet"
  "new"  "throw"  "while"  "lambda"
  "inst?"  "delete!"
  "aset"  "set!"  "fn"  "def!"
  "defn-"  "defn"
  "try"  "if"  "get"  "aget"  "str"
  "list"  "["  "vec"  "{"  "hash-map"
  "ns"  "comment"  "for"  "cons"
  "js#"  "macro"  "defmacro"]})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- MODULE_VERSION "1.0.0"
    nosemi? false
    tabspace 2
    indent (- tabspace)
    EXTERNS nil
    NSPACES nil
    SPEC_OPS {})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- regoBuiltins "" [f group]
  (each (fn [k] (set! SPEC_OPS k f)) (get RESERVED group)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- error! "" [e line file msg]
  (std.raise! (get ERRORS_MAP e)
              (if msg (str " : " msg) "")
              (if line (str "\nLine no " line) "")
              (if file (str "\nFile " file) "")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- syntax! "" [ecode ast cmd]
  (error! ecode
          (if ast ast.line 0)
          (if ast ast.source 0) cmd))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- pad "" [z] (.repeat " " z))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- testre? "" [re x] (if x (.test re x) false))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- nodeTag "" [obj src]
  (when (and obj
             src
             (not= (type obj) "boolean")
             (not= (type obj) "number"))
    (set! obj.source src.source)
    (set! obj.column src.column)
    (set! obj.line src.line))
  obj)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileTree "" [root env]
  (do-with [ret (nodeTag (tnode) root)]
    (var pstr ""
         endx (eindex root)
         treeSize (alen root))
    (+= indent tabspace)
    (set! pstr (pad indent))
    (each (fn [ast]
            (var tmp ast)
            (if (std.array? ast)
              (set! tmp (transpileList ast env)))
            (when tmp
              (.add ret [pstr tmp (if nosemi? ""  ";") "\n"])
              (set! nosemi? false))) root)
    (-= indent tabspace)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileAtoms "" [atoms env]
  (each (fn [a i arr]
          (set! arr
                i
                (if (std.array? a)
                  (transpileList a env)
                  (transpileSingle a)))) atoms))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileSingle "" [a]
  (cond
    (types.symbol? a)
    (.jsid rdr (types.symbol-s a))
    (types.keyword? a)
    (str "\"" (types.keyword-s a) "\"")
    (std.string? a)
    a
    (nil? a)
    "null"
    :else
    (str "" a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpile* "" [x env]
  (if (std.array? x)
         (transpileList x env) (transpileSingle x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- findCmd "" [ast]
  (do-with [cmd ""]
    (cond
      (types.vector? ast) (set! cmd "[")
      (types.map? ast) (set! cmd "{")
      (types.list? ast) (set! cmd (types.symbol-s (first ast))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileList "" [ast env]
  (var cmd (findCmd ast)
       mc (.get macros cmd) tmp nil)
  (do-with [ret (tnode)]
    (when mc
      (set! ast (.expandMacro rt ast env mc))
      (set! cmd (findCmd ast)))
    (cond
      (.startsWith cmd ".-")
      (.add ret [(transpile* (second ast) env)
                 "."
                 (transpileSingle (types.symbol (.slice cmd 2))) ])
      (= "." (.charAt cmd 0))
      (do (.add ret (transpile* (second ast) env))
          (.add ret [cmd "("])
          (forlet ((n 2)
                   (< n (alen ast)) (n (inc n)))
            (if (not= n 2) (.add ret ","))
            (.add ret (transpile* (nth ast n) env)))
          (.add ret ")"))
      (.hasOwnProperty SPEC-OPS cmd)
      (set! ret ((get SPEC_OPS cmd) ast env))
      :else
      (do (if (types.list? ast)
            (do (transpileAtoms ast env)
                (set! cmd (first ast)))
            (set! cmd (transpileSingle ast)))
          (if-not cmd (syntax! "e1" ast))
          (if (types.list? ast)
            (do (if (testre? (rdr.REGEX.func  cmd))
                  (set! cmd (tnodeEx ["("  cmd  ")"])))
                (.add ret [cmd
                           "("
                           (-> (tnodeEx (.slice ast 1))
                               (.join ",")) ")"]))
            (.add ret cmd))))
    (set! ret (nodeTag ret ast))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-apply "" [ast env]
  (var args (.slice ast 2)
       f (second ast)
      ret (nodeTag (tnode) ast))
  (forlet ((i 0) (< i (alen args)) (i (inc i)))
    (.add ret (transpile* (nth args i) env)))
  (if (> (alen args) 1) (.join ret ","))
  (doto ret
    (.prepend "[")
    (.add "]")
    (.prepend [(transpile* f env) ".apply(this,"])
    (.add ret ")")))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :apply sf-apply)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-compOp "" [ast env]
  (var cmd (first ast))
  (if (or (= cmd "not=")
          (= cmd "!=")) (set! ast 0 (types.symbol "!==")))
  (if (= cmd "=") (set! ast 0 (types.symbol "===")))
  (do-with [ret (nodeTag (tnode) ast)]
    (transpileAtoms ast env)
    (forlet ((i 0
              op (.shift ast))
             (< i (eindex ast)) (i (inc i)))
      (.add ret (tnodeEx [(nth ast i)
                          " " op " " (nth ast (inc i))])))
    (.join ret " && ")
    (.prepend ret "(")
    (.add ret ")")))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(regoBuiltins sf-compOp "compare")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-arithOp "" [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (transpileAtoms ast env)
    (var op (tnode)
         e1 (.shift ast)
         cmd (types.symbol-s e1))
    (if (= cmd "mod") (set! cmd "%"))
    (if (= 1 (alen ast))
      (if (= "-" cmd) (.add ret "-"))
      (.add op [""  cmd  ""]))
    (.add ret ast)
    (if (> (alen ast) 1) (.join ret op))
    (.prepend ret "(")
    (.add ret ")")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(regoBuiltins sf-arithOp "bitwise")
(regoBuiltins sf-arithOp "logic")
(regoBuiltins sf-arithOp "arith")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-repeat "" [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (transpileAtoms ast env)
    (forlet ((i 0
              end (parseInt (second ast)))
             (< i  end) (i (inc i)))
      (if (not= i 0) (.add ret ","))
      (.add ret (nth ast 2)))
    (.prepend ret "[")
    (.add ret "]")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :repeat-n sf-repeat)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileDo "" [ast env return?]
  (do-with [ret (nodeTag (tnode) ast)]
    (var p (pad indent)
         e nil
         end (eindex ast))
    (forlet ((i 0) (< i end) (i (inc i)))
      (set! e (nth ast i))
      (.add ret [p (transpileList e env) ";\n"]))
    (when  (>= end 0)
      (set! e (transpile* (nth ast end) env))
      (if-not return?
        (.add ret [p e ";\n"])
        (.add ret [p "return " e ";\n"])))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-do "" [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (var p (pad indent))
    (.add ret (str p "(function() {\n"))
    (.add ret (transpileDo (.slice ast 1) env))
    (.add ret (str p "}).call(this)"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :do sf-do)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-case "" [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (var tst (second ast)
         e nil t nil c nil dft nil)
    (if (std.odd? (alen ast))
      (set! dft (.pop ast)))
    (forlet ((i 2)
             (< i (alen ast)) (i (+ i 2)))
      (set! c (nth ast (inc i)))
      (set! e (nth ast i))
      (if (types.list? e)
        (forlet ((j 0)
                 (< j (alen e)) (i (inc)))
          (.add ret ["case " (nth e j) ":\n"])
          (if (= j (eindex e))
            (.add ret ["____x= "
                       (transpile* c env) ";\nbreak;\n"])))
        (do (.add ret ["case " e ":\n"])
            (.add ret ["____x= "
                       (transpile* c env) ";\nbreak;\n"]))))
    (when dft
      (.add ret "default:\n")
      (.add ret ["____x= "
                 (transpile* dft env) ";\nbreak;\n"]))

    (.prepend ret ["switch (",
                   (transpile* tst env) ") {\n"])
    (.add ret "}\n")
    (.prepend ret "(function() { let ____x;\n")
    (.add ret "return ____x;}).call(this)")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :case sf-case)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-range "" [ast env]
  ;;if (ast.length < 2 || ast.length > 4) syntax_E("e0",ast);
  (do-with [ret (nodeTag (tnode) ast)]
  (var len 0 start 0 step 1 end 0)
  (transpileAtoms ast env)
  (set! len (alen ast))
  (set! end (parseInt (second ast)))
  (when (> len 2)
    (set! start (parseInt (second ast)))
    (set! end (parseInt (nth ast 2))))
  (if (> len 3)
    (set! step (parseInt (nth ast 3))))

  (forlet ((i start) (< i end) (i (i + step)))
    (if (not= i start) (.add ret ","))
    (.add ret (str i)))
  (.prepend ret "[")
  (.add ret "]")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :range sf-range)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-var "" [ast env cmd]
  ;;must be even pairs
  (if (or (< (alen ast) 3)
          (= 0 (mod (alen ast) 2))) (syntax! :e0 ast))

  (do-with [ret (nodeTag (tnode) ast)]
    (var vname nil public? (== "global" cmd))
    (if (> (alen ast) 3) (+= indent tabspace))
    (if (or public?
          (== "local" cmd)) (set! cmd "var"))
    (transpileAtoms ast env)
    (forlet ((i 1) (< i (alen ast)) (i (+ i 2)))
      (if (> i 1)
        (.add ret (str ",\n" (pad indent))))
      (if-not (rdr.testid? (nth ast i)) (syntax! :e9 ast))
      (set! vname (types.symbol-s (nth ast i)))
      (if (and public?
               (= 1 (alen NSPACES))) (set! EXTERNS vname vname))
      (.add ret [vname " = " (nth ast (inc i))]))
    (.prepend ret " ")
    (.prepend ret cmd)
    (if (> (alen ast) 3) (-= indent tabspace))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-var-local "" [ast env]
  (sf-var ast env "local"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :def- sf-var-local)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-var-global "" [ast env]
  (sf-var ast env  "global"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :def sf-var-global)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-var-let "" [ast env]
  (sf-var ast env "let"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :var sf-var-let)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-inst? "" [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (.add ret ["("
               (transpile* (nth ast 2) env)
               " instanceof "
               (transpile* (nth ast 1) env) ")"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :inst? sf-inst?)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-delete "" [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (.add ret ["delete " (transpile* (nth st 1) env)])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :delete! sf-delete)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-new "" [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (.add ret (transpileList (.slice ast 1) env))
    (.prepend ret "new ")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :new sf-new)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-throw "" [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (.add ret ["throw " (transpile* (nth ast 1) env) ";"])
    (.prepend ret "(function (){ ")
    (.add ret " }).call(this)")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :throw sf-throw)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-x-opop "" [ast env]
  (transpileAtoms ast env)
  (nodeTag (tnodeEx [(first ast)
                     (second ast)]) ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(regoBuiltins sf-x-opop "incdec")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-x-eq "" [ast env]
  (transpileAtoms ast env)
  (nodeTag (tnodeEx [(second ast)
                     " " (first ast) " " (nth ast 2)])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(regoBuiltins sf-x-eq "assign")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-set "" [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (var e1 (transpile* (nth ast 1) env))
    (if (= 4 (alen ast))
      (doto ret
        (.add e1)
        (.add "[")
        (.add (transpile* (nth ast 2) env))
        (.add "]"))
      (.add ret e1))
    (.add ret [" = " (transpile* (nth ast (eindex ast)) env)])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :aset sf-set)
(set! SPEC-OPS :set! sf-set)
(set! SPEC-OPS :def! sf-set)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-lambda "" [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (var args (nth ast 1)
         varg ""
         body (.slice ast 2))
    (set! args (map (fn [a] a) args)
    (transpileAtoms args env)
    (set! args (handleArgs args))
    (if (>= (nth args 1) 0)
      (set! varg (str "let "
                      (nth args 2)
                      "=Array.prototype.slice.call(arguments,"
                      (nth args 1)
                      ");\n")))
    (.add ret (first args))
    (.join ret ",")
    (.prepend ret "function (")
    (.add ret [") {\n"
               varg
               (transpileDo body env)
               (pad indent) "}"]))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC_OPS :fn sf-lambda)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- handleArgs "" [args]
  (var skip -1 varg "" ret [] ____break false)
  (forlet ((i 0
            e nil)
           (and (not ____break)
                (< i (alen args))) (i (inc i)))
    (set! e (nth args i))
    (cond
      (== e "&")
      (do (set! varg  (str (nth args (inc i))))
          (set! skip i)
          (set! ____break true))
      (.startsWith (""+e) "&")
      (do (set! varg (.slice ("" + e) 1))
          (set! skip i)
          (set! ____break true))
      :else
      (.push ret e)))
  [ret skip varg])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-func "" [ast env public?]
  (do-with [ret (nodeTag (tnode) ast)]
    (var fname (transpileSingle (nth ast 1) env)
         dot? (.includes fname ".")
         vargs ""
         e3 (nth ast 3)
         e2 (nth ast 2)
         doc nil attrs nil args 2 body 3)
    (cond
      (types.list? e2) nil
      (std.string? e2)
      (do (set! doc 2)
          (set! args 3)
          (when (types.map? e3)
            (set! attrs 3)
            (set! args 4)))
      (types.map? e2)
      (do (set! attrs 2)
          (set! args 3)))
    (set! body (inc args))
    (if doc (set! doc (nth ast doc)))
    (if attrs (set! attrs (nth ast attrs)))
    (set! args (nth ast args))
    (set! args (map (fn [a] a) args))
    (transpileAtoms args env)
    (set! args (handleArgs args))
    (set! body (.slice ast body))
    (.add ret (nth args 0))
    (.join ret ",")
    (if dot?
      (.prepend ret [fname " = function ("])
      (.prepend ret (str "function " fname "(")))
    (if (>= (nth args 1) 0)
      (set! vargs
            (str "let "
                 (nth args 2)
                 "=Array.prototype.slice.call(arguments,"
                 (nth args 1) ");\n")))
    (.add ret [") {\n"
               vargs
               (transpileDo body env)
               (pad indent) "}\n"])
    (when (and false attrs)
      (.add ret (fmtSpecOps fname attrs))
      (.add ret ";"))
    (when doc
      (set! doc (.replace doc rdr.REGEX.dquoteHat ""))
      (set! doc (.replace doc rdr.REGEX.dquoteEnd, ""))
      (.prepend ret
                (map (fn [s] (str "//" s  "\n"))
                     (.split doc "\\n"))))
    (if (and public?
             (not dot?)
             (= 1 (alen NSPACES))) (set! EXTERNS fname fname))
    (set! nosemi? true)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-func-private "" [ast env] (sf-func ast env false))
(set! SPEC-OPS :defn- sf-func-private)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-func-public "" [ast env] (sf-func ast env true))
(set! SPEC-OPS :defn sf-func-public)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-try "" [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (var sz (alen ast)
         t nil
         f nil
         c nil
         ind (pad indent))
    ;;look for finally
    (set! f (std.last ast))
    (if (and (std.array? f)
             (== "finally" (first f)))
      (do (set! f (.pop ast))
          (set! sz (alen ast)))
      (set! f nil))
    ;;look for catch
    (set! c nil)
    (if (> sz 1) (set! c (nth ast (dec sz))))
    (if (and (std.array? c)
             (== "catch" (first c)))
      (do (if (or (< (alen c) 2)
                  (not (types.symbol? (second c)))) (syntax! :e0 ast))
          (set! c (.pop ast)))
      (set! c nil))
    ;;try needs either a catch or finally or both
    (if (and (nil? f) (nil? c)) (syntax! :e0 ast))
    (.add ret [(str "(function() {\n" ind "try {\n")
               (transpileDo (.slice ast 1) env)
               (str "\n" ind "} ")])
    (when c
      (set! t (second c))
      (.add ret [(str "catch (" t ") {\n")
                 (transpileDo (.slice c 2) env)
                 (str ";\n" ind "}\n")]))
    (when f
      (.add ret ["finally {\n",
                 (transpileDo (.slice f 1) env)
                 (str ";\n" ind "}\n")]))

    (.add ret (str ind "}).call(this)"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :try sf-try)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-if "" [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (var a1 (nth ast 1)
         a2 (nth ast 2)
         a3 (if (> (alen ast) 3) (nth ast 3)))
    (+= indent tabspace)
    (.add ret ["("
               (transpile* a1 env)
               (str " ?\n" (pad indent))
               (transpile* a2 env)
               (str " :\n" (pad indent))
               (or (transpile* a3 env) "null") ")"])
    (-= indent tabspace)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :if sf-if)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-nth "" [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (transpileAtoms ast env)
    (.add ret [(nth ast 1) "[" (nth ast 2) "]"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :nth sf-nth)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-get "" [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (transpileAtoms ast env)
    (.add ret [(nth ast 1) "[" (nth ast 2) "]"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :aget sf-get)
(set! SPEC-OPS :get sf-get)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-str "" [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (var args (.slice ast 1))
    (transpileAtoms args env)
    (if (> (alen args) 1)
      (doto ret
        (.add args)
        (.join ",")
        (.prepend "[")
        (.add "].join(\"\")"))
      (if (> (alen args) 0)
        (.add ret (.toString (first args)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :str sf-str)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-array "" [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (var p (pad indent)
         epilog (str "\n" p "]"))
    (if (std.empty? ast)
      (.add ret "[]")
      (do (if-not (types.vector? ast)
            (.splice ast 0 1))
          (+= indent tabspace)
          (transpileAtoms ast env)
          (set! p (pad indent))
          (.add ret (str "[\n"+ p))
          (forlet ((i 0) (< i (alen ast)) (i (inc i)))
            (if (> i 0) (.add ret (str ",\n" p)))
            (.add ret (nth ast i)))
          (.add ret epilog)
          (-= indent tabspace)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :vec sf-array)
(set! SPEC-OPS "[" sf-array)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-object "" [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (var p (pad indent)
         epilog (str "\n" p "}"))
    (if (std.empty? ast)
      (.add ret "{}")
      (do (if-not (types.map? ast)
            (.splice ast 0 1))
          (+= indent tabspace)
          (transpileAtoms ast env)
          (set! p (pad indent))
          (.add ret (str "{\n" p))
          (forlet ((i 0) (< i (alen ast)) (i (+ i 2)))
            (if (> i 0) (.add ret (str ",\n" p)))
            (.add ret [(nth ast i) ": " (nth ast (inc i))]))
          (.add ret epilog)
          (-= indent tabspace)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :hash-map sf-object)
(set! SPEC-OPS "{" sf-object)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-require "" [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (var path nil v nil e nil)
    (forlet ((i 1)
             (< i (alen ast)) (i (inc i)))
      (set! e (nth ast i))
      (if (or (not (std.array? e))
              (not= 3 (alen e))) (syntax! :e0 ast))
      (set! path (first e))
      (set! v (nth e 2))
      (.add ret ["var "
                 (transpileSingle v env)
                 "= require("
                 (transpileSingle path env) ");\n"]))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-ns "" [ast env]
  (do-with [ret []]
    (forlet ((i 1) (< i (alen ast)) (i (inc i)))
      (var e (nth ast i)
           nm (first e))
      (cond
        (== nm "with-meta")
        (.push NSPACES (.toString (second e)))
        (types.symbol? e)
        (.push NSPACES (.toString e))
        (and (types.list? e)
             (== "include" nm))
        (.push ret (sf_include e))
        (and (types.list? e)
             (== "require" nm))
        (.push ret (sf_require e))
        (and (types.list? e)
             (== "with-meta" nm))
        nil))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :ns sf-ns)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-comment "" [ast env] (nodeTag (tnode) ast))
(set! SPEC-OPS :comment sf-comment)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-floop "" [ast env hint]
  (do-with [ret (nodeTag (tnodeEx "for (") ast)]
    (var c1 nil c2 nil c3 nil
         c (nth ast 1) ind (pad indent))
    (if (or (not (std.array? c))
            (not= 3 (alen c))) (syntax! :e0 ast))
    (set! c1 (first c))
    (set! c2 (second c))
    (set! c3 (nth c 2))
    (+= indent tabspace)
    (if (std.array? c1)
      (forlet ((i 0) (< i (alen c1)) (i (+ i 2)))
        (if (= i 0) (.add ret (str hint " ")))
        (if (> i 0) (.add ret ","))
        (.add ret [(transpileSingle (nth c1 i) env)
                   " = "
                   (transpile* (nth c1 (inc i)) env)])))
    (.add ret "; ")
    (if (std.array? c2)
      (.add ret (transpileList c2 env)))
    (.add ret "; ")
    (if (std.array? c3)
      (forlet ((i 0) (< i (alen c3)) (i (+ i 2)))
        (if (> i 0) (.add ret ","))
        (.add ret [(transpileSingle (nth c3 i) env)
                   " = "
                   (transpile* (nth c3 (inc i)) env)])))
    (.add ret ") {\n")
    (if (> (alen ast) 2)
      (.add ret [ind (pad tabspace)
                 (transpileDo (.slice ast 2) env false) ";"]))
    (.add ret (str "\n" ind "}\n"))
    (.prepend ret "(function () {\n")
    (.add ret "}).call(this)")
    (-= indent tabspace)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :forlet (fn [ast env] (sf-floop ast env "var")))
(set! SPEC-OPS :for (fn [ast env] (sf-floop ast env "")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-wloop "" [ast env]
  (do-with [ret (nodeTag (tnodeEx "for (;") ast)]
    (var cond (second ast)
         ind (pad indent))
    (.add ret (transpile* cond env))
    (.add ret ";) {\n")
    (+= indent tabspace)
    (if (> (alen ast) 2)
      (.add ret [ind
                 (pad tabspace)
                 (transpileDo (.slice ast 2) env false) ";"]))
    (.add ret (str "\n" ind "}\n"))
    (.prepend ret "(function () {\n")
    (.add ret "}).call(this)")
    (-= indent tabspace)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :while sf-wloop)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-jscode "" [ast env]
  (set! nosemi? true)
  (nodeTag (tnodeEx (-> (.toString (second ast))
                        (.replace rdr.REGEX.dquoteHat "")
                        (.replace rdr.REGEX.dquoteEnd ""))) ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS "js#" sf-jscode)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-macro "" [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (var a2 nil a1 nil func nil
         p2 (nth ast 2) p3 (.slice ast 3))
    (set! ast [(first ast)
               (second ast)
               (std.concat [(types.symbol "fn*") p2] p3)])
    (set! a2 (nth ast 2))
    (set! a1 (.toString (nth ast 1)))
    (set! func (.eval rt a2 env))
    (set! func :_ismacro_ true)
    (.set macros a1func)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! SPEC-OPS :defmacro sf-macro)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- sf-unary "" [ast env]
  (do-with [ret (nodeTag (tnode) ast)]
    (var a0 (first ast)
         a1 (second ast))
    (if (== a0 "not") (set! a0 (types.symbol "!")))
    (.add ret ["(" (transpile* a0 env) (transpile* a1 env) ")"])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(regoBuiltins sf-unary "unary")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- spitExterns "" []
  (do-with [s ""]
    (var ks (std.keys EXTERNS)
         p (pad tabspace))
    (when (> (alen ks) 0)
      (set! s (-> (map (fn [k] (str p  k  ": " k)) ks)
                  (.join ",\n")))
      (set! s (str "\n\nmodule.exports = {\n" s "\n};\n\n")))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- banner "" []
  (str "/*"
       "Auto generated by Kirby - v"
       MODULE_VERSION " " (new Date) "*/\n\n"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileCode "" [codeStr fname srcMap?]
  (var indent (- tabspace)
       EXTERNS {}
       NSPACES []
       outNode (transpileTree
                 (.parser psr codeStr fname) (.globalEnv rt))
       extra (spitExterns))
  (.prepend outNode (banner))
  (if srcMap?
    (let [outFile (str (.basename path fname ".ky") ".js")
          srcMap (str outFile ".map")
          output (.toStringWithSourceMap outNode
                                         {:file outFile})]
      (.writeFileSync fs srcMap output.map)
      (str output.code
           extra
           "\n//# sourceMappingURL="
           (.relative path (.dirname path fname) srcMap)))
    (str outNode extra)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- transpileXXX "" [code file smap?]
  (try
    (transpileCode code file smap?)
    (catch e
      (std.println e.stack)
      (throw e))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn transpileWithSrcMap "" [code file] (transpileXXX code file true))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn transpile "" [code file] (transpileXXX code file false))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn parseWithSourceMap "" [codeStr fname]
  (var outNode (transpileTree (.parser psr codeStr fname)))
  (.prepend outNode (banner))
  (.toStringWithSourceMap outNode))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(def version MODULE_VERSION)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

