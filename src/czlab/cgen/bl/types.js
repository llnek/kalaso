/*Auto generated by Kirby - v1.0.0 Mon Oct 09 2017 00:57:53 GMT+0800 (HKT)*/

var std= require("./stdlib");
;
//
function wrap_str(s) {
return ["\"",s.replace(new RegExp("\\\\","g"),"\\\\").replace(new RegExp("\"","g"),"\\\"").replace(new RegExp("\n","g"),"\\n"),"\""].join("");
}

//
function unwrap_str(s) {
return ((s.startsWith("\"")&&s.endsWith("\"")) ?
  s.slice(1,eindex(s)).replace(new RegExp("\\\\\"","g"),"\"").replace(new RegExp("\\\\n","g"),"\n").replace(new RegExp("\\\\\\\\","g"),"\\") :
  s);
}

//
function pr_obj(obj,readable_QUERY) {
let _r = (readable_QUERY||true),
  ot = obj_type(obj);
return (function() { let ____x;
switch (ot) {
case "list":
____x= ["(",std.map(function (e) {
return pr_obj(e,_r);
},obj).join(" "),")"].join("");
break;
case "vector":
____x= ["[",std.map(function (e) {
return pr_obj(e,_r);
},obj).join(" "),"]"].join("");
break;
case "hash-map":
____x= ["{",std.map(function (e) {
return pr_obj(e,_r);
},obj).join(" "),"}"].join("");
break;
case "object":
____x= ["{",std.reduce(function (acc,k) {
acc.push(pr_obj(k,_r),pr_obj(obj[k],_r));
return acc;
},[],std.keys(obj)),"}"].join("");
break;
case "string":
____x= ((false&&_r) ?
  wrap_str(obj) :
  obj);
break;
case "null":
case "nil":
____x= "null";
break;
case "atom":
____x= ["(atom ",pr_obj(obj.value,_r),")"].join("");
break;
case "keyword":
____x= [":",obj.value].join("");
break;
default:
____x= obj.toString();
break;
}
return ____x;}).call(this);
}

//
function obj_type(obj) {
return (keyword_QUERY(obj) ?
  "keyword" :
  (symbol_QUERY(obj) ?
    "symbol" :
    (list_QUERY(obj) ?
      "list" :
      (vector_QUERY(obj) ?
        "vector" :
        ((Object.prototype.toString.call(obj) === "[object Object]") ?
          "object" :
          (map_QUERY(obj) ?
            "hash-map" :
            (std.nil_QUERY(obj) ?
              "null" :
              (std.true_QUERY(obj) ?
                "true" :
                (std.false_QUERY(obj) ?
                  "false" :
                  (atom_QUERY(obj) ?
                    "atom" :
                    (std.fn_QUERY(obj) ?
                      "function" :
                      (std.string_QUERY(obj) ?
                        "string" :
                        (std.number_QUERY(obj) ?
                          "number" :
                          (true ?
                            std.raise("Unknown type '",typeof(obj),"'") :
                            null))))))))))))));
}

//
function sequential_QUERY(arr) {
return (list_QUERY(arr)||vector_QUERY(arr));
}

//
function eq_QUERY(a,b) {
let ota = obj_type(a),
  otb = obj_type(b);
return (((ota === otb)||(sequential_QUERY(a)&&sequential_QUERY(b))) ?
  (function() { let ____x;
switch (ota) {
case "symbol":
____x= (a.value === b.value);
break;
case "hash-map":
case "list":
case "vector":
____x= (function (i,ok_QUERY) {
  ((a.length !== b.length) ?
    ok_QUERY = false :
    null);
  (function () {
for ( i = 0; (ok_QUERY&&(i < a.length)); i = (i+1)) {
        (eq_QUERY(a[i],b[i]) ?
      null :
      ok_QUERY = false);
;
  }
}).call(this);
  return ok_QUERY;
  })(0,true);
break;
case "object":
____x= (function (ks,ok_QUERY) {
  ((count(a) === count(b)) ?
    null :
    ok_QUERY = false);
  (function () {
for (var i = 0,k = null; (ok_QUERY&&(i < ks.length)); i = (i+1)) {
        k = ks[i];
    (eq_QUERY(a[k],b[k]) ?
      null :
      ok_QUERY = false);
;
  }
}).call(this);
  return ok_QUERY;
  })(std.keys(a),true);
break;
default:
____x= (a === b);
break;
}
return ____x;}).call(this) :
  false);
}

//
function clone(obj) {
return (function (ret) {
(function() { let ____x;
switch (obj_type(obj)) {
case "list":
____x= ret = std.slice(obj);
break;
case "vector":
____x= (function() {
ret = std.slice(obj);
return ret["__isvector__"] = true;
}).call(this);
break;
case "hash-map":
____x= (function() {
ret = std.slice(obj);
return ret["__ismap__"] = true;
}).call(this);
break;
case "object":
____x= (function() {
ret = {};
return std.reduce(function (acc,n) {
acc[n] = obj[n];
return acc;
},ret,std.keys(obj));
}).call(this);
break;
case "function":
____x= ret = obj.clone();
break;
default:
____x= std.raise("clone of non-collection: ",obj_type(obj));
break;
}
return ____x;}).call(this);
Object.defineProperty(ret,"__meta__",{
  "enumerable": false,
  "writable": true
});
return ret;
})(null);
}

//
function Keyword(name) {
this.value = name.slice(1);
return this;
}

//
function Symbol(name) {
this.value = name;
return this;
}

//
Symbol.prototype.toString = function () {
return this.value;
}

//
function symbol(name) {
return new Symbol(name);
}

//
function symbol_QUERY(obj) {
return (obj instanceof Symbol);
}

//
function symbol_s(s) {
return (symbol_QUERY(s) ?
  s.value :
  (s ?
    s.toString() :
    ""));
}

//
Keyword.prototype.toString = function () {
return this.value;
}

//
function keyword(name) {
return new Keyword(name);
}

//
function keyword_QUERY(obj) {
return (obj instanceof Keyword);
}

//
function keyword_s(k) {
return (keyword_QUERY(k) ?
  k.value :
  (k ?
    k.toString() :
    ""));
}

//
function fn_wrap(run,Env,ast,env,params) {
return (function (f) {
f["_ismacro_"] = false;
f["__meta__"] = null;
f["__ast__"] = ast;
f["__gen_env__"] = function (args) {
return new Env(env,params,args);
};
return f;
})(function () {
return run(ast,new Env(env,params,arguments));
});
}

//
Function.prototype.clone = function () {
let that = this;
return (function (tmp) {
std.each_key(function (k) {
return tmp[k] = that[k];
},that);
return tmp;
})(function () {
return that.apply(this,arguments);
});
}

//
function list() {
let xs=Array.prototype.slice.call(arguments,0);
return xs;
}

//
function list_QUERY(obj) {
return (std.array_QUERY(obj)&&(!obj.__isvector__)&&(!obj.__ismap__));
}

//
function vector() {
let xs=Array.prototype.slice.call(arguments,0);
xs["__isvector__"] = true;
return xs;
}

//
function vector_QUERY(obj) {
return (std.array_QUERY(obj)&&(true === obj.__isvector__));
}

//
function map_QUERY(obj) {
return (std.array_QUERY(obj)&&(true === obj.__ismap__));
}

//
function hashmap() {
let xs=Array.prototype.slice.call(arguments,0);
((1 === mod(xs.length,2)) ?
  std.raise("Odd number of hash map arguments") :
  null);
return assoc.apply(this,concat([
  {}
],xs));
}

//
function object_QUERY(m) {
return (std.object_QUERY(m)&&(!(m instanceof Atom))&&(!(m instanceof Symbol))&&(!(m instanceof Keyword)));
}

//
function assoc(m) {
((1 !== mod(arguments.length,2)) ?
  std.raise("Odd number of assoc arguments") :
  null);
(function () {
for (var i = 1,k = null,v = null; (i < arguments.length); i = (i+2)) {
    k = arguments[i];
  v = arguments[(i+1)];
  (std.string_QUERY(k) ?
    null :
    std.raise("expected string, got: ",typeof(k)));
  m[k] = v;
;
}
}).call(this);
return m;
}

//
function dissoc(m) {
(function () {
for (var i = 1; (i < arguments.length); i = (i+1)) {
    delete m;
;
}
}).call(this);
return m;
}

//
function Atom(val) {
return this.value = val;
}

//
function atom(val) {
return new Atom(val);
}

//
function atom_QUERY(atm) {
return (atm instanceof Atom);
}



module.exports = {
  wrap_str: wrap_str,
  unwrap_str: unwrap_str,
  pr_obj: pr_obj,
  obj_type: obj_type,
  sequential_QUERY: sequential_QUERY,
  eq_QUERY: eq_QUERY,
  clone: clone,
  Keyword: Keyword,
  Symbol: Symbol,
  symbol: symbol,
  symbol_QUERY: symbol_QUERY,
  symbol_s: symbol_s,
  keyword: keyword,
  keyword_QUERY: keyword_QUERY,
  keyword_s: keyword_s,
  fn_wrap: fn_wrap,
  list: list,
  list_QUERY: list_QUERY,
  vector: vector,
  vector_QUERY: vector_QUERY,
  map_QUERY: map_QUERY,
  hashmap: hashmap,
  object_QUERY: object_QUERY,
  assoc: assoc,
  dissoc: dissoc,
  Atom: Atom,
  atom: atom,
  atom_QUERY: atom_QUERY
};

