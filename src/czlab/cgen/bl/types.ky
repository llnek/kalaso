;; Copyright (c) 2013-2017, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author "Kenneth Leung"}
  czlab.kirby.types
  (require ["./stdlib" :as std]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn wrap-str "" [s]
  (str "\""
       (-> (.replace s (regex "\\\\" "g") "\\\\")
           (.replace (regex "\"" "g") "\\\"")
           (.replace (regex "\n" "g") "\\n")) "\""))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn unwrap-str "" [s]
  (if (and (.startsWith s "\"")
           (.endsWith s "\""))
    (-> (.slice s 1 (eindex s))
        (.replace (regex "\\\\\"" "g") "\"")
        (.replace (regex "\\\\n" "g") "\n")
        (.replace (regex "\\\\\\\\" "g") "\\")) s))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn pr-obj "" [obj readable?]
  (var _r (or readable? true)
       ot (obj-type obj))
  (case ot
    "list"
    (str "("
         (-> (std.map (fn [e]
                        (pr-obj e _r)) obj)(.join " ")) ")")
    "vector"
    (str "["
         (-> (std.map (fn [e]
                        (pr-obj e _r)) obj)(.join " ")) "]")
    "hash-map"
    (str "{"
         (-> (std.map (fn [e]
                        (pr-obj e _r)) obj)(.join " ")) "}")
    "object"
    (str "{"
         (std.reduce
           (fn [acc k]
             (.push acc
                    (pr-obj k _r)
                    (pr-obj (nth obj k) _r)) acc)
           []
           (std.keys obj)) "}")
    "string"
    (if (and false _r) (wrap-str obj) obj)
    ("null" "nil") "null"
    "atom"
    (str "(atom " (pr-obj (.-value obj) _r)  ")")
    "keyword"
    (str ":" (.-value obj))
    ;else
    (.toString obj)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn obj-type "" [obj]
  (cond
    (keyword? obj) "keyword"
    (symbol? obj) "symbol"
    (list? obj) "list"
    (vector? obj) "vector"
    (object? obj) "object"
    (map? obj) "hash-map"
    (std.nil? obj) "null"
    (std.true? obj) "true"
    (std.false? obj) "false"
    (atom? obj) "atom"
    (std.fn? obj) "function"
    (std.string? obj) "string"
    (std.number? obj) "number"
    :else
    (std.raise "Unknown type '" (type obj) "'")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn sequential? "" [arr] (or (list? arr) (vector? arr)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn eq? "" [a b]
  (var ota (obj-type a)
       otb (obj-type b))
  (if-not (or (= ota otb)
              (and (sequential? a) (sequential? b)))
    false
    (case ota
      "symbol" (= (.-value a)(.-value b))
      ("hash-map" "list" "vector")
      (let [i 0 ok? true]
        (if (not= (alen a) (alen b)) (set! ok? false))
        (for ((i 0) (and ok?
                         (< i (alen a))) (i (inc i)))
          (if-not (eq? (nth a i) (nth b i)) (set! ok? false)))
        ok?)
    "object"
    (let [ks (std.keys a) ok? true]
      (if-not (= (count a) (count b)) (set! ok? false))
      (forlet ((i 0 k nil)
               (and ok?
                    (< i (alen ks))) (i (inc i)))
        (set! k (nth ks i))
        (if-not (eq? (get a k) (get b k))
          (set! ok? false)))
      ok?)
    ;else
    (= a b))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn clone "" [obj]
  (do-with [ret nil]
    (case (obj-type obj)
      "list"
      (set! ret (std.slice obj))
      "vector"
      (do (set! ret (std.slice obj))
          (set! ret :__isvector__ true))
      "hash-map"
      (do (set! ret (std.slice obj))
          (set! ret :__ismap__ true))
      "object"
      (do (set! ret {})
          (std.reduce
            (fn [acc n] (set! acc n (get obj n)) acc)
            ret (std.keys obj)))
      "function"
      (set! ret (.clone obj))
      ;else
      (std.raise "clone of non-collection: " (obj-type obj)))
    (Object.defineProperty ret
                           "__meta__"
                           { :enumerable false
                            :writable true })))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn Keyword "" [name]
  (set! this.value (.slice name 1)) this)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn Symbol "" [name] (set! this.value name) this)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn Symbol.prototype.toString "" [] (.-value this))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn symbol "" [name] (new Symbol name))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn symbol? "" [obj] (inst? Symbol obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn symbol-s "" [s]
  (if (symbol? s)
    (.-value s)
    (if s (.toString s) "")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn Keyword.prototype.toString "" [] (.-value this))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn keyword "" [name] (new Keyword name))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn keyword? "" [obj] (inst? Keyword obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn keyword-s "" [k]
  (if (keyword? k)
    (.-value k)
    (if k
      (.toString k) "")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn fn-wrap "" [run Env ast env params]
  (do-with [f (fn []
                (run ast (new Env env params arguments)))]
    (set! f :_ismacro_ false)
    (set! f :__meta__ nil)
    (set! f :__ast__ ast)
    (set! f :__gen_env__  (fn [args]
                            (new Env env params args)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn Function.prototype.clone "" []
  (var that this)
  (do-with [tmp (fn []
                  (.apply that this arguments))]
    (std.each-key
      (fn [k] (set! tmp k (get that k))) that)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn list "" [&xs] xs)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn list? "" [obj]
  (and (std.array? obj)
       (not obj.__isvector__) (not obj.__ismap__)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn vector "" [&xs]
  (set! xs :__isvector__ true) xs)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn vector? "" [obj]
  (and (std.array? obj)
       (true? obj.__isvector__)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn map? "" [obj]
  (and (std.array? obj)
       (true? obj.__ismap__)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn hashmap "" [&xs]
  (if (= 1 (mod (alen xs) 2))
    (std.raise "Odd number of hash map arguments"))
  (->> (concat [{}] xs)
       (.apply assoc this )))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn object? "" [m]
  (and (std.object? m)
       (not (inst? Atom m))
       (not (inst? Symbol m))
       (not (inst? Keyword m))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn assoc "" [m]
  (if (not= 1 (mod (alen arguments) 2))
    (std.raise "Odd number of assoc arguments"))
  (forlet ((i 1 k nil v nil)
           (< i (alen arguments)) (i (+ i 2)))
    (set! k (nth arguments i))
    (set! v (nth arguments (inc i)))
    (if-not (std.string? k)
      (std.raise "expected string, got: " (type k)))
    (set! m k v))
  m)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn dissoc "" [m]
  (forlet ((i 1) (< i (alen arguments)) (i (inc i)))
    (delete! m (nth arguments i)))
  m)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn Atom "" [val] (set! this.value val))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn atom "" [val] (new Atom val))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn atom? "" [atm] (inst? Atom atm))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

