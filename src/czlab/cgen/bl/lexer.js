/*Auto generated by Kirby - v1.0.0 Mon Oct 09 2017 01:49:26 GMT+0800 (HKT)*/

var tn= require("./tnode");
var std= require("./stdlib");
;
var tnode = tn.tnode,
  tnodeEx = tn.tnodeEx;
var REGEX = {
  "noret": new RegExp("^def\\b|^var\\b|^set!\\b|^throw\\b"),
  "id": new RegExp("^[a-zA-Z_$][.?\\-*!0-9a-zA-Z_'<>#@$]*$"),
  "id2": new RegExp("^[*\\-][.?\\-*!0-9a-zA-Z_'<>#@$]+$"),
  "float": new RegExp("^[-+]?[0-9]+\\.[0-9]+$"),
  "int": new RegExp("^[-+]?[0-9]+$"),
  "hex": new RegExp("^[-+]?0x"),
  "macroGet": new RegExp("^#slice@(\\d+)"),
  "dquoteHat": new RegExp("^\""),
  "dquoteEnd": new RegExp("\"$"),
  "func": new RegExp("^function\\b"),
  "query": new RegExp("\\?","g"),
  "bang": new RegExp("!","g"),
  "dash": new RegExp("-","g"),
  "quote": new RegExp("'","g"),
  "hash": new RegExp("#","g"),
  "at": new RegExp("@","g"),
  "less": new RegExp("<","g"),
  "greater": new RegExp(">","g"),
  "star": new RegExp("\\*","g"),
  "wspace": new RegExp("\\s")
};
//
function testid_QUERY(name) {
return (REGEX.id.test(name)||REGEX.id2.test(name));
}

//
function jsid(name) {
let pfx = "";
((std.string_QUERY(name)&&("-" === name.charAt(0))) ?
    (function() {
  pfx = "-";
  return name = name.slice(1);
  }).call(this) :
  null);
return (testid_QUERY(name) ?
  [pfx,name].join("").replace(REGEX.query,"_QUERY").replace(REGEX.bang,"_BANG").replace(REGEX.dash,"_").replace(REGEX.quote,"_QTE").replace(REGEX.hash,"_HASH").replace(REGEX.at,"_AT").replace(REGEX.less,"_LT").replace(REGEX.greater,"_GT").replace(REGEX.star,"_STAR") :
  ((pfx === "") ?
    name :
    [pfx,name].join("")));
}

//
function tokenize(source,fname) {
let len = source.length,
  token = "",
  line = 1,
  tcol = 0,
  col = 0,
  pos = 0,
  ch = null,
  nx = null,
  esc_QUERY = false,
  str_QUERY = false,
  comment_QUERY = false;
return (function (tree) {
let toke = function (ln,col,s,s_QUERY) {
((s_QUERY||std.not_empty(s)) ?
  tree.push(tnode(fname,ln,col,s,s)) :
  null);
return "";
};
(function () {
for (;(pos < len);) {
    ch = source.charAt(pos);
  ++col;
  ++pos;
  nx = source.charAt(pos);
  ((ch === "\n") ?
        (function() {
    col = 0;
    ++line;
    return (comment_QUERY ?
      comment_QUERY = false :
      null);
    }).call(this) :
    null);
  (comment_QUERY ?
    null :
    (esc_QUERY ?
            (function() {
      esc_QUERY = false;
      return token += ch;
      }).call(this) :
      ((ch === "\"") ?
        (str_QUERY ?
                    (function() {
          str_QUERY = false;
          token += ch;
          return token = toke(line,tcol,token,true);
          }).call(this) :
                    (function() {
          tcol = col;
          str_QUERY = true;
          return token += ch;
          }).call(this)) :
        (str_QUERY ?
                    (function() {
          ((ch === "\n") ?
            ch = "\\n" :
            null);
          ((ch === "\\") ?
            esc_QUERY = true :
            null);
          return token += ch;
          }).call(this) :
          (((ch === "'")||(ch === "`")||(ch === "@")||(ch === "^")) ?
            ((std.empty_QUERY(token)&&(!REGEX.wspace.test(nx))) ?
                            (function() {
              tcol = col;
              return toke(line,tcol,ch);
              }).call(this) :
              token += ch) :
            (((ch === "&")&&(nx === "&")) ?
                            (function() {
              (std.empty_QUERY(token) ?
                tcol = col :
                null);
              token += [ch,nx].join("");
              return ++pos;
              }).call(this) :
              ((ch === "~") ?
                ((std.empty_QUERY(token)&&(!REGEX.wspace.test(nx))) ?
                                    (function() {
                  tcol = col;
                  return ((nx === "@") ?
                                        (function() {
                    ++pos;
                    return toke(line,tcol,"~@");
                    }).call(this) :
                    toke(line,tcol,ch));
                  }).call(this) :
                  token += ch) :
                (((ch === "[")||(ch === "]")||(ch === "{")||(ch === "}")||(ch === "(")||(ch === ")")) ?
                                    (function() {
                  token = toke(line,tcol,token);
                  tcol = col;
                  return toke(line,tcol,ch);
                  }).call(this) :
                  ((ch === ";") ?
                                        (function() {
                    token = toke(line,tcol,token);
                    tcol = col;
                    return comment_QUERY = true;
                    }).call(this) :
                    (((ch === ",")||REGEX.wspace.test(ch)) ?
                      (function (n) {
                      ((ch === "\n") ?
                        n = (line-1) :
                        null);
                      return token = toke(n,tcol,token);
                      })(line) :
                      (true ?
                                                (function() {
                        (std.empty_QUERY(token) ?
                          tcol = col :
                          null);
                        return token += ch;
                        }).call(this) :
                        null)))))))))));
;
}
}).call(this);
return tree;
})([]);
}



module.exports = {
  REGEX: REGEX,
  testid_QUERY: testid_QUERY,
  jsid: jsid,
  tokenize: tokenize
};

