/*Auto generated by Kirby - v1.0.0 Mon Oct 09 2017 18:03:13 GMT+0800 (HKT)*/

var types= require("./types");
var std= require("./stdlib");
var rdr= require("./lexer");
;
//
function throwE(token,msg) {
return std.raise((token ?
  [msg,"\nnear line ",token.line,"\nin file ",token.source].join("") :
  [msg,"\nnear EOF "].join("")));
}

//
function nextToken(tokens) {
return (function (t) {
++tokens.pos;
return t;
})(tokens[tokens.pos]);
}

//
function peekToken(tokens) {
return tokens[tokens.pos];
}

//
function copyTokenData(token,node) {
(std.object_QUERY(node) ?
    (function() {
  node.source = token.source;
  node.line = token.line;
  return node.column = token.column;
  }).call(this) :
  null);
return node;
}

//
function readAtom(tokens) {
let ret = null,
  tn = "",
  token = nextToken(tokens);
(token ?
  tn = token.name :
  null);
(std.empty_QUERY(tn) ?
  ret = undefined :
  (rdr.REGEX.float.test(tn) ?
    ret = parseFloat(tn) :
    ((rdr.REGEX.hex.test(tn)||rdr.REGEX.int.test(tn)) ?
      ret = parseInt(tn) :
      ((tn.startsWith("\"")&&tn.endsWith("\"")) ?
        ret = tn :
        (tn.startsWith(":") ?
          ret = types.keyword(tn) :
          ((("nil" === tn)||("null" === tn)) ?
            ret = null :
            (("true" === tn) ?
              ret = true :
              (("false" === tn) ?
                ret = false :
                (true ?
                  ret = types.symbol(tn) :
                  null)))))))));
return copyTokenData(token,ret);
}

//
function readBlock(tokens,head,tail) {
let token = nextToken(tokens),
  ok_QUERY = true,
  ret = null,
  tn = "",
  cur = null;
(token ?
  tn = token.name :
  null);
((tn !== head) ?
  throwE(token,["expected '",head,"'"].join("")) :
  null);
return (function (ast) {
cur = peekToken(tokens);
(function () {
for (;ok_QUERY;) {
    ((std.nichts_QUERY(cur)||(tail === cur.name)) ?
    (cur ?
      copyTokenData(token,ast) :
      throwE(cur,["expected '",tail,"', got EOF"].join(""))) :
    ok_QUERY = false);
  (ok_QUERY ?
        (function() {
    addAst(ast,readTokens(tokens));
    return cur = peekToken(tokens);
    }).call(this) :
    null);
;
}
}).call(this);
nextToken(tokens);
return ast;
})([]);
}

//
function readList(cur,tokens) {
return readBlock(tokens,"(",")");
}

//
function readVector(cur,tokens) {
return (function (v) {
v["__isvector__"] = true;
return v;
})(readBlock(tokens,"[","]"));
}

//
function readObject(cur,tokens) {
return (function (v) {
v["__ismap__"] = true;
return v;
})(readBlock(tokens,"{","}"));
}

//
function skipAndParse(tokens,func) {
return copyTokenData(nextToken(tokens),func(tokens));
}

//
function readTokens(tokens) {
let tmp = null,
  token = peekToken(tokens);
return (std.nichts_QUERY(token) ?
  undefined :
  (function() { let ____x;
switch (token.name) {
case "'":
____x= skipAndParse(tokens,function () {
  return [
    types.symbol("quote"),
    readTokens(tokens)
  ];
  });
break;
case "`":
____x= skipAndParse(tokens,function () {
  return [
    types.symbol("quasiquote"),
    readTokens(tokens)
  ];
  });
break;
case "~":
____x= skipAndParse(tokens,function () {
  return [
    types.symbol("unquote"),
    readTokens(tokens)
  ];
  });
break;
case "~@":
____x= skipAndParse(tokens,function () {
  return [
    types.symbol("splice-unquote"),
    readTokens(tokens)
  ];
  });
break;
case "^":
____x= skipAndParse(tokens,function () {
  tmp = readTokens(tokens);
  return [
    types.symbol("with-meta"),
    readTokens(tokens),
    tmp
  ];
  });
break;
case "@":
____x= skipAndParse(tokens,function () {
  return [
    types.symbol("deref"),
    readTokens(tokens)
  ];
  });
break;
case ")":
____x= throwE(token,"unexpected ')'");
break;
case "(":
____x= readList(token,tokens);
break;
case "]":
____x= throwE(token,"unexpected ']'");
break;
case "[":
____x= readVector(token,tokens);
break;
case "}":
____x= throwE(token,"unexpected '}'");
break;
case "{":
____x= readObject(token,tokens);
break;
case ";":
case ",":
____x= (function (G__1) {
  nextToken(tokens);
  return G__1;
  })(undefined);
break;
default:
____x= readAtom(tokens);
break;
}
return ____x;}).call(this));
}

//
function addAst(ast,f) {
((typeof(f) === "undefined") ?
  null :
  ast.push(f));
return ast;
}

//
function parser(source,fname) {
let tokens = rdr.lexer(source,(fname||"**adhoc**")),
  f = null,
  ast = [],
  tlen = tokens.length;
tokens.pos = 0;
return (function (ast) {
;
(function () {
for (;(tokens.pos < tlen);) {
    addAst(ast,readTokens(tokens));
;
}
}).call(this);
return ast;
})([]);
}

//
function dumpTree(tree) {
let indent = (arguments[1]||0),
  pad = " ".repeat(indent);
return (function () {
for (var i = 0; (i < tree.length); i = (i+1)) {
    std.println(types.pr_obj(tree[i]));
;
}
}).call(this);
}



module.exports = {
  parser: parser,
  dumpTree: dumpTree
};

