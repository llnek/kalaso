;; Copyright (c) 2013-2017, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author "Kenneth Leung"}

  czlab.kirby.rt.toolkit

  (require ["fs" :as fs])
  (require ["../bl/stdlib"
            :as std
            :refer [extendAttr
                    stringify
                    contains?
                    LambdaArg
                    Keyword
                    not-empty
                    object?
                    Symbol
                    into!
                    prn
                    Atom
                    symbol
                    swap!
                    atom
                    vector
                    vector?
                    list?
                    map?
                    some?
                    typeid
                    sequential?]]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- prstrX
  "" [b arr] (map (fn [x] (prn x b)) arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro prstrT
  "" [arr] `(prstrX true ~arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro prstrF
  "" [arr] `(prstrX false ~arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn Function.prototype.clone "" []
  (var that this tmp nil)
  (set! tmp #(apply that this ____args))
  (each-key
    (fn [v k] (set-in! tmp k v)) that)
  tmp)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- prnStr
  "" [&xs] (join " " (prstrT xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- prnLn
  "" [&xs] (each #(println %) (prstrT xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- slurp
  "" [f] (fs/readFileSync f "utf-8"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- clone "" [obj]
  (var ret nil oid (typeid obj))
  (case oid
    (:vector :map :list)
    (set! ret (into! oid (slice obj)))
    :array
    (set! ret (slice obj))
    :object
    (set! ret
          (reduce
            (fn [acc en]
              (set-in! acc
                       (1st en) (last en)) acc)
            {}
            (seq obj)))
    :function
    (set! ret (obj.clone))
    ;else
    (raise! "clone of non-collection: " oid )))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- cons "" [a b] (concat [a] b))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- conj "" [arr & xs]
  (cond
    (list? arr) (into! :list
                       (concat (xs.reverse) arr))
    (some? arr) (into! :vector (concat arr xs))
    :else arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- seq "" [obj]
  (cond
    (array? obj)
    (if (not-empty obj) (slice obj))
    (string? obj)
    (if (not-empty obj) (obj.split ""))
    (nil? obj)
    nil
    :else
    (raise! "seq: called on non-sequence")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fapply "" [f & xs] (f.apply this xs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fmap "" [f arr] (map f arr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- GLOBAL (if (undef? window) undefined  window))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- resolveJS "" [s]
  [(if (contains? s ".")
     (-> (.exec /^(.*)\.[^\.]*$/g s)
         (nth 1) (eval))
     GLOBAL)
   (eval s)])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- filterJS "" [obj]
  (var s (stringify obj))
  (if (not-empty s) (JSON/parse s)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- withMeta "" [obj m]
  (var ret (clone obj))
  (set-in! ret :____meta m) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- meta "" [obj]
  (if-not (or (array? obj)
              (object? obj)
              (fn? obj))
    (raise! "can't get metadata from: " (typeid obj)))
  (get obj :____meta))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- evalJS "" [s]
  (filterJS (eval (s.toString))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- invokeJS "" [method & xs]
  (var [obj f] (resolveJS method))
  (filterJS (apply f obj xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set! module.exports {

  "is-same?"  (fn [a b] (== a b))
  "is-nil?"  (fn [x] (nil? x))

  "obj-type*"  std/typeid
  "gensym*"  std/gensym
  "is-eq?"  std/eq?
  "is-some?"  std/some?

  "slice*"  (fn [arr & xs]
              (Array.prototype.slice.apply arr xs))

  "throw*"  (fn [&xs]
              (throw (new Error (.join xs ""))))

  "#f?"  (fn [x] (false? x))
  "#t?"  (fn [x] (true? x))
  "is-str?"  (fn [x] (string? x))

  "is-keyword?"  std/keyword?
  "is-symbol?"  std/symbol?
  "keyword*"  std/keyword
  "symbol*"  std/symbol

  "println*"  prnLn
  "prn*"  prnStr

  "slurp*"  slurp

  "<"   (fn [a b] (< a b))
  "<="  (fn [a b] (<= a b))
  ">"   (fn [a b] (> a b))
  ">="  (fn [a b] (>= a b))
  "+"   (fn [a b] (+ a b))
  "-"   (fn [a b] (- a b))
  "*"   (fn [a b] (* a b))
  "/"   (fn [a b] (div a b))

  "not=" (fn [a b] (not= a b))
  "=" (fn [a b] (= a b))

  "is-contains?" std/contains?

  "is-vector?"  std/vector?
  "is-list?"  std/list?
  "is-map?"  std/map?
  "hash-map*"  std/hashmap
  "vector*"  std/vector
  "list*"  std/list

  "values*"  (fn [x] (Object.values x))
  "keys*"  (fn [x] (Object.keys x))
  "get*"  (fn [m k] (get m k))

  "not*"  (fn [x] (if x #f #t))
  "dec*"  (fn [x] (-1 x))
  "inc*"  (fn [x] (+1 x))

  "is-even?"  (fn [n] (= 0 (mod n 2)))
  "is-odd?"  (fn [n]  (= 1 (mod n 2)))

  "is-sequential?"  std/sequential?
  "concat*"  std/concat*
  "count*"  std/count
  "cons*"  cons

  "rest*"  (fn [arr]
              (if arr (arr.slice 1) []))
  "nth*"  (fn [arr i] (get arr i))
  "first*"  (fn [arr] (get arr 0))

  "is-empty?" (fn [x] (= 0 (std/count x)))
  "not-empty*" std/not-empty

  "apply*"  fapply
  "map*"  fmap

  "evens" (fn [n] (= 0 (mod n 2)))
  "odds" (fn [n]  (= 1 (mod n 2)))
  "type*" (fn [x] (typeof x))

  "meta*"  meta
  "conj*"  conj
  "seq*"  seq

  "is-atom?"  std/atom?
  "atom*"  std/atom
  "deref*"  std/deref
  "reset*"  std/reset!
  "swap*"  std/swap!

  "with-meta*"  withMeta
  "js-eval*"  evalJS
  "js*"  invokeJS

})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

