/*Auto generated by Kirby - v1.0.0 czlab.kirby.rt.runtime - Wed Nov 22 2017 18:39:45 GMT+1100 (AEDT)*/

const readline= require("readline");
const parser= require("../bl/parser");
const std= require("../bl/stdlib");
const contains_QUERY=std["contains_QUERY"];
const keyword_QUERY=std["keyword_QUERY"];
const atom=std["atom"];
const into_BANG=std["into_BANG"];
const vector_QUERY=std["vector_QUERY"];
const vector=std["vector"];
const symbol_QUERY=std["symbol_QUERY"];
const symbol=std["symbol"];
const count=std["count"];
const pairs_QUERY=std["pairs_QUERY"];
const list_QUERY=std["list_QUERY"];
const map_QUERY=std["map_QUERY"];
const tree=std["tree"];
const seq=std["seq"];
const prn=std["prn"];
const not_DASH_empty=std["not_DASH_empty"];
const sequential_QUERY=std["sequential_QUERY"];
const rt= require("../rt/toolkit");
const env= require("../bl/env");
const LEXEnv=env["LEXEnv"];
const kirbystdlibref=std;
var loadedMacros_QUERY= false;
var CACHE= {};
//
const loadMacros = function () {
if ((!loadedMacros_QUERY)) {
{
loadedMacros_QUERY=true;
require("../bl/macros.ky");
};
};
return null;
};
//Register a new macro
const setMacro = function (cmd,func) {
if ((cmd&&func)) {
{
cmd=[
cmd
].join("");
if ((!contains_QUERY(cmd,"/"))) {
{
let c= global_env.peekNSP();
if ((!c)) {
throw new Error("missing namespace");
};
cmd=[
c,
"/",
cmd
].join("");
};
};
CACHE[cmd]=func;
};
};
return null;
};
//Get macro
const getMacro = function (cmd) {
let ret= null;
cmd=[
cmd
].join("");
if (contains_QUERY(cmd,"/")) {
ret=CACHE[cmd];
} else { 
{
let nsp= global_env.peekNSP();
if (nsp) {
ret=CACHE[[
nsp,
"/",
cmd
].join("")];
};
if ((!ret)) {
ret=CACHE[[
"czlab.kirby.bl.macros/",
cmd
].join("")];
};
};
};
return ret;
};
//
const wrap_DASH_str = function (s) {
return [
"\"",
s.replace(/\\/g,"\\\\").replace(/"/g,"\\\"").replace(/\n/g,"\\n"),
"\""
].join("");
};
//
const unwrap_DASH_str = function (s) {
return ((s.startsWith("\"")&&s.endsWith("\"")) ?
s.slice(1,(s.length-1)).replace(/\\"/g,"\"").replace(/\\n/g,"\n").replace(/\\\\/g,"\\") :
s);
};
//
const dbg = function (obj) {
return (console ?
console.log([
"DBG-RT: ",
prn(obj,true)
].join("")) :
null);
};
//Returns the AST
const readAST = function (s) {
let ret= parser.parser(s);
if ((1 === kirbystdlibref.count(ret))) {
ret=ret[0];
};
return ret;
};
//Returns true
//if a non-empty list
const isList_QUERY = function (x) {
return (sequential_QUERY(x)&&not_DASH_empty(x));
};
//
const quasiquote = function (ast) {
return ((!isList_QUERY(ast)) ?
[
symbol("quote"),
ast
] :
((symbol_QUERY(ast[0])&&(ast[0] == "unquote")) ?
ast[1] :
((isList_QUERY(ast[0])&&(ast[0][0] == "splice-unquote")) ?
[
symbol("concat*"),
ast[0][1],
quasiquote(ast.slice(1))
] :
(true ?
(function() {
let a0= ast[0];
let a1= ast.slice(1);
return [
symbol("cons*"),
quasiquote(a0),
quasiquote(a1)
];
}).call(this) :
null))));
};
//
const isMacroCall_QUERY = function (ast,env) {
return (pairs_QUERY(ast)&&symbol_QUERY(ast[0])&&getMacro([
ast[0]
].join("")));
};
//
const expandMacro = function (ast,env,mc) {
return mexpand(ast,env);
};
//
const mexpand = function (ast,env) {
let isM_QUERY= isMacroCall_QUERY(ast,env);
let mac= null;
let cmd= (isM_QUERY ?
ast[0] :
"");
for (let ____break=false;((!____break)&&isMacroCall_QUERY(ast,env)); ){
(cmd=[
ast[0]
].join(""),mac=getMacro(cmd),ast=mac.apply(mac,ast.slice(1)));
}
return ast;
};
//
const evalAst = function (ast,env) {
return (keyword_QUERY(ast) ?
[
"\"",
ast,
"\""
].join("") :
((typeof(ast) === "string") ?
unwrap_DASH_str(ast) :
(symbol_QUERY(ast) ?
env.get(ast) :
(pairs_QUERY(ast) ?
ast.map(function () {
let ____args= Array.prototype.slice.call(arguments);
return compute(____args[0],env);
}) :
(list_QUERY(ast) ?
into_BANG("list",ast.map(function () {
let ____args= Array.prototype.slice.call(arguments);
return compute(____args[0],env);
})) :
(vector_QUERY(ast) ?
into_BANG("vector",ast.map(function () {
let ____args= Array.prototype.slice.call(arguments);
return compute(____args[0],env);
})) :
((false&&map_QUERY(ast)) ?
seq(ast).reduce(function (acc,en) {
acc[compute(en[0],env)]=compute(last(en),env);
return acc;
},{}) :
(map_QUERY(ast) ?
(function() {
let m= {};
for (let i=0,sz=kirbystdlibref.count(ast),____break=false;((!____break)&&(i < sz)); i=(i+2)){
m[compute(ast[i],env)]=compute(ast[i+1],env);
}
return m;
}).call(this) :
(true ?
ast :
null)))))))));
};
//
const handleAND = function (ast,env) {
let ret= true;
for (let i=1,sz=kirbystdlibref.count(ast),____break=false;((!____break)&&(i < sz)); i=(i+1)){
ret=compute(ast[i],env);
if ((!ret)) {
____break=true;
};
}
return ret;
};
//
const handleOR = function (ast,env) {
let ret= null;
for (let i=1,sz=kirbystdlibref.count(ast),____break=false;((!____break)&&(i < sz)); i=(i+1)){
ret=compute(ast[i],env);
if (ret) {
____break=true;
};
}
return ret;
};
//
const handleLet = function (ast,env) {
let e= new LEXEnv(env);
let a1= ast[1];
for (let i=0,sz=kirbystdlibref.count(a1),____break=false;((!____break)&&(i < sz)); i=(i+2)){
e.set(a1[i],compute(a1[i+1],e));
}
return [
ast[2],
e
];
};
//
const handleMacro = function (ast,env) {
let rc= [
ast[0],
ast[1],
[
symbol("fn*"),
ast[2]
].concat(ast.slice(3))
];
let a2= rc[2];
let a1= rc[1];
let func= compute(a2,env);
func["____macro"]=true;
return env.set(a1,func);
};
//
const handleTry = function (ast,env) {
let a1= ast[1];
let a2= ast[2];
return (function(){
try {
return compute(a1,env);
}catch (ex) {
return ((a2&&("catch*" == a2[0])) ?
((ex instanceof Error) ?
ex=ex.message :
null) :
compute(a2[2],new LEXEnv(env,[
a2[1]
],[
ex
])));
}
}).call(this);
};
//
const handleIf = function (ast,env) {
let c= compute(ast[1],env);
let a2= ast[2];
let a3= ast[3];
return (((c === null)||(false === c)) ?
((!(typeof(a3) === "undefined")) ?
a3 :
null) :
a2);
};
//
const handleForm = function (ast,env) {
let el= evalAst(ast,env);
let f= el[0];
return (f.____ast ?
[
true,
f.____ast,
f.____genenv(el.slice(1))
] :
[
false,
f.apply(f,el.slice(1)),
env
]);
};
//
const fn_DASH_wrap = function (run,ast,env,params) {
let f= function () {
let ____args= Array.prototype.slice.call(arguments);
return run(ast,new LEXEnv(env,params,____args));
};
(f["____macro"]=false,f["____meta"]=null,f["____ast"]=ast,f["____genenv"]=function () {
let ____args= Array.prototype.slice.call(arguments);
return new LEXEnv(env,params,____args[0]);
});
return f;
};
//
const compute_STAR = function (ast,env) {
let ok_QUERY= true;
let ret= null;
for (let ____break=false;(!____break); ){
ast=mexpand(ast,env);
____break=((!Array.isArray(ast)) ?
(function() {
let G____6= true;
ret=evalAst(ast,env);
return G____6;
}).call(this) :
((0 === kirbystdlibref.count(ast)) ?
(function() {
let G____7= true;
ret=ast;
return G____7;
}).call(this) :
(("and*" == ast[0]) ?
(function() {
let G____8= true;
ret=handleAND(ast,env);
return G____8;
}).call(this) :
(("or*" == ast[0]) ?
(function() {
let G____9= true;
ret=handleOR(ast,env);
return G____9;
}).call(this) :
(("def*" == ast[0]) ?
(function() {
let G____10= true;
ret=env.set(a1,compute(a2,env));
return G____10;
}).call(this) :
(("let*" == ast[0]) ?
(function() {
let G____11= false;
let rc= handleLet(ast,env);
(ast=rc[0],env=rc[1]);
return G____11;
}).call(this) :
(("quote" == ast[0]) ?
(function() {
let G____12= true;
ret=ast[1];
return G____12;
}).call(this) :
(("quasiquote" == ast[0]) ?
(function() {
let G____13= false;
ast=quasiquote(ast[1]);
return G____13;
}).call(this) :
(("macro*" == ast[0]) ?
(function() {
let G____14= true;
ret=handleMacro(ast,env);
return G____14;
}).call(this) :
(("macroexpand" == ast[0]) ?
(function() {
let G____15= true;
ret=mexpand(ast[1],env);
return G____15;
}).call(this) :
(("try*" == ast[0]) ?
(function() {
let G____16= true;
ret=handleTry(ast,env);
return G____16;
}).call(this) :
(("do*" == ast[0]) ?
(function() {
let G____17= false;
evalAst(ast.slice(1,-1),env);
ast=ast[(ast.length-1)];
return G____17;
}).call(this) :
(("if*" == ast[0]) ?
(function() {
let G____18= false;
ast=handleIf(ast,env);
return G____18;
}).call(this) :
(("fn*" == ast[0]) ?
(function() {
let G____19= true;
ret=fn_DASH_wrap(compute,ast[2],env,ast[1]);
return G____19;
}).call(this) :
(true ?
(function() {
let rc= handleForm(ast,env);
let a1= rc[1];
let a2= rc[2];
return (rc[0] ?
(function() {
let G____20= false;
(ast=a1,env=a2);
return G____20;
}).call(this) :
(function() {
let G____21= true;
ret=a1;
return G____21;
}).call(this));
}).call(this) :
null)))))))))))))));
}
return ret;
};
//
const compute = function (ast,env) {
if ((!env)) {
env=global_env;
};
let ret= compute_STAR(ast,env);
return ((typeof(ret) === "undefined") ?
null :
ret);
};
//
const show = function (exp) {
return prn(exp);
};
//
const newEnv = function () {
let ret= new LEXEnv();
{
let G____22= rt;
Object.entries(G____22).forEach(function (e) {
return (function (v,k) {
return ret.set(symbol(k),v);
})(e[1],e[0]);
});
};
ret.set(symbol("eval"),function () {
let ____args= Array.prototype.slice.call(arguments);
return compute(____args[0],ret);
});
ret.set(symbol("*ARGV*"),[]);
ret.set(symbol("*host-language*"),"javascript");
ret.set(symbol("*gensym-counter*"),atom(0));
return ret;
};
const prefix= "kirby> ";
const run_repl= function () {
let rl= readline.createInterface(process.stdin,process.stdout);
rl.on("line",function (line) {
try {
if (line) {
if (console) {
console.log([
rep(line)
].join(""));
};
};
}catch (err) {
if (console) {
console.log([
err
].join(""));
};
}
rl.setPrompt(prefix,prefix.length);
return rl.prompt();
});
rl.on("close",function () {
if (console) {
console.log([
"Bye!"
].join(""));
};
return process.exit(0);
});
if (console) {
console.log([
prefix,
"Kirby REPL v1.0.0"
].join(""));
};
rl.setPrompt(prefix,prefix.length);
return rl.prompt();
};
const rep= function () {
let ____args= Array.prototype.slice.call(arguments);
return show(compute(readAST(____args[0])));
};
var global_env= new LEXEnv();
//
const runRepl = function () {
init();
return run_repl();
};
const macro_assert= "\n  (macro* assert* [c msg] (if* c true (throw* msg)))";
const macro_cond= "\n  (macro* cond* [&xs]\n    (if* (> (count* xs) 0)\n      (list* 'if*\n            (first* xs)\n            (nth* xs 1)\n            (cons* 'cond* (rest* (rest* xs))))))";
//
const init = function () {
global_env=newEnv();
global_env.set(symbol("*host-language*"),"javascript");
rep(macro_cond);
rep(macro_assert);
return loadMacros();
};
//
const globalEnv = function () {
return global_env;
};
module.exports = {
setMacro: setMacro,
getMacro: getMacro,
wrap_DASH_str: wrap_DASH_str,
unwrap_DASH_str: unwrap_DASH_str,
expandMacro: expandMacro,
compute: compute,
newEnv: newEnv,
runRepl: runRepl,
init: init,
globalEnv: globalEnv
};