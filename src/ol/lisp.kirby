
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- read [source]
  (reader.read_str str))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- pair? "" [obj]
  (and (sequential? obj)
       (> (count obj) 0)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- quasi-quote "" [ast]
  (cond
    (not (pair? ast))
    [(symbol "quote") ast]
    ;--
    (and (symbol? (car ast))
         (eq? "unquote" (car ast)))
    (nth ast 1)
    ;--
    (and (pair? (car ast))
         (symbol? (car (car ast)))
         (eq? "splice-unquote" (car (car ast))))
    [(symbol "concat")
     (nth (car ast) 1)
     (quasi-quote (slice ast 1))]
    :else
    [(symbol "cons")
     (quasi-quote (car ast))
     (quasi-quote (slice ast 1))]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- macro? "" [ast env]
  (and (list? ast)
       (symbol? (car ast))
       (.find env (car ast))
       (.-macro (.get env (car ast)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn macroexpand "" [ast env]
  (loop [env env
         ast ast]
    (if-not (macro? ast env)
      ast
      (let [m (.get env (car ast))]
        (recur env
               (apply m m (slice ast 1)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- evalAst "" [ast env]
  (cond
    (symbol? ast)
    (.get env ast)
    ;--
    (list? ast)
    (map (fn [a] (EVAL a env)) ast)
    ;--
    (vector? ast)
    (doto (map (fn [a]
                 (EVAL a env)) ast)
      (set! :eTYPE tkn-vector))
    ;--
    (map? ast)
    (reduce
      (fn [acc k]
        (set! acc
              (EVAL k env)
              (EVAL (get ast k) env))
        acc)
      {}
      (keys ast))
    :else ast))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- _EVAL [ast env]
  (var ret nil loop? true)
  (while loop?
    (if (list? ast)
      (set! ast (macroexpand ast env)))
    (set! loop? false)
    (set!
      ret
      (cond
        (not (list? ast))
        (evalAst ast env)
        (empty? ast)
        ast
        (case (.-value (nth ast 0))
          "def!"
          (.set env
                (nth ast 1)
                (EVAL (nth ast 2) env))
          "let*"
          (let [letenv (new Env env)
                a1 (nth ast 1)]
            (for ((i 0)(< i (alen a1))(i (+ i 2)))
              (.set letenv
                    (nth a1 i)
                    (EVAL (nth a1 (inc i)) letenv)))
            (set! ast (nth ast 2))
            (set! env letenv)
            (set! loop? true))
          "quote" (nth ast 1)
          "quasiquote"
          (do (set! ast (quasi-quote (nth ast 1)))
              (set! loop? true))
          "defmacro!"
          (let [func (EVAL (nth ast 2) env)]
            (set! func :macro true)
            (.set env (nth ast 1) func))
          "macroexpand"
          (macroexpand (nth ast 1) env)
          "try*"
          (let [a2 (nth ast 2)]
            (try
              (EVAL (nth ast 1) env)
              (catch ex
                (if (and a2
                         (eq? "catch*" (car a2)))
                  (EVAL (nth a2 2)
                        (new Env env [(nth a2 1)] [ex]))
                  (throw ex)))))
          "do"
          (do (evalAst (slice ast 1 -1) env)
              (set! ast (nth ast (dec (alen ast))))
              (set! loop? true))
          "if"
          (let [cond (EVAL (nth ast 1) env)
                a2 (nth ast 2)
                a3 (nth ast 3)]
            (if (or (nil? cond)
                    (false? cond))
              (set! ast
                    (if (undef? a3) null a3))
              (set! ast a2))
            (set! loop? true))
          "fn*"
          (_function EVAL Env (nth ast 2) env (nth ast 1))
          ;--
          (let [el (evalAst ast env)
                f (nth el 0)]
            (if (get f "____ast")
              (do (set! ast (get f "____ast"))
                  (set! env (.____genenv f (slice el 1)))
                  (set! loop? true))
              (.apply f f (slice el 1))))))))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- EVAL [ast env]
  (var ret (_EVAL ast env))
  (if (undef? ret) null ret))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- PRINT [expr]
    (pstr expr true))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(def repl_env (new Env))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn rep [str]
  (PRINT (EVAL (READ str) repl_env)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(each-key (fn [v k]
            (.set repl_env (symbol k) v)) core.exports)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(.set repl_env (symbol "*ARGV*") [])
(.set repl_env
      (symbol "eval")
      (fn [ast] (EVAL ast repl_env)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(rep "(def! *host-language* \"javascript\")")
(rep "(def! not (fn* (a) (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \")\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")
(rep "(def! *gensym-counter* (atom 0))")
(rep "(def! gensym (fn* [] (symbol (str \"G__\" (swap! *gensym-counter* (fn* [x] (+ 1 x)))))))")
(rep "(defmacro! or (fn* (& xs) (if (empty? xs) nil (if (= 1 (count xs)) (first xs) (let* (condvar (gensym)) `(let* (~condvar ~(first xs)) (if ~condvar ~condvar (or ~@(rest xs)))))))))")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(when (and (isdef? process)
           (> (alen process.argv) 2))
  (.set repl_env (symbol "*ARGV*")
        (slice process.argv 3))
  (rep "(load-file '" (nth process.argv 2) "')")
  (.exit process 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(when (and (isdef? require)
           (= module require.main))
  (rep "(println (str \"Mal [\" *host-language* \"]\"))")
  (var line nil stop? false)
  (while (not stop?)
    (set! line (.readline readline "user> "))
    (if (nil? line)
      (set! stop? true)
      (try
        (println (rep line))
        (catch ex
          (when-not (inst? BlankError)
            (if (.-stack ex)
              (println (.-stack ex))
              (println ex))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

