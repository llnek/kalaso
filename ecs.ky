;; Copyright (c) 2013-2018, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author "Kenneth Leung"}

  czlab.rygel.ecs

  (:require ["kirby"
             :as k
             :refer [atom merge swap! find
                     object? sort! some? nichts? conj!]]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createEngine
  "Create an engine, the core of ECS."
  []
  (atom {:entities {}
         :systems []
         :config {}
         :registry {}
         :updating? false}))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createSystem
  "Create a new system.  Each system must be provided with
  a user defined worker function and a priority value"
  [type priority worker]
  {:pre [(fn? worker)]}
  (atom {:update worker :typeId type
         :priority priority :active? #f}))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createComponent "" [type attrs]
  {:pre [(object? attrs)]}
  (atom (merge attrs {:typeId type :auto? #f :entity nil})))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createEntity "" [engine n]
  (var {:keys [entities]} @engine
       eid (generateEid)
       e (atom {:engine engine
                :eid eid
                :name n
                :bodyparts {}}))
  (assoc! entities eid e) e)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createPooledEntity "" [engine n take?]
  (var e (createEntity engine n))
  (if take? (takeEntity! e) e))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getEntities
  "Find all the entities inside this engine,
  which contains these component types"
  [engine & componentTypes]
  (var cmin Number.SAFE_MAX_INTEGER
       {:keys [entities
               registry]} @engine
       ret [] ccs [] missed? false)
  (var~ smallest c cid)
  ;;find smallest cache, do intersection
  (for [i 0 sz (n# componentTypes)
        :while (< i sz) :recur (+1 i)]
    ;does the engine know this component type,
    ;if so, find the collection
    (set! cid (.@i componentTypes)
          c (get registry cid))
    (cond
      (nichts? c)
      ;unknown so matching will be 0
      (do->break! (true! missed?))
      :else
      ;found it, keep track of it and
      ;if the size is smaller, point to it
      (let [cz (n# c)]
        (when (< cz cmin)
          (set! smallest c cmin cz))
        (conj! ccs c))))
  (when (and (not missed?)
             (not-empty ccs))
    (var sum 0
         ccsz (n# ccs))
    ;;use the smallest as baseline
    (each
      (fn [eid]
        (set! sum 0)
        ;;look for intersection
        (each #(if (or (= % smallest)
                       (contains? % eid)) (++ sum)) ccs)
        ;;if found in all caches means
        ;;this node(eid) has all the req'd components
        (if (= sum ccsz)
          (if-some [obj (get entities eid)] (conj! ret obj))))
      (keys smallest))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getAllEntities
  "Get all the entities inside this engine"
  [engine]
  (var {:keys [entities]} @engine) (values entities))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- *idAtom* (atom 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- generateEid "" []
  (str "e" (swap! *idAtom*
                  (fn [v]
                    (if-not (< v Number.SAFE_MAX_INTEGER)
                      (trap! "too many entities")) (+1 v)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn takeEntity! "" [entity]
  (swap! entity
         (fn [e] (assoc! e :status #t) e)) entity)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn dropEntity! "" [entity]
  (swap! entity
         (fn [e] (assoc! e :status #f) e)) entity)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn deleteEntity "" [entity]
  (dosync
    (var {:keys [engine eid]} @entity)
    (swap! engine (fn [e] (dissoc! e.entities eid) e))
    (swap! entity
           (fn [e]
             (assoc! e :dead? #t)
             (each-key
               (fn [v k]
                 (unbindComponent engine k entity)) e.bodyparts) e))) nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn deleteEntities
  "Get rid of all nodes" [engine]
  (swap! engine
         (fn [e] (assoc! e :entities {}) e)) nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn addSystem "" [engine system]
  (var {:keys [systems]} @engine
       ;high to low
       compFn (fn [s1 s2]
                (if (< s1.priority
                       s2.priority)
                  1
                  (if (> s1.priority
                         s2.priority) -1 0))))
  (conj! systems system)
  (sort! compfn systems) nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn deleteSystem "" [engine system]
  (var ret #f {:keys [systems]} @engine)
  (for [i 0 sz (n# systems)
        :while (< i sz) :recur (+1 i)]
    (when (= system (.@i systems))
      (.splice systems i 1)
      (true! ret)
      (break-out-of-loop!))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn deleteSystems "" [engine]
  (swap! engine (fn [e] (assoc! e :systems []) e)) nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn updateEngine "" [engine time]
  (swap! engine (fn [e] (assoc! e :updating? #t) e))
  (var {:keys [systems]} @engine)
  (var~ s)
  (for [i 0 sz (n# systems)
        :while (< i sz) :recur (+1 i)]
    (set! s (.@i systems))
    (when (get s :active?)
      (if-not (s.update time)
        (break-out-of-loop!))))
  (doHouseKeeping)
  (swap! engine (fn [e] (assoc! e :updating? #f) e)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn igniteEngine "" [engine initNodes initSystems]
  ((comp initSystems initNodes) engine)
  (var {:keys [systems]} @engine)
  (each (fn [s] (s.preamble)) systems) nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn doHouseKeeping "" [engine] nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getComCache "" [engine comType]
  (var {:keys [registry]} @engine) (get registry comType))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn unbindComponent "" [engine comType entity]
  (var eid (get @entity :eid))
  (swap! engine
         (fn [e]
           (if-some [m (get e.registry comType)]
             (dissoc! m eid)) e))
  nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn bindComponent "" [engine component entity]
  (var eid (get @entity :eid)
       cid (get @component :typeId))
  (swap! engine
         (fn [e]
           (var m (get e.registry cid))
           (when (nichts? m)
             (set! m {})
             (assoc! e.registry cid m))
           (assoc! m eid component) e))
  nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getSystem "" [engine systemType]
  (var {:keys [systems]} @engine)
  (find systems #(= (get % :typeId) systemType)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn addComponent "" [entity component]
  (dosync
    (swap! component (fn [c] (assoc! c :entity entity) c))
    (var cid (get @component :typeId))
    (assert (! (hasComponent? entity cid)) "Cannot add Component again")
    (bindComponent engine component entity)
    (swap! entity (fn [e] (assoc! e.bodyparts cid component) e))) nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn deleteComponent "" [entity comType]
  (swap! entity
         (fn [e]
           (dissoc! e.bodyparts comType)
           (unbindComponent e.engine comType entity) e)) nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getComponent
  "" [entity comType] (get (.-bodyparts @entity) comType))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getAllComponents
  "" [entity] (values (get @entity :bodyparts)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn hasComponent? "" [entity comType]
  (contains? (get @entity :bodyparts) comType))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createPool "" [own?]
  (atom {:cache [] :own? own? :batch 0}))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn presetPool
  "Pre-populate a bunch of objects in the pool"
  [pool ctor count]
  (swap! pool
         (fn [p]
           (dotimes [x count]
             (if-some [obj (ctor)]
               (conj! p.cache obj)))
           (assoc! p :ctor ctor :batch count) p)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn selectFromPool
  "Find an object by applying this filter" [pool sel]
  (var ret nil e nil
       {:keys [cache]} @pool)
  (for [i 0 sz (n# cache)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i cache))
    (when (sel e)
      (set! ret e) (break-out-of-loop!))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getFromPool
  "Get a free object from the pool.  More like a peek"
  [pool create?]
  (var ret nil e nil
       {:keys [batch cache ctor]} @pool)
  (for [i 0 sz (n# cache)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i cache))
    (when (get @e :status)
      (set! ret e)
      (break-out-of-loop!)))
  (cond
    (some? ret)
    ret
    (and create? ctor)
    (do (presetPool pool ctor batch)
        (getFromPool pool false))
    :else nil))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn takeFromPool
  "Get a free object from the pool and flag it as in-use"
  [pool create?]
  (var ret (getFromPool pool create?))
  (if ret
    (takeEntity! ret)) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn resetPool
  "Hibernate (status off) all objects in the pool" [pool]

  (swap! pool
         (fn [p]
           (each (fn [obj]
                   (swap! obj
                          (fn [e]
                            (assoc! e :status #f) e))) p.cache) p)))

