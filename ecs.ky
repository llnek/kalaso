(ns ^{:doc ""
      :author "Kenneth Leung"}
  czlab.rygel.ecs
  (:require ["kirby"
             :as k :refer [sort! some? nichts? conj!]]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn ctorEngine "" []
  {:systems []
   :nodes {}
   :types {}
   :updating? (atom false) })

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn ctorSystem "" [] {:typeId nil})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn ctorNode "" [engine n eid]
  {:engine engine :eid eid :name n})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn ctorComponent "" []
  {:typeId nil :auto #f :node nil})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getNodes
  "Find all the nodes inside this engine,
  which contains these component types"
  [engine & componentTypes]
  (var cmin Number.SAFE_MAX_INTEGER
       {:keys [nodes types]} engine
       ret []
       ccs []
       missed? #f)
  (var~ smallestCache c cid)
  ;;find shortest cache, doing an intersection
  (for [i 0 sz (n# componentTypes)
        :while (< i sz) :recur (+1 i)]
    ;does the engine know this component type,
    ;if so, find the collection
    (set! cid (.@i componentTypes)
          c (get types cid))
    (cond
      (nichts? c)
      ;unknown so matching will be 0
      (do->break! (true! missed?))
      :else
      ;found it, keep track of it and
      ;if the size is smaller, point to it
      (let [cz (n# c)]
        (when (< cz cmin)
          (set! smallestCache c cmin cz))
        (conj! ccs c))))
  (when (and (not missed?)
             (not-empty ccs))
    (var ccsz (n# ccs))
    ;;use the shortest cache as the baseline
    (each
      (fn [eid]
        (var sum 0)
        ;;look for intersection
        (each #(if (or (= % smallestCache)
                       (contains? % eid)) (++ sum)) ccs)
        ;;if found in all caches means
        ;;this node(eid) has all the req'd components
        (if (= sum ccsz)
          (if-some [obj (get nodes eid)] (conj! ret obj))))
      (keys smallestCache))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getNodes
  "Get all the nodes inside this engine"
  [engine]
  (var {:keys [nodes]} engine) (values nodes))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- *idAtom* (atom 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn generateEid "" []
  (swap! *idAtom*
         (fn [v]
           (if-not (< v Number.SAFE_MAX_INTEGER)
             (trap! "too many entities"))
           (+1 v))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn reifyNode "" [engine n take?]
  (var {:keys [nodes]} engine
       eid (generateEid)
       e (ctorNode engine n eid))
  (assoc! nodes eid e)
  (if take? (.take! e)) e)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn purgeNode "Get rid of this node" [engine node]
  (var eid (get node :eid)
       {:keys [nodes garbo] engine})
  (.die! node)
  (assoc! garbo eid node)
  (dissoc! nodes eid))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn purgeNodes "Get rid of all nodes" [engine]
  (var {:keys [nodes]} engine)
  (each-key (fn [v k]
               (dissoc! nodes k)
               (delete! v)) nodes)
  (doHouseKeeping))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn regoSystem "" [engine s]
  (var {:keys [systems]} engine)
  (conj! systems s))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn purgeSystem "" [engine s]
  (.purge (get engine :systems) s))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn purgeSystems "" [engine]
  (.clear (get engine :systems)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn update "" [engine time]
  (swap! (get engine :updating) (fn [] true))
  (var {:keys [systems]} engine)
  (var~ s)
  (for [i 0 sz (n# systems)
        :while (< i sz) :recur (+1 i)]
    (set! s (.@i systems))
    (when (.active? s)
      (if-not (.update s time)
        (break-out-of-loop!))))
  (doHouseKeeping)
  (swap! (get engine :updating) (fn [] false)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn ignite "" [engine initNodes initSystems]
  (initNodes engine)
  (initSystems engine)
  (var {:keys [systems]} engine)
  (each #(.preamble %) systems))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn doHouseKeeping "" [engine]
  (var {:keys [garbo]} engine)
  (each #(delete! %) garbo)
  (.splice garbo 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn dtorTypeRegistry "" [types]
  (var {:keys [rego]} types)
  (each #(delete! %) (values rego))
  (resetObject! rego))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getCache "" [types comType]
  (var {:keys [rego]} types)
  (.find rego comType))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn unbind "" [types comType e]
  (var {:keys [rego]} types)
  (when-some [it (.find rego comType)]
    (var eid (.eid e)
         m (.second it)
         it2 (.find m eid))
    (if it2
      (.erase m it2))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn bind "" [registry c e]
  (var {:keys [rego]} registry
       cid (.cid c) eid (.eid e))
  (var ~ m)
  (if-some [it (.find rego cid)]
    (set! m (.second it))
    (do (set! m (new CompoCache))
        (assoc! rego cid m)))
  (assoc! m eid c))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn addSystem "" [engine sys]
  (var {:keys [systems]} engine
       compFn (fn [s1 s2]
                (if (< s1.priority
                       s2.priority)
                  -1
                  (if (> s1.priority
                         s2.priority) 1 0))))
  (conj! systems sys)
  (sort! compfn systems))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getSystem "" [engine systemType]
  (var {:keys [systems]} engine)
  (find systems #(= (.id s) systemType)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn dtorNode "" [node]
  (var {:keys [engine]} node
       {:keys [rego]} engine
       {:keys [parts]} node)
  (var~ c)
  (for [i 0 sz (n# parts)
        :while (< i sz) :recur (+1 i)]
    (set! it (.@i parts)
          c (.second it))
    (unbind rego c node)
    ;;only delete if the object is not a reference-counted
    (if-not (.auto? c)
      (delete! c))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn checkin "" [node c]
  (var {:keys [engine parts]} node
       {:keys [rego]} engine
       z (.typeid c))
  (assert (! (has? node z)) "")
  (bind rego c node)
  (assoc! c :node node)
  (assoc! parts z c))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn purge "" [node comType]
  (var {:keys [engine parts]} node
       {:keys [rego]} engine)
  (var~ c)
  (when-some [it (.find parts comType)]
    (set! c (.second it))
    (.erase parts it)
    (unbind rego c node)
    (if-not (.auto? c) (delete! c))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn get "" [node comType]
  (var {:keys [engine parts]} node)
  (if-some [it  (.find parts comType)]
    (.second it)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getAll "" [node]
  (var {:keys [parts]} node)
  (values parts))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn has? "" [node comType]
  (var {:keys [parts]} node)
  (some? (.find parts comType)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF












