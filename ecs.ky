;; Copyright (c) 2013-2018, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author "Kenneth Leung"}

  czlab.rygel.ecs

  (:require ["kirby"
             :as k
             :refer [atom swap! find
                     sort! some? nichts? conj!]]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn reifyEngine "" []
  (k/atom {:entities {}
           :systems []
           :registry {}
           :updating? false}))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn reifySystem
  "" [type] (k/atom {:typeId type}))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn reifyComponent "" [type]
  (k/atom {:typeId type :auto? #f :entity nil}))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getEntities
  "Find all the entities inside this engine,
  which contains these component types"
  [engine & componentTypes]
  (var cmin Number.SAFE_MAX_INTEGER
       {:keys [entities
               registry]} engine
       ret [] ccs [] missed? false)
  (var~ smallest c cid)
  ;;find smallest cache, do intersection
  (for [i 0 sz (n# componentTypes)
        :while (< i sz) :recur (+1 i)]
    ;does the engine know this component type,
    ;if so, find the collection
    (set! cid (.@i componentTypes)
          c (get registry cid))
    (cond
      (nichts? c)
      ;unknown so matching will be 0
      (do->break! (true! missed?))
      :else
      ;found it, keep track of it and
      ;if the size is smaller, point to it
      (let [cz (n# c)]
        (when (< cz cmin)
          (set! smallest c cmin cz))
        (conj! ccs c))))
  (when (and (not missed?)
             (not-empty ccs))
    (var sum 0
         ccsz (n# ccs))
    ;;use the smallest as baseline
    (each
      (fn [eid]
        (set! sum 0)
        ;;look for intersection
        (each #(if (or (= % smallest)
                       (contains? % eid)) (++ sum)) ccs)
        ;;if found in all caches means
        ;;this node(eid) has all the req'd components
        (if (= sum ccsz)
          (if-some [obj (get entities eid)] (conj! ret obj))))
      (keys smallest))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getAllEntities
  "Get all the entities inside this engine"
  [engine]
  (var {:keys [entities]} engine) (values entities))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- *idAtom* (atom 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn generateEid "" []
  (str "e" (swap! *idAtom*
                    (fn [v]
                      (if-not (< v Number.SAFE_MAX_INTEGER)
                        (trap! "too many entities"))
                      (+1 v)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn reifyEntity "" [engine n take?]
  (var {:keys [entities]} engine
       eid (generateEid)
       e (k/atom {:engine engine
                  :eid eid
                  :name n
                  :bodyparts {}}))
  (assoc! entities eid e)
  (if take? (.take! e)) e)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn purgeEntity
  "Get rid of this node" [engine entity]
  (var eid (get @entity :eid))
  (swap! entity
         (fn [e] (assoc! e :dead #t) e))
  (swap! engine
         (fn [e] (dissoc! e.entities eid) e)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn purgeEntities
  "Get rid of all nodes" [engine]
  (swap! engine
         (fn [e] (assoc! e :nodes {}) e)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn regoSystem "" [engine system]
  (var {:keys [systems]} engine
       compFn (fn [s1 s2]
                (if (< s1.priority
                       s2.priority)
                  -1
                  (if (> s1.priority
                         s2.priority) 1 0))))
  (conj! systems system)
  (sort! compfn systems))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn purgeSystem "" [engine system]
  (var {:keys [systems]} engine)
  (for [i 0 sz (n# systems)
        :while (< i sz) :recur (+1 i)]
    (when (= system (.@i systems))
      (.splice systems i 1)
      (break-out-of-loop!))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn purgeSystems "" [engine]
  (assoc! engine :systems {}))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn updateEngine "" [engine time]
  (swap! (get engine :updating) (fn [_] true))
  (var {:keys [systems]} engine)
  (var~ s)
  (for [i 0 sz (n# systems)
        :while (< i sz) :recur (+1 i)]
    (set! s (.@i systems))
    (when (get s :active?)
      (if-not (updateSystem s time)
        (break-out-of-loop!))))
  (doHouseKeeping)
  (swap! (get engine :updating) (fn [_] false)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn ignite "" [engine initNodes initSystems]
  (initNodes engine)
  (initSystems engine)
  (var {:keys [systems]} engine)
  (each #(preambleSystem %) systems))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn doHouseKeeping "" [engine]
  (var {:keys [garbo]} engine)
  (assoc! engine :garbo {}))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getCache "" [engine comType]
  (var {:keys [types]} engine) (get types comType))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn unbind "" [engine comType node]
  (var {:keys [types]} engine
       eid (get node :eid))
  (if-some [m (get types comType)] (dissoc! m eid)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn bind "" [engine component node]
  (var {:keys [types]} engine
       eid (get node :eid)
       cid (get component :typeId)
       m (get types cid))
  (when (nichts? m)
    (set! m {})
    (assoc! types cid m))
  (assoc! m eid component))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getSystem "" [engine systemType]
  (var {:keys [systems]} engine)
  (find systems #(= (get % :typeId) systemType)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn dtorNode "" [node]
  (var {:keys [engine parts]} node)
  (each-key
    (fn [v k]
      (unbind engine k node)) parts))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn checkin "" [node component]
  (var {:keys [engine parts]} node
       cid (get component :typeId))
  (assert (! (has? node cid))
          "Cannot add Component again")
  (bind engine component node)
  (assoc! component :node node)
  (assoc! parts cid component))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn purge "" [node comType]
  (var {:keys [engine parts]} node)
  (dissoc! parts comType)
  (unbind engine comType node))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getComponent "" [node comType]
  (var {:keys [parts]} node)
  (get parts comType))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getAllComponents "" [node]
  (var {:keys [parts]} node) (values parts))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn hasComponent? "" [node comType]
  (var {:keys [parts]} node) (contains? parts comType))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF


