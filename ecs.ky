;; Copyright (c) 2013-2018, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author "Kenneth Leung"}

  czlab.rygel.ecs

  (:require ["kirby"
             :as k
             :refer [atom merge swap! find
                     object? sort! some? nichts? conj!]]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const SPV {
  :PreUpdate 100
  :NetPlay    200
  :AI     300
  :Motion     400
  :Move       500
  :Logic   600
  :Collide  700
  :Resolve    800
  :Render     900
  :Error -1 })

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createEngine

  "Create an engine, the core of ECS."
  [attrs]

  (atom (merge attrs
               {:entities {}
                :systems []
                :config {}
                :registry {}
                :updating? false})))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createSystem

  "Create a new system.  Each system must be provided with
  a user defined worker function and a priority value"

  [type priority preamble worker]
  {:pre [(fn? preamble)(fn? worker)]}
  (atom {:preamble preamble :update worker
         :typeId type :priority priority :active? #f}))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createComponent "" [type attrs]
  {:pre [(object? attrs)]}
  (atom (merge attrs {:typeId type :entity nil})))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createEntity "" [engine attrs]
  (var eid (generateEid)
       ent (atom (merge attrs
                        {:engine engine
                         :dead? #f
                         :eid eid
                         :bodyparts {} })))
  (swap! engine
         (fn [e] (assoc! e.entities eid ent) e)) ent)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createPoolable "" [engine attrs & [take?]]
  (var e (createEntity engine
                       (merge attrs {:status #f})))
  (if take? (takePoolable! e) e))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getEntities
  "Find all the entities inside this engine,
  which contains these component types"
  [engine & componentTypes]
  (var cmin Number.SAFE_MAX_INTEGER
       {:keys [entities
               registry]} @engine
       ret [] ccs [] missed? false)
  (var~ smallest c cid)
  ;;find smallest cache, do intersection
  (for [i 0 sz (n# componentTypes)
        :while (< i sz) :recur (+1 i)]
    ;does the engine know this component type,
    ;if so, find the collection
    (set! cid (.@i componentTypes)
          c (get registry cid))
    (cond
      (nichts? c)
      ;unknown so matching will be 0
      (do->break! (true! missed?))
      :else
      ;found it, keep track of it and
      ;if the size is smaller, point to it
      (let [cz (n# c)]
        (when (< cz cmin)
          (set! cmin cz
                smallest c)) (conj! ccs c))))
  (when (and (not missed?)
             (not-empty ccs))
    (var sum 0
         ccsz (n# ccs))
    ;;use the smallest as baseline
    (each
      (fn [eid]
        (set! sum 0)
        ;;look for intersection
        (each #(if (or (= % smallest)
                       (contains? % eid)) (++ sum)) ccs)
        ;;if found in all caches means
        ;;this node(eid) has all the req'd components
        (if (= sum ccsz)
          (if-some [obj (get entities eid)] (conj! ret obj))))
      (keys smallest))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getAllEntities
  "Get all the entities."
  [engine] (values (.-entities @engine)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const- *idAtom* (atom 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- generateEid "" []
  (str "e" (swap! *idAtom*
                  (fn [v]
                    (if-not (< v Number.SAFE_MAX_INTEGER)
                      (trap! "too many entities")) (+1 v)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn takePoolable! "" [entity]
  (swap! entity
         (fn [e] (assoc! e :status #t) e)) entity)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn freePoolable! "" [entity]
  (swap! entity
         (fn [e] (assoc! e :status #f) e)) entity)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn popEntity "" [entity]
  (dosync
    (var {:keys [engine eid]} @entity)
    (swap! engine (fn [e]
                    (dissoc! e.entities eid) e))
    (swap! entity
           (fn [e]
             (assoc! e :dead? #t)
             (each #(subComp engine % entity) (keys e.bodyparts)) e))) nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn popAllEntities
  "Get rid of all entities" [engine]
  (swap! engine
         (fn [e] (assoc! e
                         :registry {}
                         :entities {}) e)) nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn pushSystem "" [engine system]
  (var ;low to high
       compFn (fn [s1 s2]
                (if (< s1.priority
                       s2.priority)
                  -1
                  (if (> s1.priority
                         s2.priority) 1 0))))
  (swap! engine
         (fn [e]
           (conj! e.systems system)
           (sort! compfn e.systems) e)) nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn popSystem "" [engine system]
  (var ret #f)
  (swap! engine
         (fn [e]
           (for [i 0 sz (n# e.systems)
                :while (< i sz) :recur (+1 i)]
             (when (= system (.@i e.systems))
               (.splice e.systems i 1)
               (true! ret)
               (break-out-of-loop!))) e)) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn popAllSystems "" [engine]
  (swap! engine (fn [e] (assoc! e :systems []) e)) nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn updateEngine "" [engine time]
  (swap! engine (fn [e] (assoc! e :updating? #t) e))
  (var {:keys [systems]} @engine)
  (var~ s s')
  (for [i 0 sz (n# systems)
        :while (< i sz) :recur (+1 i)]
    (set! s (.@i systems)
          s' @s)
    (when (get s' :active?)
      (if-not (.update s' time) (break-out-of-loop!))))
  (doHouseKeeping)
  (swap! engine (fn [e] (assoc! e :updating? #f) e)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn igniteEngine "" [engine initNodes initSystems]
  ((comp initSystems initNodes) engine)
  (each #(.preamble (deref %)) (.-systems @engine)) nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn doHouseKeeping "" [engine] nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getCompCache
  "" [engine comType] (get (.-registry @engine) comType))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn subComp "" [engine comType entity]
  (var eid (get @entity :eid))
  (swap! engine
         (fn [e]
           (if-some [m (get e.registry comType)]
             (dissoc! m eid)) e))
  nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn addComp "" [engine component entity]
  (var eid (get @entity :eid)
       cid (get @component :typeId))
  (swap! engine
         (fn [e]
           (var m (get e.registry cid))
           (when (nichts? m)
             (set! m {})
             (assoc! e.registry cid m))
           (assoc! m eid component) e)) nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getSystem "" [engine systemType]
  (find (.-systems @engine) #(= (get (deref %) :typeId) systemType)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn bindComponent "" [entity component]
  (dosync
    (swap! component (fn [c] (assoc! c :entity entity) c))
    (var cid (get @component :typeId))
    (assert (! (hasComponent? entity cid)) "Cannot add Component again")
    (addComp engine component entity)
    (swap! entity (fn [e] (assoc! e.bodyparts cid component) e))) nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn unbindComponent "" [entity comType]
  (swap! entity
         (fn [e]
           (dissoc! e.bodyparts comType)
           (subComp e.engine comType entity) e)) nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getComponent
  "" [entity comType] (get (.-bodyparts @entity) comType))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getAllComponents
  "" [entity] (values (get @entity :bodyparts)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn hasComponent? "" [entity comType]
  (contains? (get @entity :bodyparts) comType))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createPool "" [own?]
  (atom {:cache [] :own? own? :ctor nil :batch 0}))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn presetPool
  "Pre-populate a bunch of objects in the pool"
  [pool ctor count]
  (swap! pool
         (fn [p]
           (dotimes [x count]
             (if-some [obj (ctor)]
               (conj! p.cache obj)))
           (assoc! p :ctor ctor :batch count) p)) nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn selectFromPool
  "Find an object by applying this filter" [pool sel]
  (var ret nil e nil
       {:keys [cache]} @pool)
  (for [i 0 sz (n# cache)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i cache))
    (when (sel e)
      (set! ret e) (break-out-of-loop!))) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getFromPool
  "Get a free object from the pool.  More like a peek"
  [pool create?]
  (var ret nil e nil
       {:keys [batch cache ctor]} @pool)
  (for [i 0 sz (n# cache)
        :while (< i sz) :recur (+1 i)]
    (set! e (.@i cache))
    (when-not (get @e :status)
      (set! ret e)
      (break-out-of-loop!)))
  (cond
    (some? ret)
    ret
    (and create? ctor)
    (do (presetPool pool ctor batch)
        (getFromPool pool false))
    :else nil))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn takeFromPool
  "Get a free object from the pool and flag it as in-use"
  [pool create?]
  (var ret (getFromPool pool create?))
  (if ret
    (takePoolable! ret)) ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getFromPoolAt
  "" [pool pos] (nth (.-cache @pool) pos))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn checkIntoPool "" [pool obj]
  (swap! pool
         (fn [p] (conj! p.cache obj) p)) obj)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn clearPool "" [pool]
  (var {:keys [own?]} @pool)
  (swap! pool
         (fn [p] (k/resetVec! p.cache) p)) nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getActivesInPool "" [pool]
  (filter #(get (deref %) :status) (.-cache @pool)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn countActivesInPool
  "Get the count of active objects" [pool]
  (var sum 0)
  (each #(if (get (deref %) :status) (++ sum)) (.-cache @pool)) sum)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn foreachInPool "" [pool callback]
  (each (fn [ent]
          (if (get @ent :status) (callback ent))) (.-cache @pool)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn someInPool?
  "" [pool test] (some test (.-cache @pool)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn resetPool
  "Hibernate (status off) all objects in the pool" [pool]
  (swap! pool
         (fn [p]
           (each (fn [obj]
                   (swap! obj
                          (fn [e]
                            (assoc! e :status #f) e))) p.cache) p)) nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

